{"function": "def SimpleSector(sides=0, radius=1.0, startangle=0.0, endangle=45.0):\n    newpoints = []\n\n    startangle = radians(startangle)\n    endangle = radians(endangle)\n    sides += 1\n\n    newpoints.append([0, 0, 0])\n    angle = (endangle - startangle) / sides\n    x = cos(startangle) * radius\n    y = sin(startangle) * radius\n    newpoints.append([x, y, 0])\n    j = 1\n    while j < sides:\n        t = angle * j\n        x = cos(t + startangle) * radius\n        y = sin(t + startangle) * radius\n        newpoints.append([x, y, 0])\n        j += 1\n    x = cos(endangle) * radius\n    y = sin(endangle) * radius\n    newpoints.append([x, y, 0])\n\n    return newpoints", "label": 1}
{"function": "def requires_cuda_not_available() -> pytest.MarkDecorator:\n    return pytest.mark.skipif(torch.cuda.is_available(), reason=\"CUDA is available\")", "label": 0}
{"function": "def _convert_train_id_to_eval_id(prediction, train_id_to_eval_id):\n  \"\"\"Converts the predicted label for evaluation.\n\n  There are cases where the training labels are not equal to the evaluation\n  labels. This function is used to perform the conversion so that we could\n  evaluate the results on the evaluation server.\n\n  Args:\n    prediction: Semantic segmentation prediction.\n    train_id_to_eval_id: A list mapping from train id to evaluation id.\n\n  Returns:\n    Semantic segmentation prediction whose labels have been changed.\n  \"\"\"\n  converted_prediction = prediction.copy()\n  for train_id, eval_id in enumerate(train_id_to_eval_id):\n    converted_prediction[prediction == train_id] = eval_id\n\n  return converted_prediction", "label": 1}
{"function": "    def set_response(self, response: ChatCompletion):\n        \"\"\"\n        Set the mock to return a specific response.\n        :param response: A ChatCompletion response to return.\n        \"\"\"\n        self.chat.completions.create.return_value = response", "label": 0}
{"function": "async def run_local_search(\n    query: str,\n    sv: SessionVariables,\n) -> SearchResult:\n    \"\"\"Run local search.\"\"\"\n    print(f\"Local search query: {query}\")  # noqa T201\n\n    # build local search engine\n    response_placeholder = st.session_state[\n        f\"{SearchType.Local.value.lower()}_response_placeholder\"\n    ]\n    response_container = st.session_state[f\"{SearchType.Local.value.lower()}_container\"]\n\n    with response_placeholder, st.spinner(\"Generating answer using local search...\"):\n        empty_context_data: dict[str, pd.DataFrame] = {}\n\n        response, context_data = await api.local_search(\n            config=sv.graphrag_config.value,\n            communities=sv.communities.value,\n            entities=sv.entities.value,\n            community_reports=sv.community_reports.value,\n            text_units=sv.text_units.value,\n            relationships=sv.relationships.value,\n            covariates=sv.covariates.value,\n            community_level=sv.dataset_config.value.community_level,\n            response_type=\"Multiple Paragraphs\",\n            query=query,\n        )\n\n        print(f\"Local Response: {response}\")  # noqa T201\n        print(f\"Context data: {context_data}\")  # noqa T201\n\n    # display response and reference context to UI\n    search_result = SearchResult(\n        search_type=SearchType.Local,\n        response=str(response),\n        context=context_data if isinstance(context_data, dict) else empty_context_data,\n    )\n\n    display_search_result(\n        container=response_container, result=search_result, stats=None\n    )\n\n    if \"response_lengths\" not in st.session_state:\n        st.session_state.response_lengths = []\n\n    st.session_state[\"response_lengths\"].append({\n        \"result\": search_result,\n        \"search\": SearchType.Local.value.lower(),\n    })\n\n    return search_result", "label": 0}
{"function": "    def _format_vat_cl(self, values):\n        identification_types = [self.env.ref('l10n_latam_base.it_vat').id, self.env.ref('l10n_cl.it_RUT').id,\n                                self.env.ref('l10n_cl.it_RUN').id]\n        partner_country_is_chile = (values.get('country_id') == self.env.ref('base.cl').id) or (\n                    values.get('l10n_latam_identification_type_id') and\n                    self.env['l10n_latam.identification.type'].browse(\n                        values.get('l10n_latam_identification_type_id')).country_id == self.env.ref('base.cl'))\n        if partner_country_is_chile and \\\n                values.get('l10n_latam_identification_type_id') in identification_types and values.get('vat'):\n            return stdnum.util.get_cc_module('cl', 'vat').format(values['vat']).replace('.', '').replace(\n                'CL', '').upper()\n        else:\n            return values['vat']", "label": 1}
{"function": "    def _server_loop(self):\n        \"\"\"Main server loop in a separate thread\"\"\"\n        print(\"Server thread started\")\n        self.socket.settimeout(1.0)  # Timeout to allow for stopping\n        \n        while self.running:\n            try:\n                # Accept new connection\n                try:\n                    client, address = self.socket.accept()\n                    print(f\"Connected to client: {address}\")\n                    \n                    # Handle client in a separate thread\n                    client_thread = threading.Thread(\n                        target=self._handle_client,\n                        args=(client,)\n                    )\n                    client_thread.daemon = True\n                    client_thread.start()\n                except socket.timeout:\n                    # Just check running condition\n                    continue\n                except Exception as e:\n                    print(f\"Error accepting connection: {str(e)}\")\n                    time.sleep(0.5)\n            except Exception as e:\n                print(f\"Error in server loop: {str(e)}\")\n                if not self.running:\n                    break\n                time.sleep(0.5)\n        \n        print(\"Server thread stopped\")", "label": 0}
{"function": "    def log_loss(name, loss, loss_dict, use_video):\n        # only calculate loss for video\n        if use_video == 0:\n            loss.data = torch.tensor(0.0, device=device, dtype=dtype)\n        all_reduce_sum(loss.data)\n        num_video = torch.tensor(use_video, device=device, dtype=dtype)\n        all_reduce_sum(num_video)\n        loss_item = loss.item() / num_video.item()\n        loss_dict[name] = loss_item\n        running_loss[name] += loss_item", "label": 0}
{"function": "def init_bigvgan():\r\n    global bigvgan_model, hifigan_model, sv_cn_model\r\n    from BigVGAN import bigvgan\r\n\r\n    bigvgan_model = bigvgan.BigVGAN.from_pretrained(\r\n        \"%s/GPT_SoVITS/pretrained_models/models--nvidia--bigvgan_v2_24khz_100band_256x\" % (now_dir,),\r\n        use_cuda_kernel=False,\r\n    )  # if True, RuntimeError: Ninja is required to load C++ extensions\r\n    # remove weight norm in the model and set to eval mode\r\n    bigvgan_model.remove_weight_norm()\r\n    bigvgan_model = bigvgan_model.eval()\r\n\r\n    if is_half == True:\r\n        bigvgan_model = bigvgan_model.half().to(device)\r\n    else:\r\n        bigvgan_model = bigvgan_model.to(device)\r", "label": 0}
{"function": "    def test_get_reward_funcs(self):\n        \"\"\"Test get_reward_funcs with various reward functions.\"\"\"\n        reward_names = [\n            \"accuracy\",\n            \"format\",\n            \"reasoning_steps\",\n            \"cosine\",\n            \"repetition_penalty\",\n            \"length\",\n            \"tag_count\",\n            \"code\",\n            \"ioi_code\",\n            \"code_format\",\n            \"binary_code\",\n        ]\n        reward_func_names = [\n            \"accuracy_reward\",\n            \"format_reward\",\n            \"reasoning_steps_reward\",\n            \"cosine_scaled_reward\",\n            \"repetition_penalty_reward\",\n            \"len_reward\",\n            \"tag_count_reward\",\n            \"code_reward\",\n            \"ioi_code_reward\",\n            \"code_format_reward\",\n            \"binary_code_reward\",\n        ]\n\n        args = GRPOScriptArguments(\n            dataset_name=\"dummy\",\n            reward_funcs=reward_names,\n        )\n\n        reward_funcs = get_reward_funcs(args)\n        self.assertEqual(len(reward_funcs), 11)\n        for func_name, func in zip(reward_func_names, reward_funcs):\n            self.assertEqual(func_name, func.__name__)", "label": 0}
{"function": "def test_parse_hparam_args__equals():\n    hparam_args = ['--foo=HParams(boo=1)']\n    assert parse_hparam_args(hparam_args) == {'foo': HParams(boo=1)}", "label": 1}
{"function": "def file_exists(file_path: str) -> bool:\n    \"\"\"\n    Check if a file exists.\n\n    Args:\n        file_path (str): The path to the file.\n\n    Returns:\n        bool: True if the file exists, False otherwise.\n    \"\"\"\n    return os.path.exists(file_path)", "label": 0}
{"function": "    def step(self, observations, states):\n        vec_obs = self.obs_vectorizer.to_vecs(observations)\n        feed_dict = {\n            self.seq_lens_ph: [1] * len(observations),\n            self.is_init_state_ph: [False] * len(observations),\n            self.obs_ph: [[x] for x in vec_obs],\n            self.mask_ph: [[1]] * len(observations)\n        }\n\n        if isinstance(self.first_state_ph, tuple):\n            assert isinstance(states, tuple)\n            for key, value in zip(self.first_state_ph, states):\n                feed_dict[key] = value\n        else:\n            feed_dict[self.first_state_ph] = states\n\n        acts, vals, states = self.session.run((self.actor_out,\n                                               self.critic_out,\n                                               self.states_out),\n                                              feed_dict)\n        action_params = [a[0] for a in acts]\n        return {\n            'action_params': action_params,\n            'actions': self.action_dist.sample(action_params),\n            'states': states,\n            'values': np.array(vals).flatten()\n        }", "label": 1}
{"function": "def _get_backend(fname):\n    in_doc = InputDocument(\n        path_or_stream=fname,\n        format=InputFormat.ASCIIDOC,\n        backend=AsciiDocBackend,\n    )\n\n    doc_backend = in_doc._backend\n    return doc_backend", "label": 0}
{"function": "def test_request_with_query_params():\n    \"\"\"Test a request with query parameters.\"\"\"\n    request = RequestModel(\n        name=\"Request with query params\",\n        method=\"GET\",\n        url=\"https://example.com/api/search\",\n        params=[\n            QueryParam(name=\"q\", value=\"test query\"),\n            QueryParam(name=\"page\", value=\"1\"),\n            QueryParam(name=\"disabled\", value=\"true\", enabled=False),\n        ],\n    )\n\n    expected = \"curl \\\\\\n  'https://example.com/api/search?q=test+query&page=1'\"\n    assert request.to_curl() == expected", "label": 0}
{"function": "def get_all_songs():\n    songs = []\n    for root, dirs, files in os.walk(song_dir):\n        for file in files:\n            if file.endswith(\".mp3\"):\n                songs.append(file)\n    return songs", "label": 0}
{"function": "    def valMeasuredParameter(self, obj):\n        \"\"\"Function to add ParameterName\n\n        :param obj: element to add ParameterName\n        \"\"\"\n        valuesQAStats = []\n        valuesQAFlags = []\n        valuesParameter = []\n        for i in self.parModis:\n            for val in i.retMeasure().values():\n                valuesQAStats.append(val['QAStats'])\n                valuesQAFlags.append(val['QAFlags'])\n                valuesParameter.append(val['ParameterName'])\n        for i in set(valuesParameter):\n            pn = self.ElementTree.SubElement(obj, 'ParameterName')\n            pn.text = i", "label": 1}
{"function": "    def __init__(\n        self,\n        config: \"AgentConfig\",\n        id: str | None = None,\n        name: str | None = None,\n        agent0: \"Agent|None\" = None,\n        log: Log.Log | None = None,\n        paused: bool = False,\n        streaming_agent: \"Agent|None\" = None,\n        created_at: datetime | None = None,\n        type: AgentContextType = AgentContextType.USER,\n        last_message: datetime | None = None,\n    ):\n        # build context\n        self.id = id or str(uuid.uuid4())\n        self.name = name\n        self.config = config\n        self.log = log or Log.Log()\n        self.agent0 = agent0 or Agent(0, self.config, self)\n        self.paused = paused\n        self.streaming_agent = streaming_agent\n        self.task: DeferredTask | None = None\n        self.created_at = created_at or datetime.now(timezone.utc)\n        self.type = type\n        AgentContext._counter += 1\n        self.no = AgentContext._counter\n        # set to start of unix epoch\n        self.last_message = last_message or datetime.now(timezone.utc)\n\n        existing = self._contexts.get(self.id, None)\n        if existing:\n            AgentContext.remove(self.id)\n        self._contexts[self.id] = self", "label": 0}
{"function": "    def setPixmap(self, pixmap):\n        self.imageLabel.setPixmap(pixmap)\n        self.hasImage = True", "label": 1}
{"function": "    def __repr__(self):\n        return '[%s] type=%s, value=%s' % (self.name, self.type, str(self.value))", "label": 1}
{"function": "def extract_url_content(url):\n    downloaded = trafilatura.fetch_url(url)\n    content =  trafilatura.extract(downloaded)\n    \n    return {\"url\":url, \"content\":content}", "label": 0}
{"function": "def get_conv_template(name: str) -> Conversation:\n    \"\"\"Get a conversation template.\"\"\"\n    return conv_templates[name].copy()", "label": 0}
{"function": "def no_stream_requests(ques, output_file):\n    url = 'https://qanything-local-test-265.site.youdao.com/api/local_doc_qa/local_doc_chat'\n    headers = {'content-type': 'application/json'}\n    data = {\n            \"kb_ids\": [\n            \"KBf46828db208c4289a120a34f0fc96147\",\n            \"KBc2440f13e98f4736b5ef81cfaebef3a9\",\n            \"KBb78af28c73f74fb4ae6ad44b3c53302f\",\n            \"KB6c2b097d83be430ab809e361fa8dcc8b\",\n            \"KB69331d593f5b4b5bb555a0ea1b145e5b\",\n            \"KB3cdc79f8c8d24a14bffd27e6570c33da\"\n            ],\n            \"question\": ques,\n            \"user_id\": \"liujx_265\",\n            \"streaming\": False,\n            \"rerank\": True,\n            \"history\": []\n    }\n    try:\n        response = requests.post(url=url, headers=headers, json=data, timeout=60)\n        res = response.json()\n        res = data['question'] + '::' + res['response']\n        print(res)\n        write_to_file_safe(output_file, res)\n    except Exception as e:\n        print(f\"\u8bf7\u6c42\u53d1\u9001\u5931\u8d25: {e}\")", "label": 0}
{"function": "    def test_query_ignore_older(self):\n        \"\"\"\n        wineventlog - Query by time (ignore_older than 2s)\n        \"\"\"\n        self.write_event_log(\">=2 seconds old\", eventID=20)\n        time.sleep(2)\n        self.write_event_log(\"~0 seconds old\", eventID=10)\n        evts = self.read_events(config={\n            \"event_logs\": [\n                {\n                    \"name\": self.providerName,\n                    \"api\": self.api,\n                    \"ignore_older\": \"2s\"\n                }\n            ]\n        })\n        self.assertTrue(len(evts), 1)\n        self.assertEqual(evts[0][\"winlog.event_id\"], 10)\n        self.assertEqual(evts[0][\"event.code\"], 10)", "label": 1}
{"function": "    def testLargePromptHint2(self):\n        local_pdf_path = os.path.join(os.path.dirname(__file__), \"gnarly_pdfs\", \"large_prompt_hint2.pdf\")\n\n        anchor_text = get_anchor_text(local_pdf_path, 2, pdf_engine=\"pdfreport\")\n\n        print(anchor_text)\n        print(len(anchor_text))\n        self.assertLessEqual(len(anchor_text), 4000)", "label": 0}
{"function": "    def test_soft_delete_instance(self):\n        self._test_compute_api('soft_delete_instance', 'cast',\n                instance=self.fake_instance_obj)", "label": 1}
{"function": "def hsv_to_rgb_handler(converter: TensorFlowConverter, tf_op: \"tf.Operation\"):\n    raise NotImplementedError(f\"[TensorFlowConverter] {tf_op.type} is not supported yet.\")", "label": 1}
{"function": "    def test_accuracy_reward_correct_answer(self):\n        \"\"\"Test accuracy_reward with a correct answer.\"\"\"\n        completion = [[{\"content\": r\"\\boxed{\\frac{63}{400}}\"}]]\n        solution = [r\"\\frac{63}{400}\"]\n        rewards = accuracy_reward(completion, solution)\n        self.assertEqual(rewards[0], 1.0)", "label": 0}
{"function": "    def repr_instance(self, x, level):\n        try:\n            s = builtins.repr(x)\n            # Bugs in x.__repr__() can cause arbitrary\n            # exceptions -- then make up something\n        except Exception:\n            return '<%s instance at %#x>' % (x.__class__.__name__, id(x))\n        if len(s) > self.maxother:\n            i = max(0, (self.maxother-3)//2)\n            j = max(0, self.maxother-3-i)\n            s = s[:i] + '...' + s[len(s)-j:]\n        return s", "label": 1}
{"function": "        def __init__(self, model):\n            self.model = model\n            model.changed.connect(self.model_changed)", "label": 1}
{"function": "    def _dispatch(self, method, params):\n        \"\"\"Dispatches the XML-RPC method.\n\n        XML-RPC calls are forwarded to a registered function that\n        matches the called XML-RPC method name. If no such function\n        exists then the call is forwarded to the registered instance,\n        if available.\n\n        If the registered instance has a _dispatch method then that\n        method will be called with the name of the XML-RPC method and\n        its parameters as a tuple\n        e.g. instance._dispatch('add',(2,3))\n\n        If the registered instance does not have a _dispatch method\n        then the instance will be searched to find a matching method\n        and, if found, will be called.\n\n        Methods beginning with an '_' are considered private and will\n        not be called.\n        \"\"\"\n\n        func = None\n        try:\n            # check to see if a matching function has been registered\n            func = self.funcs[method]\n        except KeyError:\n            if self.instance is not None:\n                # check for a _dispatch method\n                if hasattr(self.instance, '_dispatch'):\n                    return self.instance._dispatch(method, params)\n                else:\n                    # call instance method directly\n                    try:\n                        func = resolve_dotted_attribute(\n                            self.instance,\n                            method,\n                            self.allow_dotted_names\n                            )\n                    except AttributeError:\n                        pass\n\n        if func is not None:\n            return func(*params)\n        else:\n            raise Exception('method \"%s\" is not supported' % method)", "label": 1}
{"function": "    def current_temperature(self):\n        \"\"\"Return the current temperature.\"\"\"\n        return self._current_temperature", "label": 1}
{"function": "  def transition_power_noise_accumulator(self, num_steps):\n    \"\"\"Computes power sums in closed form.\"\"\"\n    def _pack_and_reshape(*values):\n      return array_ops.reshape(\n          array_ops.stack(axis=1, values=values),\n          array_ops.concat(values=[array_ops.shape(num_steps), [2, 2]], axis=0))\n\n    num_steps = math_ops.cast(num_steps, self.dtype)\n    noise_transitions = num_steps - 1\n    noise_transform = ops.convert_to_tensor(self.get_noise_transform(),\n                                            self.dtype)\n    noise_covariance_transformed = math_ops.matmul(\n        math_ops.matmul(noise_transform,\n                        self.state_transition_noise_covariance),\n        noise_transform,\n        adjoint_b=True)\n    # Un-packing the transformed noise as:\n    # [[a b]\n    #  [c d]]\n    a, b, c, d = array_ops.unstack(\n        array_ops.reshape(noise_covariance_transformed, [-1, 4]), axis=1)\n    sum_of_first_n = noise_transitions * (noise_transitions + 1) / 2\n    sum_of_first_n_squares = sum_of_first_n * (2 * noise_transitions + 1) / 3\n    return _pack_and_reshape(\n        num_steps * a + sum_of_first_n * (b + c) + sum_of_first_n_squares * d,\n        num_steps * b + sum_of_first_n * d,\n        num_steps * c + sum_of_first_n * d,\n        num_steps * d)", "label": 1}
{"function": "    def test_get_not_found(self):\n        \"\"\"Test retrieving a value that doesn't exist in the cache.\"\"\"\n        cache = TimedCache(datetime.timedelta(seconds=10))\n\n        # Key doesn't exist\n        assert cache.get(\"nonexistent_key\") is TimedCache.NOT_FOUND", "label": 0}
{"function": "    def create_check_constraint(self, name, source, condition,\n                                schema=None, **kw):\n        \"\"\"Issue a \"create check constraint\" instruction using the\n        current migration context.\n\n        e.g.::\n\n            from alembic import op\n            from sqlalchemy.sql import column, func\n\n            op.create_check_constraint(\n                \"ck_user_name_len\",\n                \"user\",\n                func.len(column('name')) > 5\n            )\n\n        CHECK constraints are usually against a SQL expression, so ad-hoc\n        table metadata is usually needed.   The function will convert the given\n        arguments into a :class:`sqlalchemy.schema.CheckConstraint` bound\n        to an anonymous table in order to emit the CREATE statement.\n\n        :param name: Name of the check constraint.  The name is necessary\n         so that an ALTER statement can be emitted.  For setups that\n         use an automated naming scheme such as that described at\n         `NamingConventions <http://www.sqlalchemy.org/trac/wiki/UsageRecipes/NamingConventions>`_,\n         ``name`` here can be ``None``, as the event listener will\n         apply the name to the constraint object when it is associated\n         with the table.\n        :param source: String name of the source table.\n        :param condition: SQL expression that's the condition of the constraint.\n         Can be a string or SQLAlchemy expression language structure.\n        :param deferrable: optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when\n         issuing DDL for this constraint.\n        :param initially: optional string. If set, emit INITIALLY <value> when issuing DDL\n         for this constraint.\n        :param schema: Optional schema name to operate within.\n\n         ..versionadded:: 0.4.0\n\n        \"\"\"\n        self.impl.add_constraint(\n            self._check_constraint(name, source, condition, schema=schema, **kw)\n        )", "label": 1}
{"function": "def update_profile_model(file_path: str):\n    profile_rules: dict = http_get(\n        url='https://miot-spec.org/instance/translate/models')\n    if not profile_rules and 'models' not in profile_rules and not isinstance(\n            profile_rules['models'], dict):\n        raise ValueError('Failed to get profile rule')\n    local_rules: dict = load_yaml_file(\n        yaml_file=file_path) or {}\n    for rule, ts in profile_rules['models'].items():\n        if rule not in local_rules:\n            local_rules[rule] = {'ts': ts}\n        else:\n            local_rules[rule]['ts'] = ts\n    for mode in SPECIAL_MODELS:\n        if mode not in local_rules:\n            local_rules[mode] = {'ts': 1531108800}\n        else:\n            local_rules[mode]['ts'] = 1531108800\n    local_rules = dict(sorted(local_rules.items()))\n    save_yaml_file(\n        yaml_file=file_path, data=local_rules)", "label": 0}
{"function": "    def execute_command(self, command):\n        \"\"\"Execute a command in the main Blender thread\"\"\"\n        try:            \n            return self._execute_command_internal(command)\n                \n        except Exception as e:\n            print(f\"Error executing command: {str(e)}\")\n            traceback.print_exc()\n            return {\"status\": \"error\", \"message\": str(e)}", "label": 0}
{"function": "\t\t\tdef __str__(self):\n\t\t\t\treturn '.'.join(map(str, self))", "label": 1}
{"function": "    def _set_retry_after(self, value):\n        if value is None:\n            if 'retry-after' in self.headers:\n                del self.headers['retry-after']\n            return\n        elif isinstance(value, datetime):\n            value = http_date(value)\n        else:\n            value = str(value)\n        self.headers['Retry-After'] = value", "label": 1}
{"function": "def test_lucene_sanitize():\n    # Call the function with test data\n    queries = [\n        (\n            'This has every escape character + - && || ! ( ) { } [ ] ^ \" ~ * ? : \\\\ /',\n            '\\\\This has every escape character \\\\+ \\\\- \\\\&\\\\& \\\\|\\\\| \\\\! \\\\( \\\\) \\\\{ \\\\} \\\\[ \\\\] \\\\^ \\\\\" \\\\~ \\\\* \\\\? \\\\: \\\\\\\\ \\\\/',\n        ),\n        ('this has no escape characters', 'this has no escape characters'),\n    ]\n\n    for query, assert_result in queries:\n        result = lucene_sanitize(query)\n        assert assert_result == result", "label": 0}
{"function": "    def __str__(self):\n        s = 'app 0x%02x, verb 0x%02x, len %d' % (self.app, self.verb, len(self.data))\n\n        if len(self.data) > 0:\n            s += ', data %s' % hexlify(self.data)\n\n        return s", "label": 1}
{"function": "async def mock_embedding_func(texts):\n    return np.random.rand(len(texts), 10)  # \u8fd4\u56de10\u7ef4\u968f\u673a\u5411\u91cf", "label": 0}
{"function": "    def do_unrealize(self):\n        if self._msg is not None:\n            self._api.cancel(self._msg)", "label": 1}
{"function": "    async def initialize(\n        self,\n        connection_type: str,\n        server_url: str | None = None,\n    ) -> None:\n        \"\"\"Initialize the MCP agent with the appropriate connection.\"\"\"\n        logger.info(f\"Initializing MCPAgent with {connection_type} connection...\")\n\n        if connection_type == \"stdio\":\n            await self.agent.initialize(\n                connection_type=\"stdio\",\n                command=sys.executable,\n                args=[\"-m\", self.server_reference],\n            )\n        else:  # sse\n            await self.agent.initialize(connection_type=\"sse\", server_url=server_url)\n\n        logger.info(f\"Connected to MCP server via {connection_type}\")", "label": 0}
{"function": "def flake8(file_path: str) -> str:\n    \"\"\"Run flake8 on a given file and return the output as a string\"\"\"\n    if Path(file_path).suffix != \".py\":\n        return \"\"\n    cmd = registry.get(\"LINT_COMMAND\", \"flake8 --isolated --select=F821,F822,F831,E111,E112,E113,E999,E902 {file_path}\")\n    # don't use capture_output because it's not compatible with python3.6\n    out = subprocess.run(cmd.format(file_path=file_path), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    return out.stdout.decode()", "label": 0}
{"function": "def get_youtube_cache_path() -> str:\n    \"\"\"\n    Gets the path to the YouTube cache file.\n\n    Returns:\n        path (str): The path to the YouTube cache folder\n    \"\"\"\n    return os.path.join(get_cache_path(), 'youtube.json')", "label": 0}
{"function": "def replace_with_load_state(\n    init_state: Any,\n    load_state: Any,\n    load_rename_rules: Optional[list[tuple[str, str]]] = None,\n    load_exclude_rules: Optional[list[str]] = None,\n    mesh_config: tuple = (1, 1),\n) -> Any:\n    flatten_load, _ = jax.tree_util.tree_flatten_with_path(load_state)\n    flatten_init, structure_init = jax.tree_util.tree_flatten_with_path(init_state)\n    load_map = {path_tuple_to_string(path): tensor for path, tensor in flatten_load}\n\n    replaced = []\n    num_replicas = 1\n    data_model_shards = math.prod(mesh_config)\n    for i, (init_path, tensor) in enumerate(flatten_init):\n        init_path_str = path_tuple_to_string(init_path)\n        load_path_str = get_load_path_str(init_path_str, load_rename_rules, load_exclude_rules)\n        if load_path_str is None:\n            rank_logger.info(f\"Excluded from restore: {init_path_str}.\")\n            replaced.append(tensor)\n        elif load_path_str in load_map:\n            if load_path_str == init_path_str:\n                rank_logger.info(f\"Restored from ckpt: {init_path_str}.\")\n            else:\n                rank_logger.info(f\"Restored from ckpt: {init_path_str} <-- {load_path_str}.\")\n            replaced.append(load_map[load_path_str])\n        else:\n            rank_logger.info(f\"Not found in ckpt: {init_path_str}.\")\n            if (i % num_replicas) == ((jax.process_index() // data_model_shards) % num_replicas):\n                replaced.append(tensor)\n            else:\n                replaced.append(np.zeros_like(tensor))\n\n    return jax.tree_util.tree_unflatten(structure_init, replaced)", "label": 0}
{"function": "    def drop_column(self, table_name, column_name, **kw):\n        \"\"\"Issue a \"drop column\" instruction using the current\n        migration context.\n\n        e.g.::\n\n            drop_column('organization', 'account_id')\n\n        :param table_name: name of table\n        :param column_name: name of column\n        :param schema: Optional schema name to operate within.\n\n         .. versionadded:: 0.4.0\n\n        :param mssql_drop_check: Optional boolean.  When ``True``, on\n         Microsoft SQL Server only, first\n         drop the CHECK constraint on the column using a\n         SQL-script-compatible\n         block that selects into a @variable from sys.check_constraints,\n         then exec's a separate DROP CONSTRAINT for that constraint.\n        :param mssql_drop_default: Optional boolean.  When ``True``, on\n         Microsoft SQL Server only, first\n         drop the DEFAULT constraint on the column using a\n         SQL-script-compatible\n         block that selects into a @variable from sys.default_constraints,\n         then exec's a separate DROP CONSTRAINT for that default.\n\n        \"\"\"\n\n        self.impl.drop_column(\n            table_name,\n            self._column(column_name, NULLTYPE),\n            **kw\n        )", "label": 1}
{"function": "    def __init__(self, ble, name='mpy-uart', rxbuf=100):\n        self._ble = ble\n        self._ble.active(True)\n        self._ble.irq(handler=self._irq)\n        ((self._tx_handle, self._rx_handle,),) = self._ble.gatts_register_services((_UART_SERVICE,))\n        # Increase the size of the rx buffer and enable append mode.\n        self._ble.gatts_set_buffer(self._rx_handle, rxbuf, True)\n        self._connections = set()\n        self._rx_buffer = bytearray()\n        self._handler = None\n        # Optionally add services=[_UART_UUID], but this is likely to make the payload too large.\n        self._payload = advertising_payload(name=name, appearance=_ADV_APPEARANCE_GENERIC_COMPUTER)\n        self._advertise()", "label": 1}
{"function": "def main(args):\n    all_task = [executor.submit(single_job, utt) for utt in utt2wav.keys()]\n    utt2speech_token = {}\n    for future in tqdm(as_completed(all_task)):\n        utt, speech_token = future.result()\n        utt2speech_token[utt] = speech_token\n    torch.save(utt2speech_token, '{}/utt2speech_token.pt'.format(args.dir))", "label": 0}
{"function": "    def __iadd__(self, other):\n        return self + other", "label": 1}
{"function": "def yolov10_inference_for_examples(image, model_path, image_size, conf_threshold):\n    annotated_image, _ = yolov10_inference(image, None, model_path, image_size, conf_threshold)\n    return annotated_image", "label": 0}
{"function": "    def _tokenize_text_segment(self, text: str, speaker: int) -> Tuple[torch.Tensor, torch.Tensor]:\n        frame_tokens = []\n        frame_masks = []\n\n        text_tokens = self._text_tokenizer.encode(f\"[{speaker}]{text}\")\n        text_frame = torch.zeros(len(text_tokens), 33).long()\n        text_frame_mask = torch.zeros(len(text_tokens), 33).bool()\n        text_frame[:, -1] = torch.tensor(text_tokens)\n        text_frame_mask[:, -1] = True\n\n        frame_tokens.append(text_frame.to(self.device))\n        frame_masks.append(text_frame_mask.to(self.device))\n\n        return torch.cat(frame_tokens, dim=0), torch.cat(frame_masks, dim=0)", "label": 0}
{"function": "def import_model(\n    in_path: Path,\n    out_path: Path,\n    weights_per_step_schedule: list[int] | None = None,\n    silent: bool = False,\n    max_out_n_q: int | None = None,\n) -> None:\n    if in_path.suffix == \".safetensors\":\n        tch_model = load_file(in_path)\n    else:\n        pkg = torch.load(in_path, map_location=torch.device(\"cpu\"), weights_only=False)\n        tch_model = pkg[\"fsdp_best_state\"][\"model\"]\n\n    in_n_q: int | None = None\n    for idx in range(999):\n        name = f\"emb.{idx}.weight\"\n        if name not in tch_model:\n            in_n_q = idx\n            break\n    out_n_q: int | None = None\n    for idx in range(999):\n        name = f\"linears.{idx}.weight\"\n        if name not in tch_model:\n            out_n_q = idx\n            break\n    assert in_n_q is not None\n    assert out_n_q is not None\n    if not silent:\n        print(f\"in_n_q: {in_n_q}, out_n_q: {out_n_q}\")\n\n    if weights_per_step_schedule is not None:\n        if len(weights_per_step_schedule) != out_n_q:\n            raise ValueError(\"inconsistent weights_per_step_schedule\", len(weights_per_step_schedule), out_n_q)\n\n    depformer_layers: int | None = None\n    for idx in range(999):\n        if f\"depformer.layers.{idx}.self_attn.in_proj_weight\" not in tch_model:\n            depformer_layers = idx\n            break\n    assert depformer_layers is not None\n    if not silent:\n        print(f\"depformer layers: {depformer_layers}\")\n\n    model = {}\n    for name in [\"text_emb.weight\", \"text_linear.weight\"]:\n        model[name] = tch_model[name]\n    for name in tch_model.keys():\n        if name.startswith(\"condition_provider.conditioners\"):\n            model[name] = tch_model[name]\n    model[\"out_norm.weight\"] = tch_model[\"out_norm.alpha\"][0, 0]\n    for idx in range(in_n_q):\n        src_name = f\"emb.{idx}.weight\"\n        dst_name = f\"audio_embs.{idx}.weight\"\n        model[dst_name] = tch_model[src_name]\n\n    for k, v in sorted(tch_model.items()):\n        print(k, v.shape, v.dtype)\n        if k.startswith(\"transformer\"):\n            if k.endswith(\".alpha\"):\n                v = v[0, 0]\n            k = k.replace(\".alpha\", \".weight\")\n            k = k.replace(\".in_proj_weight\", \".in_proj.weight\")\n            model[k] = v\n\n    # Only export the first slices of the depformer (main).\n    if max_out_n_q is not None:\n        exported_out_n_q = min(max_out_n_q, out_n_q)\n        print(f\"only exporting the first {exported_out_n_q} depformer layers\")\n    else:\n        exported_out_n_q = out_n_q\n\n    max_df_steps = out_n_q\n    if weights_per_step_schedule is not None:\n        max_df_steps = max(weights_per_step_schedule) + 1\n\n    for idx in range(exported_out_n_q):\n        if weights_per_step_schedule is not None:\n            tch_idx = weights_per_step_schedule[idx]\n        else:\n            tch_idx = idx\n\n        base = f\"depformer.slices.{idx}.\"\n        model[base + \"linear_in.weight\"] = tch_model[f\"depformer_in.{tch_idx}.weight\"].clone()\n        model[base + \"linear_out.weight\"] = tch_model[f\"linears.{idx}.weight\"]\n        if idx == 0:\n            model[base + \"emb.weight\"] = tch_model[\"depformer_text_emb.weight\"]\n            if \"depformer_text_emb.low_rank.weight\" in tch_model:\n                model[base + \"emb.low_rank.weight\"] = tch_model[\"depformer_text_emb.low_rank.weight\"].clone()\n        else:\n            model[base + \"emb.weight\"] = tch_model[f\"depformer_emb.{idx-1}.weight\"].clone()\n            if f\"depformer_emb.{idx-1}.low_rank.weight\" in tch_model:\n                model[base + \"emb.low_rank.weight\"] = tch_model[f\"depformer_emb.{idx-1}.low_rank.weight\"].clone()\n\n        for layer_idx in range(depformer_layers):\n            layer = base + f\"transformer.layers.{layer_idx}.\"\n            # WARNING: note that this uses in_proj_weight vs out_proj.weight\n            model[layer + \"self_attn.in_proj.weight\"] = (\n                tch_model[f\"depformer.layers.{layer_idx}.self_attn.in_proj_weight\"]\n                .chunk(max_df_steps)[tch_idx]\n                .clone()\n            )\n            model[layer + \"self_attn.out_proj.weight\"] = (\n                tch_model[f\"depformer.layers.{layer_idx}.self_attn.out_proj.weight\"]\n                .chunk(max_df_steps)[tch_idx]\n                .clone()\n            )\n            model[layer + \"norm1.weight\"] = tch_model[\n                f\"depformer.layers.{layer_idx}.norm1.alpha\"\n            ][0, 0].clone()\n            model[layer + \"norm2.weight\"] = tch_model[\n                f\"depformer.layers.{layer_idx}.norm2.alpha\"\n            ][0, 0].clone()\n            model[layer + \"gating.linear_in.weight\"] = tch_model[\n                f\"depformer.layers.{layer_idx}.gating.{tch_idx}.linear_in.weight\"\n            ].clone()\n            model[layer + \"gating.linear_out.weight\"] = tch_model[\n                f\"depformer.layers.{layer_idx}.gating.{tch_idx}.linear_out.weight\"\n            ].clone()\n\n    save_file(model, out_path)", "label": 0}
{"function": "    def __init__(\n        self,\n        model=\"F5TTS_v1_Base\",\n        ckpt_file=\"\",\n        vocab_file=\"\",\n        ode_method=\"euler\",\n        use_ema=True,\n        vocoder_local_path=None,\n        device=None,\n        hf_cache_dir=None,\n    ):\n        model_cfg = OmegaConf.load(str(files(\"f5_tts\").joinpath(f\"configs/{model}.yaml\")))\n        model_cls = get_class(f\"f5_tts.model.{model_cfg.model.backbone}\")\n        model_arc = model_cfg.model.arch\n\n        self.mel_spec_type = model_cfg.model.mel_spec.mel_spec_type\n        self.target_sample_rate = model_cfg.model.mel_spec.target_sample_rate\n\n        self.ode_method = ode_method\n        self.use_ema = use_ema\n\n        if device is not None:\n            self.device = device\n        else:\n            import torch\n\n            self.device = (\n                \"cuda\"\n                if torch.cuda.is_available()\n                else \"xpu\"\n                if torch.xpu.is_available()\n                else \"mps\"\n                if torch.backends.mps.is_available()\n                else \"cpu\"\n            )\n\n        # Load models\n        self.vocoder = load_vocoder(\n            self.mel_spec_type, vocoder_local_path is not None, vocoder_local_path, self.device, hf_cache_dir\n        )\n\n        repo_name, ckpt_step, ckpt_type = \"F5-TTS\", 1250000, \"safetensors\"\n\n        # override for previous models\n        if model == \"F5TTS_Base\":\n            if self.mel_spec_type == \"vocos\":\n                ckpt_step = 1200000\n            elif self.mel_spec_type == \"bigvgan\":\n                model = \"F5TTS_Base_bigvgan\"\n                ckpt_type = \"pt\"\n        elif model == \"E2TTS_Base\":\n            repo_name = \"E2-TTS\"\n            ckpt_step = 1200000\n\n        if not ckpt_file:\n            ckpt_file = str(\n                cached_path(f\"hf://SWivid/{repo_name}/{model}/model_{ckpt_step}.{ckpt_type}\", cache_dir=hf_cache_dir)\n            )\n        self.ema_model = load_model(\n            model_cls, model_arc, ckpt_file, self.mel_spec_type, vocab_file, self.ode_method, self.use_ema, self.device\n        )", "label": 0}
{"function": "    def validate_email(email: str) -> bool:\n        \"\"\"Validate the format of an email address.\"\"\"\n        return bool(ConfigValidator.EMAIL_REGEX.match(email))", "label": 0}
{"function": "    def irq(self, handler):\n        self._handler = handler", "label": 1}
{"function": "  def testGetChannelIndex(self):\n    data_formats = ['NHWC', 'NCHW']\n    for data_format in data_formats:\n      index = nasnet_utils.get_channel_index(data_format)\n      correct_index = 3 if data_format == 'NHWC' else 1\n      self.assertEqual(index, correct_index)", "label": 1}
{"function": "    def finalize_options(self):\n        \"\"\"Set final values for all the options that this command supports.\n        This is always called as late as possible, ie.  after any option\n        assignments from the command-line or from other commands have been\n        done.  Thus, this is the place to code option dependencies: if\n        'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as\n        long as 'foo' still has the same value it was assigned in\n        'initialize_options()'.\n\n        This method must be implemented by all command classes.\n        \"\"\"\n        raise RuntimeError(\"abstract method -- subclass %s must override\"\n                           % self.__class__)", "label": 1}
{"function": "        def __init__(self, api, *args, **kwargs):\n            self.api = api\n            self.as_generator = kwargs.pop(\"as_generator\", False)\n            self.return_json = kwargs.pop(\"return_json\", True)\n            self.parameters = {}\n            self._build_parameters(args, kwargs)\n            self._build_path()", "label": 1}
{"function": "    def default_value(self):\n        \"\"\"Returns the default value of the platform parameter.\n\n        Returns:\n            *. The default value of the platform parameter.\n        \"\"\"\n        return self._default_value", "label": 1}
{"function": "def test_add_metrics_individual_params(tracer):\n    \"\"\"Test adding metrics using individual parameters\"\"\"\n    tracer.trace = {}  # Initialize trace\n    tracer.add_metrics(\n        name=\"test_metric\",\n        score=0.95,\n        reasoning=\"Good performance\",\n        cost=0.01,\n        latency=100,\n        metadata={\"key\": \"value\"},\n        config={\"threshold\": 0.8}\n    )\n    \n    assert len(tracer.trace_metrics) == 1\n    metric = tracer.trace_metrics[0]\n    assert metric[\"name\"] == \"test_metric\"\n    assert metric[\"score\"] == 0.95\n    assert metric[\"reason\"] == \"Good performance\"\n    assert metric[\"source\"] == \"user\"\n    assert metric[\"cost\"] == 0.01\n    assert metric[\"latency\"] == 100\n    assert metric[\"metadata\"] == {\"key\": \"value\"}\n    assert metric[\"config\"] == {\"threshold\": 0.8}", "label": 0}
{"function": "    def __repr__(self):\n        return f\"Flake8Error(filename={self.filename}, line_number={self.line_number}, col_number={self.col_number}, problem={self.problem})\"", "label": 0}
{"function": "def parse_nms_url(url):\n    \"\"\"Parse NMS url into normalized parts like scheme, user, host and others.\n\n    Example NMS URL:\n        auto://admin:nexenta@192.168.1.1:2000/\n\n    NMS URL parts:\n\n    .. code-block:: none\n\n        auto                True if url starts with auto://, protocol\n                            will be automatically switched to https\n                            if http not supported;\n        scheme (auto)       connection protocol (http or https);\n        user (admin)        NMS user;\n        password (nexenta)  NMS password;\n        host (192.168.1.1)  NMS host;\n        port (2000)         NMS port.\n\n    :param url: url string\n    :return: tuple (auto, scheme, user, password, host, port, path)\n    \"\"\"\n    pr = urlparse.urlparse(url)\n    scheme = pr.scheme\n    auto = scheme == 'auto'\n    if auto:\n        scheme = 'http'\n    user = 'admin'\n    password = 'nexenta'\n    if '@' not in pr.netloc:\n        host_and_port = pr.netloc\n    else:\n        user_and_password, host_and_port = pr.netloc.split('@', 1)\n        if ':' in user_and_password:\n            user, password = user_and_password.split(':')\n        else:\n            user = user_and_password\n    if ':' in host_and_port:\n        host, port = host_and_port.split(':', 1)\n    else:\n        host, port = host_and_port, '2000'\n    return auto, scheme, user, password, host, port, '/rest/nms/'", "label": 1}
{"function": "def load_video_dir(root, dirs, save_dir, save_name):\n  videos, sparse_videos = [], []\n  first_videos = []\n  for idx, cdir in enumerate(dirs):\n    annot_path = osp.join(root, cdir, 'annot')\n    frame_path = osp.join(root, cdir, 'extraction')\n    all_frames = glob.glob( osp.join(frame_path, '*.png') )\n    all_annots = glob.glob( osp.join(annot_path, '*.pts') )\n    assert len(all_frames) == len(all_annots), 'The length is not right for {} : {} vs {}'.format(cdir, len(all_frames), len(all_annots))\n    all_frames = sorted(all_frames)\n    all_annots = sorted(all_annots)\n    current_video = []\n    txtfile = open(osp.join(save_dir, save_name + cdir), 'w')\n    nonefile = open(osp.join(save_dir, save_name + cdir + '.none'), 'w')\n\n    all_sizes = []\n    for frame, annot in zip(all_frames, all_annots):\n      basename_f = osp.basename(frame)\n      basename_a = osp.basename(annot)\n      assert basename_a[:6] == basename_f[:6], 'The name of {} is not right with {}'.format(frame, annot)\n      current_video.append( (frame, annot) )\n      box_str = datasets.dataset_utils.for_generate_box_str(annot, 68, EXPAND_RATIO)\n      txtfile.write('{} {} {}\\n'.format(frame, annot, box_str))\n      nonefile.write('{} None {}\\n'.format(frame, box_str))\n      all_sizes.append( str2size(box_str) )\n      if len(current_video) == 1:\n        first_videos.append( (frame, annot) )\n    txtfile.close()\n    nonefile.close()\n    videos.append( current_video )\n    all_sizes = np.array( all_sizes )\n    print ('--->>> {:} : [{:02d}/{:02d}] : {:} has {:} frames | face size : mean={:.2f}, std={:.2f}'.format(save_name, idx, len(dirs), cdir, len(all_frames), all_sizes.mean(), all_sizes.std()))\n\n    for jxj, video in enumerate(current_video):\n      if jxj <= 3 or jxj + 3 >= len(current_video): continue\n      if jxj % 10 == 3:\n        sparse_videos.append( video )\n\n  txtfile = open(osp.join(save_dir, save_name), 'w')\n  nonefile = open(osp.join(save_dir, save_name + '.none'), 'w')\n  for video in videos:\n    for cpair in video:\n      box_str = datasets.dataset_utils.for_generate_box_str(cpair[1], 68, EXPAND_RATIO)\n      txtfile.write('{} {} {}\\n'.format(cpair[0], cpair[1], box_str))\n      nonefile.write('{} {} {}\\n'.format(cpair[0], 'None', box_str))\n      txtfile.flush()\n      nonefile.flush()\n  txtfile.close()\n  nonefile.close()\n\n  txtfile = open(osp.join(save_dir, save_name + '.sparse' + afterfix), 'w')\n  nonefile = open(osp.join(save_dir, save_name + '.sparse.none' + afterfix), 'w')\n  for cpair in sparse_videos:\n    box_str = datasets.dataset_utils.for_generate_box_str(cpair[1], 68, EXPAND_RATIO)\n    txtfile.write('{} {} {}\\n'.format(cpair[0], cpair[1], box_str))\n    nonefile.write('{} {} {}\\n'.format(cpair[0], 'None', box_str))\n  txtfile.close()\n  nonefile.close()\n\n  txtfile = open(osp.join(save_dir, save_name + '.first'), 'w')\n  for cpair in first_videos:\n    box_str = datasets.dataset_utils.for_generate_box_str(cpair[1], 68, EXPAND_RATIO)\n    txtfile.write('{} {} {}\\n'.format(cpair[0], cpair[1], box_str))\n  txtfile.close()\n\n  print ('{} finish save into {}'.format(save_name, save_dir))\n  return videos", "label": 1}
{"function": "    def _get_browser_options(self, user_agent=None):\n        \"\"\"\u83b7\u53d6\u6d4f\u89c8\u5668\u914d\u7f6e\"\"\"\n        co = ChromiumOptions()\n        try:\n            extension_path = self._get_extension_path(\"turnstilePatch\")\n            co.add_extension(extension_path)\n        except FileNotFoundError as e:\n            logging.warning(f\"\u8b66\u544a: {e}\")\n\n        browser_path = os.getenv(\"BROWSER_PATH\")\n        if browser_path:\n            co.set_paths(browser_path=browser_path)\n\n        co.set_pref(\"credentials_enable_service\", False)\n        co.set_argument(\"--hide-crash-restore-bubble\")\n        proxy = os.getenv(\"BROWSER_PROXY\")\n        if proxy:\n            co.set_proxy(proxy)\n\n        co.auto_port()\n        if user_agent:\n            co.set_user_agent(user_agent)\n\n        co.headless(\n            os.getenv(\"BROWSER_HEADLESS\", \"True\").lower() == \"true\"\n        )  # \u751f\u4ea7\u73af\u5883\u4f7f\u7528\u65e0\u5934\u6a21\u5f0f\n\n        # Mac \u7cfb\u7edf\u7279\u6b8a\u5904\u7406\n        if sys.platform == \"darwin\":\n            co.set_argument(\"--no-sandbox\")\n            co.set_argument(\"--disable-gpu\")\n\n        return co", "label": 0}
{"function": "    def collect_all_content(self):\n        \"\"\"\n        Collects all content from the current node and its descendants.\n\n        Returns:\n            Set[int]: A set containing all content from the current node and its descendants.\n        \"\"\"\n        all_content = set(self.content)\n        for child in self.children:\n            all_content.update(child.collect_all_content())\n        return all_content", "label": 0}
{"function": "    def test_swap_volume(self):\n        self._test_compute_api('swap_volume', 'cast',\n                instance=self.fake_instance_obj, old_volume_id='oldid',\n                new_volume_id='newid', new_attachment_id=uuids.attachment_id,\n                version='5.0')", "label": 1}
{"function": "def register_post():\n    return {}", "label": 1}
{"function": "    def value(self, t):\n        \"\"\"Generates the value given a timestep (based on schedule's logic).\n\n        Args:\n            t (int): The time step. This could be a tf.Tensor.\n\n        Returns:\n            any: The calculated value depending on the schedule and `t`.\n        \"\"\"\n        if self.framework in [\"tf2\", \"tf\", \"tfe\"]:\n            return self._tf_value_op(t)\n        return self._value(t)", "label": 1}
{"function": "            def save_keys_to_config(cfg_key, value):\n                value = value.replace(\" \", \"\")\n                if value:\n                    config.app[cfg_key] = value.split(\",\")", "label": 0}
{"function": "def write_to_file_safe(file_name, data):\n    # \u83b7\u53d6\u9501\n    with lock:\n        with open(file_name, 'a') as f:\n            f.write(data + '\\n')", "label": 0}
{"function": "    def __init__(self, num_capsules, num_route_nodes, in_channels, out_channels, kernel_size=None, stride=None,\n                 num_iterations=p.NUM_ROUTING_ITERATIONS, use_cuda=False):\n        super(CapsuleLayer, self).__init__()\n\n        self.num_route_nodes = num_route_nodes\n        self.num_iterations = num_iterations\n\n        self.num_capsules = num_capsules\n\n        if num_route_nodes != -1:\n            self.route_weights = nn.Parameter(torch.randn(num_capsules, num_route_nodes, in_channels, out_channels))\n        else:\n            self.capsules = nn.ModuleList(\n                [nn.Conv2d(in_channels, out_channels, kernel_size=kernel_size, stride=stride, padding=0) for _ in\n                 range(num_capsules)])\n\n        self.use_cuda = use_cuda", "label": 1}
{"function": "\tdef release_editing_lock(self, tid):\n\t\t\"\"\"\n\t\tRelease the editing lock on a task. The caller is trusted to have the\n\t\tlock and no verification is made.\n\t\t\"\"\"\n\t\tc = self.connection.cursor()\n\t\tc.execute(\"\"\"\n\t\t\tUPDATE Task\n\t\t\tSET editing = 0\n\t\t\tWHERE id = ?\n\t\t\"\"\", (tid,))\n\t\tself.connection.commit()", "label": 1}
{"function": "def mock_playwright():\n    with patch(\"playwright.async_api.async_playwright\") as mock:\n        mock_pw = MockPlaywright()\n        mock_browser = MockBrowser()\n        mock_context = MockContext()\n        mock_page = MockPage()\n\n        mock_pw.chromium.launch.return_value = mock_browser\n        mock_pw.firefox.launch.return_value = mock_browser\n        mock_browser.new_context.return_value = mock_context\n        mock_context.new_page.return_value = mock_page\n\n        mock.return_value.__aenter__.return_value = mock_pw\n        yield mock_pw, mock_browser, mock_context, mock_page", "label": 0}
{"function": "def render_token(t: bytes) -> str:\n    # pretty print a token, escaping control characters\n    s = t.decode('utf-8', errors='replace')\n    s = replace_control_characters(s)\n    return s", "label": 0}
{"function": "def _RefIdGrad(_, grad):\n  return grad", "label": 1}
{"function": "    def _repr_(self):\n        r\"\"\"\n        EXAMPLES ::\n\n            sage: NilCoxeterAlgebra(WeylGroup(['A',3,1])) # indirect doctest\n            The Nil-Coxeter Algebra of Type A3~ over Rational Field\n\n        \"\"\"\n\n        return \"The Nil-Coxeter Algebra of Type %s over %s\"%(self._cartan_type._repr_(compact=True), self.base_ring())", "label": 1}
{"function": "def end_process():\n    stream.input_queue.push('end')", "label": 0}
{"function": "    def __init__(self, *args, **kwargs):\n        if kwargs.get('empty_permitted', True):\n            kwargs['use_required_attribute'] = False\n        super(PricingForm, self).__init__(*args, **kwargs)\n        # Setup initial values for billing_cycle and billing_dt_select\n        # in order to have empty values for extra forms.\n        if self.instance.pk:\n            self.fields['billing_dt_select'].initial = [self.instance.num_days,\n                                                        self.instance.due_sore]\n            self.fields['billing_cycle'].initial = [self.instance.billing_frequency,\n                                                    self.instance.billing_period]\n        else:\n            self.fields['billing_dt_select'].initial = [0, u'start']\n            self.fields['billing_cycle'].initial = [1, u'month']\n\n        # Add class for recurring payment fields\n        recurring_payment_fields = [\n            'taxable', 'tax_rate', 'billing_cycle', 'billing_dt_select',\n            'has_trial_period', 'trial_period_days'\n        ]\n\n        for field in recurring_payment_fields:\n            class_attr = self.fields[field].widget.attrs.get('class', None)\n            if class_attr and 'recurring-payment' not in class_attr:\n                class_attr += ' recurring-payment'\n\n                self.fields[field].widget.attrs.update({'class': class_attr})", "label": 1}
{"function": "    def test_with_ca(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\", 2048)\n        r = certs.dummy_cert(\n            ca.default_privatekey,\n            ca.default_ca,\n            b\"foo.com\",\n            [b\"one.com\", b\"two.com\", b\"*.three.com\", b\"127.0.0.1\"],\n            b\"Foo Ltd.\"\n        )\n        assert r.cn == b\"foo.com\"\n        assert r.altnames == [b'one.com', b'two.com', b'*.three.com']\n        assert r.organization == b\"Foo Ltd.\"\n\n        r = certs.dummy_cert(\n            ca.default_privatekey,\n            ca.default_ca,\n            None,\n            [],\n            None\n        )\n        assert r.cn is None\n        assert r.organization is None\n        assert r.altnames == []", "label": 1}
{"function": "def pytest_recording_configure(config: Any, vcr: VCR):\n    from . import json_body_serializer\n\n    vcr.register_serializer('yaml', json_body_serializer)\n\n    def method_matcher(r1: vcr_request.Request, r2: vcr_request.Request) -> None:\n        if r1.method.upper() != r2.method.upper():\n            raise AssertionError(f'{r1.method} != {r2.method}')\n\n    vcr.register_matcher('method', method_matcher)", "label": 0}
{"function": "    def __init__(self, family, address):\n        BaseTestHandler.__init__(self)\n        self.create_socket(family)\n        self.connect(address)", "label": 1}
{"function": "\tdef get_VerificationStatus(self):\n\t\treturn self.get_query_params().get('VerificationStatus')", "label": 1}
{"function": "def get_asr_converter():\n    \"\"\"Create a DocumentConverter configured for ASR with whisper_turbo model.\"\"\"\n    pipeline_options = AsrPipelineOptions()\n    pipeline_options.asr_options = asr_model_specs.WHISPER_TINY\n\n    converter = DocumentConverter(\n        format_options={\n            InputFormat.AUDIO: AudioFormatOption(\n                pipeline_cls=AsrPipeline,\n                pipeline_options=pipeline_options,\n            )\n        }\n    )\n    return converter", "label": 0}
{"function": "def public(request: Request):\n    root_url = gr.route_utils.get_root_url(request, \"/\", None)\n    return RedirectResponse(url=f\"{root_url}/app/\")", "label": 0}
{"function": "    def test_best_model2_alignment(self):\n        # arrange\n        sentence_pair = AlignedSent(\n            TestIBMModel.__TEST_TRG_SENTENCE, TestIBMModel.__TEST_SRC_SENTENCE\n        )\n        # None and 'bien' have zero fertility\n        translation_table = {\n            'i': {\"j'\": 0.9, 'aime': 0.05, 'bien': 0.02, 'jambon': 0.03, None: 0},\n            'love': {\"j'\": 0.05, 'aime': 0.9, 'bien': 0.01, 'jambon': 0.01, None: 0.03},\n            'ham': {\"j'\": 0, 'aime': 0.01, 'bien': 0, 'jambon': 0.99, None: 0},\n        }\n        alignment_table = defaultdict(\n            lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: 0.2)))\n        )\n\n        ibm_model = IBMModel([])\n        ibm_model.translation_table = translation_table\n        ibm_model.alignment_table = alignment_table\n\n        # act\n        a_info = ibm_model.best_model2_alignment(sentence_pair)\n\n        # assert\n        self.assertEqual(a_info.alignment[1:], (1, 2, 4))  # 0th element unused\n        self.assertEqual(a_info.cepts, [[], [1], [2], [], [3]])", "label": 1}
{"function": "    def run_test(self):\n        self.log.info('prepare some coins for multiple *rawtransaction commands')\n        self.nodes[2].generate(1)\n        self.sync_all()\n        self.nodes[0].generate(101)\n        self.sync_all()\n        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.5)\n        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.0)\n        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),5.0)\n        self.sync_all()\n        self.nodes[0].generate(5)\n        self.sync_all()\n\n        self.log.info('Test getrawtransaction on genesis block coinbase returns an error')\n        block = self.nodes[0].getblock(self.nodes[0].getblockhash(0))\n        assert_raises_rpc_error(-5, \"The genesis block coinbase is not considered an ordinary transaction\", self.nodes[0].getrawtransaction, block['merkleroot'])\n\n        self.log.info('Check parameter types and required parameters of createrawtransaction')\n        # Test `createrawtransaction` required parameters\n        assert_raises_rpc_error(-1, \"createrawtransaction\", self.nodes[0].createrawtransaction)\n        assert_raises_rpc_error(-1, \"createrawtransaction\", self.nodes[0].createrawtransaction, [])\n\n        # Test `createrawtransaction` invalid extra parameters\n        assert_raises_rpc_error(-1, \"createrawtransaction\", self.nodes[0].createrawtransaction, [], {}, 0, False, 'foo')\n\n        # Test `createrawtransaction` invalid `inputs`\n        txid = '1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000'\n        assert_raises_rpc_error(-3, \"Expected type array\", self.nodes[0].createrawtransaction, 'foo', {})\n        assert_raises_rpc_error(-1, \"JSON value is not an object as expected\", self.nodes[0].createrawtransaction, ['foo'], {})\n        assert_raises_rpc_error(-1, \"JSON value is not a string as expected\", self.nodes[0].createrawtransaction, [{}], {})\n        assert_raises_rpc_error(-8, \"txid must be of length 64 (not 3, for 'foo')\", self.nodes[0].createrawtransaction, [{'txid': 'foo'}], {})\n        assert_raises_rpc_error(-8, \"txid must be hexadecimal string (not 'ZZZ7bb8b1697ea987f3b223ba7819250cae33efacb068d23dc24859824a77844')\", self.nodes[0].createrawtransaction, [{'txid': 'ZZZ7bb8b1697ea987f3b223ba7819250cae33efacb068d23dc24859824a77844'}], {})\n        assert_raises_rpc_error(-8, \"Invalid parameter, missing vout key\", self.nodes[0].createrawtransaction, [{'txid': txid}], {})\n        assert_raises_rpc_error(-8, \"Invalid parameter, missing vout key\", self.nodes[0].createrawtransaction, [{'txid': txid, 'vout': 'foo'}], {})\n        assert_raises_rpc_error(-8, \"Invalid parameter, vout must be positive\", self.nodes[0].createrawtransaction, [{'txid': txid, 'vout': -1}], {})\n        assert_raises_rpc_error(-8, \"Invalid parameter, sequence number is out of range\", self.nodes[0].createrawtransaction, [{'txid': txid, 'vout': 0, 'sequence': -1}], {})\n\n        # Test `createrawtransaction` invalid `outputs`\n        address = self.nodes[0].getnewaddress()\n        address2 = self.nodes[0].getnewaddress()\n        assert_raises_rpc_error(-1, \"JSON value is not an array as expected\", self.nodes[0].createrawtransaction, [], 'foo')\n        self.nodes[0].createrawtransaction(inputs=[], outputs={})  # Should not throw for backwards compatibility\n        self.nodes[0].createrawtransaction(inputs=[], outputs=[])\n        assert_raises_rpc_error(-8, \"Data must be hexadecimal string\", self.nodes[0].createrawtransaction, [], {'data': 'foo'})\n        assert_raises_rpc_error(-5, \"Invalid Feathercoin address\", self.nodes[0].createrawtransaction, [], {'foo': 0})\n        assert_raises_rpc_error(-3, \"Invalid amount\", self.nodes[0].createrawtransaction, [], {address: 'foo'})\n        assert_raises_rpc_error(-3, \"Amount out of range\", self.nodes[0].createrawtransaction, [], {address: -1})\n        assert_raises_rpc_error(-8, \"Invalid parameter, duplicated address: %s\" % address, self.nodes[0].createrawtransaction, [], multidict([(address, 1), (address, 1)]))\n        assert_raises_rpc_error(-8, \"Invalid parameter, duplicated address: %s\" % address, self.nodes[0].createrawtransaction, [], [{address: 1}, {address: 1}])\n        assert_raises_rpc_error(-8, \"Invalid parameter, duplicate key: data\", self.nodes[0].createrawtransaction, [], [{\"data\": 'aa'}, {\"data\": \"bb\"}])\n        assert_raises_rpc_error(-8, \"Invalid parameter, duplicate key: data\", self.nodes[0].createrawtransaction, [], multidict([(\"data\", 'aa'), (\"data\", \"bb\")]))\n        assert_raises_rpc_error(-8, \"Invalid parameter, key-value pair must contain exactly one key\", self.nodes[0].createrawtransaction, [], [{'a': 1, 'b': 2}])\n        assert_raises_rpc_error(-8, \"Invalid parameter, key-value pair not an object as expected\", self.nodes[0].createrawtransaction, [], [['key-value pair1'], ['2']])\n\n        # Test `createrawtransaction` invalid `locktime`\n        assert_raises_rpc_error(-3, \"Expected type number\", self.nodes[0].createrawtransaction, [], {}, 'foo')\n        assert_raises_rpc_error(-8, \"Invalid parameter, locktime out of range\", self.nodes[0].createrawtransaction, [], {}, -1)\n        assert_raises_rpc_error(-8, \"Invalid parameter, locktime out of range\", self.nodes[0].createrawtransaction, [], {}, 4294967296)\n\n        # Test `createrawtransaction` invalid `replaceable`\n        assert_raises_rpc_error(-3, \"Expected type bool\", self.nodes[0].createrawtransaction, [], {}, 0, 'foo')\n\n        self.log.info('Check that createrawtransaction accepts an array and object as outputs')\n        tx = CTransaction()\n        # One output\n        tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs={address: 99}))))\n        assert_equal(len(tx.vout), 1)\n        assert_equal(\n            tx.serialize().hex(),\n            self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}]),\n        )\n        # Two outputs\n        tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=OrderedDict([(address, 99), (address2, 99)])))))\n        assert_equal(len(tx.vout), 2)\n        assert_equal(\n            tx.serialize().hex(),\n            self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}, {address2: 99}]),\n        )\n        # Multiple mixed outputs\n        tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=multidict([(address, 99), (address2, 99), ('data', '99')])))))\n        assert_equal(len(tx.vout), 3)\n        assert_equal(\n            tx.serialize().hex(),\n            self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}, {address2: 99}, {'data': '99'}]),\n        )\n\n        for type in [\"bech32\", \"p2sh-segwit\", \"legacy\"]:\n            addr = self.nodes[0].getnewaddress(\"\", type)\n            addrinfo = self.nodes[0].getaddressinfo(addr)\n            pubkey = addrinfo[\"scriptPubKey\"]\n\n            self.log.info('sendrawtransaction with missing prevtx info (%s)' %(type))\n\n            # Test `signrawtransactionwithwallet` invalid `prevtxs`\n            inputs  = [ {'txid' : txid, 'vout' : 3, 'sequence' : 1000}]\n            outputs = { self.nodes[0].getnewaddress() : 1 }\n            rawtx   = self.nodes[0].createrawtransaction(inputs, outputs)\n\n            prevtx = dict(txid=txid, scriptPubKey=pubkey, vout=3, amount=1)\n            succ = self.nodes[0].signrawtransactionwithwallet(rawtx, [prevtx])\n            assert succ[\"complete\"]\n            if type == \"legacy\":\n                del prevtx[\"amount\"]\n                succ = self.nodes[0].signrawtransactionwithwallet(rawtx, [prevtx])\n                assert succ[\"complete\"]\n\n            if type != \"legacy\":\n                assert_raises_rpc_error(-3, \"Missing amount\", self.nodes[0].signrawtransactionwithwallet, rawtx, [\n                    {\n                        \"txid\": txid,\n                        \"scriptPubKey\": pubkey,\n                        \"vout\": 3,\n                    }\n                ])\n\n            assert_raises_rpc_error(-3, \"Missing vout\", self.nodes[0].signrawtransactionwithwallet, rawtx, [\n                {\n                    \"txid\": txid,\n                    \"scriptPubKey\": pubkey,\n                    \"amount\": 1,\n                }\n            ])\n            assert_raises_rpc_error(-3, \"Missing txid\", self.nodes[0].signrawtransactionwithwallet, rawtx, [\n                {\n                    \"scriptPubKey\": pubkey,\n                    \"vout\": 3,\n                    \"amount\": 1,\n                }\n            ])\n            assert_raises_rpc_error(-3, \"Missing scriptPubKey\", self.nodes[0].signrawtransactionwithwallet, rawtx, [\n                {\n                    \"txid\": txid,\n                    \"vout\": 3,\n                    \"amount\": 1\n                }\n            ])\n\n        #########################################\n        # sendrawtransaction with missing input #\n        #########################################\n\n        self.log.info('sendrawtransaction with missing input')\n        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1}] #won't exists\n        outputs = { self.nodes[0].getnewaddress() : 4.998 }\n        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n        rawtx   = self.nodes[2].signrawtransactionwithwallet(rawtx)\n\n        # This will raise an exception since there are missing inputs\n        assert_raises_rpc_error(-25, \"Missing inputs\", self.nodes[2].sendrawtransaction, rawtx['hex'])\n\n        #####################################\n        # getrawtransaction with block hash #\n        #####################################\n\n        # make a tx by sending then generate 2 blocks; block1 has the tx in it\n        tx = self.nodes[2].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n        block1, block2 = self.nodes[2].generate(2)\n        self.sync_all()\n        # We should be able to get the raw transaction by providing the correct block\n        gottx = self.nodes[0].getrawtransaction(tx, True, block1)\n        assert_equal(gottx['txid'], tx)\n        assert_equal(gottx['in_active_chain'], True)\n        # We should not have the 'in_active_chain' flag when we don't provide a block\n        gottx = self.nodes[0].getrawtransaction(tx, True)\n        assert_equal(gottx['txid'], tx)\n        assert 'in_active_chain' not in gottx\n        # We should not get the tx if we provide an unrelated block\n        assert_raises_rpc_error(-5, \"No such transaction found\", self.nodes[0].getrawtransaction, tx, True, block2)\n        # An invalid block hash should raise the correct errors\n        assert_raises_rpc_error(-1, \"JSON value is not a string as expected\", self.nodes[0].getrawtransaction, tx, True, True)\n        assert_raises_rpc_error(-8, \"parameter 3 must be of length 64 (not 6, for 'foobar')\", self.nodes[0].getrawtransaction, tx, True, \"foobar\")\n        assert_raises_rpc_error(-8, \"parameter 3 must be of length 64 (not 8, for 'abcd1234')\", self.nodes[0].getrawtransaction, tx, True, \"abcd1234\")\n        assert_raises_rpc_error(-8, \"parameter 3 must be hexadecimal string (not 'ZZZ0000000000000000000000000000000000000000000000000000000000000')\", self.nodes[0].getrawtransaction, tx, True, \"ZZZ0000000000000000000000000000000000000000000000000000000000000\")\n        assert_raises_rpc_error(-5, \"Block hash not found\", self.nodes[0].getrawtransaction, tx, True, \"0000000000000000000000000000000000000000000000000000000000000000\")\n        # Undo the blocks and check in_active_chain\n        self.nodes[0].invalidateblock(block1)\n        gottx = self.nodes[0].getrawtransaction(txid=tx, verbose=True, blockhash=block1)\n        assert_equal(gottx['in_active_chain'], False)\n        self.nodes[0].reconsiderblock(block1)\n        assert_equal(self.nodes[0].getbestblockhash(), block2)\n\n        #########################\n        # RAW TX MULTISIG TESTS #\n        #########################\n        # 2of2 test\n        addr1 = self.nodes[2].getnewaddress()\n        addr2 = self.nodes[2].getnewaddress()\n\n        addr1Obj = self.nodes[2].getaddressinfo(addr1)\n        addr2Obj = self.nodes[2].getaddressinfo(addr2)\n\n        # Tests for createmultisig and addmultisigaddress\n        assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 1, [\"01020304\"])\n        self.nodes[0].createmultisig(2, [addr1Obj['pubkey'], addr2Obj['pubkey']]) # createmultisig can only take public keys\n        assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 2, [addr1Obj['pubkey'], addr1]) # addmultisigaddress can take both pubkeys and addresses so long as they are in the wallet, which is tested here.\n\n        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr1])['address']\n\n        #use balance deltas instead of absolute values\n        bal = self.nodes[2].getbalance()\n\n        # send 1.2 BTC to msig adr\n        txId = self.nodes[0].sendtoaddress(mSigObj, 1.2)\n        self.sync_all()\n        self.nodes[0].generate(1)\n        self.sync_all()\n        assert_equal(self.nodes[2].getbalance(), bal+Decimal('1.20000000')) #node2 has both keys of the 2of2 ms addr., tx should affect the balance\n\n\n        # 2of3 test from different nodes\n        bal = self.nodes[2].getbalance()\n        addr1 = self.nodes[1].getnewaddress()\n        addr2 = self.nodes[2].getnewaddress()\n        addr3 = self.nodes[2].getnewaddress()\n\n        addr1Obj = self.nodes[1].getaddressinfo(addr1)\n        addr2Obj = self.nodes[2].getaddressinfo(addr2)\n        addr3Obj = self.nodes[2].getaddressinfo(addr3)\n\n        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey']])['address']\n\n        txId = self.nodes[0].sendtoaddress(mSigObj, 2.2)\n        decTx = self.nodes[0].gettransaction(txId)\n        rawTx = self.nodes[0].decoderawtransaction(decTx['hex'])\n        self.sync_all()\n        self.nodes[0].generate(1)\n        self.sync_all()\n\n        #THIS IS AN INCOMPLETE FEATURE\n        #NODE2 HAS TWO OF THREE KEY AND THE FUNDS SHOULD BE SPENDABLE AND COUNT AT BALANCE CALCULATION\n        assert_equal(self.nodes[2].getbalance(), bal) #for now, assume the funds of a 2of3 multisig tx are not marked as spendable\n\n        txDetails = self.nodes[0].gettransaction(txId, True)\n        rawTx = self.nodes[0].decoderawtransaction(txDetails['hex'])\n        vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('2.20000000'))\n\n        bal = self.nodes[0].getbalance()\n        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'], \"scriptPubKey\" : vout['scriptPubKey']['hex'], \"amount\" : vout['value']}]\n        outputs = { self.nodes[0].getnewaddress() : 2.19 }\n        rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n        rawTxPartialSigned = self.nodes[1].signrawtransactionwithwallet(rawTx, inputs)\n        assert_equal(rawTxPartialSigned['complete'], False) #node1 only has one key, can't comp. sign the tx\n\n        rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx, inputs)\n        assert_equal(rawTxSigned['complete'], True) #node2 can sign the tx compl., own two of three keys\n        self.nodes[2].sendrawtransaction(rawTxSigned['hex'])\n        rawTx = self.nodes[0].decoderawtransaction(rawTxSigned['hex'])\n        self.sync_all()\n        self.nodes[0].generate(1)\n        self.sync_all()\n        assert_equal(self.nodes[0].getbalance(), bal+Decimal('80.00000000')+Decimal('2.19000000')) #block reward + tx\n\n        # 2of2 test for combining transactions\n        bal = self.nodes[2].getbalance()\n        addr1 = self.nodes[1].getnewaddress()\n        addr2 = self.nodes[2].getnewaddress()\n\n        addr1Obj = self.nodes[1].getaddressinfo(addr1)\n        addr2Obj = self.nodes[2].getaddressinfo(addr2)\n\n        self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n        mSigObjValid = self.nodes[2].getaddressinfo(mSigObj)\n\n        txId = self.nodes[0].sendtoaddress(mSigObj, 2.2)\n        decTx = self.nodes[0].gettransaction(txId)\n        rawTx2 = self.nodes[0].decoderawtransaction(decTx['hex'])\n        self.sync_all()\n        self.nodes[0].generate(1)\n        self.sync_all()\n\n        assert_equal(self.nodes[2].getbalance(), bal) # the funds of a 2of2 multisig tx should not be marked as spendable\n\n        txDetails = self.nodes[0].gettransaction(txId, True)\n        rawTx2 = self.nodes[0].decoderawtransaction(txDetails['hex'])\n        vout = next(o for o in rawTx2['vout'] if o['value'] == Decimal('2.20000000'))\n\n        bal = self.nodes[0].getbalance()\n        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'], \"scriptPubKey\" : vout['scriptPubKey']['hex'], \"redeemScript\" : mSigObjValid['hex'], \"amount\" : vout['value']}]\n        outputs = { self.nodes[0].getnewaddress() : 2.19 }\n        rawTx2 = self.nodes[2].createrawtransaction(inputs, outputs)\n        rawTxPartialSigned1 = self.nodes[1].signrawtransactionwithwallet(rawTx2, inputs)\n        self.log.debug(rawTxPartialSigned1)\n        assert_equal(rawTxPartialSigned1['complete'], False) #node1 only has one key, can't comp. sign the tx\n\n        rawTxPartialSigned2 = self.nodes[2].signrawtransactionwithwallet(rawTx2, inputs)\n        self.log.debug(rawTxPartialSigned2)\n        assert_equal(rawTxPartialSigned2['complete'], False) #node2 only has one key, can't comp. sign the tx\n        rawTxComb = self.nodes[2].combinerawtransaction([rawTxPartialSigned1['hex'], rawTxPartialSigned2['hex']])\n        self.log.debug(rawTxComb)\n        self.nodes[2].sendrawtransaction(rawTxComb)\n        rawTx2 = self.nodes[0].decoderawtransaction(rawTxComb)\n        self.sync_all()\n        self.nodes[0].generate(1)\n        self.sync_all()\n        assert_equal(self.nodes[0].getbalance(), bal+Decimal('80.00000000')+Decimal('2.19000000')) #block reward + tx\n\n        # decoderawtransaction tests\n        # witness transaction\n        encrawtx = \"010000000001010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f50500000000000102616100000000\"\n        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, True) # decode as witness transaction\n        assert_equal(decrawtx['vout'][0]['value'], Decimal('1.00000000'))\n        assert_raises_rpc_error(-22, 'TX decode failed', self.nodes[0].decoderawtransaction, encrawtx, False) # force decode as non-witness transaction\n        # non-witness transaction\n        encrawtx = \"01000000010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f505000000000000000000\"\n        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, False) # decode as non-witness transaction\n        assert_equal(decrawtx['vout'][0]['value'], Decimal('1.00000000'))\n\n        # getrawtransaction tests\n        # 1. valid parameters - only supply txid\n        txId = rawTx[\"txid\"]\n        assert_equal(self.nodes[0].getrawtransaction(txId), rawTxSigned['hex'])\n\n        # 2. valid parameters - supply txid and 0 for non-verbose\n        assert_equal(self.nodes[0].getrawtransaction(txId, 0), rawTxSigned['hex'])\n\n        # 3. valid parameters - supply txid and False for non-verbose\n        assert_equal(self.nodes[0].getrawtransaction(txId, False), rawTxSigned['hex'])\n\n        # 4. valid parameters - supply txid and 1 for verbose.\n        # We only check the \"hex\" field of the output so we don't need to update this test every time the output format changes.\n        assert_equal(self.nodes[0].getrawtransaction(txId, 1)[\"hex\"], rawTxSigned['hex'])\n\n        # 5. valid parameters - supply txid and True for non-verbose\n        assert_equal(self.nodes[0].getrawtransaction(txId, True)[\"hex\"], rawTxSigned['hex'])\n\n        # 6. invalid parameters - supply txid and string \"Flase\"\n        assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[0].getrawtransaction, txId, \"Flase\")\n\n        # 7. invalid parameters - supply txid and empty array\n        assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[0].getrawtransaction, txId, [])\n\n        # 8. invalid parameters - supply txid and empty dict\n        assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[0].getrawtransaction, txId, {})\n\n        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 1000}]\n        outputs = { self.nodes[0].getnewaddress() : 1 }\n        rawtx   = self.nodes[0].createrawtransaction(inputs, outputs)\n        decrawtx= self.nodes[0].decoderawtransaction(rawtx)\n        assert_equal(decrawtx['vin'][0]['sequence'], 1000)\n\n        # 9. invalid parameters - sequence number out of range\n        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : -1}]\n        outputs = { self.nodes[0].getnewaddress() : 1 }\n        assert_raises_rpc_error(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)\n\n        # 10. invalid parameters - sequence number out of range\n        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 4294967296}]\n        outputs = { self.nodes[0].getnewaddress() : 1 }\n        assert_raises_rpc_error(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)\n\n        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 4294967294}]\n        outputs = { self.nodes[0].getnewaddress() : 1 }\n        rawtx   = self.nodes[0].createrawtransaction(inputs, outputs)\n        decrawtx= self.nodes[0].decoderawtransaction(rawtx)\n        assert_equal(decrawtx['vin'][0]['sequence'], 4294967294)\n\n        ####################################\n        # TRANSACTION VERSION NUMBER TESTS #\n        ####################################\n\n        # Test the minimum transaction version number that fits in a signed 32-bit integer.\n        tx = CTransaction()\n        tx.nVersion = -0x80000000\n        rawtx = ToHex(tx)\n        decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n        assert_equal(decrawtx['version'], -0x80000000)\n\n        # Test the maximum transaction version number that fits in a signed 32-bit integer.\n        tx = CTransaction()\n        tx.nVersion = 0x7fffffff\n        rawtx = ToHex(tx)\n        decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n        assert_equal(decrawtx['version'], 0x7fffffff)\n\n        self.log.info('sendrawtransaction/testmempoolaccept with maxfeerate')\n\n        # Test a transaction with a small fee.\n        txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n        rawTx = self.nodes[0].getrawtransaction(txId, True)\n        vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('1.00000000'))\n\n        self.sync_all()\n        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'] }]\n        # Fee 10,000 satoshis, (1 - (10000 sat * 0.00000001 BTC/sat)) = 0.9999\n        outputs = { self.nodes[0].getnewaddress() : Decimal(\"0.99990000\") }\n        rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n        rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx)\n        assert_equal(rawTxSigned['complete'], True)\n        # Fee 10,000 satoshis, ~100 b transaction, fee rate should land around 100 sat/byte = 0.00100000 BTC/kB\n        # Thus, testmempoolaccept should reject\n        testres = self.nodes[2].testmempoolaccept([rawTxSigned['hex']], 0.00001000)[0]\n        assert_equal(testres['allowed'], False)\n        assert_equal(testres['reject-reason'], '256: absurdly-high-fee')\n        # and sendrawtransaction should throw\n        assert_raises_rpc_error(-26, \"absurdly-high-fee\", self.nodes[2].sendrawtransaction, rawTxSigned['hex'], 0.00001000)\n        # and the following calls should both succeed\n        testres = self.nodes[2].testmempoolaccept(rawtxs=[rawTxSigned['hex']])[0]\n        assert_equal(testres['allowed'], True)\n        self.nodes[2].sendrawtransaction(hexstring=rawTxSigned['hex'])\n\n        # Test a transaction with a large fee.\n        txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n        rawTx = self.nodes[0].getrawtransaction(txId, True)\n        vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('1.00000000'))\n\n        self.sync_all()\n        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'] }]\n        # Fee 2,000,000 satoshis, (1 - (2000000 sat * 0.00000001 BTC/sat)) = 0.98\n        outputs = { self.nodes[0].getnewaddress() : Decimal(\"0.98000000\") }\n        rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n        rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx)\n        assert_equal(rawTxSigned['complete'], True)\n        # Fee 2,000,000 satoshis, ~100 b transaction, fee rate should land around 20,000 sat/byte = 0.20000000 BTC/kB\n        # Thus, testmempoolaccept should reject\n        testres = self.nodes[2].testmempoolaccept([rawTxSigned['hex']])[0]\n        assert_equal(testres['allowed'], False)\n        assert_equal(testres['reject-reason'], '256: absurdly-high-fee')\n        # and sendrawtransaction should throw\n        assert_raises_rpc_error(-26, \"absurdly-high-fee\", self.nodes[2].sendrawtransaction, rawTxSigned['hex'])\n        # and the following calls should both succeed\n        testres = self.nodes[2].testmempoolaccept(rawtxs=[rawTxSigned['hex']], maxfeerate='0.20000000')[0]\n        assert_equal(testres['allowed'], True)\n        self.nodes[2].sendrawtransaction(hexstring=rawTxSigned['hex'], maxfeerate='0.20000000')", "label": 1}
{"function": "def run_command_mock(mocker: MockerFixture) -> AsyncMock:\n    \"\"\"Patch ``gitingest.clone.run_command`` with an ``AsyncMock``.\n\n    The mocked function returns a dummy process whose ``communicate`` method yields generic\n    ``stdout`` / ``stderr`` bytes. Tests can still access / tweak the mock via the fixture argument.\n    \"\"\"\n    mock_exec = mocker.patch(\"gitingest.clone.run_command\", new_callable=AsyncMock)\n\n    # Provide a default dummy process so most tests don't have to create one.\n    dummy_process = AsyncMock()\n    dummy_process.communicate.return_value = (b\"output\", b\"error\")\n    mock_exec.return_value = dummy_process\n\n    return mock_exec", "label": 0}
{"function": "            def callback(d):\n                preview = d['denoised']\n                preview = vae_decode_fake(preview)\n\n                preview = (preview * 255.0).detach().cpu().numpy().clip(0, 255).astype(np.uint8)\n                preview = einops.rearrange(preview, 'b c t h w -> (b h) (t w) c')\n\n                if stream.input_queue.top() == 'end':\n                    stream.output_queue.push(('end', None))\n                    raise KeyboardInterrupt('User ends the task.')\n\n                current_step = d['i'] + 1\n                percentage = int(100.0 * current_step / steps)\n                hint = f'Sampling {current_step}/{steps}'\n                desc = f'Total generated frames: {int(max(0, total_generated_latent_frames * 4 - 3))}, Video length: {max(0, (total_generated_latent_frames * 4 - 3) / 30) :.2f} seconds (FPS-30). The video is being extended now ...'\n                stream.output_queue.push(('progress', (preview, desc, make_progress_bar_html(percentage, hint))))\n                return", "label": 0}
{"function": "    def partition(self):\n        return Partition(label=self.label, files=self.files)", "label": 1}
{"function": "    def _load_template(self, template):\n        pyboleto_dir = os.path.dirname(os.path.abspath(__file__))\n        template_path = os.path.join(pyboleto_dir, 'templates', template)\n        with open(template_path, 'r') as tpl:\n            template_content = tpl.read()\n        return template_content", "label": 1}
{"function": "        def extract_index(s):\n            return int(index_capture.match(s).groups()[0])", "label": 1}
{"function": "    def __matmul__(self, other):\n        if isinstance(other, Quaternion):\n            return self.q.__matmul__(other.q)\n        return self.__matmul__(self.__class__(other))", "label": 1}
{"function": "    def fetch_order_book(self, symbol, limit=None, params={}):\n        self.load_markets()\n        market = self.market(symbol)\n        method = 'publicGet'\n        request = {\n            'symbol': market['id'],\n        }\n        if limit is not None:\n            request['size'] = limit\n        if market['future']:\n            method += 'Future'\n            request['contract_type'] = 'this_week'  # next_week, quarter\n        method += 'Depth'\n        orderbook = getattr(self, method)(self.extend(request, params))\n        return self.parse_order_book(orderbook)", "label": 1}
{"function": "  def test_calculate_samples_count_per_callchain(self):\n    counters = ipr.calculate_samples_count_per_callchain([\n      [\"foo\", \"BytecodeHandler:bar\"],\n      [\"foo\", \"BytecodeHandler:bar\"],\n      [\"beep\", \"BytecodeHandler:bar\"],\n    ])\n    self.assertItemsEqual(counters, [\n      ('BytecodeHandler:bar;foo', 2),\n      ('BytecodeHandler:bar;beep', 1),\n    ])", "label": 1}
{"function": "    def __len__(self):\n        \"\"\"\n        Return the number of fields in the dataclass.\n\n        Returns:\n            int: The number of fields in the dataclass.\n        \"\"\"\n        return len(fields(self))", "label": 0}
{"function": "    def _factory(branches: list[str]) -> None:\n        mocker.patch(\n            \"gitingest.utils.git_utils.run_command\",\n            new_callable=AsyncMock,\n            return_value=(\"\\n\".join(f\"refs/heads/{b}\" for b in branches).encode() + b\"\\n\", b\"\"),\n        )\n        mocker.patch(\n            \"gitingest.utils.git_utils.fetch_remote_branches_or_tags\",\n            new_callable=AsyncMock,\n            return_value=branches,\n        )", "label": 0}
{"function": "    def test_iterqueue(self, n='test_iterqueue'):\n        i = [0]\n\n        class C(compat.Consumer):\n\n            def fetch(self, limit=None):\n                z = i[0]\n                i[0] += 1\n                return z\n\n        c = C(self.connection,\n              queue=n, exchange=n, routing_key='rkey')\n        assert list(c.iterqueue(limit=10)) == list(range(10))\n        c.close()", "label": 1}
{"function": "    def __imul__(self, other):\n        return self * other", "label": 1}
{"function": "    def generate(self,\n                 input_prompt,\n                 first_frame,\n                 last_frame,\n                 max_area=720 * 1280,\n                 frame_num=81,\n                 shift=16,\n                 sample_solver='unipc',\n                 sampling_steps=50,\n                 guide_scale=5.5,\n                 n_prompt=\"\",\n                 seed=-1,\n                 offload_model=True):\n        r\"\"\"\n        Generates video frames from input first-last frame and text prompt using diffusion process.\n\n        Args:\n            input_prompt (`str`):\n                Text prompt for content generation.\n            first_frame (PIL.Image.Image):\n                Input image tensor. Shape: [3, H, W]\n            last_frame (PIL.Image.Image):\n                Input image tensor. Shape: [3, H, W]\n                [NOTE] If the sizes of first_frame and last_frame are mismatched, last_frame will be cropped & resized\n                to match first_frame.\n            max_area (`int`, *optional*, defaults to 720*1280):\n                Maximum pixel area for latent space calculation. Controls video resolution scaling\n            frame_num (`int`, *optional*, defaults to 81):\n                How many frames to sample from a video. The number should be 4n+1\n            shift (`float`, *optional*, defaults to 5.0):\n                Noise schedule shift parameter. Affects temporal dynamics\n                [NOTE]: If you want to generate a 480p video, it is recommended to set the shift value to 3.0.\n            sample_solver (`str`, *optional*, defaults to 'unipc'):\n                Solver used to sample the video.\n            sampling_steps (`int`, *optional*, defaults to 40):\n                Number of diffusion sampling steps. Higher values improve quality but slow generation\n            guide_scale (`float`, *optional*, defaults 5.0):\n                Classifier-free guidance scale. Controls prompt adherence vs. creativity\n            n_prompt (`str`, *optional*, defaults to \"\"):\n                Negative prompt for content exclusion. If not given, use `config.sample_neg_prompt`\n            seed (`int`, *optional*, defaults to -1):\n                Random seed for noise generation. If -1, use random seed\n            offload_model (`bool`, *optional*, defaults to True):\n                If True, offloads models to CPU during generation to save VRAM\n\n        Returns:\n            torch.Tensor:\n                Generated video frames tensor. Dimensions: (C, N H, W) where:\n                - C: Color channels (3 for RGB)\n                - N: Number of frames (81)\n                - H: Frame height (from max_area)\n                - W: Frame width from max_area)\n        \"\"\"\n        first_frame_size = first_frame.size\n        last_frame_size = last_frame.size\n        first_frame = TF.to_tensor(first_frame).sub_(0.5).div_(0.5).to(\n            self.device)\n        last_frame = TF.to_tensor(last_frame).sub_(0.5).div_(0.5).to(\n            self.device)\n\n        F = frame_num\n        first_frame_h, first_frame_w = first_frame.shape[1:]\n        aspect_ratio = first_frame_h / first_frame_w\n        lat_h = round(\n            np.sqrt(max_area * aspect_ratio) // self.vae_stride[1] //\n            self.patch_size[1] * self.patch_size[1])\n        lat_w = round(\n            np.sqrt(max_area / aspect_ratio) // self.vae_stride[2] //\n            self.patch_size[2] * self.patch_size[2])\n        first_frame_h = lat_h * self.vae_stride[1]\n        first_frame_w = lat_w * self.vae_stride[2]\n        if first_frame_size != last_frame_size:\n            # 1. resize\n            last_frame_resize_ratio = max(\n                first_frame_size[0] / last_frame_size[0],\n                first_frame_size[1] / last_frame_size[1])\n            last_frame_size = [\n                round(last_frame_size[0] * last_frame_resize_ratio),\n                round(last_frame_size[1] * last_frame_resize_ratio),\n            ]\n            # 2. center crop\n            last_frame = TF.center_crop(last_frame, last_frame_size)\n\n        max_seq_len = ((F - 1) // self.vae_stride[0] + 1) * lat_h * lat_w // (\n            self.patch_size[1] * self.patch_size[2])\n        max_seq_len = int(math.ceil(max_seq_len / self.sp_size)) * self.sp_size\n\n        seed = seed if seed >= 0 else random.randint(0, sys.maxsize)\n        seed_g = torch.Generator(device=self.device)\n        seed_g.manual_seed(seed)\n        noise = torch.randn(\n            16, (F - 1) // 4 + 1,\n            lat_h,\n            lat_w,\n            dtype=torch.float32,\n            generator=seed_g,\n            device=self.device)\n\n        msk = torch.ones(1, 81, lat_h, lat_w, device=self.device)\n        msk[:, 1:-1] = 0\n        msk = torch.concat([\n            torch.repeat_interleave(msk[:, 0:1], repeats=4, dim=1), msk[:, 1:]\n        ],\n                           dim=1)\n        msk = msk.view(1, msk.shape[1] // 4, 4, lat_h, lat_w)\n        msk = msk.transpose(1, 2)[0]\n\n        if n_prompt == \"\":\n            n_prompt = self.sample_neg_prompt\n\n        # preprocess\n        if not self.t5_cpu:\n            self.text_encoder.model.to(self.device)\n            context = self.text_encoder([input_prompt], self.device)\n            context_null = self.text_encoder([n_prompt], self.device)\n            if offload_model:\n                self.text_encoder.model.cpu()\n        else:\n            context = self.text_encoder([input_prompt], torch.device('cpu'))\n            context_null = self.text_encoder([n_prompt], torch.device('cpu'))\n            context = [t.to(self.device) for t in context]\n            context_null = [t.to(self.device) for t in context_null]\n\n        self.clip.model.to(self.device)\n        clip_context = self.clip.visual(\n            [first_frame[:, None, :, :], last_frame[:, None, :, :]])\n        if offload_model:\n            self.clip.model.cpu()\n\n        y = self.vae.encode([\n            torch.concat([\n                torch.nn.functional.interpolate(\n                    first_frame[None].cpu(),\n                    size=(first_frame_h, first_frame_w),\n                    mode='bicubic').transpose(0, 1),\n                torch.zeros(3, F - 2, first_frame_h, first_frame_w),\n                torch.nn.functional.interpolate(\n                    last_frame[None].cpu(),\n                    size=(first_frame_h, first_frame_w),\n                    mode='bicubic').transpose(0, 1),\n            ],\n                         dim=1).to(self.device)\n        ])[0]\n        y = torch.concat([msk, y])\n\n        @contextmanager\n        def noop_no_sync():\n            yield\n\n        no_sync = getattr(self.model, 'no_sync', noop_no_sync)\n\n        # evaluation mode\n        with amp.autocast(dtype=self.param_dtype), torch.no_grad(), no_sync():\n\n            if sample_solver == 'unipc':\n                sample_scheduler = FlowUniPCMultistepScheduler(\n                    num_train_timesteps=self.num_train_timesteps,\n                    shift=1,\n                    use_dynamic_shifting=False)\n                sample_scheduler.set_timesteps(\n                    sampling_steps, device=self.device, shift=shift)\n                timesteps = sample_scheduler.timesteps\n            elif sample_solver == 'dpm++':\n                sample_scheduler = FlowDPMSolverMultistepScheduler(\n                    num_train_timesteps=self.num_train_timesteps,\n                    shift=1,\n                    use_dynamic_shifting=False)\n                sampling_sigmas = get_sampling_sigmas(sampling_steps, shift)\n                timesteps, _ = retrieve_timesteps(\n                    sample_scheduler,\n                    device=self.device,\n                    sigmas=sampling_sigmas)\n            else:\n                raise NotImplementedError(\"Unsupported solver.\")\n\n            # sample videos\n            latent = noise\n\n            arg_c = {\n                'context': [context[0]],\n                'clip_fea': clip_context,\n                'seq_len': max_seq_len,\n                'y': [y],\n            }\n\n            arg_null = {\n                'context': context_null,\n                'clip_fea': clip_context,\n                'seq_len': max_seq_len,\n                'y': [y],\n            }\n\n            if offload_model:\n                torch.cuda.empty_cache()\n\n            self.model.to(self.device)\n            for _, t in enumerate(tqdm(timesteps)):\n                latent_model_input = [latent.to(self.device)]\n                timestep = [t]\n\n                timestep = torch.stack(timestep).to(self.device)\n\n                noise_pred_cond = self.model(\n                    latent_model_input, t=timestep, **arg_c)[0].to(\n                        torch.device('cpu') if offload_model else self.device)\n                if offload_model:\n                    torch.cuda.empty_cache()\n                noise_pred_uncond = self.model(\n                    latent_model_input, t=timestep, **arg_null)[0].to(\n                        torch.device('cpu') if offload_model else self.device)\n                if offload_model:\n                    torch.cuda.empty_cache()\n                noise_pred = noise_pred_uncond + guide_scale * (\n                    noise_pred_cond - noise_pred_uncond)\n\n                latent = latent.to(\n                    torch.device('cpu') if offload_model else self.device)\n\n                temp_x0 = sample_scheduler.step(\n                    noise_pred.unsqueeze(0),\n                    t,\n                    latent.unsqueeze(0),\n                    return_dict=False,\n                    generator=seed_g)[0]\n                latent = temp_x0.squeeze(0)\n\n                x0 = [latent.to(self.device)]\n                del latent_model_input, timestep\n\n            if offload_model:\n                self.model.cpu()\n                torch.cuda.empty_cache()\n\n            if self.rank == 0:\n                videos = self.vae.decode(x0)\n\n        del noise, latent\n        del sample_scheduler\n        if offload_model:\n            gc.collect()\n            torch.cuda.synchronize()\n        if dist.is_initialized():\n            dist.barrier()\n\n        return videos[0] if self.rank == 0 else None", "label": 0}
{"function": "def update_log():\n    \"\"\"\n    Display a quick log message while waiting.\n    \"\"\"\n    return \"Loading and Reconstructing...\"", "label": 0}
{"function": "def partial_fields(target_class, kwargs):\n    return target_class(**{k: v for k, v in kwargs.items() if hasattr(target_class, k)})", "label": 0}
{"function": "        def get_flow_dict(_flow):\n            flow_map = {_flow.name: _flow.flow_id}\n            for subflow in _flow.components:\n                flow_map.update(get_flow_dict(_flow.components[subflow]))\n            return flow_map", "label": 1}
{"function": "def main():\n    parser = argparse.ArgumentParser('export_quantized')\n    parser.add_argument(\"--tokenizer\", type=str, help=\"Path to a local tokenizer file.\")\n    parser.add_argument(\"--moshi-weight\", type=str, help=\"Path to a local checkpoint file for Moshi.\")\n    parser.add_argument(\"--mimi-weight\", type=str, help=\"Path to a local checkpoint file for Mimi.\")\n    parser.add_argument(\"--hf-repo\", type=str, default=loaders.DEFAULT_REPO,\n                        help=\"HF repo to look into, defaults Moshiko. \"\n                             \"Use this to select a different pre-trained model.\")\n    parser.add_argument(\"--config\", \"--lm-config\", dest=\"config\", type=str, help=\"The config as a json file.\")\n    parser.add_argument('new_hf_repo')\n\n    args = parser.parse_args()\n    api = get_api()\n\n    info = loaders.CheckpointInfo.from_hf_repo(\n        args.hf_repo, moshi_weights=args.moshi_weight, mimi_weights=args.mimi_weight,\n        tokenizer=args.tokenizer, config_path=args.config)\n\n    if not api.repo_exists(args.new_hf_repo):\n        api.create_repo(args.new_hf_repo, repo_type='model', private=True)\n        print(\"Repo created.\")\n\n    config = info.raw_config\n    assert config is not None\n    config['mimi_name'] = info.mimi_weights.name\n    config['moshi_name'] = info.moshi_weights.name\n    config['tokenizer_name'] = info.tokenizer.name\n    for file in [info.mimi_weights, info.moshi_weights, info.tokenizer]:\n        if not api.file_exists(args.new_hf_repo, file.name):\n            print(\"Uploading file\", file)\n            api.upload_file(\n                path_or_fileobj=file,\n                path_in_repo=file.name,\n                repo_id=args.new_hf_repo,\n                repo_type=\"model\")\n    with tempfile.NamedTemporaryFile(mode='w') as file:\n        json.dump(config, file, indent=2)\n        file.flush()\n        api.upload_file(\n            path_or_fileobj=file.name,\n            path_in_repo='config.json',\n            repo_id=args.new_hf_repo,\n            repo_type=\"model\")", "label": 0}
{"function": "    def __init__(self, kernel_size=1):\n        super(Resample2d, self).__init__()\n        self.kernel_size = kernel_size", "label": 1}
{"function": "def test_tokenizer(name, tokenizer, verbose=False):\n    print(f\"--- {name} ({tokenizer.__class__.__name__}) ---\")\n    text = \"Hello! How can I assist you today? Let me know if you need help with something or just want to chat.\"\n    encoded = tokenizer.encode(text)\n    decoded = tokenizer.decode(encoded)\n\n    print(f\"{encoded=}\")\n    print(f\"{decoded=}\")\n\n    reconstructed = \"\"\n    for token in encoded:\n      if verbose:\n        print(f\"{token=}\")\n        print(f\"{tokenizer.decode([token])=}\")\n      reconstructed += tokenizer.decode([token])\n    print(f\"{reconstructed=}\")\n\n    strip_tokens = lambda s: s.lstrip(tokenizer.decode([tokenizer.bos_token_id])).rstrip(tokenizer.decode([tokenizer.eos_token_id]))\n    assert text == strip_tokens(decoded) == strip_tokens(reconstructed)", "label": 0}
{"function": "    def on_status_button_right_click(self, e = None):\n        if not self.searching:\n            self.show_extended_status_menu()", "label": 1}
{"function": "    def __init__(self):\n        super(LiterateHaskellRenderer, self).__init__(\n            executable='ruby',\n            args=['-rubygems', os.path.join(__path__, 'bin/lhs2html.rb')])", "label": 1}
{"function": "    def _wait_until_alive(self):\n        super().check_if_alive()", "label": 0}
{"function": "    def __setstate__(self, state):\n        \"\"\"Object.__setstate__.\n\n        Args:\n            state (dict): unpickled state.\n\n        \"\"\"\n        self.__dict__.update(state)\n        self._replay_buffers = {\n            i: PathBuffer(self._replay_buffer_size)\n            for i in range(self._num_train_tasks)\n        }\n\n        self._context_replay_buffers = {\n            i: PathBuffer(self._replay_buffer_size)\n            for i in range(self._num_train_tasks)\n        }\n        self._is_resuming = True", "label": 1}
{"function": "    def _predict(self, feature):\n        \"\"\"\n        :param feature: feature of a single sample\n        :return:\n        \"\"\"\n        cur_tree_node = self.root\n        while not cur_tree_node.is_leaf:\n            if feature[cur_tree_node.split_feature] <= cur_tree_node.split_threshold:\n                cur_tree_node = cur_tree_node.left_child\n            else:\n                cur_tree_node = cur_tree_node.right_child\n        return cur_tree_node.leaf_score", "label": 1}
{"function": "    def stack(self, psf):\n        \"\"\"Stack two EnergyDependentTablePSF objects.s\n\n        Parameters\n        ----------\n        psf : `EnergyDependentTablePSF`\n            PSF to stack.\n\n        Returns\n        -------\n        stacked_psf : `EnergyDependentTablePSF`\n            Stacked PSF.\n\n        \"\"\"\n        exposure = self.exposure + psf.exposure\n        psf_value = self.psf_value.T * self.exposure + psf.psf_value.T * psf.exposure\n\n        with np.errstate(invalid=\"ignore\"):\n            # exposure can be zero\n            psf_value = np.nan_to_num(psf_value / exposure)\n\n        return self.__class__(\n            energy=self.energy, rad=self.rad, psf_value=psf_value.T, exposure=exposure\n        )", "label": 1}
{"function": "def init_env_file():\n    \"\"\"Initialize .env file if it doesn't exist\"\"\"\n    dotenv_path = find_dotenv()\n    if not dotenv_path:\n        with open(\".env\", \"w\") as f:\n            f.write(DEFAULT_ENV_TEMPLATE)\n        dotenv_path = find_dotenv()\n    return dotenv_path", "label": 0}
{"function": "    def all():\n        return list(AgentContext._contexts.values())", "label": 0}
{"function": "def SimplePoint():\n    newpoints = []\n\n    newpoints.append([0.0, 0.0, 0.0])\n\n    return newpoints", "label": 1}
{"function": "  def map_engine(engine):\n    return inference_engine_classes.get(engine, engine)  # Return original name if not found", "label": 0}
{"function": "def test_calibrate():\n    robot_cfg = MockRobotConfig()\n    cfg = CalibrateConfig(robot=robot_cfg)\n    calibrate(cfg)", "label": 0}
{"function": "  def testContainsWildcardNoMatches(self, mock_CreateWildcardIterator,\n                                    mock_gsutil_api):\n    mock_CreateWildcardIterator.return_value = iter([])\n    with self.assertRaises(CommandException):\n      ExpandUrlToSingleBlr('gs://test/hello*/', mock_gsutil_api, 'project_id',\n                           False, CreateOrGetGsutilLogger('copy_test'))", "label": 1}
{"function": "    def __repr__(self):\n        return '[%s] %s %s' % (self.name, self.type, ' '.join(self.value))", "label": 1}
{"function": "def test__xla_dist_model_create_from_context():\n    # without spawn\n    model = _XlaDistModel.create_from_context()\n\n    assert model.backend() == \"xla-tpu\"\n\n    import torch_xla.core.xla_model as xm\n\n    _assert_model(\n        model,\n        {\n            \"device\": xm.xla_device(),\n            \"local_rank\": 0,\n            \"rank\": 0,\n            \"world_size\": 1,\n            \"node_index\": 0,\n            \"nnodes\": 1,\n            \"nproc_per_node\": 1,\n        },\n    )", "label": 1}
{"function": "def main():\n    parser = argparse.ArgumentParser(description=\"Generate a tutorial for a GitHub codebase or local directory.\")\n\n    # Create mutually exclusive group for source\n    source_group = parser.add_mutually_exclusive_group(required=True)\n    source_group.add_argument(\"--repo\", help=\"URL of the public GitHub repository.\")\n    source_group.add_argument(\"--dir\", help=\"Path to local directory.\")\n\n    parser.add_argument(\"-n\", \"--name\", help=\"Project name (optional, derived from repo/directory if omitted).\")\n    parser.add_argument(\"-t\", \"--token\", help=\"GitHub personal access token (optional, reads from GITHUB_TOKEN env var if not provided).\")\n    parser.add_argument(\"-o\", \"--output\", default=\"output\", help=\"Base directory for output (default: ./output).\")\n    parser.add_argument(\"-i\", \"--include\", nargs=\"+\", help=\"Include file patterns (e.g. '*.py' '*.js'). Defaults to common code files if not specified.\")\n    parser.add_argument(\"-e\", \"--exclude\", nargs=\"+\", help=\"Exclude file patterns (e.g. 'tests/*' 'docs/*'). Defaults to test/build directories if not specified.\")\n    parser.add_argument(\"-s\", \"--max-size\", type=int, default=100000, help=\"Maximum file size in bytes (default: 100000, about 100KB).\")\n    # Add language parameter for multi-language support\n    parser.add_argument(\"--language\", default=\"english\", help=\"Language for the generated tutorial (default: english)\")\n    # Add use_cache parameter to control LLM caching\n    parser.add_argument(\"--no-cache\", action=\"store_true\", help=\"Disable LLM response caching (default: caching enabled)\")\n    # Add max_abstraction_num parameter to control the number of abstractions\n    parser.add_argument(\"--max-abstractions\", type=int, default=10, help=\"Maximum number of abstractions to identify (default: 10)\")\n\n    args = parser.parse_args()\n\n    # Get GitHub token from argument or environment variable if using repo\n    github_token = None\n    if args.repo:\n        github_token = args.token or os.environ.get('GITHUB_TOKEN')\n        if not github_token:\n            print(\"Warning: No GitHub token provided. You might hit rate limits for public repositories.\")\n\n    # Initialize the shared dictionary with inputs\n    shared = {\n        \"repo_url\": args.repo,\n        \"local_dir\": args.dir,\n        \"project_name\": args.name, # Can be None, FetchRepo will derive it\n        \"github_token\": github_token,\n        \"output_dir\": args.output, # Base directory for CombineTutorial output\n\n        # Add include/exclude patterns and max file size\n        \"include_patterns\": set(args.include) if args.include else DEFAULT_INCLUDE_PATTERNS,\n        \"exclude_patterns\": set(args.exclude) if args.exclude else DEFAULT_EXCLUDE_PATTERNS,\n        \"max_file_size\": args.max_size,\n\n        # Add language for multi-language support\n        \"language\": args.language,\n        \n        # Add use_cache flag (inverse of no-cache flag)\n        \"use_cache\": not args.no_cache,\n        \n        # Add max_abstraction_num parameter\n        \"max_abstraction_num\": args.max_abstractions,\n\n        # Outputs will be populated by the nodes\n        \"files\": [],\n        \"abstractions\": [],\n        \"relationships\": {},\n        \"chapter_order\": [],\n        \"chapters\": [],\n        \"final_output_dir\": None\n    }\n\n    # Display starting message with repository/directory and language\n    print(f\"Starting tutorial generation for: {args.repo or args.dir} in {args.language.capitalize()} language\")\n    print(f\"LLM caching: {'Disabled' if args.no_cache else 'Enabled'}\")\n\n    # Create the flow instance\n    tutorial_flow = create_tutorial_flow()\n\n    # Run the flow\n    tutorial_flow.run(shared)", "label": 0}
{"function": "    def append(self, value):\n        \"\"\"Detect list add events and emit change events.\"\"\"\n        list.append(self, value)\n        self.changed()", "label": 1}
{"function": "    async def start(self, callback=None):\n        def default_callback(self, *args, **kwargs):\n            pass\n\n        self.update_progress = callback or default_callback\n        self.run_ui = True if callback else False\n        if self.run_ui:\n            self.update_progress(f\"\u6b63\u5728\u68c0\u67e5\u7f51\u7edc\u662f\u5426\u652f\u6301IPv6\", 0)\n        self.ipv6_support = config.ipv6_support or check_ipv6_support()\n        if not os.getenv(\"GITHUB_ACTIONS\") and config.update_interval:\n            await self.scheduler(asyncio.Event())\n        else:\n            await self.main()", "label": 0}
{"function": "    def register_multicall_functions(self):\n        \"\"\"Registers the XML-RPC multicall method in the system\n        namespace.\n\n        see http://www.xmlrpc.com/discuss/msgReader$1208\"\"\"\n\n        self.funcs.update({'system.multicall' : self.system_multicall})", "label": 1}
{"function": "def main():\n    # Get database path\n    config = Config.from_env()\n    db_path = config.database.db_file\n    \n    print(f\"Database path: {db_path}\")\n    \n    # Create migration manager\n    manager = MigrationManager(db_path)\n    \n    # Get applied migrations\n    applied = manager.get_applied_migrations()\n    print(f\"Applied migrations: {', '.join(applied) if applied else 'none'}\")\n    \n    if not applied:\n        print(\"No migrations to downgrade\")\n        return\n    \n    # Check command line arguments\n    if len(sys.argv) > 1:\n        target_version = sys.argv[1]\n        if target_version not in applied:\n            print(f\"Error: Version {target_version} is not applied, cannot downgrade to this version\")\n            return\n        \n        print(f\"Downgrading to version {target_version}...\")\n        downgraded = manager.downgrade_to_version(target_version)\n    else:\n        print(\"Downgrading all migrations...\")\n        downgraded = manager.downgrade_to_version()\n    \n    if downgraded:\n        print(f\"Successfully downgraded migrations: {', '.join(downgraded)}\")\n    else:\n        print(\"No migrations were downgraded\")", "label": 0}
{"function": "    def digest(self):\n        return mysql41.encrypt(self._data[:64])[1:].decode('hex')", "label": 1}
{"function": "def interactive_image_generator():\n    print(\"Welcome to the interactive image generator!\")\n\n    # Ask for the number of images at the start of the session\n    while True:\n        num_images_input = input(\"How many images would you like to generate per prompt? (Enter a positive integer): \")\n        if num_images_input.isdigit() and int(num_images_input) > 0:\n            parallel_size = int(num_images_input)\n            break\n        else:\n            print(\"Invalid input. Please enter a positive integer.\")\n\n    while True:\n        user_input = input(\"Please describe the image you'd like to generate (or type 'exit' to quit): \")\n\n        if user_input.lower() == 'exit':\n            print(\"Exiting the image generator. Goodbye!\")\n            break\n\n        prompt = create_prompt(user_input)\n\n        # Create a sanitized version of user_input for the filename\n        short_prompt = re.sub(r'\\W+', '_', user_input)[:50]\n\n        print(f\"Generating {parallel_size} image(s) for: '{user_input}'\")\n        generate(\n            mmgpt=vl_gpt,\n            vl_chat_processor=vl_chat_processor,\n            prompt=prompt,\n            short_prompt=short_prompt,\n            parallel_size=parallel_size  # Pass the user-specified number of images\n        )\n\n        print(\"Image generation complete! Check the 'generated_samples' folder for the output.\\n\")", "label": 0}
{"function": "    def testGen(self, mock_init, mock_gen):\n        # Test with constraints\n        modelbridge = RandomModelBridge()\n        modelbridge.parameters = [\"x\", \"y\", \"z\"]\n        modelbridge.transforms = OrderedDict()\n        modelbridge.model = RandomModel()\n        observation_features, weights, best_obsf, _ = modelbridge._gen(\n            n=3,\n            search_space=self.search_space,\n            pending_observations={},\n            fixed_features=ObservationFeatures({\"z\": 3.0}),\n            optimization_config=None,\n            model_gen_options=self.model_gen_options,\n        )\n        gen_args = mock_gen.mock_calls[0][2]\n        self.assertEqual(gen_args[\"n\"], 3)\n        self.assertEqual(gen_args[\"bounds\"], [(0.0, 1.0), (1.0, 2.0), (0.0, 5.0)])\n        self.assertTrue(\n            np.array_equal(\n                gen_args[\"linear_constraints\"][0],\n                np.array([[1.0, -1, 0.0], [-1.0, 0.0, -1.0]]),\n            )\n        )\n        self.assertTrue(\n            np.array_equal(gen_args[\"linear_constraints\"][1], np.array([[0.0], [-3.5]]))\n        )\n        self.assertEqual(gen_args[\"fixed_features\"], {2: 3.0})\n        self.assertEqual(gen_args[\"model_gen_options\"], {\"option\": \"yes\"})\n        self.assertEqual(\n            observation_features[0].parameters, {\"x\": 1.0, \"y\": 2.0, \"z\": 3.0}\n        )\n        self.assertEqual(\n            observation_features[1].parameters, {\"x\": 3.0, \"y\": 4.0, \"z\": 3.0}\n        )\n        self.assertTrue(np.array_equal(weights, np.array([1.0, 2.0])))\n\n        # Test with no constraints, no fixed feature, no pending observations\n        search_space = SearchSpace(self.parameters[:2])\n        modelbridge.parameters = [\"x\", \"y\"]\n        modelbridge._gen(\n            n=3,\n            search_space=search_space,\n            pending_observations={},\n            fixed_features=ObservationFeatures({}),\n            optimization_config=None,\n            model_gen_options=self.model_gen_options,\n        )\n        gen_args = mock_gen.mock_calls[1][2]\n        self.assertEqual(gen_args[\"bounds\"], [(0.0, 1.0), (1.0, 2.0)])\n        self.assertIsNone(gen_args[\"linear_constraints\"])\n        self.assertIsNone(gen_args[\"fixed_features\"])", "label": 1}
{"function": "    def __init__(self, open, high, low, close):\n        pass", "label": 1}
{"function": "    def get(\n            self, resource_group_name, ip_groups_name, expand=None, custom_headers=None, raw=False, **operation_config):\n        \"\"\"Gets the specified ipGroups.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param ip_groups_name: The name of the ipGroups.\n        :type ip_groups_name: str\n        :param expand: Expands resourceIds (of Firewalls/Network Security\n         Groups etc.) back referenced by the IpGroups resource.\n        :type expand: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: IpGroup or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2019_09_01.models.IpGroup or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorException<azure.mgmt.network.v2019_09_01.models.ErrorException>`\n        \"\"\"\n        # Construct URL\n        url = self.get.metadata['url']\n        path_format_arguments = {\n            'resourceGroupName': self._serialize.url(\"resource_group_name\", resource_group_name, 'str'),\n            'ipGroupsName': self._serialize.url(\"ip_groups_name\", ip_groups_name, 'str'),\n            'subscriptionId': self._serialize.url(\"self.config.subscription_id\", self.config.subscription_id, 'str')\n        }\n        url = self._client.format_url(url, **path_format_arguments)\n\n        # Construct parameters\n        query_parameters = {}\n        query_parameters['api-version'] = self._serialize.query(\"self.api_version\", self.api_version, 'str')\n        if expand is not None:\n            query_parameters['$expand'] = self._serialize.query(\"expand\", expand, 'str')\n\n        # Construct headers\n        header_parameters = {}\n        header_parameters['Accept'] = 'application/json'\n        if self.config.generate_client_request_id:\n            header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())\n        if custom_headers:\n            header_parameters.update(custom_headers)\n        if self.config.accept_language is not None:\n            header_parameters['accept-language'] = self._serialize.header(\"self.config.accept_language\", self.config.accept_language, 'str')\n\n        # Construct and send request\n        request = self._client.get(url, query_parameters, header_parameters)\n        response = self._client.send(request, stream=False, **operation_config)\n\n        if response.status_code not in [200]:\n            raise models.ErrorException(self._deserialize, response)\n\n        deserialized = None\n        if response.status_code == 200:\n            deserialized = self._deserialize('IpGroup', response)\n\n        if raw:\n            client_raw_response = ClientRawResponse(deserialized, response)\n            return client_raw_response\n\n        return deserialized", "label": 1}
{"function": "    def _execute_command_internal(self, command):\n        \"\"\"Internal command execution with proper context\"\"\"\n        cmd_type = command.get(\"type\")\n        params = command.get(\"params\", {})\n\n        # Add a handler for checking PolyHaven status\n        if cmd_type == \"get_polyhaven_status\":\n            return {\"status\": \"success\", \"result\": self.get_polyhaven_status()}\n        \n        # Base handlers that are always available\n        handlers = {\n            \"get_scene_info\": self.get_scene_info,\n            \"get_object_info\": self.get_object_info,\n            \"get_viewport_screenshot\": self.get_viewport_screenshot,\n            \"execute_code\": self.execute_code,\n            \"get_polyhaven_status\": self.get_polyhaven_status,\n            \"get_hyper3d_status\": self.get_hyper3d_status,\n            \"get_sketchfab_status\": self.get_sketchfab_status,\n        }\n        \n        # Add Polyhaven handlers only if enabled\n        if bpy.context.scene.blendermcp_use_polyhaven:\n            polyhaven_handlers = {\n                \"get_polyhaven_categories\": self.get_polyhaven_categories,\n                \"search_polyhaven_assets\": self.search_polyhaven_assets,\n                \"download_polyhaven_asset\": self.download_polyhaven_asset,\n                \"set_texture\": self.set_texture,\n            }\n            handlers.update(polyhaven_handlers)\n        \n        # Add Hyper3d handlers only if enabled\n        if bpy.context.scene.blendermcp_use_hyper3d:\n            polyhaven_handlers = {\n                \"create_rodin_job\": self.create_rodin_job,\n                \"poll_rodin_job_status\": self.poll_rodin_job_status,\n                \"import_generated_asset\": self.import_generated_asset,\n            }\n            handlers.update(polyhaven_handlers)\n            \n        # Add Sketchfab handlers only if enabled\n        if bpy.context.scene.blendermcp_use_sketchfab:\n            sketchfab_handlers = {\n                \"search_sketchfab_models\": self.search_sketchfab_models,\n                \"download_sketchfab_model\": self.download_sketchfab_model,\n            }\n            handlers.update(sketchfab_handlers)\n\n        handler = handlers.get(cmd_type)\n        if handler:\n            try:\n                print(f\"Executing handler for {cmd_type}\")\n                result = handler(**params)\n                print(f\"Handler execution complete\")\n                return {\"status\": \"success\", \"result\": result}\n            except Exception as e:\n                print(f\"Error in handler: {str(e)}\")\n                traceback.print_exc()\n                return {\"status\": \"error\", \"message\": str(e)}\n        else:\n            return {\"status\": \"error\", \"message\": f\"Unknown command type: {cmd_type}\"}", "label": 0}
{"function": "    def __init__(self, real, timeperiod=30):\n        pass", "label": 1}
{"function": "    def target_temperature_low(self):\n        \"\"\"Return the lowbound target temperature we try to reach.\"\"\"\n        return self._target_temperature_low", "label": 1}
{"function": "def main():\n    cosyvoice = CosyVoice2('pretrained_models/CosyVoice2-0.5B', load_jit=True, load_trt=True, load_vllm=True, fp16=True)\n    prompt_speech_16k = load_wav('./asset/zero_shot_prompt.wav', 16000)\n    for i in tqdm(range(100)):\n        set_all_random_seed(i)\n        for _, _ in enumerate(cosyvoice.inference_zero_shot('\u6536\u5230\u597d\u53cb\u4ece\u8fdc\u65b9\u5bc4\u6765\u7684\u751f\u65e5\u793c\u7269\uff0c\u90a3\u4efd\u610f\u5916\u7684\u60ca\u559c\u4e0e\u6df1\u6df1\u7684\u795d\u798f\u8ba9\u6211\u5fc3\u4e2d\u5145\u6ee1\u4e86\u751c\u871c\u7684\u5feb\u4e50\uff0c\u7b11\u5bb9\u5982\u82b1\u513f\u822c\u7efd\u653e\u3002', '\u5e0c\u671b\u4f60\u4ee5\u540e\u80fd\u591f\u505a\u7684\u6bd4\u6211\u8fd8\u597d\u5466\u3002', prompt_speech_16k, stream=False)):\n            continue", "label": 0}
{"function": "    def testSmallPage(self):\n        local_pdf_path = os.path.join(os.path.dirname(__file__), \"gnarly_pdfs\", \"small_page_size.pdf\")\n\n        report = _pdf_report(local_pdf_path, 1)\n\n        print(report)\n\n        print(get_anchor_text(local_pdf_path, 1, pdf_engine=\"pdfreport\"))", "label": 0}
{"function": "\tdef test_get_prompt_description_no_filters(self):\n\t\t\"\"\"Test that system prompt only includes actions with no filters\"\"\"\n\t\tregistry = ActionRegistry()\n\n\t\t# Add actions with and without filters\n\t\tno_filter_action = RegisteredAction(\n\t\t\tname='no_filter_action',\n\t\t\tdescription='Action with no filters',\n\t\t\tfunction=lambda: None,\n\t\t\tparam_model=EmptyParamModel,\n\t\t\tdomains=None,\n\t\t\tpage_filter=None,\n\t\t)\n\n\t\tpage_filter_action = RegisteredAction(\n\t\t\tname='page_filter_action',\n\t\t\tdescription='Action with page filter',\n\t\t\tfunction=lambda: None,\n\t\t\tparam_model=EmptyParamModel,\n\t\t\tdomains=None,\n\t\t\tpage_filter=lambda page: True,\n\t\t)\n\n\t\tdomain_filter_action = RegisteredAction(\n\t\t\tname='domain_filter_action',\n\t\t\tdescription='Action with domain filter',\n\t\t\tfunction=lambda: None,\n\t\t\tparam_model=EmptyParamModel,\n\t\t\tdomains=['example.com'],\n\t\t\tpage_filter=None,\n\t\t)\n\n\t\tregistry.actions = {\n\t\t\t'no_filter_action': no_filter_action,\n\t\t\t'page_filter_action': page_filter_action,\n\t\t\t'domain_filter_action': domain_filter_action,\n\t\t}\n\n\t\t# System prompt (no page) should only include actions with no filters\n\t\tsystem_description = registry.get_prompt_description()\n\t\tassert 'no_filter_action' in system_description\n\t\tassert 'page_filter_action' not in system_description\n\t\tassert 'domain_filter_action' not in system_description", "label": 0}
{"function": "    def _add_frag_write_service(self, count, ioi, write_data, data_type):\n        \"\"\"\n        Add the fragmented write command stuff to the tagIOI\n        \"\"\"\n        path_size = int(len(ioi)/2)\n        service = 0x53\n        request = pack('<BB', service, path_size)\n        request += ioi\n\n        if data_type == 160:\n            request += pack('<BB', data_type, 0x02)\n            request += pack('<H', self.StructIdentifier)\n        else:\n            request += pack('<H', data_type)\n        request += pack('<H', count)\n        request += pack('<I', self.Offset)\n\n        for v in write_data:\n            try:\n                for i in range(len(v)):\n                    el = v[i]\n                    request += pack(self.CIPTypes[data_type][2], el)\n            except Exception:\n                request += pack(self.CIPTypes[data_type][2], v)\n\n        return request", "label": 1}
{"function": "    def __init__(self, in_ch=3, mid_ch=12, out_ch=3):\n        super(RSU6, self).__init__()\n\n        self.rebnconvin = REBNCONV(in_ch, out_ch, dirate=1)\n\n        self.rebnconv1 = REBNCONV(out_ch, mid_ch, dirate=1)\n        self.pool1 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv2 = REBNCONV(mid_ch, mid_ch, dirate=1)\n        self.pool2 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv3 = REBNCONV(mid_ch, mid_ch, dirate=1)\n        self.pool3 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv4 = REBNCONV(mid_ch, mid_ch, dirate=1)\n        self.pool4 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv5 = REBNCONV(mid_ch, mid_ch, dirate=1)\n\n        self.rebnconv6 = REBNCONV(mid_ch, mid_ch, dirate=2)\n\n        self.rebnconv5d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv4d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv3d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv2d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv1d = REBNCONV(mid_ch * 2, out_ch, dirate=1)", "label": 0}
{"function": "  def testContainsWildcardMatchesNotObject(self, mock_CreateWildcardIterator,\n                                           mock_gsutil_api):\n    storage_url = StorageUrlFromString('gs://test/helloworld')\n    mock_CreateWildcardIterator.return_value = iter(\n        [BucketListingPrefix(storage_url)])\n    (exp_url, have_existing_dst_container) = ExpandUrlToSingleBlr(\n        'gs://test/hello*/', mock_gsutil_api, 'project_id', False,\n        CreateOrGetGsutilLogger('copy_test'))\n\n    self.assertTrue(have_existing_dst_container)\n    self.assertEqual(exp_url, storage_url)", "label": 1}
{"function": "    def on_profile_status_changed(self, *a):\n        \"Invoked when the profile's status changes.\"\n\n        self.show_status(profile.status)", "label": 1}
{"function": "def add_env_var(key, value, from_frontend=True):\n    \"\"\"Add or update a single environment variable\n\n    Args:\n        key: Environment variable name\n        value: Environment variable value\n        from_frontend: Whether it's from frontend configuration, default is True\n    \"\"\"\n    try:\n        if not key or not key.strip():\n            return False, \"Variable name cannot be empty\"\n\n        key = key.strip()\n        value = value.strip()\n\n        # If from frontend, add to frontend environment variable dictionary\n        if from_frontend:\n            WEB_FRONTEND_ENV_VARS[key] = value\n            # Directly update system environment variables\n            os.environ[key] = value\n\n        # Also update .env file\n        dotenv_path = init_env_file()\n        set_key(dotenv_path, key, value)\n        load_dotenv(dotenv_path, override=True)\n\n        return True, f\"Environment variable {key} has been successfully added/updated!\"\n    except Exception as e:\n        return False, f\"Error adding environment variable: {str(e)}\"", "label": 0}
{"function": "    def flush(self):\n        if self.linebuf != '':\n            self.logger.log(self.log_level, self.linebuf.rstrip())\n        self.linebuf = ''", "label": 0}
{"function": "    def should_continue_social(self, state: AgentState):\n        \"\"\"Determine if social media analysis should continue.\"\"\"\n        messages = state[\"messages\"]\n        last_message = messages[-1]\n        if last_message.tool_calls:\n            return \"tools_social\"\n        return \"Msg Clear Social\"", "label": 0}
{"function": "    def test_start_handshake(self, mock_share, mock_timer, *_):\n        self.server.start_handshake(\n            key_id=self.key_id,\n            task_id=self.task_id,\n        )\n        self.assertIn(\n            self.key_id,\n            self.server.resource_handshakes,\n        )\n        mock_timer.assert_called_once_with(self.key_id)\n        mock_share.assert_called_once_with(self.key_id)", "label": 1}
{"function": "def get_stats(ids, counts=None):\n    \"\"\"\n    Given a list of integers, return a dictionary of counts of consecutive pairs\n    Example: [1, 2, 3, 1, 2] -> {(1, 2): 2, (2, 3): 1, (3, 1): 1}\n    Optionally allows to update an existing dictionary of counts\n    \"\"\"\n    counts = {} if counts is None else counts\n    for pair in zip(ids, ids[1:]): # iterate consecutive elements\n        counts[pair] = counts.get(pair, 0) + 1\n    return counts", "label": 0}
{"function": "    def key_id(self):\n        return self.public_key[2:]", "label": 1}
{"function": "    def _get_extension_path(self,exname='turnstilePatch'):\n        \"\"\"\u83b7\u53d6\u63d2\u4ef6\u8def\u5f84\"\"\"\n        root_dir = os.getcwd()\n        extension_path = os.path.join(root_dir, exname)\n\n        if hasattr(sys, \"_MEIPASS\"):\n            extension_path = os.path.join(sys._MEIPASS, exname)\n\n        if not os.path.exists(extension_path):\n            raise FileNotFoundError(f\"\u63d2\u4ef6\u4e0d\u5b58\u5728: {extension_path}\")\n\n        return extension_path", "label": 0}
{"function": "    def __init__(self, in_ch=3, mid_ch=12, out_ch=3):\n        super(RSU5, self).__init__()\n\n        self.rebnconvin = REBNCONV(in_ch, out_ch, dirate=1)\n\n        self.rebnconv1 = REBNCONV(out_ch, mid_ch, dirate=1)\n        self.pool1 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv2 = REBNCONV(mid_ch, mid_ch, dirate=1)\n        self.pool2 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv3 = REBNCONV(mid_ch, mid_ch, dirate=1)\n        self.pool3 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv4 = REBNCONV(mid_ch, mid_ch, dirate=1)\n\n        self.rebnconv5 = REBNCONV(mid_ch, mid_ch, dirate=2)\n\n        self.rebnconv4d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv3d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv2d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv1d = REBNCONV(mid_ch * 2, out_ch, dirate=1)", "label": 0}
{"function": "def _parse_args():\n    parser = argparse.ArgumentParser(\n        description=\"Generate a image or video from a text prompt or image using Wan\"\n    )\n    parser.add_argument(\n        \"--task\",\n        type=str,\n        default=\"t2v-14B\",\n        choices=list(WAN_CONFIGS.keys()),\n        help=\"The task to run.\")\n    parser.add_argument(\n        \"--size\",\n        type=str,\n        default=\"1280*720\",\n        choices=list(SIZE_CONFIGS.keys()),\n        help=\"The area (width*height) of the generated video. For the I2V task, the aspect ratio of the output video will follow that of the input image.\"\n    )\n    parser.add_argument(\n        \"--frame_num\",\n        type=int,\n        default=None,\n        help=\"How many frames to sample from a image or video. The number should be 4n+1\"\n    )\n    parser.add_argument(\n        \"--ckpt_dir\",\n        type=str,\n        default=None,\n        help=\"The path to the checkpoint directory.\")\n    parser.add_argument(\n        \"--offload_model\",\n        type=str2bool,\n        default=None,\n        help=\"Whether to offload the model to CPU after each model forward, reducing GPU memory usage.\"\n    )\n    parser.add_argument(\n        \"--ulysses_size\",\n        type=int,\n        default=1,\n        help=\"The size of the ulysses parallelism in DiT.\")\n    parser.add_argument(\n        \"--ring_size\",\n        type=int,\n        default=1,\n        help=\"The size of the ring attention parallelism in DiT.\")\n    parser.add_argument(\n        \"--t5_fsdp\",\n        action=\"store_true\",\n        default=False,\n        help=\"Whether to use FSDP for T5.\")\n    parser.add_argument(\n        \"--t5_cpu\",\n        action=\"store_true\",\n        default=False,\n        help=\"Whether to place T5 model on CPU.\")\n    parser.add_argument(\n        \"--dit_fsdp\",\n        action=\"store_true\",\n        default=False,\n        help=\"Whether to use FSDP for DiT.\")\n    parser.add_argument(\n        \"--save_file\",\n        type=str,\n        default=None,\n        help=\"The file to save the generated image or video to.\")\n    parser.add_argument(\n        \"--src_video\",\n        type=str,\n        default=None,\n        help=\"The file of the source video. Default None.\")\n    parser.add_argument(\n        \"--src_mask\",\n        type=str,\n        default=None,\n        help=\"The file of the source mask. Default None.\")\n    parser.add_argument(\n        \"--src_ref_images\",\n        type=str,\n        default=None,\n        help=\"The file list of the source reference images. Separated by ','. Default None.\"\n    )\n    parser.add_argument(\n        \"--prompt\",\n        type=str,\n        default=None,\n        help=\"The prompt to generate the image or video from.\")\n    parser.add_argument(\n        \"--use_prompt_extend\",\n        action=\"store_true\",\n        default=False,\n        help=\"Whether to use prompt extend.\")\n    parser.add_argument(\n        \"--prompt_extend_method\",\n        type=str,\n        default=\"local_qwen\",\n        choices=[\"dashscope\", \"local_qwen\"],\n        help=\"The prompt extend method to use.\")\n    parser.add_argument(\n        \"--prompt_extend_model\",\n        type=str,\n        default=None,\n        help=\"The prompt extend model to use.\")\n    parser.add_argument(\n        \"--prompt_extend_target_lang\",\n        type=str,\n        default=\"zh\",\n        choices=[\"zh\", \"en\"],\n        help=\"The target language of prompt extend.\")\n    parser.add_argument(\n        \"--base_seed\",\n        type=int,\n        default=-1,\n        help=\"The seed to use for generating the image or video.\")\n    parser.add_argument(\n        \"--image\",\n        type=str,\n        default=None,\n        help=\"[image to video] The image to generate the video from.\")\n    parser.add_argument(\n        \"--first_frame\",\n        type=str,\n        default=None,\n        help=\"[first-last frame to video] The image (first frame) to generate the video from.\"\n    )\n    parser.add_argument(\n        \"--last_frame\",\n        type=str,\n        default=None,\n        help=\"[first-last frame to video] The image (last frame) to generate the video from.\"\n    )\n    parser.add_argument(\n        \"--sample_solver\",\n        type=str,\n        default='unipc',\n        choices=['unipc', 'dpm++'],\n        help=\"The solver used to sample.\")\n    parser.add_argument(\n        \"--sample_steps\", type=int, default=None, help=\"The sampling steps.\")\n    parser.add_argument(\n        \"--sample_shift\",\n        type=float,\n        default=None,\n        help=\"Sampling shift factor for flow matching schedulers.\")\n    parser.add_argument(\n        \"--sample_guide_scale\",\n        type=float,\n        default=5.0,\n        help=\"Classifier free guidance scale.\")\n\n    args = parser.parse_args()\n\n    _validate_args(args)\n\n    return args", "label": 0}
{"function": "def ocr_error_predictor() -> OCRErrorPredictor:\n    ocr_error_predictor = OCRErrorPredictor()\n    yield ocr_error_predictor\n    del ocr_error_predictor", "label": 0}
{"function": "    def test_get_signal_signal_wrong_data_shape(self):\n        s = self.signal\n        s = s.transpose(signal_axes=1)\n        with pytest.raises(ValueError):\n            s._get_signal_signal(data=np.zeros((3, 2)))", "label": 1}
{"function": "def format_time(milliseconds):\n    \"\"\"\u5c06\u6beb\u79d2\u8f6c\u6362\u4e3a\u65f6:\u5206:\u79d2.\u6beb\u79d2\u683c\u5f0f\"\"\"\n    total_seconds = milliseconds / 1000\n    hours = int(total_seconds // 3600)\n    minutes = int((total_seconds % 3600) // 60)\n    seconds = int(total_seconds % 60)\n    ms = int((total_seconds * 1000) % 1000)\n\n    if hours > 0:\n        return f\"{hours:02d}:{minutes:02d}:{seconds:02d}.{ms:03d}\"\n    else:\n        return f\"{minutes:02d}:{seconds:02d}.{ms:03d}\"", "label": 0}
{"function": "    def reset(self):\n        self.kill_process()\n        self.log.reset()\n        self.agent0 = Agent(0, self.config, self)\n        self.streaming_agent = None\n        self.paused = False", "label": 0}
{"function": "def get_logger(name: str, lv=logging.INFO, remove_exist=False, format_root=False):\n    logger = logging.getLogger(name)\n    logger.setLevel(lv)\n    if remove_exist and logger.hasHandlers():\n        logger.handlers.clear()\n    if not logger.hasHandlers():\n        syslog = logging.StreamHandler()\n        syslog.setFormatter(Formatter())\n        logger.addHandler(syslog)\n    else:\n        for h in logger.handlers:\n            h.setFormatter(Formatter())\n    if format_root:\n        for h in logger.root.handlers:\n            h.setFormatter(Formatter())\n    return logger", "label": 0}
{"function": "def test_encoder_stats():\n    \"\"\"Test encoder statistics\"\"\"\n    encoder = MemvidEncoder()\n    chunks = [\"short\", \"medium length chunk\", \"this is a longer chunk with more text\"]\n    encoder.add_chunks(chunks)\n    \n    stats = encoder.get_stats()\n    assert stats[\"total_chunks\"] == 3\n    assert stats[\"total_characters\"] == sum(len(c) for c in chunks)\n    assert stats[\"avg_chunk_size\"] > 0", "label": 0}
{"function": "def Logger(content):\n    if not ddp or dist.get_rank() == 0:\n        print(content)", "label": 0}
{"function": "    def test_atomic_compare_and_swap(self):\n        n = 100\n        res = [-99] * (n // 2) + [-1] * (n // 2)\n        random.shuffle(res)\n        res = np.asarray(res, dtype=np.int32)\n        out = np.zeros_like(res)\n        ary = np.random.randint(1, 10, size=res.size).astype(res.dtype)\n\n        fill_mask = res == -99\n        unfill_mask = res == -1\n\n        expect_res = np.zeros_like(res)\n        expect_res[fill_mask] = ary[fill_mask]\n        expect_res[unfill_mask] = -1\n\n        expect_out = np.zeros_like(out)\n        expect_out[fill_mask] = res[fill_mask]\n        expect_out[unfill_mask] = -1\n\n        cuda_func = cuda.jit(atomic_compare_and_swap)\n        cuda_func[10, 10](res, out, ary)\n\n        np.testing.assert_array_equal(expect_res, res)\n        np.testing.assert_array_equal(expect_out, out)", "label": 1}
{"function": "    def generate(self, messages, tools_to_call_from=None, stop_sequences=None):\n        if len(messages) < 3:\n            return ChatMessage(\n                role=MessageRole.ASSISTANT,\n                content=\"\",\n                tool_calls=[\n                    ChatMessageToolCall(\n                        id=\"call_0\",\n                        type=\"function\",\n                        function=ChatMessageToolCallFunction(\n                            name=\"fake_image_generation_tool\",\n                            arguments={\"prompt\": \"An image of a cat\"},\n                        ),\n                    )\n                ],\n            )\n        else:\n            return ChatMessage(\n                role=MessageRole.ASSISTANT,\n                content=\"\",\n                tool_calls=[\n                    ChatMessageToolCall(\n                        id=\"call_1\",\n                        type=\"function\",\n                        function=ChatMessageToolCallFunction(name=\"final_answer\", arguments=\"image.png\"),\n                    )\n                ],\n            )", "label": 0}
{"function": "    def test_get_signal_signal_given_data(self):\n        s = self.signal\n        s = s.transpose(signal_axes=2)\n        data = np.zeros(s.axes_manager._signal_shape_in_array)\n        ns = s._get_signal_signal(data=data)\n        assert ns.data is data", "label": 1}
{"function": "\tdef get_ClientToken(self):\n\t\treturn self.get_query_params().get('ClientToken')", "label": 1}
{"function": "def build_logger(logger_name, logger_filename):\n    global handler\n\n    formatter = logging.Formatter(\n        fmt=\"%(asctime)s | %(levelname)s | %(name)s | %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n    )\n\n    # Set the format of root handlers\n    if not logging.getLogger().handlers:\n        logging.basicConfig(level=logging.INFO)\n    logging.getLogger().handlers[0].setFormatter(formatter)\n\n    # Redirect stdout and stderr to loggers\n    stdout_logger = logging.getLogger(\"stdout\")\n    stdout_logger.setLevel(logging.INFO)\n    sl = StreamToLogger(stdout_logger, logging.INFO)\n    sys.stdout = sl\n\n    stderr_logger = logging.getLogger(\"stderr\")\n    stderr_logger.setLevel(logging.ERROR)\n    sl = StreamToLogger(stderr_logger, logging.ERROR)\n    sys.stderr = sl\n\n    # Get logger\n    logger = logging.getLogger(logger_name)\n    logger.setLevel(logging.INFO)\n\n    # Add a file handler for all loggers\n    if handler is None:\n        os.makedirs(LOGDIR, exist_ok=True)\n        filename = os.path.join(LOGDIR, logger_filename)\n        handler = logging.handlers.TimedRotatingFileHandler(\n            filename, when='D', utc=True, encoding='UTF-8')\n        handler.setFormatter(formatter)\n\n        for name, item in logging.root.manager.loggerDict.items():\n            if isinstance(item, logging.Logger):\n                item.addHandler(handler)\n\n    return logger", "label": 0}
{"function": "def test_teleoperate():\n    robot_cfg = MockRobotConfig()\n    teleop_cfg = MockTeleopConfig()\n    cfg = TeleoperateConfig(\n        robot=robot_cfg,\n        teleop=teleop_cfg,\n        teleop_time_s=0.1,\n    )\n    teleoperate(cfg)", "label": 0}
{"function": "    def fetch_ticker(self, symbol, params={}):\n        self.load_markets()\n        market = self.market(symbol)\n        method = 'publicGet'\n        request = {\n            'symbol': market['id'],\n        }\n        if market['future']:\n            method += 'Future'\n            request['contract_type'] = 'this_week'  # next_week, quarter\n        method += 'Ticker'\n        response = getattr(self, method)(self.extend(request, params))\n        ticker = self.safe_value(response, 'ticker')\n        if ticker is None:\n            raise ExchangeError(self.id + ' fetchTicker returned an empty response: ' + self.json(response))\n        timestamp = self.safe_integer(response, 'date')\n        if timestamp is not None:\n            timestamp *= 1000\n            ticker = self.extend(ticker, {'timestamp': timestamp})\n        return self.parse_ticker(ticker, market)", "label": 1}
{"function": "def load_config(config_path: str) -> List[TaskConfig]:\n    with open(config_path, \"r\") as f:\n        config_data = yaml.safe_load(f)\n\n    configs = []\n    for idx, entry in enumerate(config_data.get(\"tasks\", [])):\n        if not isinstance(entry, dict):\n            raise ValueError(f\"Invalid entry at index {idx}\")\n\n        config = TaskConfig(\n            server_cmd=entry.get(\"server_cmd\"),\n            client_cmd=entry.get(\"client_cmd\"),\n            name=entry.get(\"name\", f\"task-{idx+1}\"),\n            server_type=entry.get(\"server_type\"),\n        )\n\n        if not config.server_cmd or not config.client_cmd:\n            raise ValueError(f\"Missing commands in {config.name}\")\n\n        configs.append(config)\n\n    return configs", "label": 0}
{"function": "def test_basic_crawl(tester: Crawl4AiTester):\n    print(\"\\n=== Testing Basic Crawl ===\")\n    request = {\n        \"urls\": [\"https://www.nbcnews.com/business\"],\n        \"priority\": 10,\n        \"session_id\": \"test\",\n    }\n\n    result = tester.submit_and_wait(request)\n    print(f\"Basic crawl result length: {len(result['result']['markdown'])}\")\n    assert result[\"result\"][\"success\"]\n    assert len(result[\"result\"][\"markdown\"]) > 0", "label": 0}
{"function": "def check_samples(samples=()):\n    \"\"\"\n      Check script output for all samples. Sample is a two element list, where the first is input and\n      the second is output.\n    \"\"\"\n    for sample in samples:\n        if len(sample) == 2:\n            output = get_file_output(arg_string=str(sample[0]))\n            if \"\\n\".join(output) != sample[1]:\n                failed(\n                    \"Test from samples failed: \\n \\n\"\n                    \"Input:\\n{}\"\n                    \"\\n \\n\"\n                    \"Expected:\\n{}\"\n                    \"\\n \\n\"\n                    \"Your result:\\n{}\".format(str.strip(sample[0]), str.strip(sample[1]), \"\\n\".join(output)))\n                return\n        set_congratulation_message(\"All test from samples passed. Now we are checking your solution on Stepic server.\")\n\n    passed()", "label": 1}
{"function": "    def test_delitem_with_2_invalid_keys(self):\n        d = {\n            'a': {\n                'b': 1,\n            }\n        }\n        b = KeypathDict(d)\n        with self.assertRaises(KeyError):\n            del b['a.c']\n        self.assertEqual(b.get('a'), { 'b': 1 })", "label": 1}
{"function": "    def recomputeConvexHullDelayed(self) -> None:\n        \"\"\"The same as recomputeConvexHull, but using a timer if it was set.\"\"\"\n        if self._recompute_convex_hull_timer is not None:\n            self._recompute_convex_hull_timer.start()\n        else:\n            from cura.CuraApplication import CuraApplication\n            if not self._timer_scheduled_to_be_created:\n                # The timer is not created and we never scheduled it. Time to create it now!\n                CuraApplication.getInstance().callLater(self.createRecomputeConvexHullTimer)\n            # Now we know for sure that the timer has been scheduled for creation, so we can try this again.\n            CuraApplication.getInstance().callLater(self.recomputeConvexHullDelayed)", "label": 1}
{"function": "    def __len__(self):\n        if self.batch is not None:\n            return self.batch.batch_size[0]\n        elif self.non_tensor_batch is not None and len(self.non_tensor_batch) > 0:\n            random_key = list(self.non_tensor_batch.keys())[0]\n            return self.non_tensor_batch[random_key].shape[0]\n        else:\n            return 0", "label": 0}
{"function": "def init_log():\n    logger.remove()\n    _lvl = \"DEBUG\"\n\n    def format_record(record):\n        # \u83b7\u53d6\u65e5\u5fd7\u8bb0\u5f55\u4e2d\u7684\u6587\u4ef6\u5168\u8def\u5f84\n        file_path = record[\"file\"].path\n        # \u5c06\u7edd\u5bf9\u8def\u5f84\u8f6c\u6362\u4e3a\u76f8\u5bf9\u4e8e\u9879\u76ee\u6839\u76ee\u5f55\u7684\u8def\u5f84\n        relative_path = os.path.relpath(file_path, root_dir)\n        # \u66f4\u65b0\u8bb0\u5f55\u4e2d\u7684\u6587\u4ef6\u8def\u5f84\n        record[\"file\"].path = f\"./{relative_path}\"\n        # \u8fd4\u56de\u4fee\u6539\u540e\u7684\u683c\u5f0f\u5b57\u7b26\u4e32\n        # \u60a8\u53ef\u4ee5\u6839\u636e\u9700\u8981\u8c03\u6574\u8fd9\u91cc\u7684\u683c\u5f0f\n        record[\"message\"] = record[\"message\"].replace(root_dir, \".\")\n\n        _format = (\n            \"<green>{time:%Y-%m-%d %H:%M:%S}</> | \"\n            + \"<level>{level}</> | \"\n            + '\"{file.path}:{line}\":<blue> {function}</> '\n            + \"- <level>{message}</>\"\n            + \"\\n\"\n        )\n        return _format\n\n    logger.add(\n        sys.stdout,\n        level=_lvl,\n        format=format_record,\n        colorize=True,\n    )", "label": 0}
{"function": "    def extract_tracks(self, tracks):\n        \"\"\"\n        Extracts results from the provided data.\n\n        Args:\n            tracks (list): List of tracks obtained from the object tracking process.\n        \"\"\"\n        self.boxes = tracks[0].boxes.xyxy.cpu()\n        self.clss = tracks[0].boxes.cls.cpu().tolist()\n        self.trk_ids = tracks[0].boxes.id.int().cpu().tolist()", "label": 0}
{"function": "def mixer():\n    from mixer.backend.marshmallow import Mixer\n    return Mixer(required=True)", "label": 1}
{"function": "    def getConvexHullBoundary(self) -> Optional[Polygon]:\n        \"\"\"Get convex hull of the node\n\n        In case of printing all at once this None??\n        For one at the time this is the area without the head.\n        \"\"\"\n        if self._node is None:\n            return None\n\n        if self._node.callDecoration(\"isNonPrintingMesh\"):\n            return None\n\n        if self._isSingularOneAtATimeNode():\n            # Printing one at a time and it's not an object in a group\n            return self._compute2DConvexHull()\n        return None", "label": 1}
{"function": "def test_structured_extraction(tester: Crawl4AiTester):\n    print(\"\\n=== Testing Structured Extraction ===\")\n    schema = {\n        \"name\": \"Coinbase Crypto Prices\",\n        \"baseSelector\": \".cds-tableRow-t45thuk\",\n        \"fields\": [\n            {\n                \"name\": \"crypto\",\n                \"selector\": \"td:nth-child(1) h2\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"symbol\",\n                \"selector\": \"td:nth-child(1) p\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"price\",\n                \"selector\": \"td:nth-child(2)\",\n                \"type\": \"text\",\n            },\n        ],\n    }\n\n    request = {\n        \"urls\": [\"https://www.coinbase.com/explore\"],\n        \"priority\": 9,\n        \"extraction_config\": {\"type\": \"json_css\", \"params\": {\"schema\": schema}},\n    }\n\n    result = tester.submit_and_wait(request)\n    extracted = json.loads(result[\"result\"][\"extracted_content\"])\n    print(f\"Extracted {len(extracted)} items\")\n    print(\"Sample item:\", json.dumps(extracted[0], indent=2))\n    assert result[\"result\"][\"success\"]\n    assert len(extracted) > 0", "label": 0}
{"function": "    def __init__(self, lam_over_diam=None, lam=None, diam=None, obscuration=0., flux=1.,\n                 scale_unit=None, gsparams=None):\n        from .angle import arcsec, radians, AngleUnit\n\n        self._obscuration = float(obscuration)\n        self._flux = float(flux)\n        self._gsparams = GSParams.check(gsparams)\n\n        # Parse arguments: either lam_over_diam in arbitrary units, or lam in nm and diam in m.\n        # If the latter, then get lam_over_diam in units of scale_unit, as specified in\n        # docstring.\n        if lam_over_diam is not None:\n            if lam is not None or diam is not None:\n                raise GalSimIncompatibleValuesError(\n                    \"If specifying lam_over_diam, then do not specify lam or diam\",\n                    lam_over_diam=lam_over_diam, lam=lam, diam=diam)\n            self._lod = float(lam_over_diam)\n        else:\n            if lam is None or diam is None:\n                raise GalSimIncompatibleValuesError(\n                    \"If not specifying lam_over_diam, then specify lam AND diam\",\n                    lam_over_diam=lam_over_diam, lam=lam, diam=diam)\n            # In this case we're going to use scale_unit, so parse it in case of string input:\n            if isinstance(scale_unit, str):\n                scale_unit = AngleUnit.from_name(scale_unit)\n            elif scale_unit is None:\n                scale_unit = arcsec\n            self._lod = (1.e-9*float(lam)/float(diam))*(radians/scale_unit)", "label": 1}
{"function": "    def test_1d_slicing6(self, flags=enable_pyobj_flags):\n        pyfunc = slicing_1d_usecase6\n        self.check_1d_slicing_with_arg(pyfunc, flags)", "label": 1}
{"function": "    def check_file_matches_md5(checksum, fpath):\n        if not os.path.exists(fpath):\n            return False\n        with open(fpath, 'rb') as f:\n            current_md5checksum = hashlib.md5(f.read()).hexdigest()\n        return current_md5checksum == checksum", "label": 1}
{"function": "    def is_enabled(cls, filename, syntax):\n        if syntax == 'text.tex.latex.haskell':  # Literate Haskell.tmLanguage\n            return True\n        return filename.endswith('.lhs')", "label": 1}
{"function": "    def __truediv__(self, name: str) -> URL: ...", "label": 1}
{"function": "    def parse_trade(self, trade, market=None):\n        symbol = None\n        if market:\n            symbol = market['symbol']\n        return {\n            'info': trade,\n            'timestamp': trade['date_ms'],\n            'datetime': self.iso8601(trade['date_ms']),\n            'symbol': symbol,\n            'id': str(trade['tid']),\n            'order': None,\n            'type': None,\n            'side': trade['type'],\n            'price': self.safe_float(trade, 'price'),\n            'amount': self.safe_float(trade, 'amount'),\n        }", "label": 1}
{"function": "    def should_continue_fundamentals(self, state: AgentState):\n        \"\"\"Determine if fundamentals analysis should continue.\"\"\"\n        messages = state[\"messages\"]\n        last_message = messages[-1]\n        if last_message.tool_calls:\n            return \"tools_fundamentals\"\n        return \"Msg Clear Fundamentals\"", "label": 0}
{"function": "    def assert_create_called_with(self, **kwargs):\n        self.chat.completions.create.assert_called_with(**kwargs)", "label": 0}
{"function": "    def export_item(self, item):\n        print(json.dumps(item))", "label": 1}
{"function": "    def delete(self, child=False):\n        \"\"\"Delete the filter documents\n\n        if child is True then delete nested collection and documents also\n        \"\"\"\n        transaction_or_batch = self.query_transaction if self.query_transaction else self.query_batch\n        q = self.query()\n        DeleteQuery(self.model, query=q, child=child).exec(transaction_or_batch)", "label": 1}
{"function": "async def run_flow():\n    agents = {\n        \"manus\": Manus(),\n    }\n    if config.run_flow_config.use_data_analysis_agent:\n        agents[\"data_analysis\"] = DataAnalysis()\n    try:\n        prompt = input(\"Enter your prompt: \")\n\n        if prompt.strip().isspace() or not prompt:\n            logger.warning(\"Empty prompt provided.\")\n            return\n\n        flow = FlowFactory.create_flow(\n            flow_type=FlowType.PLANNING,\n            agents=agents,\n        )\n        logger.warning(\"Processing your request...\")\n\n        try:\n            start_time = time.time()\n            result = await asyncio.wait_for(\n                flow.execute(prompt),\n                timeout=3600,  # 60 minute timeout for the entire execution\n            )\n            elapsed_time = time.time() - start_time\n            logger.info(f\"Request processed in {elapsed_time:.2f} seconds\")\n            logger.info(result)\n        except asyncio.TimeoutError:\n            logger.error(\"Request processing timed out after 1 hour\")\n            logger.info(\n                \"Operation terminated due to timeout. Please try a simpler request.\"\n            )\n\n    except KeyboardInterrupt:\n        logger.info(\"Operation cancelled by user.\")\n    except Exception as e:\n        logger.error(f\"Error: {str(e)}\")", "label": 0}
{"function": "    def handle_close(self):\n        raise Exception(\"handle_close not supposed to be called\")", "label": 1}
{"function": "def progress_bar(progress, total, prefix=\"\", length=50):\n    filled = int(length * progress // total)\n    bar = \"\u2588\" * filled + \"\u2591\" * (length - filled)\n    percent = f\"{100 * progress / total:.1f}\"\n    print(f\"\\r{prefix} |{bar}| {percent}% Complete\", end=\"\", flush=True)\n    if progress == total:\n        print()", "label": 0}
{"function": "    def restore_dtype(self, x):\n        if x.dtype != self.original_run_dtype and self.original_run_dtype is not None:\n            x = x.to(self.original_run_dtype)\n        return x", "label": 0}
{"function": "    def reset(self, count=10):\n        self.logger.info('Facedancer resetting...')\n        for i in range(count):\n            self.halt()\n            self.serialport.setDTR(0)\n            rsp_data = self.read(1024)\n            if len(rsp_data) < 4:\n                continue\n            app, verb, n = struct.unpack('<BBH', rsp_data[:4])\n            if verb == 0x7f and n == (len(rsp_data) - 4):\n                self.logger.debug(\"No buffer any more\")\n                self.logger.info(\"Facedancer reset\")\n                return\n        raise Exception(\"Facedancer reset fault.\")", "label": 1}
{"function": "def get_all_fonts():\n    fonts = []\n    for root, dirs, files in os.walk(font_dir):\n        for file in files:\n            if file.endswith(\".ttf\") or file.endswith(\".ttc\"):\n                fonts.append(file)\n    fonts.sort()\n    return fonts", "label": 0}
{"function": "def main():\n  \"\"\"Configures and runs a pipeline.\"\"\"\n  args = parse_arguments(sys.argv)\n  config = parse_config(\n      \"CLOUD\" if args.cloud else \"LOCAL\",\n      get_relative_path(\"config.ini\"))\n  set_logging(config.get(\"log_level\"))\n  options = get_pipeline_options(args, config)\n  runner = str(config.get(\"runner\"))\n\n  with beam.Pipeline(runner, options=options) as pipeline:\n    with beam_impl.Context(\n        temp_dir=os.path.join(args.tft_dir, constants.TMP_DIR)):\n      preprocess.run(pipeline, args)", "label": 1}
{"function": "def split_line(text: str) -> List[str]:\n    \"\"\"Split text into lines based on terminal width.\"\"\"\n    term_width = shutil.get_terminal_size().columns or 80\n    if not text.strip():\n        return []\n    # Split by explicit newlines and wrap long lines\n    lines = []\n    for line in text.split('\\n'):\n        while len(line) > term_width:\n            lines.append(line[:term_width])\n            line = line[term_width:]\n        if line:\n            lines.append(line)\n    return lines", "label": 0}
{"function": "def setbufsize(size):\n    \"\"\"\n    Set the size of the buffer used in ufuncs.\n\n    Parameters\n    ----------\n    size : int\n        Size of buffer.\n\n    \"\"\"\n    if size > 10e6:\n        raise ValueError(\"Buffer size, %s, is too big.\" % size)\n    if size < 5:\n        raise ValueError(\"Buffer size, %s, is too small.\" % size)\n    if size % 16 != 0:\n        raise ValueError(\"Buffer size, %s, is not a multiple of 16.\" % size)\n\n    pyvals = umath.geterrobj()\n    old = getbufsize()\n    pyvals[0] = size\n    umath.seterrobj(pyvals)\n    return old", "label": 1}
{"function": "def test_add_chunks():\n    \"\"\"Test adding chunks\"\"\"\n    encoder = MemvidEncoder()\n    chunks = [\"chunk1\", \"chunk2\", \"chunk3\"]\n    \n    encoder.add_chunks(chunks)\n    assert len(encoder.chunks) == 3\n    assert encoder.chunks == chunks", "label": 0}
{"function": "def sidebar_config():\n    with st.sidebar:\n        st.title(\"\ud83d\udd11 Configuration\")\n        st.markdown(\"---\")\n        \n        st.session_state.qdrant_url = st.text_input(\n            \"Qdrant URL\",\n            value=st.session_state.qdrant_url,\n            type=\"password\"\n        )\n        st.session_state.qdrant_api_key = st.text_input(\n            \"Qdrant API Key\",\n            value=st.session_state.qdrant_api_key,\n            type=\"password\"\n        )\n        st.session_state.firecrawl_api_key = st.text_input(\n            \"Firecrawl API Key\",\n            value=st.session_state.firecrawl_api_key,\n            type=\"password\"\n        )\n        st.session_state.openai_api_key = st.text_input(\n            \"OpenAI API Key\",\n            value=st.session_state.openai_api_key,\n            type=\"password\"\n        )\n        \n        st.markdown(\"---\")\n        st.session_state.doc_url = st.text_input(\n            \"Documentation URL\",\n            value=st.session_state.doc_url,\n            placeholder=\"https://docs.example.com\"\n        )\n        \n        st.markdown(\"---\")\n        st.markdown(\"### \ud83c\udfa4 Voice Settings\")\n        voices = [\"alloy\", \"ash\", \"ballad\", \"coral\", \"echo\", \"fable\", \"onyx\", \"nova\", \"sage\", \"shimmer\", \"verse\"]\n        st.session_state.selected_voice = st.selectbox(\n            \"Select Voice\",\n            options=voices,\n            index=voices.index(st.session_state.selected_voice),\n            help=\"Choose the voice for the audio response\"\n        )\n        \n        if st.button(\"Initialize System\", type=\"primary\"):\n            if all([\n                st.session_state.qdrant_url,\n                st.session_state.qdrant_api_key,\n                st.session_state.firecrawl_api_key,\n                st.session_state.openai_api_key,\n                st.session_state.doc_url\n            ]):\n                progress_placeholder = st.empty()\n                with progress_placeholder.container():\n                    try:\n                        st.markdown(\"\ud83d\udd04 Setting up Qdrant connection...\")\n                        client, embedding_model = setup_qdrant_collection(\n                            st.session_state.qdrant_url,\n                            st.session_state.qdrant_api_key\n                        )\n                        st.session_state.client = client\n                        st.session_state.embedding_model = embedding_model\n                        st.markdown(\"\u2705 Qdrant setup complete!\")\n                        \n                        st.markdown(\"\ud83d\udd04 Crawling documentation pages...\")\n                        pages = crawl_documentation(\n                            st.session_state.firecrawl_api_key,\n                            st.session_state.doc_url\n                        )\n                        st.markdown(f\"\u2705 Crawled {len(pages)} documentation pages!\")\n                        \n                        store_embeddings(\n                            client,\n                            embedding_model,\n                            pages,\n                            \"docs_embeddings\"\n                        )\n                        \n                        processor_agent, tts_agent = setup_agents(\n                            st.session_state.openai_api_key\n                        )\n                        st.session_state.processor_agent = processor_agent\n                        st.session_state.tts_agent = tts_agent\n                        \n                        st.session_state.setup_complete = True\n                        st.success(\"\u2705 System initialized successfully!\")\n                        \n                    except Exception as e:\n                        st.error(f\"Error during setup: {str(e)}\")\n            else:\n                st.error(\"Please fill in all the required fields!\")", "label": 0}
{"function": "def home():\n    return render_template('index.html')", "label": 0}
{"function": "def punc_norm(text: str) -> str:\n    \"\"\"\n        Quick cleanup func for punctuation from LLMs or\n        containing chars not seen often in the dataset\n    \"\"\"\n    if len(text) == 0:\n        return \"You need to add some text for me to talk.\"\n\n    # Capitalise first letter\n    if text[0].islower():\n        text = text[0].upper() + text[1:]\n\n    # Remove multiple space chars\n    text = \" \".join(text.split())\n\n    # Replace uncommon/llm punc\n    punc_to_replace = [\n        (\"...\", \", \"),\n        (\"\u2026\", \", \"),\n        (\":\", \",\"),\n        (\" - \", \", \"),\n        (\";\", \", \"),\n        (\"\u2014\", \"-\"),\n        (\"\u2013\", \"-\"),\n        (\" ,\", \",\"),\n        (\"\u201c\", \"\\\"\"),\n        (\"\u201d\", \"\\\"\"),\n        (\"\u2018\", \"'\"),\n        (\"\u2019\", \"'\"),\n    ]\n    for old_char_sequence, new_char in punc_to_replace:\n        text = text.replace(old_char_sequence, new_char)\n\n    # Add full stop if no ending punc\n    text = text.rstrip(\" \")\n    sentence_enders = {\".\", \"!\", \"?\", \"-\", \",\"}\n    if not any(text.endswith(p) for p in sentence_enders):\n        text += \".\"\n\n    return text", "label": 0}
{"function": "    async def create_llm_artifact(self, *args, **kwargs):\n        return None", "label": 0}
{"function": "def test_gpt4_tiktoken_equality_special_tokens():\n    tokenizer = GPT4Tokenizer()\n    enc = tiktoken.get_encoding(\"cl100k_base\")\n    tiktoken_ids = enc.encode(specials_string, allowed_special=\"all\")\n    gpt4_tokenizer_ids = tokenizer.encode(specials_string, allowed_special=\"all\")\n    assert gpt4_tokenizer_ids == tiktoken_ids", "label": 0}
{"function": "async def main():\n    pretty_print(\"Initializing...\", color=\"status\")\n    stealth_mode = config.getboolean('BROWSER', 'stealth_mode')\n    personality_folder = \"jarvis\" if config.getboolean('MAIN', 'jarvis_personality') else \"base\"\n    languages = config[\"MAIN\"][\"languages\"].split(' ')\n\n    provider = Provider(provider_name=config[\"MAIN\"][\"provider_name\"],\n                        model=config[\"MAIN\"][\"provider_model\"],\n                        server_address=config[\"MAIN\"][\"provider_server_address\"],\n                        is_local=config.getboolean('MAIN', 'is_local'))\n\n    browser = Browser(\n        create_driver(headless=config.getboolean('BROWSER', 'headless_browser'), stealth_mode=stealth_mode, lang=languages[0]),\n        anticaptcha_manual_install=stealth_mode\n    )\n\n    agents = [\n        CasualAgent(name=config[\"MAIN\"][\"agent_name\"],\n                    prompt_path=f\"prompts/{personality_folder}/casual_agent.txt\",\n                    provider=provider, verbose=False),\n        CoderAgent(name=\"coder\",\n                   prompt_path=f\"prompts/{personality_folder}/coder_agent.txt\",\n                   provider=provider, verbose=False),\n        FileAgent(name=\"File Agent\",\n                  prompt_path=f\"prompts/{personality_folder}/file_agent.txt\",\n                  provider=provider, verbose=False),\n        BrowserAgent(name=\"Browser\",\n                     prompt_path=f\"prompts/{personality_folder}/browser_agent.txt\",\n                     provider=provider, verbose=False, browser=browser),\n        PlannerAgent(name=\"Planner\",\n                     prompt_path=f\"prompts/{personality_folder}/planner_agent.txt\",\n                     provider=provider, verbose=False, browser=browser),\n        #McpAgent(name=\"MCP Agent\",\n        #            prompt_path=f\"prompts/{personality_folder}/mcp_agent.txt\",\n        #            provider=provider, verbose=False), # NOTE under development\n    ]\n\n    interaction = Interaction(agents,\n                              tts_enabled=config.getboolean('MAIN', 'speak'),\n                              stt_enabled=config.getboolean('MAIN', 'listen'),\n                              recover_last_session=config.getboolean('MAIN', 'recover_last_session'),\n                              langs=languages\n                            )\n    try:\n        while interaction.is_active:\n            interaction.get_user()\n            if await interaction.think():\n                interaction.show_answer()\n                interaction.speak_answer()\n    except Exception as e:\n        if config.getboolean('MAIN', 'save_session'):\n            interaction.save_session()\n        raise e\n    finally:\n        if config.getboolean('MAIN', 'save_session'):\n            interaction.save_session()", "label": 0}
{"function": "def main(config_path):\n    config = load_config(config_path)\n    task_instances = initialize_tasks_and_models(config)\n\n    # get input and output path from config\n    input_data = config.get('inputs', None)\n    result_path = config.get('outputs', 'outputs'+'/'+TASK_NAME)\n\n    # formula_detection_task\n    model_formula_detection = task_instances[TASK_NAME]\n\n    # for image detection\n    detection_results = model_formula_detection.predict_images(input_data, result_path)\n\n    # for pdf detection\n    # detection_results = model_formula_detection.predict_pdfs(input_data, result_path)\n\n    # print(detection_results)\n    print(f'The predicted results can be found at {result_path}')", "label": 0}
{"function": "    def check_edges(self):\n        \"\"\"Return True if alien is at edge of screen.\"\"\"\n        screen_rect = self.screen.get_rect()\n        if self.rect.right >= screen_rect.right or self.rect.left <= 0:\n            return True", "label": 1}
{"function": "    def __init__(self, in_ch=3, mid_ch=12, out_ch=3, img_size=512):\n        super(RSU7, self).__init__()\n\n        self.in_ch = in_ch\n        self.mid_ch = mid_ch\n        self.out_ch = out_ch\n\n        self.rebnconvin = REBNCONV(in_ch, out_ch, dirate=1)  ## 1 -> 1/2\n\n        self.rebnconv1 = REBNCONV(out_ch, mid_ch, dirate=1)\n        self.pool1 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv2 = REBNCONV(mid_ch, mid_ch, dirate=1)\n        self.pool2 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv3 = REBNCONV(mid_ch, mid_ch, dirate=1)\n        self.pool3 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv4 = REBNCONV(mid_ch, mid_ch, dirate=1)\n        self.pool4 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv5 = REBNCONV(mid_ch, mid_ch, dirate=1)\n        self.pool5 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv6 = REBNCONV(mid_ch, mid_ch, dirate=1)\n\n        self.rebnconv7 = REBNCONV(mid_ch, mid_ch, dirate=2)\n\n        self.rebnconv6d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv5d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv4d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv3d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv2d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv1d = REBNCONV(mid_ch * 2, out_ch, dirate=1)", "label": 0}
{"function": "    def __init__(\n        self,\n        agent: Callable,\n        tickers: list[str],\n        start_date: str,\n        end_date: str,\n        initial_capital: float,\n        model_name: str = \"gpt-4.1\",\n        model_provider: str = \"OpenAI\",\n        selected_analysts: list[str] = [],\n        initial_margin_requirement: float = 0.0,\n    ):\n        \"\"\"\n        :param agent: The trading agent (Callable).\n        :param tickers: List of tickers to backtest.\n        :param start_date: Start date string (YYYY-MM-DD).\n        :param end_date: End date string (YYYY-MM-DD).\n        :param initial_capital: Starting portfolio cash.\n        :param model_name: Which LLM model name to use (gpt-4, etc).\n        :param model_provider: Which LLM provider (OpenAI, etc).\n        :param selected_analysts: List of analyst names or IDs to incorporate.\n        :param initial_margin_requirement: The margin ratio (e.g. 0.5 = 50%).\n        \"\"\"\n        self.agent = agent\n        self.tickers = tickers\n        self.start_date = start_date\n        self.end_date = end_date\n        self.initial_capital = initial_capital\n        self.model_name = model_name\n        self.model_provider = model_provider\n        self.selected_analysts = selected_analysts\n\n        # Initialize portfolio with support for long/short positions\n        self.portfolio_values = []\n        self.portfolio = {\n            \"cash\": initial_capital,\n            \"margin_used\": 0.0,  # total margin usage across all short positions\n            \"margin_requirement\": initial_margin_requirement,  # The margin ratio required for shorts\n            \"positions\": {ticker: {\"long\": 0, \"short\": 0, \"long_cost_basis\": 0.0, \"short_cost_basis\": 0.0, \"short_margin_used\": 0.0} for ticker in tickers},  # Number of shares held long  # Number of shares held short  # Average cost basis per share (long)  # Average cost basis per share (short)  # Dollars of margin used for this ticker's short\n            \"realized_gains\": {\n                ticker: {\n                    \"long\": 0.0,  # Realized gains from long positions\n                    \"short\": 0.0,  # Realized gains from short positions\n                }\n                for ticker in tickers\n            },\n        }", "label": 0}
{"function": "def test_tool_calling_agents_raises_agent_execution_error_when_tool_raises():\n    @tool\n    def _sample_tool(_: str) -> float:\n        \"\"\"Tool that fails\n\n        Args:\n            _: The pointless string\n        Returns:\n            Some number\n        \"\"\"\n\n        return 1 / 0\n\n    agent = ToolCallingAgent(model=FakeToolCallModel(), tools=[_sample_tool])\n    with pytest.raises(AgentExecutionError):\n        agent.execute_tool_call(_sample_tool.name, \"sample\")", "label": 0}
{"function": "def get_db_path():\n    \"\"\"Get the database path from environment or use default\"\"\"\n    config = Config.from_env()\n    db_path = config.get(\"SQLITE_DB_PATH\", os.path.join(project_root, \"data\", \"sqlite\", \"lpm.db\"))\n    return db_path", "label": 0}
{"function": "def main():\n    install_package(\"requests\", \"rich\", \"ruamel.yaml\", \"InquirerPy\")\n    from rich.console import Console\n    from rich.panel import Panel\n    from rich.box import DOUBLE\n    from InquirerPy import inquirer\n    from translations.translations import translate as t\n    from translations.translations import DISPLAY_LANGUAGES\n    from core.utils.config_utils import load_key, update_key\n    from core.utils.decorator import except_handler\n\n    console = Console()\n    \n    width = max(len(line) for line in ascii_logo.splitlines()) + 4\n    welcome_panel = Panel(\n        ascii_logo,\n        width=width,\n        box=DOUBLE,\n        title=\"[bold green]\ud83c\udf0f[/bold green]\",\n        border_style=\"bright_blue\"\n    )\n    console.print(welcome_panel)\n    # Language selection\n    current_language = load_key(\"display_language\")\n    # Find the display name for current language code\n    current_display = next((k for k, v in DISPLAY_LANGUAGES.items() if v == current_language), \"\ud83c\uddec\ud83c\udde7 English\")\n    selected_language = DISPLAY_LANGUAGES[inquirer.select(\n        message=\"Select language / \u9009\u62e9\u8bed\u8a00 / \u9078\u64c7\u8a9e\u8a00 / \u8a00\u8a9e\u3092\u9078\u629e / Seleccionar idioma / S\u00e9lectionner la langue / \u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u044f\u0437\u044b\u043a:\",\n        choices=list(DISPLAY_LANGUAGES.keys()),\n        default=current_display\n    ).execute()]\n    update_key(\"display_language\", selected_language)\n\n    console.print(Panel.fit(t(\"\ud83d\ude80 Starting Installation\"), style=\"bold magenta\"))\n\n    # Configure mirrors\n    # add a check to ask user if they want to configure mirrors\n    if inquirer.confirm(\n        message=t(\"Do you need to auto-configure PyPI mirrors? (Recommended if you have difficulty accessing pypi.org)\"),\n        default=True\n    ).execute():\n        from core.utils.pypi_autochoose import main as choose_mirror\n        choose_mirror()\n\n    # Detect system and GPU\n    has_gpu = platform.system() != 'Darwin' and check_nvidia_gpu()\n    if has_gpu:\n        console.print(Panel(t(\"\ud83c\udfae NVIDIA GPU detected, installing CUDA version of PyTorch...\"), style=\"cyan\"))\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"torch==2.0.0\", \"torchaudio==2.0.0\", \"--index-url\", \"https://download.pytorch.org/whl/cu118\"])\n    else:\n        system_name = \"\ud83c\udf4e MacOS\" if platform.system() == 'Darwin' else \"\ud83d\udcbb No NVIDIA GPU\"\n        console.print(Panel(t(f\"{system_name} detected, installing CPU version of PyTorch... Note: it might be slow during whisperX transcription.\"), style=\"cyan\"))\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"torch==2.1.2\", \"torchaudio==2.1.2\"])\n\n    @except_handler(\"Failed to install project\")\n    def install_requirements():\n        console.print(Panel(t(\"Installing project in editable mode using `pip install -e .`\"), style=\"cyan\"))\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"-e\", \".\"], env={**os.environ, \"PIP_NO_CACHE_DIR\": \"0\", \"PYTHONIOENCODING\": \"utf-8\"})\n\n    @except_handler(\"Failed to install Noto fonts\")\n    def install_noto_font():\n        # Detect Linux distribution type\n        if os.path.exists('/etc/debian_version'):\n            # Debian/Ubuntu systems\n            cmd = ['sudo', 'apt-get', 'install', '-y', 'fonts-noto']\n            pkg_manager = \"apt-get\"\n        elif os.path.exists('/etc/redhat-release'):\n            # RHEL/CentOS/Fedora systems\n            cmd = ['sudo', 'yum', 'install', '-y', 'google-noto*']\n            pkg_manager = \"yum\"\n        else:\n            console.print(\"Warning: Unrecognized Linux distribution, please install Noto fonts manually\", style=\"yellow\")\n            return\n\n        subprocess.run(cmd, check=True)\n        console.print(f\"\u2705 Successfully installed Noto fonts using {pkg_manager}\", style=\"green\")\n\n    if platform.system() == 'Linux':\n        install_noto_font()\n    \n    install_requirements()\n    check_ffmpeg()\n    \n    # First panel with installation complete and startup command\n    panel1_text = (\n        t(\"Installation completed\") + \"\\n\\n\" +\n        t(\"Now I will run this command to start the application:\") + \"\\n\" +\n        \"[bold]streamlit run st.py[/bold]\\n\" +\n        t(\"Note: First startup may take up to 1 minute\")\n    )\n    console.print(Panel(panel1_text, style=\"bold green\"))\n\n    # Second panel with troubleshooting tips\n    panel2_text = (\n        t(\"If the application fails to start:\") + \"\\n\" +\n        \"1. \" + t(\"Check your network connection\") + \"\\n\" +\n        \"2. \" + t(\"Re-run the installer: [bold]python install.py[/bold]\")\n    )\n    console.print(Panel(panel2_text, style=\"yellow\"))\n\n    # start the application\n    subprocess.Popen([\"streamlit\", \"run\", \"st.py\"])", "label": 0}
{"function": "    def __init__(self, settings):\n        self.topic_todo = settings.get('SPIDER_FEED_TOPIC')\n        self.topic_done = settings.get('SPIDER_LOG_TOPIC')\n        self.topic_scoring = settings.get('SCORING_LOG_TOPIC')\n        self.topic_stats = settings.get('STATS_LOG_TOPIC')\n\n        self.spiderlog_dbw_group = settings.get('SPIDER_LOG_DBW_GROUP')\n        self.spiderlog_sw_group = settings.get('SPIDER_LOG_SW_GROUP')\n        self.scoringlog_dbw_group = settings.get('SCORING_LOG_DBW_GROUP')\n        self.statslog_reader_group = settings.get('STATS_LOG_READER_GROUP')\n        self.spider_feed_group = settings.get('SPIDER_FEED_GROUP')\n        self.spider_partition_id = settings.get('SPIDER_PARTITION_ID')\n        self.max_next_requests = settings.MAX_NEXT_REQUESTS\n        self.hostname_partitioning = settings.get('QUEUE_HOSTNAME_PARTITIONING')\n        self.codec = settings.get('KAFKA_CODEC')\n        self.kafka_location = settings.get('KAFKA_LOCATION')\n        self.enable_ssl = settings.get('KAFKA_ENABLE_SSL')\n        self.cert_path = settings.get('KAFKA_CERT_PATH')\n        self.spider_log_partitions = settings.get('SPIDER_LOG_PARTITIONS')\n        self.spider_feed_partitions = settings.get('SPIDER_FEED_PARTITIONS')", "label": 1}
{"function": "    def fetch(self, limit=None):\n        \"\"\"Fetch the result from firestore\n\n        Parameters\n        ---------\n        limit : optional\n            Apply limit to firestore documents, how much documents you want to retrieve\n        \"\"\"\n        # save the Limit in cursor for next fetch\n        self.cursor_dict['limit'] = limit\n\n        if limit:\n            self.n_limit = limit\n        return QueryIterator(self)", "label": 1}
{"function": "def requires_cuda_initialized() -> pytest.MarkDecorator:\n    if not torch.cuda.is_available():\n        return pytest.mark.skip(reason=\"CUDA is not available\")\n\n    if not torch.cuda.is_initialized():\n        torch.cuda.init()\n\n    return pytest.mark.skipif(\n        not torch.cuda.is_initialized(), reason=\"CUDA is not initialized\"\n    )", "label": 0}
{"function": "def run_tts(\n    text,\n    model,\n    prompt_text=None,\n    prompt_speech=None,\n    gender=None,\n    pitch=None,\n    speed=None,\n    save_dir=\"example/results\",\n):\n    \"\"\"Perform TTS inference and save the generated audio.\"\"\"\n    logging.info(f\"Saving audio to: {save_dir}\")\n\n    if prompt_text is not None:\n        prompt_text = None if len(prompt_text) <= 1 else prompt_text\n\n    # Ensure the save directory exists\n    os.makedirs(save_dir, exist_ok=True)\n\n    # Generate unique filename using timestamp\n    timestamp = datetime.now().strftime(\"%Y%m%d%H%M%S\")\n    save_path = os.path.join(save_dir, f\"{timestamp}.wav\")\n\n    logging.info(\"Starting inference...\")\n\n    # Perform inference and save the output audio\n    with torch.no_grad():\n        wav = model.inference(\n            text,\n            prompt_speech,\n            prompt_text,\n            gender,\n            pitch,\n            speed,\n        )\n\n        sf.write(save_path, wav, samplerate=16000)\n\n    logging.info(f\"Audio saved at: {save_path}\")\n\n    return save_path", "label": 0}
{"function": "def init_sv_cn():\r\n    global hifigan_model, bigvgan_model, sv_cn_model\r\n    sv_cn_model = SV(device, is_half)\r", "label": 0}
{"function": "    def test_delitem_with_2_valid_keys(self):\n        d = {\n            'a': {\n                'b': 1,\n            }\n        }\n        b = KeypathDict(d)\n\n        del b['a.b']\n        with self.assertRaises(KeyError):\n            del b['a.b']\n        self.assertEqual(b.get('a'), {})\n\n        del b['a']\n        with self.assertRaises(KeyError):\n            del b['a']\n        self.assertEqual(b.get('a'), None)", "label": 1}
{"function": "def validate_input(question: str) -> bool:\n    \"\"\"Validate if user input is valid\n\n    Args:\n        question: User question\n\n    Returns:\n        bool: Whether the input is valid\n    \"\"\"\n    # Check if input is empty or contains only spaces\n    if not question or question.strip() == \"\":\n        return False\n    return True", "label": 0}
{"function": "    def _tokenize_audio(self, audio: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n        assert audio.ndim == 1, \"Audio must be single channel\"\n\n        frame_tokens = []\n        frame_masks = []\n\n        # (K, T)\n        audio = audio.to(self.device)\n        audio_tokens = self._audio_tokenizer.encode(audio.unsqueeze(0).unsqueeze(0))[0]\n        # add EOS frame\n        eos_frame = torch.zeros(audio_tokens.size(0), 1).to(self.device)\n        audio_tokens = torch.cat([audio_tokens, eos_frame], dim=1)\n\n        audio_frame = torch.zeros(audio_tokens.size(1), 33).long().to(self.device)\n        audio_frame_mask = torch.zeros(audio_tokens.size(1), 33).bool().to(self.device)\n        audio_frame[:, :-1] = audio_tokens.transpose(0, 1)\n        audio_frame_mask[:, :-1] = True\n\n        frame_tokens.append(audio_frame)\n        frame_masks.append(audio_frame_mask)\n\n        return torch.cat(frame_tokens, dim=0), torch.cat(frame_masks, dim=0)", "label": 0}
{"function": "def audio_volume_normalize(audio: np.ndarray, coeff: float = 0.2) -> np.ndarray:\n    \"\"\"\n    Normalize the volume of an audio signal.\n\n    Parameters:\n        audio (numpy array): Input audio signal array.\n        coeff (float): Target coefficient for normalization, default is 0.2.\n\n    Returns:\n        numpy array: The volume-normalized audio signal.\n    \"\"\"\n    # Sort the absolute values of the audio signal\n    temp = np.sort(np.abs(audio))\n\n    # If the maximum value is less than 0.1, scale the array to have a maximum of 0.1\n    if temp[-1] < 0.1:\n        scaling_factor = max(\n            temp[-1], 1e-3\n        )  # Prevent division by zero with a small constant\n        audio = audio / scaling_factor * 0.1\n\n    # Filter out values less than 0.01 from temp\n    temp = temp[temp > 0.01]\n    L = temp.shape[0]  # Length of the filtered array\n\n    # If there are fewer than or equal to 10 significant values, return the audio without further processing\n    if L <= 10:\n        return audio\n\n    # Compute the average of the top 10% to 1% of values in temp\n    volume = np.mean(temp[int(0.9 * L) : int(0.99 * L)])\n\n    # Normalize the audio to the target coefficient level, clamping the scale factor between 0.1 and 10\n    audio = audio * np.clip(coeff / volume, a_min=0.1, a_max=10)\n\n    # Ensure the maximum absolute value in the audio does not exceed 1\n    max_value = np.max(np.abs(audio))\n    if max_value > 1:\n        audio = audio / max_value\n\n    return audio", "label": 0}
{"function": "def load_model():\n    model = ChatterboxTTS.from_pretrained(DEVICE)\n    return model", "label": 0}
{"function": "    def get(id: str):\n        return AgentContext._contexts.get(id, None)", "label": 0}
{"function": "async def test_read_bytes_with_offset_and_length(computer):\n    \"\"\"Test read_bytes with offset and length parameters.\"\"\"\n    tmp_path = \"test_read_bytes_offset.bin\"\n    test_data = b\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n    # Write test data\n    await computer.interface.write_text(tmp_path, test_data.decode('latin-1'))\n    \n    # Test reading with offset only\n    read_data = await computer.interface.read_bytes(tmp_path, offset=5)\n    expected = test_data[5:]\n    assert read_data == expected, f\"Data from offset 5 should match. Got: {read_data}, Expected: {expected}\"\n    \n    # Test reading with offset and length\n    read_data = await computer.interface.read_bytes(tmp_path, offset=10, length=5)\n    expected = test_data[10:15]\n    assert read_data == expected, f\"Data from offset 10, length 5 should match. Got: {read_data}, Expected: {expected}\"\n    \n    # Test reading from beginning with length\n    read_data = await computer.interface.read_bytes(tmp_path, offset=0, length=10)\n    expected = test_data[:10]\n    assert read_data == expected, f\"Data from beginning, length 10 should match. Got: {read_data}, Expected: {expected}\"\n    \n    await computer.interface.delete_file(tmp_path)", "label": 0}
{"function": "  def testUpdateCloudStorageDependenciesMissingDependency(\n      self, uploader_cs_mock):\n    self.fs.CreateFile(self.file_path,\n                       contents='\\n'.join(self.expected_file_lines))\n    config = dependency_manager.BaseConfig(self.file_path, writable=True)\n    self.assertRaises(ValueError, config.AddCloudStorageDependencyUpdateJob,\n                      'dep', 'plat', 'path')\n    self.assertRaises(ValueError, config.AddCloudStorageDependencyUpdateJob,\n                      'dep', 'plat', 'path', version='1.2.3')\n    self.assertRaises(ValueError, config.AddCloudStorageDependencyUpdateJob,\n                      'dep', 'plat', 'path', execute_job=False)\n    self.assertRaises(ValueError, config.AddCloudStorageDependencyUpdateJob,\n                      'dep', 'plat', 'path', version='1.2.3', execute_job=False)", "label": 1}
{"function": "def quantized_resize_bilinear_handler(converter: TensorFlowConverter, tf_op: \"tf.Operation\"):\n    raise NotImplementedError(f\"[TensorFlowConverter] {tf_op.type} is not supported yet.\")", "label": 1}
{"function": "    def init_browser(self, user_agent=None):\n        \"\"\"\u521d\u59cb\u5316\u6d4f\u89c8\u5668\"\"\"\n        co = self._get_browser_options(user_agent)\n        self.browser = Chromium(co)\n        return self.browser", "label": 0}
{"function": "    def close(self):\n        pass", "label": 1}
{"function": "def main():\n  if getattr(sys, \"frozen\", False):\n    scriptpath = os.path.dirname(sys.executable)\n  else:\n    scriptpath = os.path.realpath(__file__)\n\n  if \"steam.exe\" not in get_processes():\n    print(\"WARNING: Steam is not running. Build will most likely fail.\\n\")\n\n  print(\"{} Binarizer\".format(PROJECTNAME))\n  print(\"Authors: {}\".format(\", \".join(AUTHORS)))\n  b = Binarizer(scriptpath)\n\n  try:\n    b.check_paths()\n  except:\n    print(\" Failed to get tool paths. \".center(79, \"=\"))\n    print(\"\")\n    raise\n\n  print(\"\")\n  print(\" Tools found, binarizing. \".center(79, \"=\"))\n  print(\"\")\n\n  b.remove_obsolete()\n  attempted = b.binarize()\n\n  failed = b.verify()\n  succeeded = attempted - failed\n\n  result = \" {} / {} modules binarized. \".format(succeeded, attempted)\n  print(\"\")\n\n  try:\n    import colorama\n  except ImportError:\n    print(result.center(79, \"=\"))\n  else:\n    colorama.init()\n    result = result.center(79, \"=\")\n    if succeeded == attempted:\n      result = \"\\33[32m\" + result + \"\\33[39m\"\n    else:\n      result = \"\\33[31m\" + result + \"\\33[39m\"\n    print(result)\n  print(\"\")\n  print(\"[Finished at {}]\".format(time.ctime()))\n\n  if getattr(sys, \"frozen\", False):\n    input(\"\\nPress any key to exit...\\n\")\n\n  if failed > 0:\n    sys.exit(1)", "label": 1}
{"function": "   def init(self):\n      self.DATALEN = 256 * 2**10\n      self.PAYLOAD = \"\\x00\\xfe\\x23\\xfa\\xf0\"\n      self.WAITSECS = 10\n      self.reportTime = True", "label": 1}
{"function": "    def any(self):\n        return len(self._rx_buffer)", "label": 1}
{"function": "def data():\n    project = manager.get_project_list()\n    models = LLM().list_models()\n    search_engines = [\"Bing\", \"Google\", \"DuckDuckGo\"]\n    return jsonify({\"projects\": project, \"models\": models, \"search_engines\": search_engines})", "label": 0}
{"function": "async def test_take_full_page_screenshot():\n\tbrowser_session = BrowserSession(browser_profile=BrowserProfile(headless=True, disable_security=True))\n\tawait browser_session.start()\n\ttry:\n\t\tpage = await browser_session.get_current_page()\n\t\t# Go to a test page\n\t\tawait page.goto('https://example.com')\n\n\t\tawait asyncio.sleep(3)\n\t\t# Take full page screenshot\n\t\tscreenshot_b64 = await browser_session.take_screenshot(full_page=True)\n\t\tawait asyncio.sleep(3)\n\t\t# Verify screenshot is not empty and is valid base64\n\t\tassert screenshot_b64 is not None\n\t\tassert isinstance(screenshot_b64, str)\n\t\tassert len(screenshot_b64) > 0\n\n\t\t# Test we can decode the base64 string\n\t\ttry:\n\t\t\tbase64.b64decode(screenshot_b64)\n\t\texcept Exception as e:\n\t\t\tpytest.fail(f'Failed to decode base64 screenshot: {str(e)}')\n\tfinally:\n\t\tawait browser_session.stop()", "label": 0}
{"function": "    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]", "label": 1}
{"function": "    def test_valid_json_object(self):\n        \"\"\"Test with valid JSON object\"\"\"\n        content = '{\"key\": \"value\", \"number\": 123}'\n        result = repair_json_output(content)\n        expected = json.dumps({\"key\": \"value\", \"number\": 123}, ensure_ascii=False)\n        assert result == expected", "label": 0}
{"function": "def pytest_addoption(parser):\n    parser.addoption(\n        \"--base-url\",\n        action=\"store\",\n        help=\"Base URL for OpenAI compatible API\",\n    )\n    parser.addoption(\n        \"--api-key\",\n        action=\"store\",\n        help=\"API key to use for the provider\",\n    )\n    parser.addoption(\n        \"--provider\",\n        action=\"store\",\n        help=\"Provider to use for testing\",\n    )\n    parser.addoption(\n        \"--model\",\n        action=\"store\",\n        help=\"Model to use for testing\",\n    )", "label": 0}
{"function": "        def update_visibility(input_type):\n            image = gr.update(visible=True) if input_type == \"Image\" else gr.update(visible=False)\n            video = gr.update(visible=False) if input_type == \"Image\" else gr.update(visible=True)\n            output_image = gr.update(visible=True) if input_type == \"Image\" else gr.update(visible=False)\n            output_video = gr.update(visible=False) if input_type == \"Image\" else gr.update(visible=True)\n\n            return image, video, output_image, output_video", "label": 0}
{"function": "def write_in_github_step_summary(results: List[TaskResult]):\n    \"\"\"Write formatted results to GitHub step summary.\"\"\"\n    if not os.environ.get(\"GITHUB_STEP_SUMMARY\"):\n        logging.warning(\"GITHUB_STEP_SUMMARY environment variable not set\")\n        return\n\n    formatted_content = format_results(results)\n    with open(os.environ[\"GITHUB_STEP_SUMMARY\"], \"a\") as f:\n        f.write(formatted_content)", "label": 0}
{"function": "def generate(\n    model: Transformer,\n    prompt_tokens: List[List[int]],\n    max_new_tokens: int,\n    eos_id: int,\n    temperature: float = 1.0\n) -> List[List[int]]:\n    \"\"\"\n    Generates new tokens based on the given prompt tokens using the specified model.\n\n    Args:\n        model (Transformer): The transformer model used for token generation.\n        prompt_tokens (List[List[int]]): A list of lists containing the prompt tokens for each sequence.\n        max_new_tokens (int): The maximum number of new tokens to generate.\n        eos_id (int): The end-of-sequence token ID.\n        temperature (float, optional): The temperature value for sampling. Defaults to 1.0.\n\n    Returns:\n        List[List[int]]: A list of lists containing the generated tokens for each sequence.\n    \"\"\"\n    prompt_lens = [len(t) for t in prompt_tokens]\n    assert max(prompt_lens) <= model.max_seq_len, f\"Prompt length exceeds model maximum sequence length (max_seq_len={model.max_seq_len})\"\n    total_len = min(model.max_seq_len, max_new_tokens + max(prompt_lens))\n    tokens = torch.full((len(prompt_tokens), total_len), -1, dtype=torch.long, device=\"cuda\")\n    for i, t in enumerate(prompt_tokens):\n        tokens[i, :len(t)] = torch.tensor(t, dtype=torch.long, device=\"cuda\")\n    prev_pos = 0\n    finished = torch.tensor([False] * len(prompt_tokens), device=\"cuda\")\n    prompt_mask = tokens != -1\n    for cur_pos in range(min(prompt_lens), total_len):\n        logits = model.forward(tokens[:, prev_pos:cur_pos], prev_pos)\n        if temperature > 0:\n            next_token = sample(logits, temperature)\n        else:\n            next_token = logits.argmax(dim=-1)\n        next_token = torch.where(prompt_mask[:, cur_pos], tokens[:, cur_pos], next_token)\n        tokens[:, cur_pos] = next_token\n        finished |= torch.logical_and(~prompt_mask[:, cur_pos], next_token == eos_id)\n        prev_pos = cur_pos\n        if finished.all():\n            break\n    completion_tokens = []\n    for i, toks in enumerate(tokens.tolist()):\n        toks = toks[prompt_lens[i]:prompt_lens[i]+max_new_tokens]\n        if eos_id in toks:\n            toks = toks[:toks.index(eos_id)]\n        completion_tokens.append(toks)\n    return completion_tokens", "label": 0}
{"function": "    def testCrossValidate(self, mock_init):\n        modelbridge = RandomModelBridge()\n        modelbridge.transforms = OrderedDict()\n        modelbridge.parameters = [\"x\", \"y\", \"z\"]\n        with self.assertRaises(NotImplementedError):\n            modelbridge._cross_validate([], [], [])", "label": 1}
{"function": "    def cmd_next_screen(self):\n        \"\"\"Move to next screen\"\"\"\n        return self.focus_screen(\n            (self.screens.index(self.current_screen) + 1) % len(self.screens)\n        )", "label": 1}
{"function": "def stream_requests(ques, output_file):\n    base_url = \"http://0.0.0.0:8777\"\n    URL = base_url + \"/api/local_doc_qa/local_doc_chat\" #\u6d41\u5f0f\n    data = {\n            \"kb_ids\": [\n            \"KBf46828db208c4289a120a34f0fc96147\",\n            \"KBc2440f13e98f4736b5ef81cfaebef3a9\",\n            \"KBb78af28c73f74fb4ae6ad44b3c53302f\",\n            \"KB6c2b097d83be430ab809e361fa8dcc8b\",\n            \"KB69331d593f5b4b5bb555a0ea1b145e5b\",\n            \"KB3cdc79f8c8d24a14bffd27e6570c33da\"\n            ],\n            \"question\": ques,\n            \"user_id\": \"liujx_265\",\n            \"streaming\": False,\n            \"rerank\": True,\n            \"history\": []\n    }\n    response = requests.post(\n        URL,\n        json=data,\n        timeout=60,\n        stream=True\n    )\n    print(\"response\", response)\n    print(response.iter_lines)\n    for line in response.iter_lines(decode_unicode=False, delimiter=b\"\\n\\n\"):\n    # for line in response.iter_lines():\n        if line:\n            yield line", "label": 0}
{"function": "    def test_setitem_override_existing_item(self):\n        d = {}\n        b = KeypathDict(d)\n        b['a.b.c'] = 1\n        r = {\n            'a': {\n                'b': {\n                    'c': 1\n                }\n            }\n        }\n        b['a.b.c'] = 2\n        r = {\n            'a': {\n                'b': {\n                    'c': 2\n                }\n            }\n        }\n        self.assertEqual(b, r)\n        b['a.b.c.d'] = 3\n        r = {\n            'a': {\n                'b': {\n                    'c': {\n                        'd': 3\n                    }\n                }\n            }\n        }\n        self.assertEqual(b, r)", "label": 1}
{"function": "def restore(\n    checkpoint_path: str,\n    state_shapes: Any,\n    mesh,\n    between_hosts_config,\n    params_only,\n    state_sharding,\n    init_state: Optional[Any] = None,\n) -> Any:\n    ckpt_path = os.path.join(checkpoint_path, \"ckpt-0\")\n\n    rank_logger.info(\"Loading checkpoint at {}\".format(ckpt_path))\n    ckpt_shapes = state_shapes\n    ckpt_shapes_with_path, structure = jax.tree_util.tree_flatten_with_path(ckpt_shapes)\n\n    ckpt_shapes_flat = [elem[1] for elem in ckpt_shapes_with_path]\n    loaded_tensors = load_tensors(ckpt_shapes_flat, ckpt_path, between_hosts_config)\n\n    state = jax.tree_util.tree_unflatten(structure, loaded_tensors)\n\n    # Sanity check to give a better error message.\n    ckpt_keys = set(state.params.keys())\n    code_keys = set(state_sharding.params.keys())\n\n    if ckpt_keys != code_keys and init_state is None:\n        missing_in_ckpt = code_keys - ckpt_keys\n        missing_locally = ckpt_keys - code_keys\n        raise ValueError(\n            \"Parameters in the code are not matching checkpoint parameters.\\n\"\n            \"Params missing in checkpoint: {}\\nParams missing in code: {}\".format(\n                missing_in_ckpt, missing_locally\n            )\n        )\n    state_sharding = jax.tree_util.tree_map(\n        lambda x: jax.sharding.PartitionSpec() if x is None else x,\n        state_sharding,\n        is_leaf=lambda x: x is None,\n    )\n    state = multihost_utils.host_local_array_to_global_array(state, mesh, state_sharding)\n    if params_only:\n        state = state.params\n    return state", "label": 0}
{"function": "    def setUp(self):\n        self.tool_manager = Tools()", "label": 0}
{"function": "    def _drawReciboCaixa(self, boletoDados):\n        \"\"\"Imprime o Recibo do Caixa\n\n        :param boletoDados: Objeto com os dados do boleto a ser preenchido.\n            Deve ser subclasse de :class:`pyboleto.data.BoletoData`\n        :type boletoDados: :class:`pyboleto.data.BoletoData`\n\n        \"\"\"\n        tpl = string.Template(self._load_template('recibo_caixa.html'))\n        tpl_data = {}\n\n        # Cabe\u00e7alho\n        tpl_data['logo_img'] = ''\n        if boletoDados.logo_image:\n            tpl_data['logo_img'] = self._load_image(boletoDados.logo_image)\n        tpl_data['codigo_dv_banco'] = boletoDados.codigo_dv_banco\n        tpl_data['linha_digitavel'] = boletoDados.linha_digitavel\n\n        # Corpo\n        data_vencimento = boletoDados.data_vencimento\n        tpl_data['data_vencimento'] = data_vencimento.strftime('%d/%m/%Y')\n\n        # value em unicode em data.py\n        if isinstance(boletoDados.local_pagamento, unicode):\n            tpl_data['local_pagamento'] = boletoDados.local_pagamento.encode\n            ('utf-8')\n        else:\n            tpl_data['local_pagamento'] = boletoDados.local_pagamento\n        tpl_data['cedente'] = boletoDados.cedente\n        tpl_data['agencia_conta_cedente'] = boletoDados.agencia_conta_cedente\n\n        data_documento = boletoDados.data_documento\n        tpl_data['data_documento'] = data_documento.strftime('%d/%m/%Y')\n        tpl_data['numero_documento'] = boletoDados.numero_documento\n        tpl_data['especie_documento'] = boletoDados.especie_documento\n        tpl_data['aceite'] = boletoDados.aceite\n\n        data_process = boletoDados.data_processamento\n        tpl_data['data_processamento'] = data_process.strftime('%d/%m/%Y')\n        tpl_data['nosso_numero_format'] = boletoDados.format_nosso_numero()\n        tpl_data['carteira'] = boletoDados.carteira\n        tpl_data['especie'] = boletoDados.especie\n        tpl_data['quantidade'] = boletoDados.quantidade\n\n        valor = self._formataValorParaExibir(boletoDados.valor)\n        tpl_data['valor'] = valor\n\n        valor_doc = self._formataValorParaExibir(boletoDados.valor_documento)\n        tpl_data['valor_documento'] = valor_doc\n\n        # Instru\u00e7\u00f5es\n        tpl_data['instrucoes'] = ''\n        for instrucao in boletoDados.instrucoes:\n            tpl_data['instrucoes'] += '<p>{0}</p>'.format(instrucao)\n\n        # Rodap\u00e9\n        tpl_data['sacado_info'] = ''\n        for linha_sacado in boletoDados.sacado:\n            tpl_data['sacado_info'] += '<p>{0}</p>'.format(linha_sacado)\n\n        # C\u00f3digo de barras\n        tpl_data['barcode'] = self._codigoBarraI25(boletoDados.barcode)\n\n        self.html += tpl.substitute(tpl_data)", "label": 1}
{"function": "        def noop_no_sync():\n            yield", "label": 0}
{"function": "    def accept_encodings(self):\n        r = {}\n        ae = self.headers.get(\"Accept-Encoding\", \"\")\n        for e in ae.split(\",\"):\n            match = self.aepattern.match(e)\n            if match:\n                v = match.group(3)\n                v = float(v) if v else 1.0\n                r[match.group(1)] = v\n        return r", "label": 1}
{"function": "    def using(self, *args): ...", "label": 1}
{"function": "def weight_dequant(x: torch.Tensor, s: torch.Tensor, block_size: int = 128) -> torch.Tensor:\n    \"\"\"\n    Dequantizes the given weight tensor using the provided scale tensor.\n\n    Args:\n        x (torch.Tensor): The quantized weight tensor of shape (M, N).\n        s (torch.Tensor): The scale tensor of shape (M//block_size, N//block_size).\n        block_size (int, optional): The block size to use for dequantization. Defaults to 128.\n\n    Returns:\n        torch.Tensor: The dequantized weight tensor of the same shape as `x`.\n\n    Raises:\n        AssertionError: If `x` or `s` are not contiguous or if their dimensions are not 2.\n    \"\"\"\n    assert x.is_contiguous() and s.is_contiguous(), 'Input tensors must be contiguous'\n    assert x.dim() == 2 and s.dim() == 2, 'Input tensors must have 2 dimensions'\n    M, N = x.size()\n    y = torch.empty_like(x, dtype=torch.get_default_dtype())\n    grid = lambda meta: (triton.cdiv(M, meta['BLOCK_SIZE']), triton.cdiv(N, meta['BLOCK_SIZE']))\n    weight_dequant_kernel[grid](x, s, y, M, N, BLOCK_SIZE=block_size)\n    return y", "label": 0}
{"function": "    def __init__(self, open, high, low, close):\n        pass", "label": 1}
{"function": "async def test_directory_exists(computer):\n    tmp_dir = \"test_directory_exists\"\n    if await computer.interface.directory_exists(tmp_dir):\n        # Remove all files in directory before removing directory\n        files = await computer.interface.list_dir(tmp_dir)\n        for fname in files:\n            await computer.interface.delete_file(f\"{tmp_dir}/{fname}\")\n        # Remove the directory itself\n        await computer.interface.delete_dir(tmp_dir)\n    exists = await computer.interface.directory_exists(tmp_dir)\n    assert exists is False, f\"Directory {tmp_dir} should not exist\"\n    await computer.interface.create_dir(tmp_dir)\n    exists = await computer.interface.directory_exists(tmp_dir)\n    assert exists is True, f\"Directory {tmp_dir} should exist\"\n    # Cleanup: remove files and directory\n    files = await computer.interface.list_dir(tmp_dir)\n    for fname in files:\n        await computer.interface.delete_file(f\"{tmp_dir}/{fname}\")\n    await computer.interface.delete_dir(tmp_dir)", "label": 0}
{"function": "  def testLocalFileNotDirectory(self, mock_StorageUrlFromString,\n                                mock_gsutil_api):\n    mock_storage_url = mock.Mock()\n    mock_storage_url.isFileUrl.return_value = True\n    mock_storage_url.IsDirectory.return_value = False\n    mock_StorageUrlFromString.return_value = mock_storage_url\n    (exp_url, have_existing_dst_container) = ExpandUrlToSingleBlr(\n        '/home/test', mock_gsutil_api, 'project_id', False,\n        CreateOrGetGsutilLogger('copy_test'))\n\n    self.assertFalse(have_existing_dst_container)\n    self.assertEqual(exp_url, mock_storage_url)", "label": 1}
{"function": "  def get_observation_model(self, times):\n    \"\"\"Observe level but not slope.\n\n    See StateSpaceModel.get_observation_model.\n\n    Args:\n      times: Unused. See the parent class for details.\n    Returns:\n      A static, univariate observation model for later broadcasting.\n    \"\"\"\n    del times  # Does not rely on times. Uses broadcasting from the parent.\n    return constant_op.constant([1., 0.], dtype=self.dtype)", "label": 1}
{"function": "    def __repr__(self) -> str: ...", "label": 1}
{"function": "def end_session(req: gr.Request):\n    user_dir = os.path.join(TMP_DIR, str(req.session_hash))\n    shutil.rmtree(user_dir)", "label": 0}
{"function": "    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('id')\n        display_id = mobj.group('display_id') or video_id\n\n        video = self._download_json(\n            'https://api.byutv.org/api3/catalog/getvideosforcontent',\n            display_id, query={\n                'contentid': video_id,\n                'channel': 'byutv',\n                'x-byutv-context': 'web$US',\n            }, headers={\n                'x-byutv-context': 'web$US',\n                'x-byutv-platformkey': 'xsaaw9c7y5',\n            })\n\n        ep = video.get('ooyalaVOD')\n        if ep:\n            return {\n                '_type': 'url_transparent',\n                'ie_key': 'Ooyala',\n                'url': 'ooyala:%s' % ep['providerId'],\n                'id': video_id,\n                'display_id': display_id,\n                'title': ep.get('title'),\n                'description': ep.get('description'),\n                'thumbnail': ep.get('imageThumbnail'),\n            }\n\n        info = {}\n        formats = []\n        for format_id, ep in video.items():\n            if not isinstance(ep, dict):\n                continue\n            video_url = url_or_none(ep.get('videoUrl'))\n            if not video_url:\n                continue\n            ext = determine_ext(video_url)\n            if ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    video_url, video_id, 'mp4', entry_protocol='m3u8_native',\n                    m3u8_id='hls', fatal=False))\n            elif ext == 'mpd':\n                formats.extend(self._extract_mpd_formats(\n                    video_url, video_id, mpd_id='dash', fatal=False))\n            else:\n                formats.append({\n                    'url': video_url,\n                    'format_id': format_id,\n                })\n            merge_dicts(info, {\n                'title': ep.get('title'),\n                'description': ep.get('description'),\n                'thumbnail': ep.get('imageThumbnail'),\n                'duration': parse_duration(ep.get('length')),\n            })\n        self._sort_formats(formats)\n\n        return merge_dicts(info, {\n            'id': video_id,\n            'display_id': display_id,\n            'title': display_id,\n            'formats': formats,\n        })", "label": 1}
{"function": "    def __isub__(self, other):\n        return self + (-other)", "label": 1}
{"function": "    def log_to_all(\n        type: Log.Type,\n        heading: str | None = None,\n        content: str | None = None,\n        kvps: dict | None = None,\n        temp: bool | None = None,\n        update_progress: Log.ProgressUpdate | None = None,\n        id: str | None = None,  # Add id parameter\n        **kwargs,\n    ) -> list[Log.LogItem]:\n        items: list[Log.LogItem] = []\n        for context in AgentContext.all():\n            items.append(\n                context.log.log(\n                    type, heading, content, kvps, temp, update_progress, id, **kwargs\n                )\n            )\n        return items", "label": 0}
{"function": "def initialize_model(model_path):\n    args = parse_args()\n    models_root_path = Path(model_path)\n    if not models_root_path.exists():\n        raise ValueError(f\"`models_root` not exists: {models_root_path}\")\n    \n    hunyuan_video_sampler = HunyuanVideoSampler.from_pretrained(models_root_path, args=args)\n    return hunyuan_video_sampler", "label": 0}
{"function": "    def test_repo_rename_noargs(self, shell):\n        \"\"\"\n        Test do_repo_rename no arguments.\n\n        :param shell:\n        :return:\n        \"\"\"\n        shell.help_repo_rename = MagicMock()\n        shell.client.channel.software.getRepoDetails = MagicMock()\n        shell.do_repo_list = MagicMock()\n        mprint = MagicMock()\n        logger = MagicMock()\n\n        with patch(\"spacecmd.repo.print\", mprint) as prn, \\\n                patch(\"spacecmd.repo.logging\", logger) as lgr:\n            out = spacecmd.repo.do_repo_rename(shell, \"\")\n\n        assert out is 1\n        assert not mprint.called\n        assert not logger.error.called\n        assert not shell.client.channel.software.getRepoDetails.called\n        assert shell.help_repo_rename.called", "label": 1}
{"function": "    def __rmul__(self, other):\n        return self.__class__(other) * self", "label": 1}
{"function": "    def __init__(self, **kwargs):\n        \"\"\"Behaviour can be customized by overriding attributes in a subclass or setting them in the constructor.\n\n        :param string kill_xpath: XPath expression for tags to remove along with their contents.\n        :param string strip_xpath: XPath expression for tags to replace with their contents.\n        :param string allow_xpath: XPath expression for tags to except from strip_xpath.\n        :param bool fix_whitespace: Normalize whitespace to a single space and ensure newlines around block elements.\n        :param dict namespaces: Namespace prefixes to register for the XPaths.\n        \"\"\"\n        # TODO: This is weird. Why don't we change to proper individual keyword arguments with class attribs as default\n        for name, value in kwargs.items():\n            if not hasattr(self, name):\n                raise TypeError('Unknown parameter: %s=%r' % (name, value))\n            setattr(self, name, value)", "label": 1}
{"function": "    def action_execution_server_url(self):\n        return self.api_url", "label": 0}
{"function": "    def __hash__(self) -> int: ...", "label": 1}
{"function": "    def test_reasoning_steps_reward(self):\n        \"\"\"Test reasoning_steps_reward with various formats.\"\"\"\n        test_cases = [\n            # Full credit cases (3 or more steps)\n            (\"Step 1: First step\\nStep 2: Second step\\nStep 3: Third step\", 1.0),\n            (\"First, we do this.\\nSecond, we do that.\\nFinally, we conclude.\", 1.0),\n            # Partial credit cases (less than 3 steps)\n            (\"Step 1: Only step\", 1 / 3),\n            (\"First, we do this.\\nFinally, we conclude.\", 2 / 3),\n            # No credit case\n            (\"Just plain text without any clear steps\", 0.0),\n        ]\n\n        for content, expected_reward in test_cases:\n            completion = [[{\"content\": content}]]\n            rewards = reasoning_steps_reward(completion)\n            self.assertAlmostEqual(rewards[0], expected_reward)", "label": 0}
{"function": "    def from_dict(cls, param_dict):\n        \"\"\"Returns an PlatformParameter object from a dict.\n\n        Args:\n            param_dict: dict. A dict mapping of all fields of\n                PlatformParameter object.\n\n        Returns:\n            PlatformParameter. The corresponding PlatformParameter domain\n            object.\n        \"\"\"\n        if (param_dict['rule_schema_version'] !=\n                feconf.CURRENT_PLATFORM_PARAMETER_RULE_SCHEMA_VERSION):\n            # NOTE: When there's a new rule schema version, a new method with\n            # name of the form '_convert_rule_v1_dict_to_v2_dict` should be\n            # added to the class and called here to convert the rule dicts to\n            # the latest schema.\n            raise Exception(\n                'Current platform parameter rule schema version is v%s, '\n                'received v%s, and there\\'s no convert method from v%s to '\n                'v%s.' % (\n                    feconf.CURRENT_PLATFORM_PARAMETER_RULE_SCHEMA_VERSION,\n                    param_dict['rule_schema_version'],\n                    feconf.CURRENT_PLATFORM_PARAMETER_RULE_SCHEMA_VERSION,\n                    param_dict['rule_schema_version']))\n\n        return cls(\n            param_dict['name'],\n            param_dict['description'],\n            param_dict['data_type'],\n            [\n                PlatformParameterRule.from_dict(rule_dict)\n                for rule_dict in param_dict['rules']],\n            param_dict['rule_schema_version'],\n            param_dict['default_value'],\n            param_dict['is_feature'],\n            param_dict['feature_stage'],\n        )", "label": 1}
{"function": "    def delete(self, commit: bool = True) -> Union[bool, Any]:\n        \"\"\"Remove the record from the database.\"\"\"\n        db.session.delete(self)\n        return commit and db.session.commit()", "label": 1}
{"function": "    def registered_models(self):\n        return RegisteredModels(self._conn, self._conf)", "label": 1}
{"function": "def generate_seed():\n    seed = random.randint(1, 100000000)\n    return {\n        \"__type__\": \"update\",\n        \"value\": seed\n    }", "label": 0}
{"function": "def init_hifigan():\r\n    global hifigan_model, bigvgan_model, sv_cn_model\r\n    hifigan_model = Generator(\r\n        initial_channel=100,\r\n        resblock=\"1\",\r\n        resblock_kernel_sizes=[3, 7, 11],\r\n        resblock_dilation_sizes=[[1, 3, 5], [1, 3, 5], [1, 3, 5]],\r\n        upsample_rates=[10, 6, 2, 2, 2],\r\n        upsample_initial_channel=512,\r\n        upsample_kernel_sizes=[20, 12, 4, 4, 4],\r\n        gin_channels=0,\r\n        is_bias=True,\r\n    )\r\n    hifigan_model.eval()\r\n    hifigan_model.remove_weight_norm()\r\n    state_dict_g = torch.load(\r\n        \"%s/GPT_SoVITS/pretrained_models/gsv-v4-pretrained/vocoder.pth\" % (now_dir,),\r\n        map_location=\"cpu\",\r\n        weights_only=False,\r\n    )\r\n    print(\"loading vocoder\", hifigan_model.load_state_dict(state_dict_g))\r\n    if is_half == True:\r\n        hifigan_model = hifigan_model.half().to(device)\r\n    else:\r\n        hifigan_model = hifigan_model.to(device)\r", "label": 0}
{"function": "async def listen_to_F5TTS(text, server_ip=\"localhost\", server_port=9998):\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    await asyncio.get_event_loop().run_in_executor(None, client_socket.connect, (server_ip, int(server_port)))\n\n    start_time = time.time()\n    first_chunk_time = None\n\n    async def play_audio_stream():\n        nonlocal first_chunk_time\n        p = pyaudio.PyAudio()\n        stream = p.open(format=pyaudio.paFloat32, channels=1, rate=24000, output=True, frames_per_buffer=2048)\n\n        try:\n            while True:\n                data = await asyncio.get_event_loop().run_in_executor(None, client_socket.recv, 8192)\n                if not data:\n                    break\n                if data == b\"END\":\n                    logger.info(\"End of audio received.\")\n                    break\n\n                audio_array = np.frombuffer(data, dtype=np.float32)\n                stream.write(audio_array.tobytes())\n\n                if first_chunk_time is None:\n                    first_chunk_time = time.time()\n\n        finally:\n            stream.stop_stream()\n            stream.close()\n            p.terminate()\n\n        logger.info(f\"Total time taken: {time.time() - start_time:.4f} seconds\")\n\n    try:\n        data_to_send = f\"{text}\".encode(\"utf-8\")\n        await asyncio.get_event_loop().run_in_executor(None, client_socket.sendall, data_to_send)\n        await play_audio_stream()\n\n    except Exception as e:\n        logger.error(f\"Error in listen_to_F5TTS: {e}\")\n\n    finally:\n        client_socket.close()", "label": 0}
{"function": "    def test_simple(self, tdata):\n        with open(tdata.path(\"mitmproxy/net/data/text_cert\"), \"rb\") as f:\n            d = f.read()\n        c1 = certs.Cert.from_pem(d)\n        assert c1.cn == b\"google.com\"\n        assert len(c1.altnames) == 436\n        assert c1.organization == b\"Google Inc\"\n\n        with open(tdata.path(\"mitmproxy/net/data/text_cert_2\"), \"rb\") as f:\n            d = f.read()\n        c2 = certs.Cert.from_pem(d)\n        assert c2.cn == b\"www.inode.co.nz\"\n        assert len(c2.altnames) == 2\n        assert c2.digest(\"sha1\")\n        assert c2.notbefore\n        assert c2.notafter\n        assert c2.subject\n        assert c2.keyinfo == (\"RSA\", 2048)\n        assert c2.serial\n        assert c2.issuer\n        assert c2.to_pem()\n        assert c2.has_expired is not None\n\n        assert c1 != c2", "label": 1}
{"function": "async def test_complex_inputs():\n    \"\"\"Test the complex inputs server\"\"\"\n    from examples.complex_inputs import mcp\n\n    async with Client(mcp) as client:\n        tank = {\"shrimp\": [{\"name\": \"bob\"}, {\"name\": \"alice\"}]}\n        result = await client.call_tool_mcp(\n            \"name_shrimp\", {\"tank\": tank, \"extra_names\": [\"charlie\"]}\n        )\n        assert len(result.content) == 1\n        assert result.content[0].text == '[\"bob\",\"alice\",\"charlie\"]'  # type: ignore[attr-defined]", "label": 0}
{"function": "def hf_clip_vision_encode(image, feature_extractor, image_encoder):\n    assert isinstance(image, np.ndarray)\n    assert image.ndim == 3 and image.shape[2] == 3\n    assert image.dtype == np.uint8\n\n    preprocessed = feature_extractor.preprocess(images=image, return_tensors=\"pt\").to(device=image_encoder.device, dtype=image_encoder.dtype)\n    image_encoder_output = image_encoder(**preprocessed)\n\n    return image_encoder_output", "label": 0}
{"function": "    def info(self):\n        \"\"\"Print basic info\"\"\"\n        print(str(self))", "label": 1}
{"function": "    def remove_methods(self, env):\n        \"\"\"\n        Removes the methods that were added by the tool initialization\n        so we no longer copy and re-bind them when the construction\n        environment gets cloned.\n        \"\"\"\n        for method in self.methods.values():\n            env.RemoveMethod(method)", "label": 1}
{"function": "    def __init__(self):\n        warnings.warn(\"ContextStack has been renamed to ExitStack\",\n                      DeprecationWarning)\n        super(ContextStack, self).__init__()", "label": 1}
{"function": "    def repr_int(self, x, level):\n        s = builtins.repr(x) # XXX Hope this isn't too slow...\n        if len(s) > self.maxlong:\n            i = max(0, (self.maxlong-3)//2)\n            j = max(0, self.maxlong-3-i)\n            s = s[:i] + '...' + s[len(s)-j:]\n        return s", "label": 1}
{"function": "        def extract_parameters(_flow, _flow_dict, component_model, _main_call=False, main_id=None):\n            def is_subcomponent_specification(values):\n                # checks whether the current value can be a specification of\n                # subcomponents, as for example the value for steps parameter\n                # (in Pipeline) or transformers parameter (in\n                # ColumnTransformer). These are always lists/tuples of lists/\n                # tuples, size bigger than 2 and an OpenMLFlow item involved.\n                if not isinstance(values, (tuple, list)):\n                    return False\n                for item in values:\n                    if not isinstance(item, (tuple, list)):\n                        return False\n                    if len(item) < 2:\n                        return False\n                    if not isinstance(item[1], (openml.flows.OpenMLFlow, str)):\n                        if (\n                            isinstance(item[1], str)\n                            and item[1] in SKLEARN_PIPELINE_STRING_COMPONENTS\n                        ):\n                            pass\n                        else:\n                            return False\n                return True\n\n            # _flow is openml flow object, _param dict maps from flow name to flow\n            # id for the main call, the param dict can be overridden (useful for\n            # unit tests / sentinels) this way, for flows without subflows we do\n            # not have to rely on _flow_dict\n            exp_parameters = set(_flow.parameters)\n            if (\n                isinstance(component_model, str)\n                and component_model in SKLEARN_PIPELINE_STRING_COMPONENTS\n            ):\n                model_parameters = set()\n            else:\n                model_parameters = set([mp for mp in component_model.get_params(deep=False)])\n            if len(exp_parameters.symmetric_difference(model_parameters)) != 0:\n                flow_params = sorted(exp_parameters)\n                model_params = sorted(model_parameters)\n                raise ValueError(\n                    \"Parameters of the model do not match the \"\n                    \"parameters expected by the \"\n                    \"flow:\\nexpected flow parameters: \"\n                    \"%s\\nmodel parameters: %s\" % (flow_params, model_params)\n                )\n            exp_components = set(_flow.components)\n            if (\n                isinstance(component_model, str)\n                and component_model in SKLEARN_PIPELINE_STRING_COMPONENTS\n            ):\n                model_components = set()\n            else:\n                _ = set([mp for mp in component_model.get_params(deep=False)])\n                model_components = set(\n                    [\n                        mp\n                        for mp in component_model.get_params(deep=True)\n                        if \"__\" not in mp and mp not in _\n                    ]\n                )\n            if len(exp_components.symmetric_difference(model_components)) != 0:\n                is_problem = True\n                if len(exp_components - model_components) > 0:\n                    # If an expected component is not returned as a component by get_params(),\n                    # this means that it is also a parameter -> we need to check that this is\n                    # actually the case\n                    difference = exp_components - model_components\n                    component_in_model_parameters = []\n                    for component in difference:\n                        if component in model_parameters:\n                            component_in_model_parameters.append(True)\n                        else:\n                            component_in_model_parameters.append(False)\n                    is_problem = not all(component_in_model_parameters)\n                if is_problem:\n                    flow_components = sorted(exp_components)\n                    model_components = sorted(model_components)\n                    raise ValueError(\n                        \"Subcomponents of the model do not match the \"\n                        \"parameters expected by the \"\n                        \"flow:\\nexpected flow subcomponents: \"\n                        \"%s\\nmodel subcomponents: %s\" % (flow_components, model_components)\n                    )\n\n            _params = []\n            for _param_name in _flow.parameters:\n                _current = OrderedDict()\n                _current[\"oml:name\"] = _param_name\n\n                current_param_values = self.model_to_flow(component_model.get_params()[_param_name])\n\n                # Try to filter out components (a.k.a. subflows) which are\n                # handled further down in the code (by recursively calling\n                # this function)!\n                if isinstance(current_param_values, openml.flows.OpenMLFlow):\n                    continue\n\n                if is_subcomponent_specification(current_param_values):\n                    # complex parameter value, with subcomponents\n                    parsed_values = list()\n                    for subcomponent in current_param_values:\n                        # scikit-learn stores usually tuples in the form\n                        # (name (str), subcomponent (mixed), argument\n                        # (mixed)). OpenML replaces the subcomponent by an\n                        # OpenMLFlow object.\n                        if len(subcomponent) < 2 or len(subcomponent) > 3:\n                            raise ValueError(\"Component reference should be \" \"size {2,3}. \")\n\n                        subcomponent_identifier = subcomponent[0]\n                        subcomponent_flow = subcomponent[1]\n                        if not isinstance(subcomponent_identifier, str):\n                            raise TypeError(\n                                \"Subcomponent identifier should be of type string, \"\n                                \"but is {}\".format(type(subcomponent_identifier))\n                            )\n                        if not isinstance(subcomponent_flow, (openml.flows.OpenMLFlow, str)):\n                            if (\n                                isinstance(subcomponent_flow, str)\n                                and subcomponent_flow in SKLEARN_PIPELINE_STRING_COMPONENTS\n                            ):\n                                pass\n                            else:\n                                raise TypeError(\n                                    \"Subcomponent flow should be of type flow, but is {}\".format(\n                                        type(subcomponent_flow)\n                                    )\n                                )\n\n                        current = {\n                            \"oml-python:serialized_object\": COMPONENT_REFERENCE,\n                            \"value\": {\n                                \"key\": subcomponent_identifier,\n                                \"step_name\": subcomponent_identifier,\n                            },\n                        }\n                        if len(subcomponent) == 3:\n                            if not isinstance(subcomponent[2], list) and not isinstance(\n                                subcomponent[2], OrderedDict\n                            ):\n                                raise TypeError(\n                                    \"Subcomponent argument should be list or OrderedDict\"\n                                )\n                            current[\"value\"][\"argument_1\"] = subcomponent[2]\n                        parsed_values.append(current)\n                    parsed_values = json.dumps(parsed_values)\n                else:\n                    # vanilla parameter value\n                    parsed_values = json.dumps(current_param_values)\n\n                _current[\"oml:value\"] = parsed_values\n                if _main_call:\n                    _current[\"oml:component\"] = main_id\n                else:\n                    _current[\"oml:component\"] = _flow_dict[_flow.name]\n                _params.append(_current)\n\n            for _identifier in _flow.components:\n                subcomponent_model = component_model.get_params()[_identifier]\n                _params.extend(\n                    extract_parameters(\n                        _flow.components[_identifier], _flow_dict, subcomponent_model\n                    )\n                )\n            return _params", "label": 1}
{"function": "    def test_neighboring_finds_neighbor_alignments(self):\n        # arrange\n        a_info = AlignmentInfo(\n            (0, 3, 2),\n            (None, 'des', '\u0153ufs', 'verts'),\n            ('UNUSED', 'green', 'eggs'),\n            [[], [], [2], [1]],\n        )\n        ibm_model = IBMModel([])\n\n        # act\n        neighbors = ibm_model.neighboring(a_info)\n\n        # assert\n        neighbor_alignments = set()\n        for neighbor in neighbors:\n            neighbor_alignments.add(neighbor.alignment)\n        expected_alignments = set(\n            [\n                # moves\n                (0, 0, 2),\n                (0, 1, 2),\n                (0, 2, 2),\n                (0, 3, 0),\n                (0, 3, 1),\n                (0, 3, 3),\n                # swaps\n                (0, 2, 3),\n                # original alignment\n                (0, 3, 2),\n            ]\n        )\n        self.assertEqual(neighbor_alignments, expected_alignments)", "label": 1}
{"function": "  def testContainsWildcardMatchesObject(self, mock_CreateWildcardIterator,\n                                        mock_gsutil_api):\n    storage_url = StorageUrlFromString('gs://test/helloworld')\n    mock_CreateWildcardIterator.return_value = iter(\n        [BucketListingObject(storage_url)])\n    (exp_url, have_existing_dst_container) = ExpandUrlToSingleBlr(\n        'gs://test/hello*/', mock_gsutil_api, 'project_id', False,\n        CreateOrGetGsutilLogger('copy_test'))\n\n    self.assertFalse(have_existing_dst_container)\n    self.assertEqual(exp_url, storage_url)", "label": 1}
{"function": "def pad_dataproto_to_divisor(data: 'DataProto', size_divisor: int):\n    \"\"\"Pad a DataProto to size divisible by size_divisor\n\n    Args:\n        size_divisor (int): size divisor\n\n    Returns:\n        data: (DataProto): the padded DataProto\n        pad_size (int)\n    \"\"\"\n    assert isinstance(data, DataProto), 'data must be a DataProto'\n    if len(data) % size_divisor != 0:\n        pad_size = size_divisor - len(data) % size_divisor\n        data_padded = DataProto.concat([data, data[:pad_size]])\n    else:\n        pad_size = 0\n        data_padded = data\n    return data_padded, pad_size", "label": 0}
{"function": "def path_tuple_to_string(path: tuple) -> str:\n    pieces = []\n    for elem in path:\n        if isinstance(elem, jax.tree_util.DictKey):\n            pieces.append(elem.key)\n        elif isinstance(elem, jax.tree_util.GetAttrKey):\n            pieces.append(elem.name)\n        else:\n            assert isinstance(elem, (jax.tree_util.FlattenedIndexKey, jax.tree_util.SequenceKey))\n    return \"/\".join(pieces)", "label": 0}
{"function": "def gpu_wrapped_execute_video(*args, **kwargs):\n    return gradio_pipeline_animal.execute_video(*args, **kwargs)", "label": 0}
{"function": "        def fset(self, value):\n            if not value:\n                del self.headers[name]\n            elif isinstance(value, string_types):\n                self.headers[name] = value\n            else:\n                self.headers[name] = dump_header(value)", "label": 1}
{"function": "def run_model(target_dir, model) -> dict:\n    \"\"\"\n    Run the VGGT model on images in the 'target_dir/images' folder and return predictions.\n    \"\"\"\n    print(f\"Processing images from {target_dir}\")\n\n    # Device check\n    device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n    if not torch.cuda.is_available():\n        raise ValueError(\"CUDA is not available. Check your environment.\")\n\n    # Move model to device\n    model = model.to(device)\n    model.eval()\n\n    # Load and preprocess images\n    image_names = glob.glob(os.path.join(target_dir, \"images\", \"*\"))\n    image_names = sorted(image_names)\n    print(f\"Found {len(image_names)} images\")\n    if len(image_names) == 0:\n        raise ValueError(\"No images found. Check your upload.\")\n\n    images = load_and_preprocess_images(image_names).to(device)\n    print(f\"Preprocessed images shape: {images.shape}\")\n\n    # Run inference\n    print(\"Running inference...\")\n    dtype = torch.bfloat16 if torch.cuda.get_device_capability()[0] >= 8 else torch.float16\n\n    with torch.no_grad():\n        with torch.cuda.amp.autocast(dtype=dtype):\n            predictions = model(images)\n\n    # Convert pose encoding to extrinsic and intrinsic matrices\n    print(\"Converting pose encoding to extrinsic and intrinsic matrices...\")\n    extrinsic, intrinsic = pose_encoding_to_extri_intri(predictions[\"pose_enc\"], images.shape[-2:])\n    predictions[\"extrinsic\"] = extrinsic\n    predictions[\"intrinsic\"] = intrinsic\n\n    # Convert tensors to numpy\n    for key in predictions.keys():\n        if isinstance(predictions[key], torch.Tensor):\n            predictions[key] = predictions[key].cpu().numpy().squeeze(0)  # remove batch dimension\n\n    # Generate world points from depth map\n    print(\"Computing world points from depth map...\")\n    depth_map = predictions[\"depth\"]  # (S, H, W, 1)\n    world_points = unproject_depth_map_to_point_map(depth_map, predictions[\"extrinsic\"], predictions[\"intrinsic\"])\n    predictions[\"world_points_from_depth\"] = world_points\n\n    # Clean up\n    torch.cuda.empty_cache()\n    return predictions", "label": 0}
{"function": "    def test_accuracy_reward_wrong_answer(self):\n        \"\"\"Test accuracy_reward with an incorrect answer.\"\"\"\n        completion = [[{\"content\": r\"\\boxed{\\frac{64}{400}}\"}]]\n        solution = [r\"\\frac{63}{400}\"]\n        rewards = accuracy_reward(completion, solution)\n        self.assertEqual(rewards[0], 0.0)", "label": 0}
{"function": "    def _parse_missing_dependency(self, error_str: str) -> str:\n        \"\"\"\n        Parse the missing dependency name from an ImportError string.\n        \"\"\"\n        if \"No module named\" in error_str:\n            parts = error_str.split(\"No module named\")\n            missing_module = parts[-1].strip(\" '\\\"\")\n        else:\n            missing_module = error_str\n        return missing_module", "label": 0}
{"function": "def test_request_with_url_fragment():\n    \"\"\"Test a request with a URL fragment.\"\"\"\n    request = RequestModel(\n        name=\"Request with URL fragment\",\n        method=\"GET\",\n        url=\"https://example.com/api/docs#section1\",\n        params=[QueryParam(name=\"version\", value=\"1.0\")],\n    )\n\n    expected = \"curl \\\\\\n  'https://example.com/api/docs?version=1.0#section1'\"\n    assert request.to_curl() == expected", "label": 0}
{"function": "    def __init__(self, sm):\n        self._mModel = sm\n        self._mCurrentBytePos = 0\n        self._mCurrentCharLen = 0\n        self.reset()", "label": 1}
{"function": "async def stop():\n    logger.info(\"Stop endpoint called\")\n    interaction.current_agent.request_stop()\n    return JSONResponse(status_code=200, content={\"status\": \"stopped\"})", "label": 0}
{"function": "    def test_string_slice_replace(self):\n        self.check_func(lambda x: x.str.slice_replace(1, repl=\"X\"))\n        self.check_func(lambda x: x.str.slice_replace(stop=2, repl=\"X\"))\n        self.check_func(lambda x: x.str.slice_replace(start=1, stop=3, repl=\"X\"))", "label": 1}
{"function": "    def target_temperature(self):\n        \"\"\"Return the temperature we try to reach.\"\"\"\n        return self._target_temperature", "label": 1}
{"function": "    def _get_file_stream(self, total_content_length, content_type, filename=None,\n                        content_length=None):\n        \"\"\"Called to get a stream for the file upload.\n\n        This must provide a file-like class with `read()`, `readline()`\n        and `seek()` methods that is both writeable and readable.\n\n        The default implementation returns a temporary file if the total\n        content length is higher than 500KB.  Because many browsers do not\n        provide a content length for the files only the total content\n        length matters.\n\n        :param total_content_length: the total content length of all the\n                                     data in the request combined.  This value\n                                     is guaranteed to be there.\n        :param content_type: the mimetype of the uploaded file.\n        :param filename: the filename of the uploaded file.  May be `None`.\n        :param content_length: the length of this file.  This value is usually\n                               not provided because webbrowsers do not provide\n                               this value.\n        \"\"\"\n        return default_stream_factory(total_content_length, content_type,\n                                      filename, content_length)", "label": 1}
{"function": "    def valDataFiles(self, obj):\n        \"\"\"Function to add DataFileContainer\n\n        :param obj: element to add DataFileContainer\n        \"\"\"\n        values = []\n        for i in self.parModis:\n            values.append(i.retDataFiles())\n        for i in values:\n            dfc = self.ElementTree.SubElement(obj, 'DataFileContainer')\n            self._cicle_values(dfc, i)", "label": 1}
{"function": "    def get_attention_mask(self, attention_mask, repeat_num):\n        if self.on_npu and attention_mask is not None:\n            if npu_config.enable_FA:\n                attention_mask = attention_mask.to(torch.bool)\n            attention_mask = attention_mask.repeat_interleave(repeat_num, dim=-2)\n        return attention_mask", "label": 0}
{"function": "def parse_pytest_output(output: str) -> List[Dict[str, any]]:\n    # Match lines like:\n    # all_llm_provider/test_all_llm_provider.py .......... [55%]\n    # llamaindex_examples/legal_research_rag/test_legal_rag.py F [94%]\n    test_result_pattern = re.compile(r\"^(.*\\.py)\\s+([.EF]+)\")\n    results = []\n    for line in output.splitlines():\n        match = test_result_pattern.match(line.strip())\n        if match:\n            module = match.group(1)\n            result_str = match.group(2)\n            passed = result_str.count(\".\")\n            failed = result_str.count(\"F\")\n            errors = result_str.count(\"E\")\n            total = len(result_str)\n            results.append({\n                \"module\": module,\n                \"count\": total,\n                \"passed\": passed,\n                \"failed\": failed,\n                \"errors\": errors\n            })\n    return results", "label": 0}
{"function": "def install_urllib2_ca_file():\n    \"\"\"Makes urllib2.urlopen and urllib2.build_opener use the ca file\n    returned by get_ca_file()\n    \"\"\"\n\n    try:\n        import ssl\n    except ImportError:\n        return\n\n    base = request_module.HTTPSHandler\n\n    class MyHandler(base):\n\n        def __init__(self, debuglevel=0, context=None):\n            ca_file = get_ca_file()\n            if context is None and ca_file is not None:\n                context = ssl.create_default_context(\n                    purpose=ssl.Purpose.SERVER_AUTH,\n                    cafile=ca_file)\n            base.__init__(self, debuglevel, context)\n\n    request_module.HTTPSHandler = MyHandler", "label": 1}
{"function": "    def to(self, device):\n        self.t3 = self.t3.to(device=device)\n        for k, v in self.gen.items():\n            if torch.is_tensor(v):\n                self.gen[k] = v.to(device=device)\n        return self", "label": 0}
{"function": "    def log_received(msg):\n        if config.ui[\"hide_log\"]:\n            return\n        with log_container:\n            log_records.append(msg)\n            st.code(\"\\n\".join(log_records))", "label": 0}
{"function": "    def save(self, path: str) -> None:\n        \"\"\"Save the current configuration instance to a JSON file.\n\n        Ensures the parent directory exists and the file has a .json extension.\n\n        Args:\n            path: The target file path to save the configuration.\n\n        Raises:\n            ValueError: If the path is not a file with a .json extension.\n        \"\"\"\n        os.makedirs(os.path.dirname(path), exist_ok=True)\n        config_json = self.model_dump_json(indent=2)\n        with open(path, \"w\") as f:\n            f.write(config_json)", "label": 0}
{"function": "    def get(self):\n        status_active = FuzzingJobState.query.filter_by(name='Active').first()\n        status_completed = FuzzingJobState.query.filter_by(name='Completed').first()\n        status_queued = FuzzingJobState.query.filter_by(name='Queued').first()\n\n        total_job_count = FuzzingJob.query.count()\n        active_job_count = FuzzingJob.query.filter_by(state_id=status_active.id).count()\n        completed_job_count = FuzzingJob.query.filter_by(state_id=status_completed.id).count()\n        queued_job_count = FuzzingJob.query.filter_by(state_id=status_queued.id).count()\n        crash_count = FuzzingCrash.query.count()\n        node_count = FuzzingHost.query.count()\n        return {\n            'total_job_count': total_job_count,\n            'active_job_count': active_job_count,\n            'completed_job_count': completed_job_count,\n            'queued_job_count': queued_job_count,\n            'crash_count': crash_count,\n            'node_count': node_count,\n            'serverTime' : str(datetime.now())\n        }, 200", "label": 1}
{"function": "def image_to_3d(\n    image: Image.Image,\n    multiimages: List[Tuple[Image.Image, str]],\n    is_multiimage: bool,\n    seed: int,\n    ss_guidance_strength: float,\n    ss_sampling_steps: int,\n    slat_guidance_strength: float,\n    slat_sampling_steps: int,\n    multiimage_algo: Literal[\"multidiffusion\", \"stochastic\"],\n    req: gr.Request,\n) -> Tuple[dict, str]:\n    \"\"\"\n    Convert an image to a 3D model.\n\n    Args:\n        image (Image.Image): The input image.\n        multiimages (List[Tuple[Image.Image, str]]): The input images in multi-image mode.\n        is_multiimage (bool): Whether is in multi-image mode.\n        seed (int): The random seed.\n        ss_guidance_strength (float): The guidance strength for sparse structure generation.\n        ss_sampling_steps (int): The number of sampling steps for sparse structure generation.\n        slat_guidance_strength (float): The guidance strength for structured latent generation.\n        slat_sampling_steps (int): The number of sampling steps for structured latent generation.\n        multiimage_algo (Literal[\"multidiffusion\", \"stochastic\"]): The algorithm for multi-image generation.\n\n    Returns:\n        dict: The information of the generated 3D model.\n        str: The path to the video of the 3D model.\n    \"\"\"\n    user_dir = os.path.join(TMP_DIR, str(req.session_hash))\n    if not is_multiimage:\n        outputs = pipeline.run(\n            image,\n            seed=seed,\n            formats=[\"gaussian\", \"mesh\"],\n            preprocess_image=False,\n            sparse_structure_sampler_params={\n                \"steps\": ss_sampling_steps,\n                \"cfg_strength\": ss_guidance_strength,\n            },\n            slat_sampler_params={\n                \"steps\": slat_sampling_steps,\n                \"cfg_strength\": slat_guidance_strength,\n            },\n        )\n    else:\n        outputs = pipeline.run_multi_image(\n            [image[0] for image in multiimages],\n            seed=seed,\n            formats=[\"gaussian\", \"mesh\"],\n            preprocess_image=False,\n            sparse_structure_sampler_params={\n                \"steps\": ss_sampling_steps,\n                \"cfg_strength\": ss_guidance_strength,\n            },\n            slat_sampler_params={\n                \"steps\": slat_sampling_steps,\n                \"cfg_strength\": slat_guidance_strength,\n            },\n            mode=multiimage_algo,\n        )\n    video = render_utils.render_video(outputs['gaussian'][0], num_frames=120)['color']\n    video_geo = render_utils.render_video(outputs['mesh'][0], num_frames=120)['normal']\n    video = [np.concatenate([video[i], video_geo[i]], axis=1) for i in range(len(video))]\n    video_path = os.path.join(user_dir, 'sample.mp4')\n    imageio.mimsave(video_path, video, fps=15)\n    state = pack_state(outputs['gaussian'][0], outputs['mesh'][0])\n    torch.cuda.empty_cache()\n    return state, video_path", "label": 0}
{"function": "    def get_cuda_version_of_torch(self):\n        torch_cuda_version = parse(torch.version.cuda)\n        cuda_version = f\"{torch_cuda_version.major}{torch_cuda_version.minor}\"\n        return cuda_version", "label": 0}
{"function": "    def _add_mod_write_service(self, tag_name, ioi, write_data, data_type):\n        \"\"\"\n        This will add the bit level request to the tagIOI\n        Writing to a bit is handled in a different way than\n        other writes\n        \"\"\"\n        element_size = self.CIPTypes[data_type][0]\n        data_len = len(write_data)\n        byte_count = element_size*data_len\n        RequestPathSize = int(len(ioi)/2)\n        RequestService = 0x4E\n        write_request = pack('<BB', RequestService, RequestPathSize)\n        write_request += ioi\n\n        fmt = self.CIPTypes[data_type][2]\n        fmt = fmt.upper()\n        s = tag_name.split('.')\n        if data_type == 211:\n            t = s[len(s)-1]\n            tag, base_tag, index = _parseTagName(t, 0)\n            index %= 32\n        else:\n            index = s[len(s)-1]\n            index = int(index)\n\n        write_request += pack('<h', byte_count)\n        byte = 2**(byte_count*8)-1\n        bits = 2**index\n        if write_data[0]:\n            write_request += pack(fmt, bits)\n            write_request += pack(fmt, byte)\n        else:\n            write_request += pack(fmt, 0x00)\n            write_request += pack(fmt, (byte-bits))\n\n        return write_request", "label": 1}
{"function": "    def set_sequential_responses(self, responses: list[ChatCompletion]):\n        \"\"\"\n        Set the mock to return different responses sequentially.\n        :param responses: A list of ChatCompletion responses to return in order.\n        \"\"\"\n        self.chat.completions.create.side_effect = responses", "label": 0}
{"function": "def main(config_path):\n    config = load_config(config_path)\n    task_instances = initialize_tasks_and_models(config)\n\n    # get input and output path from config\n    input_data = config.get('inputs', None)\n    result_path = config.get('outputs', 'outputs'+'/'+TASK_NAME)\n    visualize = config.get('visualize', False)\n\n    # formula_detection_task\n    task = task_instances[TASK_NAME]\n\n    detection_results = task.process(input_data, save_dir=result_path, visualize=visualize)\n\n    print(f'Task done, results can be found at {result_path}')", "label": 0}
{"function": "def setup_agents(openai_api_key: str) -> Tuple[Agent, Agent]:\n    \"\"\"Initialize the processor and TTS agents.\"\"\"\n    os.environ[\"OPENAI_API_KEY\"] = openai_api_key\n    \n    processor_agent = Agent(\n        name=\"Documentation Processor\",\n        instructions=\"\"\"You are a helpful documentation assistant. Your task is to:\n        1. Analyze the provided documentation content\n        2. Answer the user's question clearly and concisely\n        3. Include relevant examples when available\n        4. Cite the source files when referencing specific content\n        5. Keep responses natural and conversational\n        6. Format your response in a way that's easy to speak out loud\"\"\",\n        model=\"gpt-4o\"\n    )\n\n    tts_agent = Agent(\n        name=\"Text-to-Speech Agent\",\n        instructions=\"\"\"You are a text-to-speech agent. Your task is to:\n        1. Convert the processed documentation response into natural speech\n        2. Maintain proper pacing and emphasis\n        3. Handle technical terms clearly\n        4. Keep the tone professional but friendly\n        5. Use appropriate pauses for better comprehension\n        6. Ensure the speech is clear and well-articulated\"\"\",\n        model=\"gpt-4o\"\n    )\n    \n    return processor_agent, tts_agent", "label": 0}
{"function": "def run_inference():\n    build_dir = \"build\"\n    if platform.system() == \"Windows\":\n        main_path = os.path.join(build_dir, \"bin\", \"Release\", \"llama-cli.exe\")\n        if not os.path.exists(main_path):\n            main_path = os.path.join(build_dir, \"bin\", \"llama-cli\")\n    else:\n        main_path = os.path.join(build_dir, \"bin\", \"llama-cli\")\n    command = [\n        f'{main_path}',\n        '-m', args.model,\n        '-n', str(args.n_predict),\n        '-t', str(args.threads),\n        '-p', args.prompt,\n        '-ngl', '0',\n        '-c', str(args.ctx_size),\n        '--temp', str(args.temperature),\n        \"-b\", \"1\",\n    ]\n    if args.conversation:\n        command.append(\"-cnv\")\n    run_command(command)", "label": 0}
{"function": "def _maketup(descr, val):\n    dt = dtype(descr)\n    # Place val in all scalar tuples:\n    fields = dt.fields\n    if fields is None:\n        return val\n    else:\n        res = [_maketup(fields[name][0], val) for name in dt.names]\n        return tuple(res)", "label": 1}
{"function": "def set_seed(seed: int):\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    random.seed(seed)\n    np.random.seed(seed)", "label": 0}
{"function": "    def test_revive(self, n='test_revive'):\n        c = compat.Consumer(self.connection, queue=n, exchange=n)\n        cs = compat.ConsumerSet(self.connection, consumers=[c])\n\n        with self.connection.channel() as c2:\n            cs.revive(c2)\n            assert cs.backend is c2", "label": 1}
{"function": "    def _load_func(index):\n        y, name, marchive, mname = images[index]\n        im = imread(marchive.extractfile(mname), num_channels=3)\n        x = _resize_image(im, args.width, args.height, args.mode == 'padding')\n        return x, np.array([y]).astype(np.int32)", "label": 1}
{"function": "        def get_value(self):\n            return self.__value", "label": 1}
{"function": "  def testExtremeDefaultValues(self):\n    message = unittest_pb2.TestExtremeDefaultValues()\n\n    # Python pre-2.6 does not have isinf() or isnan() functions, so we have\n    # to provide our own.\n    def isnan(val):\n      # NaN is never equal to itself.\n      return val != val\n    def isinf(val):\n      # Infinity times zero equals NaN.\n      return not isnan(val) and isnan(val * 0)\n\n    self.assertTrue(isinf(message.inf_double))\n    self.assertTrue(message.inf_double > 0)\n    self.assertTrue(isinf(message.neg_inf_double))\n    self.assertTrue(message.neg_inf_double < 0)\n    self.assertTrue(isnan(message.nan_double))\n\n    self.assertTrue(isinf(message.inf_float))\n    self.assertTrue(message.inf_float > 0)\n    self.assertTrue(isinf(message.neg_inf_float))\n    self.assertTrue(message.neg_inf_float < 0)\n    self.assertTrue(isnan(message.nan_float))\n    self.assertEqual(\"? ? ?? ?? ??? ??/ ??-\", message.cpp_trigraph)", "label": 1}
{"function": "    def forward(self, input1, input2):\n        input1_c = input1.contiguous()\n\n        result = Resample2dFunction(self.kernel_size)(input1_c, input2)\n\n        return result", "label": 1}
{"function": "    def __new__(cls, name, value):\n        kwds = {'defects': []}\n        cls.parse(value, kwds)\n        if utils._has_surrogates(kwds['decoded']):\n            kwds['decoded'] = utils._sanitize(kwds['decoded'])\n        self = str.__new__(cls, kwds['decoded'])\n        # del kwds['decoded']\n        self.init(name, **kwds)\n        return self", "label": 1}
{"function": "    def __init__(self, name):\n        self.name = name", "label": 1}
{"function": "\tdef take_editing_lock(self, tid):\n\t\t\"\"\"\n\t\tSet the column `editing` to 1 iff it's 0. Return True if the column was effectively set, False otherwise.\n\t\t\"\"\"\n\t\tc = self.connection.cursor()\n\t\tc.execute(\"\"\"\n\t\t\tUPDATE Task\n\t\t\tSET editing = 1\n\t\t\tWHERE id = ?\n\t\t\t  AND editing = 0\n\t\t\"\"\", (tid,))\n\t\ttaken = c.rowcount == 1\n\t\tself.connection.commit()\n\t\treturn taken", "label": 1}
{"function": "def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):\n    \"\"\"\n    Returns a boolean array where two arrays are element-wise equal within a\n    tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    .. warning:: The default `atol` is not appropriate for comparing numbers\n                 that are much smaller than one (see Notes).\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN's as equal.  If True, NaN's in `a` will be\n        considered equal to NaN's in `b` in the output array.\n\n    Returns\n    -------\n    y : array_like\n        Returns a boolean array of where `a` and `b` are equal within the\n        given tolerance. If both `a` and `b` are scalars, returns a single\n        boolean value.\n\n    See Also\n    --------\n    allclose\n\n    Notes\n    -----\n    .. versionadded:: 1.7.0\n\n    For finite values, isclose uses the following equation to test whether\n    two floating point values are equivalent.\n\n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    Unlike the built-in `math.isclose`, the above equation is not symmetric\n    in `a` and `b` -- it assumes `b` is the reference value -- so that\n    `isclose(a, b)` might be different from `isclose(b, a)`. Furthermore,\n    the default value of atol is not zero, and is used to determine what\n    small values should be considered close to zero. The default value is\n    appropriate for expected values of order unity: if the expected values\n    are significantly smaller than one, it can result in false positives.\n    `atol` should be carefully selected for the use case at hand. A zero value\n    for `atol` will result in `False` if either `a` or `b` is zero.\n\n    Examples\n    --------\n    >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])\n    array([True, False])\n    >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])\n    array([True, True])\n    >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])\n    array([False, True])\n    >>> np.isclose([1.0, np.nan], [1.0, np.nan])\n    array([True, False])\n    >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\n    array([True, True])\n    >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])\n    array([ True, False], dtype=bool)\n    >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)\n    array([False, False], dtype=bool)\n    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])\n    array([ True,  True], dtype=bool)\n    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)\n    array([False,  True], dtype=bool)\n    \"\"\"\n    def within_tol(x, y, atol, rtol):\n        with errstate(invalid='ignore'):\n            return less_equal(abs(x-y), atol + rtol * abs(y))\n\n    x = asanyarray(a)\n    y = asanyarray(b)\n\n    # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).\n    # This will cause casting of x later. Also, make sure to allow subclasses\n    # (e.g., for numpy.ma).\n    dt = multiarray.result_type(y, 1.)\n    y = array(y, dtype=dt, copy=False, subok=True)\n\n    xfin = isfinite(x)\n    yfin = isfinite(y)\n    if all(xfin) and all(yfin):\n        return within_tol(x, y, atol, rtol)\n    else:\n        finite = xfin & yfin\n        cond = zeros_like(finite, subok=True)\n        # Because we're using boolean indexing, x & y must be the same shape.\n        # Ideally, we'd just do x, y = broadcast_arrays(x, y). It's in\n        # lib.stride_tricks, though, so we can't import it here.\n        x = x * ones_like(cond)\n        y = y * ones_like(cond)\n        # Avoid subtraction with infinite/nan values...\n        cond[finite] = within_tol(x[finite], y[finite], atol, rtol)\n        # Check for equality of infinite values...\n        cond[~finite] = (x[~finite] == y[~finite])\n        if equal_nan:\n            # Make NaN == NaN\n            both_nan = isnan(x) & isnan(y)\n\n            # Needed to treat masked arrays correctly. = True would not work.\n            cond[both_nan] = both_nan[both_nan]\n\n        return cond[()]  # Flatten 0d arrays to scalars", "label": 1}
{"function": "    def stop(self):\n        for task in self.tasks:\n            task.cancel()\n        self.tasks = []\n        if self.pbar:\n            self.pbar.close()\n        if self.stop_event:\n            self.stop_event.set()", "label": 0}
{"function": "\tdef get_PageNum(self):\n\t\treturn self.get_query_params().get('PageNum')", "label": 1}
{"function": "def detect_server_type(cmd: str) -> str:\n    for server_type, config in SERVER_DEFAULTS.items():\n        if config.command in cmd:\n            return server_type\n    return \"unknown\"", "label": 0}
{"function": "def test_handoff(mock_openai_client: MockOpenAIClient):\n    def transfer_to_agent2():\n        return agent2\n\n    agent1 = Agent(name=\"Test Agent 1\", functions=[transfer_to_agent2])\n    agent2 = Agent(name=\"Test Agent 2\")\n\n    # set mock to return a response that triggers the handoff\n    mock_openai_client.set_sequential_responses(\n        [\n            create_mock_response(\n                message={\"role\": \"assistant\", \"content\": \"\"},\n                function_calls=[{\"name\": \"transfer_to_agent2\"}],\n            ),\n            create_mock_response(\n                {\"role\": \"assistant\", \"content\": DEFAULT_RESPONSE_CONTENT}\n            ),\n        ]\n    )\n\n    # set up client and run\n    client = Swarm(client=mock_openai_client)\n    messages = [{\"role\": \"user\", \"content\": \"I want to talk to agent 2\"}]\n    response = client.run(agent=agent1, messages=messages)\n\n    assert response.agent == agent2\n    assert response.messages[-1][\"role\"] == \"assistant\"\n    assert response.messages[-1][\"content\"] == DEFAULT_RESPONSE_CONTENT", "label": 0}
{"function": "def get_cmake_abi_args(cmake_args):\n    if torch.compiled_with_cxx11_abi():\n        cmake_args.append(\"-D_GLIBCXX_USE_CXX11_ABI=1\")\n    else:\n        cmake_args.append(\"-D_GLIBCXX_USE_CXX11_ABI=0\")\n    return cmake_args", "label": 0}
{"function": "def copy_to_shm(file: str):\n    if file.startswith(\"/dev/shm/\"):\n        # Nothing to do, the file is already in shared memory.\n        yield file\n        return\n\n    tmp_dir = \"/dev/shm/\"\n    fd, tmp_path = tempfile.mkstemp(dir=tmp_dir)\n    try:\n        shutil.copyfile(file, tmp_path)\n        yield tmp_path\n    finally:\n        os.remove(tmp_path)\n        os.close(fd)", "label": 0}
{"function": "def test_parse_hparam_args__string():\n    hparam_args = ['--foo', 'HParams(boo=\"WaveNet\")']\n    assert parse_hparam_args(hparam_args) == {'foo': HParams(boo='WaveNet')}", "label": 1}
{"function": "def root_testdata_dir() -> Path:\n    return Path(__file__).parent / \"testdata\"", "label": 0}
{"function": "        def on_update(d):\n            self.headers['Content-Type'] = \\\n                dump_options_header(self.mimetype, d)", "label": 1}
{"function": "def test_available_policies():\n    \"\"\"\n    This test verifies that the class attribute `name` for all policies is\n    consistent with those listed in `lerobot/__init__.py`.\n    \"\"\"\n    policy_classes = [ACTPolicy, DiffusionPolicy, TDMPCPolicy, VQBeTPolicy]\n    policies = [pol_cls.name for pol_cls in policy_classes]\n    assert set(policies) == set(lerobot.available_policies), policies", "label": 0}
{"function": "def is_empty(*items):  # \u4efb\u610f\u4e00\u9879\u4e0d\u4e3a\u7a7a\u8fd4\u56deFalse\r\n    for item in items:\r\n        if item is not None and item != \"\":\r\n            return False\r\n    return True\r", "label": 0}
{"function": "        def _get_with_next_url(self, url, method=\"GET\", body=None, headers=None):\n            pass", "label": 1}
{"function": "def agent_logger():\n    return AgentLogger(\n        LogLevel.DEBUG, console=Console(record=True, no_color=True, force_terminal=False, file=io.StringIO())\n    )", "label": 0}
{"function": "    def is_user_validator(user_id: int) -> bool:\n        \"\"\" Determines if user is a validator \"\"\"\n        user = UserService.get_user_by_id(user_id)\n\n        if UserRole(user.role) in [\n            UserRole.ADMIN,\n        ]:\n            return True\n\n        return False", "label": 1}
{"function": "    def __init__(self):\n        self.is_running = False\n        self.animation_thread = None", "label": 0}
{"function": "    def generate(self, messages, tools_to_call_from=None, stop_sequences=None):\n        if len(messages) < 3:\n            return ChatMessage(\n                role=MessageRole.ASSISTANT,\n                content=\"\",\n                tool_calls=[\n                    ChatMessageToolCall(\n                        id=\"call_0\",\n                        type=\"function\",\n                        function=ChatMessageToolCallFunction(\n                            name=\"fake_image_understanding_tool\",\n                            arguments={\n                                \"prompt\": \"What is in this image?\",\n                                \"image\": \"image.png\",\n                            },\n                        ),\n                    )\n                ],\n            )\n        else:\n            return ChatMessage(\n                role=MessageRole.ASSISTANT,\n                content=\"\",\n                tool_calls=[\n                    ChatMessageToolCall(\n                        id=\"call_1\",\n                        type=\"function\",\n                        function=ChatMessageToolCallFunction(name=\"final_answer\", arguments=\"The image is a cat.\"),\n                    )\n                ],\n            )", "label": 0}
{"function": "def astar(matrix, targets, sources):\n    def neighbors(position):\n        (x, y) = position\n        candidates = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n        return [(x, y) for (x, y) in candidates if x >= 0 and x < len(matrix)\n                                               and y >= 0 and y < len(matrix[0])]\n\n    def evaluate(path):\n        f = sum(matrix[y][x] for (x, y) in path)\n        h = min(distance(path[-1], target) for target in targets)\n        return f + h\n\n    targets = set(targets)\n    frontier = set(sources)\n    explored = set()\n    frontier_queue = []\n    for source in sources:\n        path = [source]\n        heapq.heappush(frontier_queue, (evaluate(path), path))\n\n    while frontier:\n        (_, path) = heapq.heappop(frontier_queue)\n        frontier.remove(path[-1])\n        explored.add(path[-1])\n        if path[-1] in targets:\n            return path\n        for neighbor in neighbors(path[-1]):\n            if neighbor not in frontier | explored:\n                frontier.add(neighbor)\n                new_path = path + [neighbor]\n                heapq.heappush(frontier_queue, (evaluate(new_path), new_path))", "label": 1}
{"function": "  def testExecuteUpdateJobsSuccessOnePendingDepNoCloudStorageCollision(\n      self, uploader_cs_mock):\n    uploader_cs_mock.Exists.return_value = False\n    self.fs.CreateFile(self.file_path,\n                       contents='\\n'.join(self.expected_file_lines))\n    config = dependency_manager.BaseConfig(self.file_path, writable=True)\n    config._config_data = self.new_dependencies.copy()\n    config._pending_uploads = [self.new_pending_upload]\n    self.assertEqual(self.new_dependencies, config._config_data)\n    self.assertTrue(config._IsDirty())\n    self.assertEqual(1, len(config._pending_uploads))\n    self.assertEqual(self.new_pending_upload, config._pending_uploads[0])\n    expected_exists_calls = [mock.call(self.new_bucket, self.new_remote_path)]\n    expected_insert_calls = [mock.call(self.new_bucket, self.new_remote_path,\n                                       self.new_dep_path)]\n    expected_copy_calls = []\n    expected_delete_calls = []\n\n    self.assertTrue(config.ExecuteUpdateJobs())\n    self.assertFalse(config._IsDirty())\n    self.assertFalse(config._pending_uploads)\n    self.assertEqual(self.new_dependencies, config._config_data)\n    file_module = fake_filesystem.FakeFileOpen(self.fs)\n    expected_file_lines = list(self.new_expected_file_lines)\n    for line in file_module(self.file_path):\n      self.assertEqual(expected_file_lines.pop(0), line.strip())\n    self.fs.CloseOpenFile(file_module(self.file_path))\n    self.assertFalse(config._pending_uploads)\n    self.assertEqual(expected_insert_calls,\n                     uploader_cs_mock.Insert.call_args_list)\n    self.assertEqual(expected_exists_calls,\n                     uploader_cs_mock.Exists.call_args_list)\n    self.assertEqual(expected_copy_calls,\n                     uploader_cs_mock.Copy.call_args_list)\n    self.assertEqual(expected_delete_calls,\n                     uploader_cs_mock.Delete.call_args_list)", "label": 1}
{"function": "async def initialize_graph_storage():\n    \"\"\"\n    \u6839\u636e\u73af\u5883\u53d8\u91cf\u521d\u59cb\u5316\u76f8\u5e94\u7684\u56fe\u5b58\u50a8\u5b9e\u4f8b\n    \u8fd4\u56de\u521d\u59cb\u5316\u7684\u5b58\u50a8\u5b9e\u4f8b\n    \"\"\"\n    # \u4ece\u73af\u5883\u53d8\u91cf\u4e2d\u83b7\u53d6\u56fe\u5b58\u50a8\u7c7b\u578b\n    graph_storage_type = os.getenv(\"LIGHTRAG_GRAPH_STORAGE\", \"NetworkXStorage\")\n\n    # \u9a8c\u8bc1\u5b58\u50a8\u7c7b\u578b\u662f\u5426\u6709\u6548\n    try:\n        verify_storage_implementation(\"GRAPH_STORAGE\", graph_storage_type)\n    except ValueError as e:\n        ASCIIColors.red(f\"\u9519\u8bef: {str(e)}\")\n        ASCIIColors.yellow(\n            f\"\u652f\u6301\u7684\u56fe\u5b58\u50a8\u7c7b\u578b: {', '.join(STORAGE_IMPLEMENTATIONS['GRAPH_STORAGE']['implementations'])}\"\n        )\n        return None\n\n    # \u68c0\u67e5\u6240\u9700\u7684\u73af\u5883\u53d8\u91cf\n    required_env_vars = STORAGE_ENV_REQUIREMENTS.get(graph_storage_type, [])\n    missing_env_vars = [var for var in required_env_vars if not os.getenv(var)]\n\n    if missing_env_vars:\n        ASCIIColors.red(\n            f\"\u9519\u8bef: {graph_storage_type} \u9700\u8981\u4ee5\u4e0b\u73af\u5883\u53d8\u91cf\uff0c\u4f46\u672a\u8bbe\u7f6e: {', '.join(missing_env_vars)}\"\n        )\n        return None\n\n    # \u52a8\u6001\u5bfc\u5165\u76f8\u5e94\u7684\u6a21\u5757\n    module_path = STORAGES.get(graph_storage_type)\n    if not module_path:\n        ASCIIColors.red(f\"\u9519\u8bef: \u672a\u627e\u5230 {graph_storage_type} \u7684\u6a21\u5757\u8def\u5f84\")\n        return None\n\n    try:\n        module = importlib.import_module(module_path, package=\"lightrag\")\n        storage_class = getattr(module, graph_storage_type)\n    except (ImportError, AttributeError) as e:\n        ASCIIColors.red(f\"\u9519\u8bef: \u5bfc\u5165 {graph_storage_type} \u5931\u8d25: {str(e)}\")\n        return None\n\n    # \u521d\u59cb\u5316\u5b58\u50a8\u5b9e\u4f8b\n    global_config = {\n        \"embedding_batch_num\": 10,  # \u6279\u5904\u7406\u5927\u5c0f\n        \"vector_db_storage_cls_kwargs\": {\n            \"cosine_better_than_threshold\": 0.5  # \u4f59\u5f26\u76f8\u4f3c\u5ea6\u9608\u503c\n        },\n        \"working_dir\": os.environ.get(\"WORKING_DIR\", \"./rag_storage\"),  # \u5de5\u4f5c\u76ee\u5f55\n    }\n\n    # \u5982\u679c\u4f7f\u7528 NetworkXStorage\uff0c\u9700\u8981\u5148\u521d\u59cb\u5316 shared_storage\n    if graph_storage_type == \"NetworkXStorage\":\n        initialize_share_data()  # \u4f7f\u7528\u5355\u8fdb\u7a0b\u6a21\u5f0f\n\n    try:\n        storage = storage_class(\n            namespace=\"test_graph\",\n            global_config=global_config,\n            embedding_func=mock_embedding_func,\n        )\n\n        # \u521d\u59cb\u5316\u8fde\u63a5\n        await storage.initialize()\n        return storage\n    except Exception as e:\n        ASCIIColors.red(f\"\u9519\u8bef: \u521d\u59cb\u5316 {graph_storage_type} \u5931\u8d25: {str(e)}\")\n        return None", "label": 0}
{"function": "    def test_orientations(self):\n        pose3Graph = gtsam.InitializePose3.buildPose3graph(self.graph)\n        initial = gtsam.InitializePose3.computeOrientationsChordal(pose3Graph)\n    \n        # comparison is up to M_PI, that's why we add some multiples of 2*M_PI\n        self.gtsamAssertEquals(initial.atRot3(x0), self.R0, 1e-6)\n        self.gtsamAssertEquals(initial.atRot3(x1), self.R1, 1e-6)\n        self.gtsamAssertEquals(initial.atRot3(x2), self.R2, 1e-6)\n        self.gtsamAssertEquals(initial.atRot3(x3), self.R3, 1e-6)", "label": 1}
{"function": "def write_version_to_commons(version):\n    commons_path = os.path.join(os.path.dirname(__file__), 'mineru', 'version.py')\n    with open(commons_path, 'w') as f:\n        f.write(f'__version__ = \"{version}\"\\n')", "label": 0}
{"function": "def remove_account(account_id: str) -> None:\n    \"\"\"\n    Removes an account from the cache.\n\n    Args:\n        account_id (str): The ID of the account to remove\n\n    Returns:\n        None\n    \"\"\"\n    # Get the current accounts\n    accounts = get_accounts()\n\n    # Remove the account\n    accounts = [account for account in accounts if account['id'] != account_id]\n\n    # Write the new accounts to the cache\n    with open(get_twitter_cache_path(), 'w') as file:\n        json.dump({\n            \"accounts\": accounts\n        }, file, indent=4)", "label": 0}
{"function": "    def __init__(\n            self,\n            env,\n            inner_policy,\n            qf,\n            vf,\n            *,  # Mostly numbers after here.\n            num_train_tasks,\n            num_test_tasks=None,\n            latent_dim,\n            encoder_hidden_sizes,\n            test_env_sampler,\n            policy_class=ContextConditionedPolicy,\n            encoder_class=MLPEncoder,\n            policy_lr=3E-4,\n            qf_lr=3E-4,\n            vf_lr=3E-4,\n            context_lr=3E-4,\n            policy_mean_reg_coeff=1E-3,\n            policy_std_reg_coeff=1E-3,\n            policy_pre_activation_coeff=0.,\n            soft_target_tau=0.005,\n            kl_lambda=.1,\n            optimizer_class=torch.optim.Adam,\n            use_information_bottleneck=True,\n            use_next_obs_in_context=False,\n            meta_batch_size=64,\n            num_steps_per_epoch=1000,\n            num_initial_steps=100,\n            num_tasks_sample=100,\n            num_steps_prior=100,\n            num_steps_posterior=0,\n            num_extra_rl_steps_posterior=100,\n            batch_size=1024,\n            embedding_batch_size=1024,\n            embedding_mini_batch_size=1024,\n            discount=0.99,\n            replay_buffer_size=1000000,\n            reward_scale=1,\n            update_post_train=1):\n\n        self._env = env\n        self._qf1 = qf\n        self._qf2 = copy.deepcopy(qf)\n        self._vf = vf\n        self._num_train_tasks = num_train_tasks\n        self._latent_dim = latent_dim\n\n        self._policy_mean_reg_coeff = policy_mean_reg_coeff\n        self._policy_std_reg_coeff = policy_std_reg_coeff\n        self._policy_pre_activation_coeff = policy_pre_activation_coeff\n        self._soft_target_tau = soft_target_tau\n        self._kl_lambda = kl_lambda\n        self._use_information_bottleneck = use_information_bottleneck\n        self._use_next_obs_in_context = use_next_obs_in_context\n\n        self._meta_batch_size = meta_batch_size\n        self._num_steps_per_epoch = num_steps_per_epoch\n        self._num_initial_steps = num_initial_steps\n        self._num_tasks_sample = num_tasks_sample\n        self._num_steps_prior = num_steps_prior\n        self._num_steps_posterior = num_steps_posterior\n        self._num_extra_rl_steps_posterior = num_extra_rl_steps_posterior\n        self._batch_size = batch_size\n        self._embedding_batch_size = embedding_batch_size\n        self._embedding_mini_batch_size = embedding_mini_batch_size\n        self._discount = discount\n        self._replay_buffer_size = replay_buffer_size\n        self._reward_scale = reward_scale\n        self._update_post_train = update_post_train\n        self._task_idx = None\n        self._single_env = env[0]()\n        self.max_episode_length = self._single_env.spec.max_episode_length\n\n        self._is_resuming = False\n\n        if num_test_tasks is None:\n            num_test_tasks = test_env_sampler.n_tasks\n        if num_test_tasks is None:\n            raise ValueError('num_test_tasks must be provided if '\n                             'test_env_sampler.n_tasks is None')\n\n        worker_args = dict(deterministic=True, accum_context=True)\n        self._evaluator = MetaEvaluator(test_task_sampler=test_env_sampler,\n                                        worker_class=PEARLWorker,\n                                        worker_args=worker_args,\n                                        n_test_tasks=num_test_tasks)\n\n        encoder_spec = self.get_env_spec(self._single_env, latent_dim,\n                                         'encoder')\n        encoder_in_dim = int(np.prod(encoder_spec.input_space.shape))\n        encoder_out_dim = int(np.prod(encoder_spec.output_space.shape))\n        context_encoder = encoder_class(input_dim=encoder_in_dim,\n                                        output_dim=encoder_out_dim,\n                                        hidden_sizes=encoder_hidden_sizes)\n\n        self._policy = policy_class(\n            latent_dim=latent_dim,\n            context_encoder=context_encoder,\n            policy=inner_policy,\n            use_information_bottleneck=use_information_bottleneck,\n            use_next_obs=use_next_obs_in_context)\n\n        # buffer for training RL update\n        self._replay_buffers = {\n            i: PathBuffer(replay_buffer_size)\n            for i in range(num_train_tasks)\n        }\n\n        self._context_replay_buffers = {\n            i: PathBuffer(replay_buffer_size)\n            for i in range(num_train_tasks)\n        }\n\n        self.target_vf = copy.deepcopy(self._vf)\n        self.vf_criterion = torch.nn.MSELoss()\n\n        self._policy_optimizer = optimizer_class(\n            self._policy.networks[1].parameters(),\n            lr=policy_lr,\n        )\n        self.qf1_optimizer = optimizer_class(\n            self._qf1.parameters(),\n            lr=qf_lr,\n        )\n        self.qf2_optimizer = optimizer_class(\n            self._qf2.parameters(),\n            lr=qf_lr,\n        )\n        self.vf_optimizer = optimizer_class(\n            self._vf.parameters(),\n            lr=vf_lr,\n        )\n        self.context_optimizer = optimizer_class(\n            self._policy.networks[0].parameters(),\n            lr=context_lr,\n        )", "label": 1}
{"function": "    def handle(self, **options):\n        everyone = Group.objects.get(name='everyone')\n        anonymous = User.objects.get(pk=settings.ANONYMOUS_USER_ID)\n\n        for x in Activity.objects.all():\n            if not x.admin_only:\n                assign_perm('newsfeed.read_activity', anonymous, x)\n                assign_perm('newsfeed.read_activity', everyone, x)", "label": 1}
{"function": "def save_img(res, imgid, divide=False):\n    output = res.detach().cpu().numpy() # d * d, 3, width, width    \n    output = np.transpose(output, (0, 2, 3, 1))\n    if divide:\n        output = small2large(output)\n        output = smooth(output)\n    else:\n        output = output[0]\n    output = (output * 255).astype('uint8')\n    output = cv2.resize(output, origin_shape)\n    cv2.imwrite('output/generated' + str(imgid) + '.png', output)", "label": 1}
{"function": "def disable_real_model_clients(monkeypatch, request):\n    # If the test is marked to allow the method call, don't override it.\n    if request.node.get_closest_marker(\"allow_call_model_methods\"):\n        return\n\n    def failing_version(*args, **kwargs):\n        pytest.fail(\"Real models should not be used in tests!\")\n\n    monkeypatch.setattr(OpenAIResponsesModel, \"get_response\", failing_version)\n    monkeypatch.setattr(OpenAIResponsesModel, \"stream_response\", failing_version)\n    monkeypatch.setattr(OpenAIChatCompletionsModel, \"get_response\", failing_version)\n    monkeypatch.setattr(OpenAIChatCompletionsModel, \"stream_response\", failing_version)", "label": 0}
{"function": "    def load(cls, fpath, map_location=\"cpu\"):\n        if isinstance(map_location, str):\n            map_location = torch.device(map_location)\n        kwargs = torch.load(fpath, map_location=map_location, weights_only=True)\n        return cls(T3Cond(**kwargs['t3']), kwargs['gen'])", "label": 0}
{"function": "    def __init__(self, ai_game):\n        \"\"\"Initialize the alien and set its starting position.\"\"\"\n        super().__init__()\n        self.screen = ai_game.screen\n        self.settings = ai_game.settings\n\n        # Load the alien image and set its rect attribute.\n        self.image = pygame.image.load('images/alien.bmp')\n        self.rect = self.image.get_rect()\n\n        # Start each new alien near the top left of the screen.\n        self.rect.x = self.rect.width\n        self.rect.y = self.rect.height\n\n        # Store the alien's exact horizontal position.\n        self.x = float(self.rect.x)", "label": 1}
{"function": "def setup_logging():\n    # Create a logger\n    logger = logging.getLogger()\n    logger.setLevel(logging.INFO)  # Set the logging level to INFO\n\n    # Create console handler and set level to INFO\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setLevel(logging.INFO)\n\n    # Create formatter\n    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n\n    # Add formatter to console handler\n    console_handler.setFormatter(formatter)\n\n    # Add console handler to logger\n    logger.addHandler(console_handler)\n\n    return logger", "label": 0}
{"function": "def collate_fn(x: list['DataProtoItem']):\n    batch = []\n    non_tensor_batch = []\n    for data in x:\n        batch.append(data.batch)\n        non_tensor_batch.append(data.non_tensor_batch)\n    batch = torch.stack(batch).contiguous()\n    non_tensor_batch = list_of_dict_to_dict_of_list(non_tensor_batch)\n    for key, val in non_tensor_batch.items():\n        non_tensor_batch[key] = np.array(val, dtype=object)\n    return DataProto(batch=batch, non_tensor_batch=non_tensor_batch)", "label": 0}
{"function": "    def __init__(self, argv=sys.argv[1:]):\n        args = self.args = []\n        for aa in argv:\n            args.append(arg(len(args) + 1, aa))", "label": 1}
{"function": "    def __eq__(self, other):\n        if type(other) != type(self):\n            return False\n        return (self.display_name == other.display_name and\n                self.addresses == other.addresses)", "label": 1}
{"function": "  def test_jit_code_symbols_regex(self):\n    jit_code_symbols = [\n      \"LazyCompile:~Foo blah.js\",\n      \"Eval:*\",\n      \"Script:*Bar tmp.js\",\n    ]\n    for jit_code_symbol in jit_code_symbols:\n      self.assertTrue(ipr.JIT_CODE_SYMBOLS_RE.match(jit_code_symbol))", "label": 1}
{"function": "def is_valid_closer(string):\n    \"\"\"\n    Returns True if every opener has a valid closer\n    \"\"\"\n    openers = ['[', '(', '{']\n    closers = [']', ')', '}']\n    stack = []\n\n    for ch in string:\n        # If there is a closer, but no openers\n        if not stack and ch in closers:\n            return False\n\n        # Add any opener into the stack\n        elif ch in openers:\n            stack.append(ch)\n\n        # If the following closers do not pair with the opener popped from stack\n        # then the function will return False\n        elif ch == ']':\n            if stack.pop() != '[':\n                return False\n\n        elif ch == ')':\n            if stack.pop() != '(':\n                return False\n\n        elif ch == '}':\n            if stack.pop() != '{':\n                return False\n\n    # Nothing in our stack == True\n    return not stack", "label": 1}
{"function": "    def describe(self):\n        return self.deep_extend(super(okcoinusd, self).describe(), {\n            'id': 'okcoinusd',\n            'name': 'OKCoin USD',\n            'countries': ['CN', 'US'],\n            'version': 'v1',\n            'rateLimit': 1000,  # up to 3000 requests per 5 minutes \u2248 600 requests per minute \u2248 10 requests per second \u2248 100 ms\n            'has': {\n                'CORS': False,\n                'fetchOHLCV': True,\n                'fetchOrder': True,\n                'fetchOrders': False,\n                'fetchOpenOrders': True,\n                'fetchClosedOrders': True,\n                'withdraw': True,\n                'futures': False,\n            },\n            'extension': '.do',  # appended to endpoint URL\n            'timeframes': {\n                '1m': '1min',\n                '3m': '3min',\n                '5m': '5min',\n                '15m': '15min',\n                '30m': '30min',\n                '1h': '1hour',\n                '2h': '2hour',\n                '4h': '4hour',\n                '6h': '6hour',\n                '12h': '12hour',\n                '1d': '1day',\n                '3d': '3day',\n                '1w': '1week',\n            },\n            'api': {\n                'web': {\n                    'get': [\n                        'spot/markets/currencies',\n                        'spot/markets/products',\n                    ],\n                },\n                'public': {\n                    'get': [\n                        'depth',\n                        'exchange_rate',\n                        'future_depth',\n                        'future_estimated_price',\n                        'future_hold_amount',\n                        'future_index',\n                        'future_kline',\n                        'future_price_limit',\n                        'future_ticker',\n                        'future_trades',\n                        'kline',\n                        'otcs',\n                        'ticker',\n                        'tickers',\n                        'trades',\n                    ],\n                },\n                'private': {\n                    'post': [\n                        'account_records',\n                        'batch_trade',\n                        'borrow_money',\n                        'borrow_order_info',\n                        'borrows_info',\n                        'cancel_borrow',\n                        'cancel_order',\n                        'cancel_otc_order',\n                        'cancel_withdraw',\n                        'funds_transfer',\n                        'future_batch_trade',\n                        'future_cancel',\n                        'future_devolve',\n                        'future_explosive',\n                        'future_order_info',\n                        'future_orders_info',\n                        'future_position',\n                        'future_position_4fix',\n                        'future_trade',\n                        'future_trades_history',\n                        'future_userinfo',\n                        'future_userinfo_4fix',\n                        'lend_depth',\n                        'order_fee',\n                        'order_history',\n                        'order_info',\n                        'orders_info',\n                        'otc_order_history',\n                        'otc_order_info',\n                        'repayment',\n                        'submit_otc_order',\n                        'trade',\n                        'trade_history',\n                        'trade_otc_order',\n                        'wallet_info',\n                        'withdraw',\n                        'withdraw_info',\n                        'unrepayments_info',\n                        'userinfo',\n                    ],\n                },\n            },\n            'urls': {\n                'logo': 'https://user-images.githubusercontent.com/1294454/27766791-89ffb502-5ee5-11e7-8a5b-c5950b68ac65.jpg',\n                'api': {\n                    'web': 'https://www.okcoin.com/v2',\n                    'public': 'https://www.okcoin.com/api',\n                    'private': 'https://www.okcoin.com/api',\n                },\n                'www': 'https://www.okcoin.com',\n                'doc': [\n                    'https://www.okcoin.com/rest_getStarted.html',\n                    'https://www.npmjs.com/package/okcoin.com',\n                ],\n            },\n            'fees': {\n                'trading': {\n                    'taker': 0.002,\n                    'maker': 0.002,\n                },\n            },\n            'exceptions': {\n                '1009': OrderNotFound,  # for spot markets, cancelling closed order\n                '1051': OrderNotFound,  # for spot markets, cancelling \"just closed\" order\n                '1019': OrderNotFound,  # order closed?\n                '20015': OrderNotFound,  # for future markets\n                '1013': InvalidOrder,  # no contract type(PR-1101)\n                '1027': InvalidOrder,  # createLimitBuyOrder(symbol, 0, 0): Incorrect parameter may exceeded limits\n                '1002': InsufficientFunds,  # \"The transaction amount exceed the balance\"\n                '1050': InvalidOrder,  # returned when trying to cancel an order that was filled or canceled previously\n                '10000': ExchangeError,  # createLimitBuyOrder(symbol, None, None)\n                '10005': AuthenticationError,  # bad apiKey\n                '10008': ExchangeError,  # Illegal URL parameter\n            },\n            'options': {\n                'warnOnFetchOHLCVLimitArgument': True,\n                'fiats': ['USD', 'CNY'],\n                'futures': {\n                    'BCH': True,\n                    'BTC': True,\n                    'BTG': True,\n                    'EOS': True,\n                    'ETC': True,\n                    'ETH': True,\n                    'LTC': True,\n                    'NEO': True,\n                    'QTUM': True,\n                    'USDT': True,\n                    'XUC': True,\n                },\n            },\n        })", "label": 1}
{"function": "def revert_audio_delay(\n    audio_BxTxC: torch.Tensor,\n    pad_value: int,\n    precomp: tp.Tuple[torch.Tensor, torch.Tensor],\n    T: int,\n) -> torch.Tensor:\n    \"\"\"\n    Reverts a delay pattern from batched audio tokens using precomputed indices (PyTorch version).\n\n    Args:\n        audio_BxTxC: Input delayed audio tensor\n        pad_value: Padding value for out-of-bounds indices\n        precomp: Precomputed revert indices tuple containing:\n            - t_idx_BxTxC: Time offset indices tensor\n            - indices_BTCx3: Gather indices tensor for original audio\n        T: Original sequence length before padding\n\n    Returns:\n        Reverted audio tensor with same shape as input\n    \"\"\"\n    t_idx_BxTxC, indices_BTCx3 = precomp\n    device = audio_BxTxC.device  # Get device from input tensor\n\n    # Move precomputed indices to the same device as audio_BxTxC if they aren't already\n    t_idx_BxTxC = t_idx_BxTxC.to(device)\n    indices_BTCx3 = indices_BTCx3.to(device)\n\n    # Using PyTorch advanced indexing (equivalent to tf.gather_nd or np equivalent)\n    gathered_flat = audio_BxTxC[indices_BTCx3[:, 0], indices_BTCx3[:, 1], indices_BTCx3[:, 2]]\n    gathered_BxTxC = gathered_flat.view(audio_BxTxC.size())  # Use .size() for robust reshaping\n\n    # Create pad_tensor on the correct device\n    pad_tensor = torch.tensor(pad_value, dtype=audio_BxTxC.dtype, device=device)\n    # Create T tensor on the correct device for comparison\n    T_tensor = torch.tensor(T, device=device)\n\n    result_BxTxC = torch.where(t_idx_BxTxC >= T_tensor, pad_tensor, gathered_BxTxC)  # Changed np.where to torch.where\n\n    return result_BxTxC", "label": 0}
{"function": "def test():\n    data_raw = {\n        \"kb_ids\": [\n           \"KBf46828db208c4289a120a34f0fc96147\",\n           \"KBc2440f13e98f4736b5ef81cfaebef3a9\",\n           \"KBb78af28c73f74fb4ae6ad44b3c53302f\",\n           \"KB6c2b097d83be430ab809e361fa8dcc8b\",\n           \"KB69331d593f5b4b5bb555a0ea1b145e5b\",\n           \"KB3cdc79f8c8d24a14bffd27e6570c33da\"\n        ],\n        \"question\": \"\u897f\u5357\u4ea4\u901a\u5927\u5b66\u662f211\u9662\u6821\u5417\",\n        \"user_id\": \"liujx_265\",\n        \"rerank\": True,\n        \"history\": []\n    }\n    print(type(no_stream_requests))\n    no_stream_requests(data_raw) ", "label": 0}
{"function": "    def get_root(self):\n        # Return first element if it exists else inf (MaxHeap) or -inf (MinHeap)\n        if self.size > 0:\n            return self.array[1]\n        else:\n            return self.array[0]", "label": 1}
{"function": "    def invertImage(self):\n        \"\"\" Sets whether the amount of ink applied to the canvas is to be\n            inverted (subtracted from the maximum value) before the ink is\n            applied.\n        \"\"\"\n        self.inverted = not self.inverted\n        self.createImage()\n        self.imageChanged.emit()", "label": 1}
{"function": "    def calculate_portfolio_value(self, current_prices):\n        \"\"\"\n        Calculate total portfolio value, including:\n          - cash\n          - market value of long positions\n          - unrealized gains/losses for short positions\n        \"\"\"\n        total_value = self.portfolio[\"cash\"]\n\n        for ticker in self.tickers:\n            position = self.portfolio[\"positions\"][ticker]\n            price = current_prices[ticker]\n\n            # Long position value\n            long_value = position[\"long\"] * price\n            total_value += long_value\n\n            # Short position unrealized PnL = short_shares * (short_cost_basis - current_price)\n            if position[\"short\"] > 0:\n                total_value -= position[\"short\"] * price\n\n        return total_value", "label": 0}
{"function": "    def get(self, key: str, default: Any = None) -> Any:\n        \"\"\"Get the value associated with the given key. If the key does not exist, return the default value.\n\n        Args:\n            key (str): The attribute name to retrieve.\n            default (Any, optional): The value to return if the attribute does not exist. Defaults to None.\n\n        Returns:\n            Any: The value of the attribute or the default value.\n        \"\"\"\n        try:\n            return getattr(self, key)\n        except AttributeError:\n            return default", "label": 0}
{"function": "def main(args):\n    all_task = [executor.submit(single_job, utt) for utt in utt2wav.keys()]\n    utt2embedding, spk2embedding = {}, {}\n    for future in tqdm(as_completed(all_task)):\n        utt, embedding = future.result()\n        utt2embedding[utt] = embedding\n        spk = utt2spk[utt]\n        if spk not in spk2embedding:\n            spk2embedding[spk] = []\n        spk2embedding[spk].append(embedding)\n    for k, v in spk2embedding.items():\n        spk2embedding[k] = torch.tensor(v).mean(dim=0).tolist()\n    torch.save(utt2embedding, \"{}/utt2embedding.pt\".format(args.dir))\n    torch.save(spk2embedding, \"{}/spk2embedding.pt\".format(args.dir))", "label": 0}
{"function": "        def on_update(cache_control):\n            if not cache_control and 'cache-control' in self.headers:\n                del self.headers['cache-control']\n            elif cache_control:\n                self.headers['Cache-Control'] = cache_control.to_header()", "label": 1}
{"function": "    def __iter__(self):\n        \"\"\"Implement the iterator protocol. Allows iterating over the attribute names of the instance.\n\n        Yields:\n            str: The name of each field in the dataclass.\n        \"\"\"\n        for f in fields(self):\n            yield f.name", "label": 0}
{"function": "    def test_from_array_event_value_wrong_3(surv_arrays):\n        event, time = surv_arrays\n        event[event == 0] = 3\n\n        with pytest.raises(ValueError,\n                           match=\"non-boolean event indicator must contain 0 and 1 only\"):\n            Surv.from_arrays(event, time)", "label": 1}
{"function": "    def test_repo_clearfilters_noargs(self, shell):\n        \"\"\"\n        Test do_repo_clearfilters with no arguments.\n\n        :param shell:\n        :return:\n        \"\"\"\n        shell.help_repo_clearfilters = MagicMock()\n        shell.client.channel.software.clearRepoFilters = MagicMock()\n        mprint = MagicMock()\n        logger = MagicMock()\n\n        with patch(\"spacecmd.repo.print\", mprint) as prn, \\\n                patch(\"spacecmd.repo.logging\", logger) as lgr:\n            out = spacecmd.repo.do_repo_clearfilters(shell, \"\")\n\n        assert out is 1\n        assert not mprint.called\n        assert not logger.error.called\n        assert not shell.client.channel.software.clearRepoFilters.called\n        assert shell.help_repo_clearfilters.called", "label": 1}
{"function": "    def get(self):\n        \"\"\"Get the first matching document from firestore\n\n        Get first matching document and convert it into model and return it\n        This is same as `fetch(limit=1)` the only difference is `get()` method\n        return **model instance** and the `fetch()` method return the **generator**\n        \"\"\"\n        self.n_limit = 1\n        doc = next(self.query().stream(self.query_transaction), None)\n        if doc:\n            m = query_wrapper.ModelWrapper.from_query_result(self.model, doc)\n            m._update_doc = self._update_doc_key(m)\n            return m\n        return None", "label": 1}
{"function": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)", "label": 1}
{"function": "    def get_map(self) -> Mapping[_FileObject, SelectorKey]: ...", "label": 1}
{"function": "def generate_test_report(test_results, duration):\n    total_tests = sum(item[\"count\"] for item in test_results)\n    total_passed = sum(item[\"passed\"] for item in test_results)\n    total_failed = sum(item[\"failed\"] for item in test_results)\n    total_errors = sum(item[\"errors\"] for item in test_results)\n    summary = f\"\"\"\nTEST EXECUTION REPORT\n=====================\nDate: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\nSummary:\n- Duration: {duration}\n- Total Tests: {total_tests}\n- Passed: {total_passed} ({total_passed / total_tests * 100:.1f}%)\n- Failed: {total_failed} ({total_failed / total_tests * 100:.1f}%)\n- Errors: {total_errors} ({total_errors / total_tests * 100:.1f}%)\n\"\"\"\n    # Create rows for tabulate\n    table_data = []\n    for result in test_results:\n        if result[\"errors\"] > 0:\n            status = \"\ud83d\udca5\"  # Error symbol\n        elif result[\"failed\"] > 0:\n            status = \"\u274c\"  # Failed symbol\n        else:\n            status = \"\u2705\"  # Passed symbol\n            \n        table_data.append([\n            result[\"module\"],\n            result[\"count\"],\n            result[\"passed\"],\n            result[\"failed\"],\n            result[\"errors\"],\n            status\n        ])\n    headers = [\"Test Module\", \"Tests\", \"Passed\", \"Failed\", \"Errors\", \"Status\"]\n    table = tabulate(table_data, headers=headers, tablefmt=\"fancy_grid\", \n                    colalign=(\"left\", \"right\", \"right\", \"right\", \"right\", \"center\"))\n    report = summary + \"\\nDetailed Test Results:\\n\" + table\n    \n    if total_failed > 0 or total_errors > 0:\n        problematic_tests = [r for r in test_results if r[\"failed\"] > 0 or r[\"errors\"] > 0]\n        report += \"\\n\\nProblematic Tests:\\n\"\n        for test in problematic_tests:\n            issues = []\n            if test[\"failed\"] > 0:\n                issues.append(f\"{test['failed']} failed\")\n            if test[\"errors\"] > 0:\n                issues.append(f\"{test['errors']} errors\")\n            report += f\"- {test['module']}: {', '.join(issues)}\\n\"\n        report += f\"{'-'*50}\\n\"\n        report += \"  (Investigation needed - check test logs for specific issues)\\n\"\n        report += f\"{'-'*50}\"\n    return report", "label": 0}
{"function": "def SimpleLine(c1=[0.0, 0.0, 0.0], c2=[2.0, 2.0, 2.0]):\n    newpoints = []\n\n    c3 = Vector(c2) - Vector(c1)\n    newpoints.append([0.0, 0.0, 0.0])\n    newpoints.append([c3[0], c3[1], c3[2]])\n\n    return newpoints", "label": 1}
{"function": "def web_demo():\n    \"\"\"Launch Web UI for interactive testing with fine-tuned model.\"\"\"\n    from weclone.eval.web_demo import main as web_demo_main\n\n    web_demo_main()", "label": 0}
{"function": "def load_tensors(shaped_arrays, directory, mesh_config, tensor_indices=None):\n    \"\"\"Loads a set of arrays.\"\"\"\n    pool = ThreadPoolExecutor(max_workers=32)\n    fs = list()\n    num_tensors = 0\n    num_replicas = 1\n    data_model_shards = math.prod(mesh_config)\n    if tensor_indices is None:\n        iterator = enumerate(shaped_arrays)\n    else:\n        iterator = zip(tensor_indices, shaped_arrays)\n    for i, t in iterator:\n        if (i % num_replicas) == ((jax.process_index() // data_model_shards) % num_replicas):\n            idx = (\n                jax.process_index() // (num_replicas * data_model_shards) * data_model_shards\n                + jax.process_index() % data_model_shards\n            )\n            fs.append(\n                pool.submit(fast_unpickle, os.path.join(directory, f\"tensor{i:05d}_{idx:03d}\"))\n            )\n            num_tensors += 1\n        else:\n            fs.append(pool.submit(np.zeros, t.shape, dtype=t.dtype))\n    wait(fs)\n    return [f.result() for f in fs]", "label": 0}
{"function": "def process_text():\n    with st.spinner(t(\"Using Whisper for transcription...\")):\n        _2_asr.transcribe()\n    with st.spinner(t(\"Splitting long sentences...\")):  \n        _3_1_split_nlp.split_by_spacy()\n        _3_2_split_meaning.split_sentences_by_meaning()\n    with st.spinner(t(\"Summarizing and translating...\")):\n        _4_1_summarize.get_summary()\n        if load_key(\"pause_before_translate\"):\n            input(t(\"\u26a0\ufe0f PAUSE_BEFORE_TRANSLATE. Go to `output/log/terminology.json` to edit terminology. Then press ENTER to continue...\"))\n        _4_2_translate.translate_all()\n    with st.spinner(t(\"Processing and aligning subtitles...\")): \n        _5_split_sub.split_for_sub_main()\n        _6_gen_sub.align_timestamp_main()\n    with st.spinner(t(\"Merging subtitles to video...\")):\n        _7_sub_into_vid.merge_subtitles_to_video()\n    \n    st.success(t(\"Subtitle processing complete! \ud83c\udf89\"))\n    st.balloons()", "label": 0}
{"function": "    def as_cmd(self, func):\n        return c.Function(c.NSName(self.name))", "label": 1}
{"function": "    def test_single(self):\n        self.l1.flush()\n\n        # Send a datagram...\n        dg = Datagram.create([1234], 4321, 1337)\n        dg.add_string('HELLO')\n        self.c1.send(dg)\n\n        # Make sure the MD passes it upward.\n        self.expect(self.l1, dg)", "label": 1}
{"function": "    def __init__(self, use_cuda=False, num_iterations=p.NUM_ROUTING_ITERATIONS):\n        super(CapsuleNet, self).__init__()\n        self.use_cuda = use_cuda\n        self.encoder = nn.Sequential(\n            View(dim=(-1, 2, 129, 21)),\n            # conv layer\n            nn.Conv2d(in_channels=2, out_channels=256, kernel_size=(21, 3), stride=(2, 1)),\n            Swish(),\n            # primary capsule\n            CapsuleLayer(num_capsules=8, num_route_nodes=-1, in_channels=256, out_channels=16,\n                         kernel_size=(21, 3), stride=(4, 2), num_iterations=num_iterations),\n            # class capsule\n            CapsuleLayer(num_capsules=p.NUM_LABELS, num_route_nodes=16 * 9 * 9, in_channels=8,\n                         out_channels=16, num_iterations=num_iterations)\n        )\n        self.decoder = nn.Sequential(\n            nn.Linear(16 * p.NUM_LABELS, 1024),\n            Swish(),\n            nn.Linear(1024, 4096),\n            Swish(),\n            nn.Linear(4096, 5418),\n            nn.Sigmoid()\n        )", "label": 1}
{"function": "def main():\n  if len(sys.argv) < 2:\n    print(\"Usage: python3 format.py <directory_or_file> e.g. python3 format.py ./exo\")\n    sys.exit(1)\n\n  target = sys.argv[1]\n  run_yapf(target)\n  print(\"Formatting completed.\")", "label": 0}
{"function": "    def forward(self, x, y, y_hat, x_hat):\n        left = F.relu(0.9 - y_hat, inplace=True) ** 2\n        right = F.relu(y_hat - 0.1, inplace=True) ** 2\n\n        margin_loss = y * left + 0.5 * (1. - y) * right\n        margin_loss = margin_loss.sum()\n\n        assert torch.numel(x) == torch.numel(x_hat)\n        x = x.view(x_hat.size()[0], -1)\n        reconstruction_loss = self.reconstruction_loss(x_hat, x)\n\n        return (margin_loss + 0.0005 * reconstruction_loss) / x.size(0)", "label": 1}
{"function": "    def forward(self, x):\n        hx = x\n        xout = self.relu_s1(self.bn_s1(self.conv_s1(hx)))\n\n        return xout", "label": 0}
{"function": "    def createImage(self):\n        \"\"\" Creates a new image by separating out the cyan, magenta, or yellow\n            component, depending on the mask color specified in the constructor.\n            The amount of the component found in each pixel of the image is used\n            to determine how much of a user-selected ink is used for each pixel\n            in the new image for the label widget.\n        \"\"\"\n        self.newImage = newImage = self.originalImage.copy()\n\n        # Create CMY components for the ink being used.\n        cyanInk = float(255 - QColor(self.paintColor).red()) / 255.0\n        magentaInk = float(255 - QColor(self.paintColor).green()) / 255.0\n        yellowInk = float(255 - QColor(self.paintColor).blue()) / 255.0\n\n        convert = self.convertMap[self.maskColor]\n\n        for y in range(newImage.height()):\n            for x in range(newImage.width()):\n                p = self.originalImage.pixel(x, y)\n\n                # Separate the source pixel into its cyan component.\n                if self.inverted:\n                    amount = convert(p)\n                else:\n                    amount = 255 - convert(p)\n\n                newColor = QColor(\n                    255 - min(int(amount * cyanInk), 255),\n                    255 - min(int(amount * magentaInk), 255),\n                    255 - min(int(amount * yellowInk), 255))\n\n                newImage.setPixel(x, y, newColor.rgb())\n\n        self.imageLabel.setPixmap(QPixmap.fromImage(newImage))", "label": 1}
{"function": "    def valDbID(self, obj):\n        \"\"\"Function to add DbID\n\n        :param obj: element to add DbID\n        \"\"\"\n        values = []\n        for i in self.parModis:\n            values.append(i.retDbID())\n        for i in set(values):\n            dbid = self.ElementTree.SubElement(obj, 'DbID')\n            dbid.text = i", "label": 1}
{"function": "def _upsample_like(src, tar):\n    src = F.interpolate(src, size=tar.shape[2:], mode=\"bilinear\")\n    return src", "label": 0}
{"function": "def main():\n    other.call_me_back1(call_this)\n    print('TEST SUCEEDED!')", "label": 1}
{"function": "def shared_tmp_dir(tmp_path_factory):\n    return tmp_path_factory.mktemp(\"pytest_tmp\")", "label": 0}
{"function": "    def digest(self):\n        return oracle10.encrypt(self._data[:64], user=self._user).decode('hex')", "label": 1}
{"function": "    def stop(self):\n        self.is_running = False\n        if self.animation_thread:\n            self.animation_thread.join()\n        print(\"\\r\" + \" \" * 70 + \"\\r\", end=\"\", flush=True)", "label": 0}
{"function": "def decode_png_handler(converter: TensorFlowConverter, tf_op: \"tf.Operation\"):\n    raise NotImplementedError(f\"[TensorFlowConverter] {tf_op.type} is not supported yet.\")", "label": 1}
{"function": "    def system_multicall(self, call_list):\n        \"\"\"system.multicall([{'methodName': 'add', 'params': [2, 2]}, ...]) => \\\n[[4], ...]\n\n        Allows the caller to package multiple XML-RPC calls into a single\n        request.\n\n        See http://www.xmlrpc.com/discuss/msgReader$1208\n        \"\"\"\n\n        results = []\n        for call in call_list:\n            method_name = call['methodName']\n            params = call['params']\n\n            try:\n                # XXX A marshalling error in any response will fail the entire\n                # multicall. If someone cares they should fix this.\n                results.append([self._dispatch(method_name, params)])\n            except Fault as fault:\n                results.append(\n                    {'faultCode' : fault.faultCode,\n                     'faultString' : fault.faultString}\n                    )\n            except:\n                exc_type, exc_value, exc_tb = sys.exc_info()\n                results.append(\n                    {'faultCode' : 1,\n                     'faultString' : \"%s:%s\" % (exc_type, exc_value)}\n                    )\n        return results", "label": 1}
{"function": "def test_available_env_task(env_name: str, task_name: list):\n    \"\"\"\n    This test verifies that all environments listed in `lerobot/__init__.py` can\n    be successfully imported \u2014 if they're installed \u2014 and that their\n    `available_tasks_per_env` are valid.\n    \"\"\"\n    package_name = f\"gym_{env_name}\"\n    importlib.import_module(package_name)\n    gym_handle = f\"{package_name}/{task_name}\"\n    assert gym_handle in gym.envs.registry, gym_handle", "label": 0}
{"function": "    def test_cache_with_sorted_params(self):\n        \"\"\"Test that cache works correctly with sorted parameters\"\"\"\n        params1 = {\"b\": [{\"y\": 1, \"x\": 2}], \"a\": 3}\n        params2 = {\"a\": 3, \"b\": [{\"x\": 2, \"y\": 1}]}\n\n        # Both caches should work with the same key\n        cache1 = cache.TranslationCache(\"test_engine\", params1)\n        cache1.set(\"hello\", \"\u4f60\u597d\")\n\n        cache2 = cache.TranslationCache(\"test_engine\", params2)\n        self.assertEqual(cache2.get(\"hello\"), \"\u4f60\u597d\")", "label": 0}
{"function": "def pytest_generate_tests(metafunc: Metafunc):\n  \"\"\"Generate test cases for each environment setup.\"\"\"\n  if env_variables.__name__ in metafunc.fixturenames:\n    if not _is_explicitly_marked(env_variables.__name__, metafunc):\n      metafunc.parametrize(\n          env_variables.__name__, ENV_SETUPS.keys(), indirect=True\n      )", "label": 0}
{"function": "    def is_sentinel(self):\n        return len(self.metapartitions) == 1 and self.label is None", "label": 1}
{"function": "    def get_coding_state_machine(self):\n        return self._mModel['name']", "label": 1}
{"function": "def validate_strings(result, expected_strings, exclude_strings=None):\n    \"\"\"Validate presence or absence of specific strings.\"\"\"\n    text_content = result.text_content.replace(\"\\\\\", \"\")\n    for string in expected_strings:\n        assert string in text_content\n    if exclude_strings:\n        for string in exclude_strings:\n            assert string not in text_content", "label": 0}
{"function": "def is_docstring(t):\n    return t.type == token.STRING and t.string.startswith('\"\"\"') and t.line.strip().startswith('\"\"\"')", "label": 0}
{"function": "    def read(self):\n        if 'new' in self.data and self.data['new']:\n            self._api.read_message(self.data['name'])\n            self.data['new'] = False\n        self.get_style_context().add_class('read')\n        self._g('unread').props.visible = False", "label": 1}
{"function": "def demo_fn(args):\n    # Print configuration\n    print(\"Arguments:\", vars(args))\n\n    # Set seed for reproducibility\n    np.random.seed(args.seed)\n    torch.manual_seed(args.seed)\n    random.seed(args.seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed(args.seed)\n        torch.cuda.manual_seed_all(args.seed)  # for multi-GPU\n    print(f\"Setting seed as: {args.seed}\")\n\n    # Set device and dtype\n    dtype = torch.bfloat16 if torch.cuda.get_device_capability()[0] >= 8 else torch.float16\n    device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n    print(f\"Using device: {device}\")\n    print(f\"Using dtype: {dtype}\")\n\n    # Run VGGT for camera and depth estimation\n    model = VGGT()\n    _URL = \"https://huggingface.co/facebook/VGGT-1B/resolve/main/model.pt\"\n    model.load_state_dict(torch.hub.load_state_dict_from_url(_URL))\n    model.eval()\n    model = model.to(device)\n    print(f\"Model loaded\")\n\n    # Get image paths and preprocess them\n    image_dir = os.path.join(args.scene_dir, \"images\")\n    image_path_list = glob.glob(os.path.join(image_dir, \"*\"))\n    if len(image_path_list) == 0:\n        raise ValueError(f\"No images found in {image_dir}\")\n    base_image_path_list = [os.path.basename(path) for path in image_path_list]\n\n    # Load images and original coordinates\n    # Load Image in 1024, while running VGGT with 518\n    vggt_fixed_resolution = 518\n    img_load_resolution = 1024\n\n    images, original_coords = load_and_preprocess_images_square(image_path_list, img_load_resolution)\n    images = images.to(device)\n    original_coords = original_coords.to(device)\n    print(f\"Loaded {len(images)} images from {image_dir}\")\n\n    # Run VGGT to estimate camera and depth\n    # Run with 518x518 images\n    extrinsic, intrinsic, depth_map, depth_conf = run_VGGT(model, images, dtype, vggt_fixed_resolution)\n    points_3d = unproject_depth_map_to_point_map(depth_map, extrinsic, intrinsic)\n\n    if args.use_ba:\n        image_size = np.array(images.shape[-2:])\n        scale = img_load_resolution / vggt_fixed_resolution\n        shared_camera = args.shared_camera\n\n        with torch.cuda.amp.autocast(dtype=dtype):\n            # Predicting Tracks\n            # Using VGGSfM tracker instead of VGGT tracker for efficiency\n            # VGGT tracker requires multiple backbone runs to query different frames (this is a problem caused by the training process)\n            # Will be fixed in VGGT v2\n\n            # You can also change the pred_tracks to tracks from any other methods\n            # e.g., from COLMAP, from CoTracker, or by chaining 2D matches from Lightglue/LoFTR.\n            pred_tracks, pred_vis_scores, pred_confs, points_3d, points_rgb = predict_tracks(\n                images,\n                conf=depth_conf,\n                points_3d=points_3d,\n                masks=None,\n                max_query_pts=args.max_query_pts,\n                query_frame_num=args.query_frame_num,\n                keypoint_extractor=\"aliked+sp\",\n                fine_tracking=args.fine_tracking,\n            )\n\n            torch.cuda.empty_cache()\n\n        # rescale the intrinsic matrix from 518 to 1024\n        intrinsic[:, :2, :] *= scale\n        track_mask = pred_vis_scores > args.vis_thresh\n\n        # TODO: radial distortion, iterative BA, masks\n        reconstruction, valid_track_mask = batch_np_matrix_to_pycolmap(\n            points_3d,\n            extrinsic,\n            intrinsic,\n            pred_tracks,\n            image_size,\n            masks=track_mask,\n            max_reproj_error=args.max_reproj_error,\n            shared_camera=shared_camera,\n            camera_type=args.camera_type,\n            points_rgb=points_rgb,\n        )\n\n        if reconstruction is None:\n            raise ValueError(\"No reconstruction can be built with BA\")\n\n        # Bundle Adjustment\n        ba_options = pycolmap.BundleAdjustmentOptions()\n        pycolmap.bundle_adjustment(reconstruction, ba_options)\n\n        reconstruction_resolution = img_load_resolution\n    else:\n        conf_thres_value = args.conf_thres_value\n        max_points_for_colmap = 100000  # randomly sample 3D points\n        shared_camera = False  # in the feedforward manner, we do not support shared camera\n        camera_type = \"PINHOLE\"  # in the feedforward manner, we only support PINHOLE camera\n\n        image_size = np.array([vggt_fixed_resolution, vggt_fixed_resolution])\n        num_frames, height, width, _ = points_3d.shape\n\n        points_rgb = F.interpolate(\n            images, size=(vggt_fixed_resolution, vggt_fixed_resolution), mode=\"bilinear\", align_corners=False\n        )\n        points_rgb = (points_rgb.cpu().numpy() * 255).astype(np.uint8)\n        points_rgb = points_rgb.transpose(0, 2, 3, 1)\n\n        # (S, H, W, 3), with x, y coordinates and frame indices\n        points_xyf = create_pixel_coordinate_grid(num_frames, height, width)\n\n        conf_mask = depth_conf >= conf_thres_value\n        # at most writing 100000 3d points to colmap reconstruction object\n        conf_mask = randomly_limit_trues(conf_mask, max_points_for_colmap)\n\n        points_3d = points_3d[conf_mask]\n        points_xyf = points_xyf[conf_mask]\n        points_rgb = points_rgb[conf_mask]\n\n        print(\"Converting to COLMAP format\")\n        reconstruction = batch_np_matrix_to_pycolmap_wo_track(\n            points_3d,\n            points_xyf,\n            points_rgb,\n            extrinsic,\n            intrinsic,\n            image_size,\n            shared_camera=shared_camera,\n            camera_type=camera_type,\n        )\n\n        reconstruction_resolution = vggt_fixed_resolution\n\n    reconstruction = rename_colmap_recons_and_rescale_camera(\n        reconstruction,\n        base_image_path_list,\n        original_coords.cpu().numpy(),\n        img_size=reconstruction_resolution,\n        shift_point2d_to_original_res=True,\n        shared_camera=shared_camera,\n    )\n\n    print(f\"Saving reconstruction to {args.scene_dir}/sparse\")\n    sparse_reconstruction_dir = os.path.join(args.scene_dir, \"sparse\")\n    os.makedirs(sparse_reconstruction_dir, exist_ok=True)\n    reconstruction.write(sparse_reconstruction_dir)\n\n    # Save point cloud for fast visualization\n    trimesh.PointCloud(points_3d, colors=points_rgb).export(os.path.join(args.scene_dir, \"sparse/points.ply\"))\n\n    return True", "label": 0}
{"function": "    def runCodeBlocks(self):\n        \"\"\"\u4ee3\u7801\u5757\u4e2d\u53ef\u4ee5\u653eQPalette\u7684\u5b9a\u4e49\uff0c\u5982\u679c\u6709Qpalette\u5b9a\u4e49\uff0c\u5728\u9884\u89c8\u7684\u65f6\u5019\u9700\u8981\u5148\u8fd0\u884c\u4ee3\u7801\u5757\u4e2d\u7684\u5b9a\u4e49\"\"\"\n        self.codeBlocks = self.reCodeBlock.findall(self.srctext)\n        if self.codeBlocks:\n            try:\n                eval(\"from PyQt5.QtGui import QPalette\")\n                for code in self.codeBlocks:\n                    exec(code)\n            except:\n                print(\"warning: codeblock in qsst exec error.\")", "label": 1}
{"function": "    def on_text_lose_focus(self, new_msg):\n        if self.searching:\n            return self.on_search_timer()\n\n        # Cancel the status button timer if it's running.\n        self.cancel_timer()\n\n        if getattr(self, 'skipenter', False):\n            wx.CallAfter(lambda: setattr(self, 'skipenter', False))\n        else:\n            # don't set status if we lost focus because the user is clicking\n            # on the state button\n            if wx.GetMouseState().LeftDown() and wx.FindWindowAtPoint(wx.GetMousePosition()) is self.cbutton:\n                return\n\n            profile_status = self.get_profile_status()\n            if new_msg == '':\n                self.display.empty_text = profile_status.hint\n            if new_msg != profile_status.message or self.status_state != profile_status.status:\n                # entering a new text value clears all exceptions\n                newmsg = StatusMessage(new_msg, self.status_state, new_msg)\n                self.set_profile_status(newmsg)", "label": 1}
{"function": "    def should_continue_risk_analysis(self, state: AgentState) -> str:\n        \"\"\"Determine if risk analysis should continue.\"\"\"\n        if (\n            state[\"risk_debate_state\"][\"count\"] >= 3 * self.max_risk_discuss_rounds\n        ):  # 3 rounds of back-and-forth between 3 agents\n            return \"Risk Judge\"\n        if state[\"risk_debate_state\"][\"latest_speaker\"].startswith(\"Risky\"):\n            return \"Safe Analyst\"\n        if state[\"risk_debate_state\"][\"latest_speaker\"].startswith(\"Safe\"):\n            return \"Neutral Analyst\"\n        return \"Risky Analyst\"", "label": 0}
{"function": "    def load(cls, path: str) -> \"DiaConfig | None\":\n        \"\"\"Load and validate a Dia configuration from a JSON file.\n\n        Args:\n            path: The path to the configuration file.\n\n        Returns:\n            A validated DiaConfig instance if the file exists and is valid,\n            otherwise None if the file is not found.\n\n        Raises:\n            ValueError: If the path does not point to an existing .json file.\n            pydantic.ValidationError: If the JSON content fails validation against the DiaConfig schema.\n        \"\"\"\n        try:\n            with open(path, \"r\") as f:\n                content = f.read()\n            return cls.model_validate_json(content)\n        except FileNotFoundError:\n            return None", "label": 0}
{"function": "def load_dataset(dataset: str, sv: SessionVariables):\n    \"\"\"Load dataset from the dropdown.\"\"\"\n    sv.dataset.value = dataset\n    sv.dataset_config.value = next(\n        (d for d in sv.datasets.value if d.key == dataset), None\n    )\n    if sv.dataset_config.value is not None:\n        sv.datasource.value = create_datasource(f\"{sv.dataset_config.value.path}\")  # type: ignore\n        sv.graphrag_config.value = sv.datasource.value.read_settings(\"settings.yaml\")\n        load_knowledge_model(sv)", "label": 0}
{"function": "async def get_latest_answer():\n    global query_resp_history\n    if interaction.current_agent is None:\n        return JSONResponse(status_code=404, content={\"error\": \"No agent available\"})\n    uid = str(uuid.uuid4())\n    if not any(q[\"answer\"] == interaction.current_agent.last_answer for q in query_resp_history):\n        query_resp = {\n            \"done\": \"false\",\n            \"answer\": interaction.current_agent.last_answer,\n            \"reasoning\": interaction.current_agent.last_reasoning,\n            \"agent_name\": interaction.current_agent.agent_name if interaction.current_agent else \"None\",\n            \"success\": interaction.current_agent.success,\n            \"blocks\": {f'{i}': block.jsonify() for i, block in enumerate(interaction.get_last_blocks_result())} if interaction.current_agent else {},\n            \"status\": interaction.current_agent.get_status_message if interaction.current_agent else \"No status available\",\n            \"uid\": uid\n        }\n        interaction.current_agent.last_answer = \"\"\n        interaction.current_agent.last_reasoning = \"\"\n        query_resp_history.append(query_resp)\n        return JSONResponse(status_code=200, content=query_resp)\n    if query_resp_history:\n        return JSONResponse(status_code=200, content=query_resp_history[-1])\n    return JSONResponse(status_code=404, content={\"error\": \"No answer available\"})", "label": 0}
{"function": "def main():\n    parser = argparse.ArgumentParser(\n        prog=\"moshi_import\", description=\"Imports moshi checkpoints\"\n    )\n    parser.add_argument(\"checkpoint\", help=\"The checkpoint to be imported.\")\n    parser.add_argument(\"out\", help=\"The safetensors out file.\")\n    args = parser.parse_args()\n\n    out_path = Path(args.out)\n\n    if out_path.exists():\n        print(\"file already exists\")\n    else:\n        import_model(args.checkpoint, out_path)\n    print(out_path)", "label": 0}
{"function": "    def _add_partial_read_service(self, ioi, elements):\n        \"\"\"\n        Add the partial read service to the tag IOI\n        \"\"\"\n        RequestService = 0x52\n        RequestPathSize = int(len(ioi)/2)\n        read_service = pack('<BB', RequestService, RequestPathSize)\n        read_service += ioi\n        read_service += pack('<H', int(elements))\n        read_service += pack('<I', self.Offset)\n        return read_service", "label": 1}
{"function": "    def __init__(self, real):\n        pass", "label": 1}
{"function": "    def action_redirect_to_forum(self):\n        self.ensure_one()\n        action = self.env.ref('website_forum.action_forum_post').read()[0]\n        action['view_mode'] = 'tree'\n        action['context'] = {\n            'create': False\n        }\n        action['domain'] = [('forum_id', '=', self.forum_id.id)]\n\n        return action", "label": 1}
{"function": "        def insert_item(buf, at, newpos):\n            newtext = \"\".join(item[0] for item in buf)\n            newsc = buf[0][2]  # start char of first item in buffer\n            newec = buf[-1][3]  # end char of last item in buffer\n            parts.insert(insertat, (newtext, newpos, newsc, newec))", "label": 1}
{"function": "    def _sample_data(self, indices):\n        \"\"\"Sample batch of training data from a list of tasks.\n\n        Args:\n            indices (list): List of task indices to sample from.\n\n        Returns:\n            torch.Tensor: Obervations, with shape :math:`(X, N, O^*)` where X\n                is the number of tasks. N is batch size.\n            torch.Tensor: Actions, with shape :math:`(X, N, A^*)`.\n            torch.Tensor: Rewards, with shape :math:`(X, N, 1)`.\n            torch.Tensor: Next obervations, with shape :math:`(X, N, O^*)`.\n            torch.Tensor: Dones, with shape :math:`(X, N, 1)`.\n\n        \"\"\"\n        # transitions sampled randomly from replay buffer\n        initialized = False\n        for idx in indices:\n            batch = self._replay_buffers[idx].sample_transitions(\n                self._batch_size)\n            if not initialized:\n                o = batch['observations'][np.newaxis]\n                a = batch['actions'][np.newaxis]\n                r = batch['rewards'][np.newaxis]\n                no = batch['next_observations'][np.newaxis]\n                d = batch['dones'][np.newaxis]\n                initialized = True\n            else:\n                o = np.vstack((o, batch['observations'][np.newaxis]))\n                a = np.vstack((a, batch['actions'][np.newaxis]))\n                r = np.vstack((r, batch['rewards'][np.newaxis]))\n                no = np.vstack((no, batch['next_observations'][np.newaxis]))\n                d = np.vstack((d, batch['dones'][np.newaxis]))\n\n        o = torch.as_tensor(o, device=global_device()).float()\n        a = torch.as_tensor(a, device=global_device()).float()\n        r = torch.as_tensor(r, device=global_device()).float()\n        no = torch.as_tensor(no, device=global_device()).float()\n        d = torch.as_tensor(d, device=global_device()).float()\n\n        return o, a, r, no, d", "label": 1}
{"function": "    def _wrap_object(self, space, obj):\n        return space.newlong_from_rarith_int(obj)", "label": 1}
{"function": "def test_detection(detection_predictor, test_image):\n    detection_results = detection_predictor([test_image])\n\n    assert len(detection_results) == 1\n    assert detection_results[0].image_bbox == [0, 0, 1024, 1024]\n\n    bboxes = detection_results[0].bboxes\n    assert len(bboxes) == 4", "label": 0}
{"function": "def save_audio_file(base64_data: str, filename: str = \"output.mp3\") -> None:\n    audio_bytes = base64.b64decode(base64_data)\n    with open(filename, \"wb\") as file:\n        file.write(audio_bytes)", "label": 0}
{"function": "    def test_record(self):\n        install_dir = self.mkdtemp()\n        project_dir, dist = self.create_dist(py_modules=['hello'],\n                                             scripts=['sayhi'])\n        os.chdir(project_dir)\n        self.write_file('hello.py', \"def main(): print 'o hai'\")\n        self.write_file('sayhi', 'from hello import main; main()')\n\n        cmd = install(dist)\n        dist.command_obj['install'] = cmd\n        cmd.root = install_dir\n        cmd.record = os.path.join(project_dir, 'filelist')\n        cmd.ensure_finalized()\n        cmd.run()\n\n        f = open(cmd.record)\n        try:\n            content = f.read()\n        finally:\n            f.close()\n\n        found = [os.path.basename(line) for line in content.splitlines()]\n        expected = ['hello.py', 'hello.pyc', 'sayhi',\n                    'UNKNOWN-0.0.0-py%s.%s.egg-info' % sys.version_info[:2]]\n        self.assertEqual(found, expected)", "label": 1}
{"function": "  def _GetDeviceAddresses(self, excluded_iface):\n    \"\"\"Returns the IP addresses on all connected devices.\n    Excludes interface |excluded_iface| on the selected device.\n    \"\"\"\n    my_device = str(self._device)\n    addresses = []\n    for device_serial in android_device.GetDeviceSerials(None):\n      try:\n        device = device_utils.DeviceUtils(device_serial)\n        if device_serial == my_device:\n          excluded = excluded_iface\n        else:\n          excluded = 'no interfaces excluded on other devices'\n        output = device.RunShellCommand(\n            ['ip', '-o', '-4', 'addr'], check_return=True)\n        addresses += [\n            line.split()[3] for line in output if excluded not in line]\n      except device_errors.CommandFailedError:\n        logging.warning('Unable to determine IP addresses for %s',\n                        device_serial)\n    return addresses", "label": 1}
{"function": "def install_package(*packages):\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", *packages])", "label": 0}
{"function": "def partial_fields(target_class, kwargs):\n    return target_class(**{k: v for k, v in kwargs.items() if hasattr(target_class, k)})", "label": 0}
{"function": "def create_demo(model_path, save_path):\n    model = initialize_model(model_path)\n    \n    with gr.Blocks() as demo:\n        gr.Markdown(\"# Hunyuan Video Generation\")\n        \n        with gr.Row():\n            with gr.Column():\n                prompt = gr.Textbox(label=\"Prompt\", value=\"A cat walks on the grass, realistic style.\")\n                with gr.Row():\n                    resolution = gr.Dropdown(\n                        choices=[\n                            # 720p\n                            (\"1280x720 (16:9, 720p)\", \"1280x720\"),\n                            (\"720x1280 (9:16, 720p)\", \"720x1280\"), \n                            (\"1104x832 (4:3, 720p)\", \"1104x832\"),\n                            (\"832x1104 (3:4, 720p)\", \"832x1104\"),\n                            (\"960x960 (1:1, 720p)\", \"960x960\"),\n                            # 540p\n                            (\"960x544 (16:9, 540p)\", \"960x544\"),\n                            (\"544x960 (9:16, 540p)\", \"544x960\"),\n                            (\"832x624 (4:3, 540p)\", \"832x624\"), \n                            (\"624x832 (3:4, 540p)\", \"624x832\"),\n                            (\"720x720 (1:1, 540p)\", \"720x720\"),\n                        ],\n                        value=\"1280x720\",\n                        label=\"Resolution\"\n                    )\n                    video_length = gr.Dropdown(\n                        label=\"Video Length\",\n                        choices=[\n                            (\"2s(65f)\", 65),\n                            (\"5s(129f)\", 129),\n                        ],\n                        value=129,\n                    )\n                num_inference_steps = gr.Slider(1, 100, value=50, step=1, label=\"Number of Inference Steps\")\n                show_advanced = gr.Checkbox(label=\"Show Advanced Options\", value=False)\n                with gr.Row(visible=False) as advanced_row:\n                    with gr.Column():\n                        seed = gr.Number(value=-1, label=\"Seed (-1 for random)\")\n                        guidance_scale = gr.Slider(1.0, 20.0, value=1.0, step=0.5, label=\"Guidance Scale\")\n                        flow_shift = gr.Slider(0.0, 10.0, value=7.0, step=0.1, label=\"Flow Shift\") \n                        embedded_guidance_scale = gr.Slider(1.0, 20.0, value=6.0, step=0.5, label=\"Embedded Guidance Scale\")\n                show_advanced.change(fn=lambda x: gr.Row(visible=x), inputs=[show_advanced], outputs=[advanced_row])\n                generate_btn = gr.Button(\"Generate\")\n            \n            with gr.Column():\n                output = gr.Video(label=\"Generated Video\")\n        \n        generate_btn.click(\n            fn=lambda *inputs: generate_video(model, *inputs),\n            inputs=[\n                prompt,\n                resolution,\n                video_length,\n                seed,\n                num_inference_steps,\n                guidance_scale,\n                flow_shift,\n                embedded_guidance_scale\n            ],\n            outputs=output\n        )\n    \n    return demo", "label": 0}
{"function": "def with_community_info(func):\n    \"\"\"\n    Decorator: Show community info before executing the command\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        show_community_info()\n        return func(*args, **kwargs)\n\n    return wrapper", "label": 0}
{"function": "    def _getReplyValues(self, tag_name, elements, data):\n        \"\"\"\n        Gather up all the values in the reply/replies\n        \"\"\"\n        tag, base_tag, index = _parseTagName(tag_name, 0)\n        data_type = self.KnownTags[base_tag][0]\n        fmt = self.CIPTypes[data_type][2]\n        vals = []\n\n        data_size = self.CIPTypes[data_type][0]\n        numbytes = len(data)-data_size\n        counter = 0\n\n        # this is going to check if the data type was a struct\n        # if so, return the raw data\n        if data_type == 160:\n            tmp = unpack_from('<h', data, 2)[0]\n            if tmp != self.StructIdentifier:\n                d = data[4:4+len(data)]\n                vals.append(d)\n                self.Offset += len(data)\n                return vals\n\n        while True:\n            index = 2+(counter*data_size)\n            if index > numbytes:\n                break\n            if data_type == 160:\n                index = 4+(counter*data_size)\n                name_len = unpack_from('<L', data, index)[0]\n                s = data[index+4:index+4+name_len]\n                vals.append(str(s.decode(self.StringEncoding)))\n\n            elif data_type == 218:\n                # remove the data type\n                data = data[2:] \n                while len(data) > 0:\n                    # get the next string length\n                    length = unpack_from('<B', data, 0)[0]\n                    # remove the length from the packet\n                    data = data[1:]\n                    # grab the string\n                    s = data[:length]\n                    vals.append(str(s.decode(self.StringEncoding)))\n                    # remove the string from the packet\n                    data = data[length:]\n                break\n            else:\n                returnvalue = unpack_from(fmt, data, index)[0]\n                vals.append(returnvalue)\n\n            self.Offset += data_size\n            counter += 1\n\n        return vals", "label": 1}
{"function": "    def assignment_callback(offsets: Mapping[Partition, int]) -> None:\n        assignment_callback.called = True\n        assert inner_consumer.tell() == {partition: 0}\n        assert consumer.tell() == {partition: 0}", "label": 1}
{"function": "    def pbar_update(self, name: str = \"\", item_name: str = \"\"):\n        if self.pbar.n < self.total:\n            self.pbar.update()\n            self.update_progress(\n                f\"\u6b63\u5728\u8fdb\u884c{name}, \u5269\u4f59{self.total - self.pbar.n}\u4e2a{item_name}, \u9884\u8ba1\u5269\u4f59\u65f6\u95f4: {get_pbar_remaining(n=self.pbar.n, total=self.total, start_time=self.start_time)}\",\n                int((self.pbar.n / self.total) * 100),\n            )", "label": 0}
{"function": "    def consumer(self):\n        return Consumer(self._location, self._enable_ssl, self._cert_path, self._topic, self._group, partition_id=None)", "label": 1}
{"function": "def test_parse_hparam_args__decimal():\n    hparam_args = ['--foo', 'HParams(boo=0.01)']\n    assert parse_hparam_args(hparam_args) == {'foo': HParams(boo=0.01)}", "label": 1}
{"function": "    def graph(self, graph):\n        self._graph = graph", "label": 1}
{"function": "def test_merge_configs():\n    \"\"\" Test the merging of two configurations via `add_config`.\n    \"\"\"\n\n    @configurable\n    def configured(arg, arg_two):\n        pass\n\n    @configurable\n    def other_configured(arg):\n        pass\n\n    add_config({configured: HParams(arg='arg', arg_two='arg_two')})\n    add_config({other_configured: HParams()})\n    assert len(get_config()) == 2\n    assert get_config()[_get_function_signature(configured.__wrapped__)]['arg'] == 'arg'\n    add_config({configured: HParams(arg='gra')})\n    assert len(get_config()) == 2\n    assert get_config()[_get_function_signature(configured.__wrapped__)]['arg'] == 'gra'\n    assert get_config()[_get_function_signature(configured.__wrapped__)]['arg_two'] == 'arg_two'", "label": 1}
{"function": "    def bulk_create(self, *args): ...", "label": 1}
{"function": "\tdef test_domain_filter_matching(self):\n\t\t\"\"\"Test that domain filters work correctly with glob patterns\"\"\"\n\t\tregistry = ActionRegistry()\n\n\t\t# Create actions with different domain patterns\n\t\tactions = {\n\t\t\t'exact_match': RegisteredAction(\n\t\t\t\tname='exact_match',\n\t\t\t\tdescription='Exact domain match',\n\t\t\t\tfunction=lambda: None,\n\t\t\t\tparam_model=EmptyParamModel,\n\t\t\t\tdomains=['example.com'],\n\t\t\t\tpage_filter=None,\n\t\t\t),\n\t\t\t'subdomain_match': RegisteredAction(\n\t\t\t\tname='subdomain_match',\n\t\t\t\tdescription='Subdomain wildcard match',\n\t\t\t\tfunction=lambda: None,\n\t\t\t\tparam_model=EmptyParamModel,\n\t\t\t\tdomains=['*.example.com'],\n\t\t\t\tpage_filter=None,\n\t\t\t),\n\t\t\t'prefix_match': RegisteredAction(\n\t\t\t\tname='prefix_match',\n\t\t\t\tdescription='Prefix wildcard match',\n\t\t\t\tfunction=lambda: None,\n\t\t\t\tparam_model=EmptyParamModel,\n\t\t\t\tdomains=['example*'],\n\t\t\t\tpage_filter=None,\n\t\t\t),\n\t\t\t'non_matching': RegisteredAction(\n\t\t\t\tname='non_matching',\n\t\t\t\tdescription='Non-matching domain',\n\t\t\t\tfunction=lambda: None,\n\t\t\t\tparam_model=EmptyParamModel,\n\t\t\t\tdomains=['other.com'],\n\t\t\t\tpage_filter=None,\n\t\t\t),\n\t\t}\n\n\t\tregistry.actions = actions\n\n\t\t# Test exact domain match\n\t\tmock_page = MagicMock(spec=Page)\n\t\tmock_page.url = 'https://example.com/page'\n\n\t\texact_match_description = registry.get_prompt_description(mock_page)\n\t\tassert 'exact_match' in exact_match_description\n\t\tassert 'non_matching' not in exact_match_description\n\n\t\t# Test subdomain match\n\t\tmock_page.url = 'https://sub.example.com/page'\n\t\tsubdomain_match_description = registry.get_prompt_description(mock_page)\n\t\tassert 'subdomain_match' in subdomain_match_description\n\t\tassert 'exact_match' not in subdomain_match_description\n\n\t\t# Test prefix match\n\t\tmock_page.url = 'https://example123.org/page'\n\t\tprefix_match_description = registry.get_prompt_description(mock_page)\n\t\tassert 'prefix_match' in prefix_match_description", "label": 0}
{"function": "    def producer(self):\n        return SimpleProducer(self._location, self._enable_ssl, self._cert_path, self._topic, self._codec,\n                              batch_size=DEFAULT_BATCH_SIZE,\n                              buffer_memory=DEFAULT_BUFFER_MEMORY)", "label": 1}
{"function": "    def _alpha(key):\n        return key", "label": 1}
{"function": "def find_nearest_bucket(h, w, resolution=640):\n    min_metric = float('inf')\n    best_bucket = None\n    for (bucket_h, bucket_w) in bucket_options[resolution]:\n        metric = abs(h * bucket_w - w * bucket_h)\n        if metric <= min_metric:\n            min_metric = metric\n            best_bucket = (bucket_h, bucket_w)\n    return best_bucket", "label": 0}
{"function": "def small2large(x):\n    # (d * d, width, width) -> (d * width, d * width)    \n    x = x.reshape(args.divide, args.divide, width, width, -1)\n    x = np.transpose(x, (0, 2, 1, 3, 4))\n    x = x.reshape(args.divide * width, args.divide * width, -1)\n    return x", "label": 1}
{"function": "async def test_exclude_specific_custom_types():\n    \"\"\"Test excluding specific custom entity types while keeping others.\"\"\"\n    graphiti = Graphiti(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD)\n\n    try:\n        await graphiti.build_indices_and_constraints()\n\n        # Define multiple entity types\n        entity_types = {\n            'Person': Person,\n            'Organization': Organization,\n            'Location': Location,\n        }\n\n        # Add an episode with content that would create all types\n        episode_content = (\n            'Sarah Johnson from Google visited the San Francisco office to discuss the new project.'\n        )\n\n        result = await graphiti.add_episode(\n            name='Office Visit',\n            episode_body=episode_content,\n            source_description='Visit report',\n            reference_time=datetime.now(timezone.utc),\n            entity_types=entity_types,\n            excluded_entity_types=['Organization', 'Location'],  # Exclude these types\n            group_id='test_exclude_custom',\n        )\n\n        assert result is not None\n\n        # Search for nodes to verify only Person and Entity types were created\n        search_results = await graphiti.search_(\n            query='Sarah Johnson Google San Francisco', group_ids=['test_exclude_custom']\n        )\n\n        found_nodes = search_results.nodes\n\n        # Should have Person and Entity type nodes, but no Organization or Location\n        for node in found_nodes:\n            assert 'Entity' in node.labels\n            # Should not have excluded types\n            assert 'Organization' not in node.labels, (\n                f'Found excluded Organization in node: {node.name}'\n            )\n            assert 'Location' not in node.labels, f'Found excluded Location in node: {node.name}'\n\n        # Should find at least one Person entity (Sarah Johnson)\n        person_nodes = [n for n in found_nodes if 'Person' in n.labels]\n        assert len(person_nodes) > 0, 'Should have found at least one Person entity'\n\n        # Clean up\n        await _cleanup_test_nodes(graphiti, 'test_exclude_custom')\n\n    finally:\n        await graphiti.close()", "label": 0}
{"function": "def _sign_alg_name_to_id(s_alg):\n    \"\"\"Try to convert signature algorithm name to SignatureAlgorithm TLS ID.\n\n    accepts also a string with a single number in it\n    \"\"\"\n    try:\n        return int(s_alg)\n    except ValueError:\n        return getattr(SignatureAlgorithm, s_alg)", "label": 1}
{"function": "    def get(self, name: str):\n        \"\"\"\n        Get the alias by name\n        \"\"\"\n        return self.primary_to_aliases.get(name, set())", "label": 0}
{"function": "def resample(audio_tensor, sr0, sr1, device):\r\n    global resample_transform_dict\r\n    key = \"%s-%s-%s\" % (sr0, sr1, str(device))\r\n    if key not in resample_transform_dict:\r\n        resample_transform_dict[key] = torchaudio.transforms.Resample(sr0, sr1).to(device)\r\n    return resample_transform_dict[key](audio_tensor)\r", "label": 0}
{"function": "    def __init__(\n        self,\n        config: OpenHandsConfig,\n        event_stream: EventStream,\n        sid: str = 'default',\n        plugins: list[PluginRequirement] | None = None,\n        env_vars: dict[str, str] | None = None,\n        status_callback: Callable | None = None,\n        attach_to_existing: bool = False,\n        headless_mode: bool = True,\n        user_id: str | None = None,\n        git_provider_tokens: PROVIDER_TOKEN_TYPE | None = None,\n    ):\n        # Read Runloop API key from environment variable\n        runloop_api_key = os.getenv('RUNLOOP_API_KEY')\n        if not runloop_api_key:\n            raise ValueError('RUNLOOP_API_KEY environment variable is required for Runloop runtime')\n            \n        self.devbox: DevboxView | None = None\n        self.config = config\n        self.runloop_api_client = Runloop(\n            bearer_token=runloop_api_key,\n        )\n        self.container_name = CONTAINER_NAME_PREFIX + sid\n        super().__init__(\n            config,\n            event_stream,\n            sid,\n            plugins,\n            env_vars,\n            status_callback,\n            attach_to_existing,\n            headless_mode,\n            user_id,\n            git_provider_tokens,\n        )\n        # Buffer for container logs\n        self._vscode_url: str | None = None", "label": 0}
{"function": "def test_cosine_extraction(tester: Crawl4AiTester):\n    print(\"\\n=== Testing Cosine Extraction ===\")\n    request = {\n        \"urls\": [\"https://www.nbcnews.com/business\"],\n        \"priority\": 8,\n        \"extraction_config\": {\n            \"type\": \"cosine\",\n            \"params\": {\n                \"semantic_filter\": \"business finance economy\",\n                \"word_count_threshold\": 10,\n                \"max_dist\": 0.2,\n                \"top_k\": 3,\n            },\n        },\n    }\n\n    try:\n        result = tester.submit_and_wait(request)\n        extracted = json.loads(result[\"result\"][\"extracted_content\"])\n        print(f\"Extracted {len(extracted)} text clusters\")\n        print(\"First cluster tags:\", extracted[0][\"tags\"])\n        assert result[\"result\"][\"success\"]\n    except Exception as e:\n        print(f\"Cosine extraction test failed: {str(e)}\")", "label": 0}
{"function": "def save_yaml_file(file_path: str, data: dict) -> None:\n    with open(file_path, 'w', encoding='utf-8') as file:\n        yaml.safe_dump(data,\n                       file,\n                       default_flow_style=False,\n                       allow_unicode=True,\n                       indent=2,\n                       sort_keys=False)", "label": 0}
{"function": "def nfort_flags(conf):\n\tv=conf.env\n\tv['_FCMODOUTFLAGS']=[]\n\tv['FCFLAGS_DEBUG']=[]\n\tv['FCFLAGS_fcshlib']=[]\n\tv['LINKFLAGS_fcshlib']=[]\n\tv['FCSTLIB_MARKER']=''\n\tv['FCSHLIB_MARKER']=''", "label": 1}
{"function": "    def __init__(self, open, high, low, close):\n        pass", "label": 1}
{"function": "def writable_preferred_server_selector(selection):\n    \"\"\"Like PrimaryPreferred but doesn't use tags or latency.\"\"\"\n    return (writable_server_selector(selection) or\n            secondary_server_selector(selection))", "label": 1}
{"function": "def compute_chunk(chunk, chunk_expr, part):\n    return compute(chunk_expr, {chunk: part})", "label": 1}
{"function": "    def upsert_mapped_projects(user_id: int, project_id: int):\n        \"\"\" Add project to mapped projects if it doesn't exist, otherwise return \"\"\"\n        User.upsert_mapped_projects(user_id, project_id)", "label": 1}
{"function": "    def select(self, timeout: Optional[float] = ...) -> List[Tuple[SelectorKey, _EventMask]]: ...", "label": 1}
{"function": "    def test_mean(self):\n        self.check('CAN15/GMPEtInterface_Low_combo.csv',\n                   max_discrep_percentage=900.)", "label": 1}
{"function": "def get_converter():\n    converter = DocumentConverter(allowed_formats=[InputFormat.CSV])\n\n    return converter", "label": 0}
{"function": "def format_duration(milliseconds):\n    \"\"\"\u5c06\u6beb\u79d2\u8f6c\u6362\u4e3a\u65f6\u5206\u79d2\u7684\u663e\u793a\u683c\u5f0f\"\"\"\n    total_seconds = milliseconds / 1000\n    hours = int(total_seconds // 3600)\n    minutes = int((total_seconds % 3600) // 60)\n    seconds = int(total_seconds % 60)\n\n    if hours > 0:\n        return f\"{hours:02d}\u65f6{minutes:02d}\u5206{seconds:02d}\u79d2\"\n    elif minutes > 0:\n        return f\"{minutes:02d}\u5206{seconds:02d}\u79d2\"\n    else:\n        return f\"{seconds:02d}\u79d2\"", "label": 0}
{"function": "        def _prediction_to_probabilities(y: np.ndarray, classes: List[Any]) -> np.ndarray:\n            \"\"\"Transforms predicted probabilities to match with OpenML class indices.\n\n            Parameters\n            ----------\n            y : np.ndarray\n                Predicted probabilities (possibly omitting classes if they were not present in the\n                training data).\n            model_classes : list\n                List of classes known_predicted by the model, ordered by their index.\n\n            Returns\n            -------\n            np.ndarray\n            \"\"\"\n            # y: list or numpy array of predictions\n            # model_classes: sklearn classifier mapping from original array id to\n            # prediction index id\n            if not isinstance(classes, list):\n                raise ValueError(\"please convert model classes to list prior to \" \"calling this fn\")\n            result = np.zeros((len(y), len(classes)), dtype=np.float32)\n            for obs, prediction_idx in enumerate(y):\n                result[obs][prediction_idx] = 1.0\n            return result", "label": 1}
{"function": "    def deactivate_restore(self):\n        if self.is_restore_active:\n            for seq in self.RESTORE_SEQUENCES:\n                self.text.event_delete(self.RESTORE_VIRTUAL_EVENT_NAME, seq)\n            self.is_restore_active = False", "label": 1}
{"function": "    def __init__(self, id):\n        if id < 0:\n            self.id = c_uint32(id).value\n        else:\n            self.id = id\n        if zibe_errors.error_codes.has_key(self.id):\n            error_data = zibe_errors.error_codes[self.id]\n            self.message = error_data[1]\n            self.name = error_data[0]\n        else:\n            self.message = 'Unknown error 0x%x' % self.id", "label": 1}
{"function": "  def __init__(\n      self,\n      name: str,\n      disallow_transfer_to_parent: bool = False,\n      parent_agent: Optional[BaseAgent] = None,\n  ):\n    # Use a string model instead of mock\n    super().__init__(name=name, model=\"gemini-1.5-pro\", sub_agents=[])\n    self.disallow_transfer_to_parent = disallow_transfer_to_parent\n    self.parent_agent = parent_agent", "label": 0}
{"function": "    def test_finalize_options(self):\n        dist = Distribution({'name': 'xx'})\n        cmd = install(dist)\n\n        # must supply either prefix/exec-prefix/home or\n        # install-base/install-platbase -- not both\n        cmd.prefix = 'prefix'\n        cmd.install_base = 'base'\n        self.assertRaises(DistutilsOptionError, cmd.finalize_options)\n\n        # must supply either home or prefix/exec-prefix -- not both\n        cmd.install_base = None\n        cmd.home = 'home'\n        self.assertRaises(DistutilsOptionError, cmd.finalize_options)\n\n        # can't combine user with prefix/exec_prefix/home or\n        # install_(plat)base\n        cmd.prefix = None\n        cmd.user = 'user'\n        self.assertRaises(DistutilsOptionError, cmd.finalize_options)", "label": 1}
{"function": "    def _wait_for_devbox(self, devbox: DevboxView) -> DevboxView:\n        \"\"\"Pull devbox status until it is running\"\"\"\n        if devbox == 'running':\n            return devbox\n\n        devbox = self.runloop_api_client.devboxes.retrieve(id=devbox.id)\n        if devbox.status != 'running':\n            raise ConnectionRefusedError('Devbox is not running')\n\n        # Devbox is connected and running\n        logging.debug(f'devbox.id={devbox.id} is running')\n        return devbox", "label": 0}
{"function": "\tdef set_OwnerId(self,OwnerId):\n\t\tself.add_query_param('OwnerId',OwnerId)", "label": 1}
{"function": "\tdef testbanOK(self):\n\t\tself._addDefItems()\n\t\tself.__failManager.setMaxRetry(5)\n\t\t#ticket = FailTicket('193.168.0.128', None)\n\t\tticket = self.__failManager.toBan()\n\t\tself.assertEqual(ticket.getIP(), \"193.168.0.128\")\n\t\tself.assertTrue(isinstance(ticket.getIP(), (str, IPAddr)))\n\n\t\t# finish with rudimentary tests of the ticket\n\t\t# verify consistent str\n\t\tticket_str = str(ticket)\n\t\tticket_repr = repr(ticket)\n\t\tself.assertEqual(\n\t\t\tticket_str,\n\t\t\t'FailTicket: ip=193.168.0.128 time=1167605999.0 bantime=None bancount=0 #attempts=5 matches=[]')\n\t\tself.assertEqual(\n\t\t\tticket_repr,\n\t\t\t'FailTicket: ip=193.168.0.128 time=1167605999.0 bantime=None bancount=0 #attempts=5 matches=[]')\n\t\tself.assertFalse(not ticket)\n\t\t# and some get/set-ers otherwise not tested\n\t\tticket.setTime(1000002000.0)\n\t\tself.assertEqual(ticket.getTime(), 1000002000.0)\n\t\t# and str() adjusted correspondingly\n\t\tself.assertEqual(\n\t\t\tstr(ticket),\n\t\t\t'FailTicket: ip=193.168.0.128 time=1000002000.0 bantime=None bancount=0 #attempts=5 matches=[]')", "label": 1}
{"function": "    def predict(self, features):\n        pool = Pool(self.num_thread)\n        preds = pool.map(self._predict, features)\n        pool.close()\n        return np.array(preds)", "label": 1}
{"function": "    def reset_just_opened(self, kwargs):\n        self.log(\"Front door no longer just opened\")\n        self.just_opened_door = False", "label": 1}
{"function": "    def test_handle_extra_path(self):\n        dist = Distribution({'name': 'xx', 'extra_path': 'path,dirs'})\n        cmd = install(dist)\n\n        # two elements\n        cmd.handle_extra_path()\n        self.assertEqual(cmd.extra_path, ['path', 'dirs'])\n        self.assertEqual(cmd.extra_dirs, 'dirs')\n        self.assertEqual(cmd.path_file, 'path')\n\n        # one element\n        cmd.extra_path = ['path']\n        cmd.handle_extra_path()\n        self.assertEqual(cmd.extra_path, ['path'])\n        self.assertEqual(cmd.extra_dirs, 'path')\n        self.assertEqual(cmd.path_file, 'path')\n\n        # none\n        dist.extra_path = cmd.extra_path = None\n        cmd.handle_extra_path()\n        self.assertEqual(cmd.extra_path, None)\n        self.assertEqual(cmd.extra_dirs, '')\n        self.assertEqual(cmd.path_file, None)\n\n        # three elements (no way !)\n        cmd.extra_path = 'path,dirs,again'\n        self.assertRaises(DistutilsOptionError, cmd.handle_extra_path)", "label": 1}
{"function": "def train_epoch(epoch, wandb):\n    # \u601d\u8003\u6807\u7b7e\u5360\u4f4d\u7b26\n    start_of_think_ids = tokenizer('<think>').input_ids\n    end_of_think_ids = tokenizer('</think>').input_ids\n    start_of_answer_ids = tokenizer('<answer>').input_ids\n    end_of_answer_ids = tokenizer('</answer>').input_ids\n    loss_fct = nn.CrossEntropyLoss(reduction='none')\n    start_time = time.time()\n    for step, (X, Y, loss_mask) in enumerate(train_loader):\n        X = X.to(args.device)\n        Y = Y.to(args.device)\n        loss_mask = loss_mask.to(args.device)\n        lr = get_lr(epoch * iter_per_epoch + step, args.epochs * iter_per_epoch, args.learning_rate)\n        for param_group in optimizer.param_groups:\n            param_group['lr'] = lr\n\n        with ctx:\n            res = model(X)\n            loss = loss_fct(\n                res.logits.view(-1, res.logits.size(-1)),\n                Y.view(-1)\n            ).view(Y.size())\n            sp_ids = torch.isin(Y.view(-1),\n                                torch.tensor(start_of_think_ids + end_of_think_ids\n                                             + start_of_answer_ids + end_of_answer_ids\n                                             ).to(args.device))\n            # \u5728 sp_ids \u5bf9\u5e94\u7684\u4f4d\u7f6e\u589e\u52a0\u989d\u5916\u7684\u60e9\u7f5a\n            loss_mask = loss_mask.view(-1)\n            loss_mask_sum = loss_mask.sum()\n            loss_mask[sp_ids] = 10\n            loss_mask = loss_mask.view(Y.size())\n            loss = (loss * loss_mask).sum() / loss_mask_sum\n            loss += res.aux_loss\n            loss = loss / args.accumulation_steps\n\n        scaler.scale(loss).backward()\n\n        if (step + 1) % args.accumulation_steps == 0:\n            scaler.unscale_(optimizer)\n            torch.nn.utils.clip_grad_norm_(model.parameters(), args.grad_clip)\n\n            scaler.step(optimizer)\n            scaler.update()\n\n            optimizer.zero_grad(set_to_none=True)\n\n        if step % args.log_interval == 0:\n            spend_time = time.time() - start_time\n            Logger(\n                'Epoch:[{}/{}]({}/{}) loss:{:.3f} lr:{:.12f} epoch_Time:{}min:'.format(\n                    epoch + 1,\n                    args.epochs,\n                    step,\n                    iter_per_epoch,\n                    loss.item() * args.accumulation_steps,\n                    optimizer.param_groups[-1]['lr'],\n                    spend_time / (step + 1) * iter_per_epoch // 60 - spend_time // 60))\n\n            if (wandb is not None) and (not ddp or dist.get_rank() == 0):\n                wandb.log({\"loss\": loss * args.accumulation_steps,\n                           \"lr\": optimizer.param_groups[-1]['lr'],\n                           \"epoch_Time\": spend_time / (step + 1) * iter_per_epoch // 60 - spend_time // 60})\n\n        if (step + 1) % args.save_interval == 0 and (not ddp or dist.get_rank() == 0):\n            model.eval()\n            moe_path = '_moe' if lm_config.use_moe else ''\n            ckp = f'{args.save_dir}/reason_{lm_config.hidden_size}{moe_path}.pth'\n\n            if isinstance(model, torch.nn.parallel.DistributedDataParallel):\n                state_dict = model.module.state_dict()\n            else:\n                state_dict = model.state_dict()\n\n            state_dict = {k: v.half() for k, v in state_dict.items()}  # \u534a\u7cbe\u5ea6\u4fdd\u5b58\n            torch.save(state_dict, ckp)\n            model.train()", "label": 0}
{"function": "def form_data_consumer(request):\n    result_object = request.args['object']\n    if result_object == 'text':\n        return Response(repr(request.form['text']))\n    f = request.files[result_object]\n    return Response(b'\\n'.join((\n        repr(f.filename).encode('ascii'),\n        repr(f.name).encode('ascii'),\n        repr(f.content_type).encode('ascii'),\n        f.stream.read()\n    )))", "label": 1}
{"function": "    def test_get_signal_signal_dtype(self):\n        s = self.signal\n        assert s._get_signal_signal().data.dtype.name == s.data.dtype.name", "label": 1}
{"function": "async def test_read_bytes_basic(computer):\n    \"\"\"Test basic read_bytes functionality.\"\"\"\n    tmp_path = \"test_read_bytes.bin\"\n    test_data = b\"Hello, World! This is binary data \\x00\\x01\\x02\\x03\"\n    \n    # Write binary data using write_text (assuming it handles bytes)\n    await computer.interface.write_text(tmp_path, test_data.decode('latin-1'))\n    \n    # Read all bytes\n    read_data = await computer.interface.read_bytes(tmp_path)\n    assert read_data == test_data, \"Binary data should match\"\n    \n    await computer.interface.delete_file(tmp_path)", "label": 0}
{"function": "    def __init__(self, filename: str, line_number: int, col_number: int, problem: str):\n        self.filename = filename\n        self.line_number = line_number\n        self.col_number = col_number\n        self.problem = problem", "label": 0}
{"function": "    def __init__(self, ass):\n        super().__init__(ass.mem_set)\n        self._ass = ass", "label": 1}
{"function": "    def prefetch(self):\n        return self.value.prefetch", "label": 1}
{"function": "def run_code():\n    data = request.json\n    project_name = data.get(\"project_name\")\n    code = data.get(\"code\")\n    # TODO: Implement code execution logic\n    return jsonify({\"message\": \"Code execution started\"})", "label": 0}
{"function": "    def serialize(self):\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"created_at\": (\n                Localization.get().serialize_datetime(self.created_at)\n                if self.created_at\n                else Localization.get().serialize_datetime(datetime.fromtimestamp(0))\n            ),\n            \"no\": self.no,\n            \"log_guid\": self.log.guid,\n            \"log_version\": len(self.log.updates),\n            \"log_length\": len(self.log.logs),\n            \"paused\": self.paused,\n            \"last_message\": (\n                Localization.get().serialize_datetime(self.last_message)\n                if self.last_message\n                else Localization.get().serialize_datetime(datetime.fromtimestamp(0))\n            ),\n            \"type\": self.type.value,\n        }", "label": 0}
{"function": "def main():\n    parser = argparse.ArgumentParser(description=\"Generate audio using the Dia model.\")\n\n    parser.add_argument(\"text\", type=str, help=\"Input text for speech generation.\")\n    parser.add_argument(\n        \"--output\", type=str, required=True, help=\"Path to save the generated audio file (e.g., output.wav).\"\n    )\n\n    parser.add_argument(\n        \"--repo-id\",\n        type=str,\n        default=\"nari-labs/Dia-1.6B-0626\",\n        help=\"Hugging Face repository ID (e.g., nari-labs/Dia-1.6B-0626).\",\n    )\n    parser.add_argument(\n        \"--local-paths\", action=\"store_true\", help=\"Load model from local config and checkpoint files.\"\n    )\n\n    parser.add_argument(\n        \"--config\", type=str, help=\"Path to local config.json file (required if --local-paths is set).\"\n    )\n    parser.add_argument(\n        \"--checkpoint\", type=str, help=\"Path to local model checkpoint .pth file (required if --local-paths is set).\"\n    )\n    parser.add_argument(\n        \"--audio-prompt\", type=str, default=None, help=\"Path to an optional audio prompt WAV file for voice cloning.\"\n    )\n\n    gen_group = parser.add_argument_group(\"Generation Parameters\")\n    gen_group.add_argument(\n        \"--max-tokens\",\n        type=int,\n        default=None,\n        help=\"Maximum number of audio tokens to generate (defaults to config value).\",\n    )\n    gen_group.add_argument(\n        \"--cfg-scale\", type=float, default=3.0, help=\"Classifier-Free Guidance scale (default: 3.0).\"\n    )\n    gen_group.add_argument(\n        \"--temperature\", type=float, default=1.3, help=\"Sampling temperature (higher is more random, default: 0.7).\"\n    )\n    gen_group.add_argument(\"--top-p\", type=float, default=0.95, help=\"Nucleus sampling probability (default: 0.95).\")\n\n    infra_group = parser.add_argument_group(\"Infrastructure\")\n    infra_group.add_argument(\"--seed\", type=int, default=None, help=\"Random seed for reproducibility.\")\n    infra_group.add_argument(\n        \"--device\",\n        type=str,\n        default=\"cuda\" if torch.cuda.is_available() else \"cpu\",\n        help=\"Device to run inference on (e.g., 'cuda', 'cpu', default: auto).\",\n    )\n\n    args = parser.parse_args()\n\n    # Validation for local paths\n    if args.local_paths:\n        if not args.config:\n            parser.error(\"--config is required when --local-paths is set.\")\n        if not args.checkpoint:\n            parser.error(\"--checkpoint is required when --local-paths is set.\")\n        if not os.path.exists(args.config):\n            parser.error(f\"Config file not found: {args.config}\")\n        if not os.path.exists(args.checkpoint):\n            parser.error(f\"Checkpoint file not found: {args.checkpoint}\")\n\n    # Set seed if provided\n    if args.seed is not None:\n        set_seed(args.seed)\n        print(f\"Using user-selected seed: {args.seed}\")\n\n    # Determine device\n    device = torch.device(args.device)\n    print(f\"Using device: {device}\")\n\n    # Load model\n    print(\"Loading model...\")\n    if args.local_paths:\n        print(f\"Loading from local paths: config='{args.config}', checkpoint='{args.checkpoint}'\")\n        try:\n            model = Dia.from_local(args.config, args.checkpoint, device=device)\n        except Exception as e:\n            print(f\"Error loading local model: {e}\")\n            exit(1)\n    else:\n        print(f\"Loading from Hugging Face Hub: repo_id='{args.repo_id}'\")\n        try:\n            model = Dia.from_pretrained(args.repo_id, device=device)\n        except Exception as e:\n            print(f\"Error loading model from Hub: {e}\")\n            exit(1)\n    print(\"Model loaded.\")\n\n    # Generate audio\n    print(\"Generating audio...\")\n    try:\n        sample_rate = 44100  # Default assumption\n\n        output_audio = model.generate(\n            text=args.text,\n            audio_prompt=args.audio_prompt,\n            max_tokens=args.max_tokens,\n            cfg_scale=args.cfg_scale,\n            temperature=args.temperature,\n            top_p=args.top_p,\n        )\n        print(\"Audio generation complete.\")\n\n        print(f\"Saving audio to {args.output}...\")\n        os.makedirs(os.path.dirname(args.output) or \".\", exist_ok=True)\n\n        sf.write(args.output, output_audio, sample_rate)\n        print(f\"Audio successfully saved to {args.output}\")\n\n    except Exception as e:\n        print(f\"Error during audio generation or saving: {e}\")\n        exit(1)", "label": 0}
{"function": "def scroll_to_bottom():\n    js = \"\"\"\n    <script>\n        console.log(\"scroll_to_bottom\");\n        function scroll(dummy_var_to_force_repeat_execution){\n            var sections = parent.document.querySelectorAll('section.main');\n            console.log(sections);\n            for(let index = 0; index<sections.length; index++) {\n                sections[index].scrollTop = sections[index].scrollHeight;\n            }\n        }\n        scroll(1);\n    </script>\n    \"\"\"\n    st.components.v1.html(js, height=0, width=0)", "label": 0}
{"function": "  def testNestedMessageDescriptor(self):\n    field_name = 'optional_nested_message'\n    proto_type = unittest_pb2.TestAllTypes\n    self.assertEqual(\n        proto_type.NestedMessage.DESCRIPTOR,\n        proto_type.DESCRIPTOR.fields_by_name[field_name].message_type)", "label": 1}
{"function": "def init_omni_lmm(model_path):\n    torch.backends.cuda.matmul.allow_tf32 = True\n    disable_torch_init()\n    model_name = os.path.expanduser(model_path)\n    print(f'Load omni_lmm model and tokenizer from {model_name}')\n    tokenizer = AutoTokenizer.from_pretrained(\n        model_name, model_max_length=2048)\n\n    if False:\n        # model on multiple devices for small size gpu memory (Nvidia 3090 24G x2) \n        with init_empty_weights():\n            model = OmniLMMForCausalLM.from_pretrained(model_name, tune_clip=True, torch_dtype=torch.bfloat16)\n        model = load_checkpoint_and_dispatch(model, model_name, dtype=torch.bfloat16, \n                    device_map=\"auto\",  no_split_module_classes=['Eva','MistralDecoderLayer', 'ModuleList', 'Resampler']\n        )\n    else:\n        model = OmniLMMForCausalLM.from_pretrained(\n            model_name, tune_clip=True, torch_dtype=torch.bfloat16\n        ).to(device='cuda', dtype=torch.bfloat16)\n\n    image_processor = build_transform(\n        is_train=False, input_size=model.model.config.image_size, std_mode='OPENAI_CLIP')\n\n    mm_use_im_start_end = getattr(model.config, \"mm_use_im_start_end\", False)\n    assert mm_use_im_start_end\n\n    tokenizer.add_tokens([DEFAULT_IMAGE_PATCH_TOKEN, DEFAULT_IM_START_TOKEN,\n                         DEFAULT_IM_END_TOKEN], special_tokens=True)\n\n\n    vision_config = model.model.vision_config\n    vision_config.im_patch_token = tokenizer.convert_tokens_to_ids(\n        [DEFAULT_IMAGE_PATCH_TOKEN])[0]\n    vision_config.use_im_start_end = mm_use_im_start_end\n    vision_config.im_start_token, vision_config.im_end_token = tokenizer.convert_tokens_to_ids(\n        [DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN])\n    image_token_len = model.model.config.num_query\n\n    return model, image_processor, image_token_len, tokenizer", "label": 0}
{"function": "    def set_endpoint(self, *args, **kwargs):\n        \"\"\"\n        Alias for :meth:`Client.get_or_create_endpoint()`.\n\n        \"\"\"\n        return self.get_or_create_endpoint(*args, **kwargs)", "label": 1}
{"function": "def clear_fields():\n    \"\"\"\n    Clears the 3D viewer, the stored target_dir, and empties the gallery.\n    \"\"\"\n    return None", "label": 0}
{"function": "    def _unwrap_object(self, space, w_obj):\n        return space.int_w(w_obj)", "label": 1}
{"function": "def http_get(\n    url: str, params: dict = None, headers: dict = None\n) -> dict:\n    if params:\n        encoded_params = urlencode(params)\n        full_url = f'{url}?{encoded_params}'\n    else:\n        full_url = url\n    request = Request(full_url, method='GET', headers=headers or {})\n    content: bytes = None\n    with urlopen(request) as response:\n        content = response.read()\n    return (\n        json.loads(str(content, 'utf-8'))\n        if content is not None else None)", "label": 0}
{"function": "def main():\n    \"\"\"Main entry point for the AIHawk Job Application Bot.\"\"\"\n    try:\n        # Define and validate the data folder\n        data_folder = Path(\"data_folder\")\n        secrets_file, config_file, plain_text_resume_file, output_folder = FileManager.validate_data_folder(data_folder)\n\n        # Validate configuration and secrets\n        config = ConfigValidator.validate_config(config_file)\n        llm_api_key = ConfigValidator.validate_secrets(secrets_file)\n\n        # Prepare parameters\n        config[\"uploads\"] = FileManager.get_uploads(plain_text_resume_file)\n        config[\"outputFileDirectory\"] = output_folder\n\n        # Interactive prompt for user to select actions\n        selected_actions = prompt_user_action()\n\n        # Handle selected actions and execute them\n        handle_inquiries(selected_actions, config, llm_api_key)\n\n    except ConfigError as ce:\n        logger.error(f\"Configuration error: {ce}\")\n        logger.error(\n            \"Refer to the configuration guide for troubleshooting: \"\n            \"https://github.com/feder-cr/Auto_Jobs_Applier_AIHawk?tab=readme-ov-file#configuration\"\n        )\n    except FileNotFoundError as fnf:\n        logger.error(f\"File not found: {fnf}\")\n        logger.error(\"Ensure all required files are present in the data folder.\")\n    except RuntimeError as re:\n        logger.error(f\"Runtime error: {re}\")\n        logger.debug(traceback.format_exc())\n    except Exception as e:\n        logger.exception(f\"An unexpected error occurred: {e}\")", "label": 0}
{"function": "async def test_list_dir(computer):\n    tmp_dir = \"test_list_dir\"\n    if not await computer.interface.directory_exists(tmp_dir):\n        await computer.interface.create_dir(tmp_dir)\n    files = [\"foo.txt\", \"bar.txt\"]\n    for fname in files:\n        await computer.interface.write_text(f\"{tmp_dir}/{fname}\", \"hi\")\n    result = await computer.interface.list_dir(tmp_dir)\n    assert set(result) >= set(files), f\"Directory {tmp_dir} should contain files {files}\"\n    for fname in files:\n        await computer.interface.delete_file(f\"{tmp_dir}/{fname}\")\n    await computer.interface.delete_dir(tmp_dir)", "label": 0}
{"function": "def main(config_path):\n    config = load_config(config_path)\n    task_instances = initialize_tasks_and_models(config)\n\n    # \u4ece\u914d\u7f6e\u6587\u4ef6\u4e2d\u83b7\u53d6\u8f93\u5165\u6570\u636e\u8def\u5f84\n    input_data = config.get('inputs', None)\n    result_path = config.get('outputs', 'outputs')\n\n    # formula_detection_task\n    model_formula_detection = task_instances['formula_detection']\n    detection_results = model_formula_detection.predict(input_data, result_path)\n    print(detection_results)", "label": 0}
{"function": "\tdef set_PageNum(self,PageNum):\n\t\tself.add_query_param('PageNum',PageNum)", "label": 1}
{"function": "    def fp(self):\n        return self.value.fp", "label": 1}
{"function": "    def on_dialog(self, dialog, title):\n        pass", "label": 1}
{"function": "    def from_dict(dct):\n        \"\"\"\n        Create a :class:`~kartothek.io_components.metapartition.MetaPartition` from a dictionary.\n\n        Parameters\n        ----------\n        dct : dict\n            Dictionary containing constructor arguments as keys\n\n        Returns\n        -------\n\n        \"\"\"\n        return MetaPartition(\n            label=dct[\"label\"],\n            files=dct.get(\"files\", {}),\n            metadata=dct.get(\"metadata\", {}),\n            data=dct.get(\"data\", {}),\n            indices=dct.get(\"indices\", {}),\n            metadata_version=dct.get(\"metadata_version\", None),\n            dataset_metadata=dct.get(\"dataset_metadata\", {}),\n            table_meta=dct.get(\"table_meta\", {}),\n            partition_keys=dct.get(\"partition_keys\", None),\n            logical_conjunction=dct.get(\"logical_conjunction\", None),\n        )", "label": 1}
{"function": "async def generate(request: Request):\n    logger.info(\"Worker generating...\")\n    params = await request.json()\n    uid = uuid.uuid4()\n    try:\n        file_path, uid = worker.generate(uid, params)\n        return FileResponse(file_path)\n    except ValueError as e:\n        traceback.print_exc()\n        print(\"Caught ValueError:\", e)\n        ret = {\n            \"text\": server_error_msg,\n            \"error_code\": 1,\n        }\n        return JSONResponse(ret, status_code=404)\n    except torch.cuda.CudaError as e:\n        print(\"Caught torch.cuda.CudaError:\", e)\n        ret = {\n            \"text\": server_error_msg,\n            \"error_code\": 1,\n        }\n        return JSONResponse(ret, status_code=404)\n    except Exception as e:\n        print(\"Caught Unknown Error\", e)\n        traceback.print_exc()\n        ret = {\n            \"text\": server_error_msg,\n            \"error_code\": 1,\n        }\n        return JSONResponse(ret, status_code=404)", "label": 0}
{"function": "  def testUpdateCloudStorageDependenciesNoWrite(\n      self, base_config_cs_mock, uploader_cs_mock):\n    self.fs.CreateFile(self.file_path,\n                       contents='\\n'.join(self.expected_file_lines))\n    config = dependency_manager.BaseConfig(self.file_path, writable=True)\n\n    self.assertRaises(ValueError, config.AddCloudStorageDependencyUpdateJob,\n                      'dep', 'plat', 'path')\n    self.assertRaises(ValueError, config.AddCloudStorageDependencyUpdateJob,\n                      'dep', 'plat', 'path', version='1.2.3')\n\n    expected_dependencies = self.dependencies\n    config = dependency_manager.BaseConfig(self.file_path, writable=True)\n    self.assertFalse(config._IsDirty())\n    self.assertFalse(config._pending_uploads)\n    self.assertEqual(expected_dependencies, config._config_data)\n\n    base_config_cs_mock.CalculateHash.return_value = self.new_dep_hash\n    uploader_cs_mock.Exists.return_value = False\n    expected_dependencies = self.new_dependencies\n    config.AddCloudStorageDependencyUpdateJob(\n        'dep1', 'plat2', self.new_dep_path, execute_job=False)\n    self.assertTrue(config._IsDirty())\n    self.assertEqual(1, len(config._pending_uploads))\n    self.assertEqual(self.new_pending_upload, config._pending_uploads[0])\n    self.assertEqual(expected_dependencies, config._config_data)\n    # check that file contents have not been updated.\n    expected_file_lines = list(self.expected_file_lines)\n    file_module = fake_filesystem.FakeFileOpen(self.fs)\n    for line in file_module(self.file_path):\n      self.assertEqual(expected_file_lines.pop(0), line.strip())\n    self.fs.CloseOpenFile(file_module(self.file_path))\n\n    expected_dependencies = self.final_dependencies\n    base_config_cs_mock.CalculateHash.return_value = self.final_dep_hash\n    config.AddCloudStorageDependencyUpdateJob(\n        'dep2', 'plat1', self.final_dep_path, execute_job=False)\n    self.assertTrue(config._IsDirty())\n    self.assertEqual(expected_dependencies, config._config_data)\n    # check that file contents have not been updated.\n    expected_file_lines = list(self.expected_file_lines)\n    file_module = fake_filesystem.FakeFileOpen(self.fs)\n    for line in file_module(self.file_path):\n      self.assertEqual(expected_file_lines.pop(0), line.strip())\n    self.fs.CloseOpenFile(file_module(self.file_path))", "label": 1}
{"function": "\tdef get_OwnerId(self):\n\t\treturn self.get_query_params().get('OwnerId')", "label": 1}
{"function": "    def cffi_type(self, space):\n        state = space.fromcache(State)\n        return state.c_long", "label": 1}
{"function": "    def __str__(self):\n        return self.name", "label": 1}
{"function": "def main(config_path):\n    config = load_config(config_path)\n    task_instances = initialize_tasks_and_models(config)\n\n    # get input and output path from config\n    input_data = config.get('inputs', None)\n    result_path = config.get('outputs', 'outputs'+'/'+TASK_NAME)\n\n    # layout_detection_task\n    model_layout_detection = task_instances[TASK_NAME]\n\n    # for image detection\n    detection_results = model_layout_detection.predict_images(input_data, result_path)\n\n    # for pdf detection\n    # detection_results = model_layout_detection.predict_pdfs(input_data, result_path)\n\n    # print(detection_results)\n    print(f'The predicted results can be found at {result_path}')", "label": 0}
{"function": "async def test_exclude_all_types():\n    \"\"\"Test excluding all entity types (edge case).\"\"\"\n    graphiti = Graphiti(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD)\n\n    try:\n        await graphiti.build_indices_and_constraints()\n\n        entity_types = {\n            'Person': Person,\n            'Organization': Organization,\n        }\n\n        # Exclude all types\n        result = await graphiti.add_episode(\n            name='No Entities',\n            episode_body='This text mentions John and Microsoft but no entities should be created.',\n            source_description='Test content',\n            reference_time=datetime.now(timezone.utc),\n            entity_types=entity_types,\n            excluded_entity_types=['Entity', 'Person', 'Organization'],  # Exclude everything\n            group_id='test_exclude_all',\n        )\n\n        assert result is not None\n\n        # Search for nodes - should find very few or none from this episode\n        search_results = await graphiti.search_(\n            query='John Microsoft', group_ids=['test_exclude_all']\n        )\n\n        # There should be minimal to no entities created\n        found_nodes = search_results.nodes\n        assert len(found_nodes) == 0, (\n            f'Expected no entities, but found: {[n.name for n in found_nodes]}'\n        )\n\n        # Clean up\n        await _cleanup_test_nodes(graphiti, 'test_exclude_all')\n\n    finally:\n        await graphiti.close()", "label": 0}
{"function": "    def init_ui(self):\n        # \u521b\u5efa\u4e3b\u5e03\u5c40\n        main_layout = QVBoxLayout(self)\n        main_layout.setContentsMargins(16, 16, 16, 16)\n        main_layout.setSpacing(8)\n\n        # \u9876\u90e8\u63a7\u5236\u533a\u57df\n        top_layout = QHBoxLayout()\n        top_layout.setSpacing(8)\n\n        # \u4efb\u52a1\u7c7b\u578b\u9009\u62e9\n        self.task_type_combo = ComboBox()\n        self.task_type_combo.addItems([str(task_type) for task_type in BatchTaskType])\n        self.task_type_combo.setCurrentText(str(BatchTaskType.FULL_PROCESS))\n\n        # \u63a7\u5236\u6309\u94ae\n        self.add_file_btn = PushButton(\"\u6dfb\u52a0\u6587\u4ef6\", icon=FIF.ADD)\n        self.start_all_btn = PushButton(\"\u5f00\u59cb\u5904\u7406\", icon=FIF.PLAY)\n        self.clear_btn = PushButton(\"\u6e05\u7a7a\u5217\u8868\", icon=FIF.DELETE)\n\n        # \u6dfb\u52a0\u5230\u9876\u90e8\u5e03\u5c40\n        top_layout.addWidget(self.task_type_combo)\n        top_layout.addWidget(self.add_file_btn)\n        top_layout.addWidget(self.clear_btn)\n\n        top_layout.addStretch()\n        top_layout.addWidget(self.start_all_btn)\n\n        # \u521b\u5efa\u4efb\u52a1\u8868\u683c\n        self.task_table = TableWidget()\n        self.task_table.setColumnCount(3)\n        self.task_table.setHorizontalHeaderLabels([\"\u6587\u4ef6\u540d\", \"\u8fdb\u5ea6\", \"\u72b6\u6001\"])\n\n        # \u8bbe\u7f6e\u8868\u683c\u6837\u5f0f\n        self.task_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)\n        self.task_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.Fixed)\n        self.task_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Fixed)\n        self.task_table.setColumnWidth(1, 250)  # \u8fdb\u5ea6\u6761\u5217\u5bbd\n        self.task_table.setColumnWidth(2, 160)  # \u72b6\u6001\u5217\u5bbd\n\n        # \u8bbe\u7f6e\u884c\u9ad8\n        self.task_table.verticalHeader().setDefaultSectionSize(40)  # \u8bbe\u7f6e\u9ed8\u8ba4\u884c\u9ad8\n\n        # \u8bbe\u7f6e\u8868\u683c\u8fb9\u6846\n        self.task_table.setBorderVisible(True)\n        self.task_table.setBorderRadius(12)\n\n        # \u8bbe\u7f6e\u8868\u683c\u4e0d\u53ef\u7f16\u8f91\n        self.task_table.setEditTriggers(QTableWidget.NoEditTriggers)\n\n        # \u8bbe\u7f6e\u8868\u683c\u5927\u5c0f\u7b56\u7565\n        self.task_table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        self.task_table.setMinimumHeight(300)  # \u8bbe\u7f6e\u6700\u5c0f\u9ad8\u5ea6\n\n        # \u8fde\u63a5\u53cc\u51fb\u4fe1\u53f7\n        self.task_table.doubleClicked.connect(self.on_table_double_clicked)\n\n        # \u6dfb\u52a0\u5230\u4e3b\u5e03\u5c40\n        main_layout.addLayout(top_layout)\n        main_layout.addWidget(self.task_table)\n\n        # \u8fde\u63a5\u4fe1\u53f7\n        self.add_file_btn.clicked.connect(self.on_add_file_clicked)\n        self.start_all_btn.clicked.connect(self.start_all_tasks)\n        self.clear_btn.clicked.connect(self.clear_tasks)\n        self.task_type_combo.currentTextChanged.connect(self.on_task_type_changed)", "label": 0}
{"function": "    def forward(self, x):\n        if self.num_route_nodes != -1:\n            priors = x[None, :, :, None, :] @ self.route_weights[:, None, :, :, :]\n\n            logits = Variable(torch.zeros(*priors.size()))\n            if self.use_cuda:\n                logits = logits.cuda()\n            for i in range(self.num_iterations):\n                probs = softmax(logits, dim=2)\n                outputs = self.squash((probs * priors).sum(dim=2, keepdim=True))\n\n                if i != self.num_iterations - 1:\n                    delta_logits = (priors * outputs).sum(dim=-1, keepdim=True)\n                    logits = logits + delta_logits\n        else:\n            outputs = [capsule(x).view(x.size(0), -1, 1) for capsule in self.capsules]\n            outputs = torch.cat(outputs, dim=-1)\n            outputs = self.squash(outputs)\n\n        return outputs", "label": 1}
{"function": "    def temperature_unit(self):\n        \"\"\"Return the unit of measurement.\"\"\"\n        return self._unit_of_measurement", "label": 1}
{"function": "def save_env_vars(env_vars):\n    \"\"\"Save environment variables to .env file\n\n    Args:\n        env_vars: Dictionary, keys are environment variable names, values can be strings or (value, source) tuples\n    \"\"\"\n    try:\n        dotenv_path = init_env_file()\n\n        # Save each environment variable\n        for key, value_data in env_vars.items():\n            if key and key.strip():  # Ensure key is not empty\n                # Handle case where value might be a tuple\n                if isinstance(value_data, tuple):\n                    value = value_data[0]\n                else:\n                    value = value_data\n\n                set_key(dotenv_path, key.strip(), value.strip())\n\n        # Reload environment variables to ensure they take effect\n        load_dotenv(dotenv_path, override=True)\n\n        return True, \"Environment variables have been successfully saved!\"\n    except Exception as e:\n        return False, f\"Error saving environment variables: {str(e)}\"", "label": 0}
{"function": "def call_this():\n    print('break here')", "label": 1}
{"function": "def is_cuda_available() -> bool:\n    \"\"\"Returns True if cuda devices exist.\"\"\"\n    return torch.cuda.is_available()", "label": 0}
{"function": "    def __call__(self, env, *args, **kw):\n        if self.init_kw is not None:\n            # Merge call kws into init kws;\n            # but don't bash self.init_kw.\n            if kw is not None:\n                call_kw = kw\n                kw = self.init_kw.copy()\n                kw.update(call_kw)\n            else:\n                kw = self.init_kw\n        env.Append(TOOLS=[self.name])\n        if hasattr(self, 'options'):\n            import SCons.Variables\n            if 'options' not in env:\n                from SCons.Script import ARGUMENTS\n                env['options'] = SCons.Variables.Variables(args=ARGUMENTS)\n            opts = env['options']\n\n            self.options(opts)\n            opts.Update(env)\n\n        self.generate(env, *args, **kw)", "label": 1}
{"function": "  def testExecuteUpdateJobsSuccessOnePendingDepCloudStorageCollision(\n      self, uploader_cs_mock):\n    uploader_cs_mock.Exists.return_value = True\n    self.fs.CreateFile(self.file_path,\n                       contents='\\n'.join(self.expected_file_lines))\n    config = dependency_manager.BaseConfig(self.file_path, writable=True)\n    config._config_data = self.new_dependencies.copy()\n    config._pending_uploads = [self.new_pending_upload]\n    self.assertEqual(self.new_dependencies, config._config_data)\n    self.assertTrue(config._IsDirty())\n    self.assertEqual(1, len(config._pending_uploads))\n    self.assertEqual(self.new_pending_upload, config._pending_uploads[0])\n    expected_exists_calls = [mock.call(self.new_bucket, self.new_remote_path)]\n    expected_insert_calls = [mock.call(self.new_bucket, self.new_remote_path,\n                                       self.new_dep_path)]\n    expected_copy_calls = [mock.call(self.new_bucket, self.new_bucket,\n                                     self.new_remote_path,\n                                     self.expected_new_backup_path)]\n\n    self.assertTrue(config.ExecuteUpdateJobs(force=True))\n    self.assertFalse(config._IsDirty())\n    self.assertFalse(config._pending_uploads)\n    self.assertEqual(self.new_dependencies, config._config_data)\n    file_module = fake_filesystem.FakeFileOpen(self.fs)\n    expected_file_lines = list(self.new_expected_file_lines)\n    for line in file_module(self.file_path):\n      self.assertEqual(expected_file_lines.pop(0), line.strip())\n    self.fs.CloseOpenFile(file_module(self.file_path))\n    self.assertFalse(config._pending_uploads)\n    self.assertEqual(expected_insert_calls,\n                     uploader_cs_mock.Insert.call_args_list)\n    self.assertEqual(expected_exists_calls,\n                     uploader_cs_mock.Exists.call_args_list)\n    self.assertEqual(expected_copy_calls,\n                     uploader_cs_mock.Copy.call_args_list)", "label": 1}
{"function": "    async def connect(self):\n        self.set_runtime_status(RuntimeStatus.STARTING_RUNTIME)\n\n        if self.attach_to_existing:\n            active_devboxes = self.runloop_api_client.devboxes.list(\n                status='running'\n            ).devboxes\n            self.devbox = next(\n                (devbox for devbox in active_devboxes if devbox.name == self.sid), None\n            )\n\n        if self.devbox is None:\n            self.devbox = self._create_new_devbox()\n\n        # Create tunnel - this will return a stable url, so is safe to call if we are attaching to existing\n        tunnel = self.runloop_api_client.devboxes.create_tunnel(\n            id=self.devbox.id,\n            port=self._sandbox_port,\n        )\n\n        self.api_url = tunnel.url\n        logger.info(f'Container started. Server url: {self.api_url}')\n\n        # End Runloop connect\n        # NOTE: Copied from DockerRuntime\n        logger.info('Waiting for client to become ready...')\n        self.set_runtime_status(RuntimeStatus.STARTING_RUNTIME)\n        self._wait_until_alive()\n\n        if not self.attach_to_existing:\n            self.setup_initial_env()\n\n        logger.info(\n            f'Container initialized with plugins: {[plugin.name for plugin in self.plugins]}'\n        )\n        self.set_runtime_status(RuntimeStatus.READY)", "label": 0}
{"function": "def asr_page():\n    st.title(\"\ud83c\udfaf ASR \u89c6\u9891\u5b57\u5e55\u8bc6\u522b\")\n    st.markdown(\"---\")\n\n    # \u521d\u59cb\u5316session state\n    if \"srt_content\" not in st.session_state:\n        st.session_state.srt_content = None\n    if \"subtitle_path\" not in st.session_state:\n        st.session_state.subtitle_path = None\n    if \"asr_data\" not in st.session_state:\n        st.session_state.asr_data = None\n    if \"translated_asr_data\" not in st.session_state:\n        st.session_state.translated_asr_data = None\n\n    temp_dir = create_temp_dir()\n\n    # \u521b\u5efa\u4e24\u5217\u5e03\u5c40\n    col1, col2 = st.columns([1, 1])\n\n    with col1:\n        st.markdown(\"### \ud83d\udcfa \u89c6\u9891\u9884\u89c8\")\n        video_file = st.file_uploader(\n            label=\"\u4e0a\u4f20\u89c6\u9891\u6587\u4ef6\",\n            type=[\"mp4\", \"mov\", \"avi\", \"mkv\", \"flv\"],\n            key=\"asr_video\",\n            accept_multiple_files=False,\n            label_visibility=\"collapsed\",\n            help=\"\u652f\u6301\u7684\u89c6\u9891\u683c\u5f0f: MP4, MOV, AVI, MKV, WMV, FLV, WebM, M4V\",\n        )\n        video_placeholder = st.empty()\n\n        if video_file:\n            video_path = temp_dir / video_file.name\n            # \u68c0\u67e5\u6587\u4ef6\u662f\u5426\u5df2\u5b58\u5728\uff0c\u907f\u514d\u91cd\u590d\u5199\u5165\n            if not video_path.exists():\n                with open(video_path, \"wb\") as f:\n                    f.write(video_file.getbuffer())\n                logger.info(f\"\u89c6\u9891\u6587\u4ef6\u5df2\u4fdd\u5b58\u5230: {video_path}\")\n\n            video_placeholder.video(\n                video_file,\n                subtitles=(\n                    st.session_state.subtitle_path\n                    if st.session_state.subtitle_path\n                    else None\n                ),\n            )\n\n    with col2:\n        st.markdown(\"### \ud83c\udfaf \u64cd\u4f5c\u9762\u677f\")\n        if video_file is not None:\n            st.success(\"\u2705 \u89c6\u9891\u4e0a\u4f20\u6210\u529f\uff01\")\n\n            if st.button(\"\ud83d\ude80 \u5f00\u59cb\u8bc6\u522b\", use_container_width=True):\n                with st.spinner(\"\u23f3 \u6b63\u5728\u5904\u7406\u4e2d...\"):\n                    try:\n                        logger.info(f\"\u5f00\u59cb\u5904\u7406\u89c6\u9891\u6587\u4ef6: {video_file.name}\")\n                        # \u8f6c\u6362\u4e3a\u97f3\u9891\n                        audio_path = temp_dir / f\"{video_path.stem}.wav\"\n                        logger.info(f\"\u5f00\u59cb\u5c06\u89c6\u9891\u8f6c\u6362\u4e3a\u97f3\u9891: {audio_path}\")\n                        is_success = video2audio(str(video_path), str(audio_path))\n\n                        if not is_success:\n                            logger.error(\"\u97f3\u9891\u8f6c\u6362\u5931\u8d25\")\n                            st.error(\"\u97f3\u9891\u8f6c\u6362\u5931\u8d25\")\n                            return\n\n                        logger.info(\"\u5f00\u59cbASR\u8bc6\u522b\")\n                        # \u4f7f\u7528BcutASR\u8fdb\u884c\u8bc6\u522b\n                        asr = BcutASR(str(audio_path))\n                        asr_data = asr.run()\n                        logger.info(\"ASR\u8bc6\u522b\u5b8c\u6210\")\n\n                        st.session_state.srt_content = asr_data.to_srt()\n                        st.session_state.asr_data = asr_data\n\n                        # \u4fdd\u5b58\u5b57\u5e55\u6587\u4ef6\n                        subtitle_path = temp_dir / f\"{video_path.stem}.srt\"\n                        logger.info(f\"\u4fdd\u5b58\u5b57\u5e55\u6587\u4ef6\u5230: {subtitle_path}\")\n                        with open(subtitle_path, \"w\", encoding=\"utf-8\") as f:\n                            f.write(st.session_state.srt_content)\n\n                        st.session_state.subtitle_path = str(subtitle_path)\n\n                        # \u4f7f\u7528\u4e4b\u524d\u521b\u5efa\u7684\u5bb9\u5668\u66f4\u65b0\u89c6\u9891\u663e\u793a\n                        video_placeholder.video(\n                            video_file, subtitles=st.session_state.subtitle_path\n                        )\n\n                        logger.info(\"\u5b57\u5e55\u8bc6\u522b\u5168\u6d41\u7a0b\u5b8c\u6210\")\n                        st.success(\"\u2728 \u8bc6\u522b\u5b8c\u6210\uff01\")\n\n                        # \u663e\u793a\u5b57\u5e55\u7edf\u8ba1\u4fe1\u606f\n                        if st.session_state.asr_data:\n                            st.markdown(\"### \ud83d\udcca \u5b57\u5e55\u7edf\u8ba1\")\n                            segments = st.session_state.asr_data.segments\n                            total_segments = len(segments)\n                            total_duration = sum(\n                                seg.end_time - seg.start_time for seg in segments\n                            )\n                            total_chars = sum(len(seg.text.strip()) for seg in segments)\n                            avg_segment_duration = (\n                                total_duration / total_segments\n                                if total_segments > 0\n                                else 0\n                            )\n\n                            col_stats1, col_stats2, col_stats3 = st.columns(3)\n                            with col_stats1:\n                                st.metric(\"\u5b57\u5e55\u6bb5\u843d\u6570\", f\"{total_segments} \u6bb5\")\n                            with col_stats2:\n                                st.metric(\"\u603b\u65f6\u957f\", format_duration(total_duration))\n                            with col_stats3:\n                                st.metric(\"\u603b\u5b57\u6570\", f\"{total_chars} \u5b57\")\n\n                    except Exception as e:\n                        logger.exception(f\"\u5904\u7406\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u9519\u8bef: {str(e)}\")\n                        st.error(f\"\u5904\u7406\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u9519\u8bef: {str(e)}\")\n                    finally:\n                        # \u6e05\u7406\u97f3\u9891\u6587\u4ef6\n                        if \"audio_path\" in locals() and audio_path.exists():\n                            logger.info(f\"\u6e05\u7406\u4e34\u65f6\u97f3\u9891\u6587\u4ef6: {audio_path}\")\n                            os.remove(audio_path)\n\n            # \u5982\u679c\u6709\u5b57\u5e55\u5185\u5bb9\uff0c\u663e\u793a\u9884\u89c8\u548c\u4e0b\u8f7d\u533a\u57df\n            if st.session_state.srt_content and st.session_state.asr_data:\n                st.markdown(\"---\")\n                # \u521b\u5efa\u5b57\u5e55\u9884\u89c8\u533a\u57df\n                with st.expander(\"\ud83d\udcdd \u5b57\u5e55\u9884\u89c8\", expanded=True):\n                    # \u6dfb\u52a0\u641c\u7d22\u6846\u548c\u8fc7\u6ee4\u9009\u9879\n                    search_term = st.text_input(\n                        \"\ud83d\udd0d \u641c\u7d22\u5b57\u5e55\u5185\u5bb9\",\n                        key=\"subtitle_search\",\n                        placeholder=\"\u8f93\u5165\u5173\u952e\u8bcd\u8fdb\u884c\u641c\u7d22...\",\n                    )\n\n                    # \u5c06\u5b57\u5e55\u5185\u5bb9\u8f6c\u6362\u4e3aDataFrame\u683c\u5f0f\u663e\u793a\n                    segments = st.session_state.asr_data.segments\n                    df = pd.DataFrame(\n                        [\n                            {\n                                \"\u5e8f\u53f7\": i + 1,\n                                \"\u5f00\u59cb\u65f6\u95f4\": format_time(seg.start_time),\n                                \"\u7ed3\u675f\u65f6\u95f4\": format_time(seg.end_time),\n                                \"\u65f6\u957f(\u79d2)\": round(\n                                    (seg.end_time - seg.start_time) / 1000, 1\n                                ),\n                                \"\u5b57\u5e55\u6587\u672c\": seg.text.strip(),\n                            }\n                            for i, seg in enumerate(segments)\n                        ]\n                    )\n\n                    # \u5e94\u7528\u8fc7\u6ee4\u6761\u4ef6\n                    if search_term:\n                        df = df[\n                            df[\"\u5b57\u5e55\u6587\u672c\"].str.contains(\n                                search_term, case=False, na=False\n                            )\n                        ]\n\n                    # \u4f7f\u7528\u81ea\u5b9a\u4e49\u6837\u5f0f\u663e\u793a\u6570\u636e\n                    st.dataframe(\n                        df,\n                        use_container_width=True,\n                        height=400,\n                        hide_index=True,\n                        column_config={\n                            \"\u5e8f\u53f7\": st.column_config.NumberColumn(\n                                \"\u5e8f\u53f7\", help=\"\u5b57\u5e55\u6bb5\u843d\u5e8f\u53f7\", format=\"%d\", width=\"small\"\n                            ),\n                            \"\u5f00\u59cb\u65f6\u95f4\": st.column_config.TextColumn(\n                                \"\u5f00\u59cb\u65f6\u95f4\", help=\"\u5b57\u5e55\u5f00\u59cb\u65f6\u95f4\", width=\"small\"\n                            ),\n                            \"\u7ed3\u675f\u65f6\u95f4\": st.column_config.TextColumn(\n                                \"\u7ed3\u675f\u65f6\u95f4\", help=\"\u5b57\u5e55\u7ed3\u675f\u65f6\u95f4\", width=\"small\"\n                            ),\n                            \"\u65f6\u957f(\u79d2)\": st.column_config.NumberColumn(\n                                \"\u65f6\u957f(\u79d2)\",\n                                help=\"\u5b57\u5e55\u6301\u7eed\u65f6\u95f4\",\n                                format=\"%.1f\",\n                                width=\"small\",\n                            ),\n                            \"\u5b57\u5e55\u6587\u672c\": st.column_config.TextColumn(\n                                \"\u5b57\u5e55\u6587\u672c\", help=\"\u8bc6\u522b\u51fa\u7684\u5b57\u5e55\u5185\u5bb9\", width=\"medium\"\n                            ),\n                        },\n                    )\n\n                # \u4e0b\u8f7d\u6309\u94ae\u533a\u57df\n                st.markdown(\"### \ud83d\udcbe \u5bfc\u51fa\u5b57\u5e55\")\n                st.download_button(\n                    label=\"\ud83d\udce5 \u4e0b\u8f7d SRT \u5b57\u5e55\u6587\u4ef6\",\n                    data=st.session_state.srt_content,\n                    file_name=f\"{video_file.name.rsplit('.', 1)[0]}.srt\",\n                    mime=\"text/plain\",\n                    use_container_width=True,\n                )", "label": 0}
{"function": "    def test_setitem_with_keys_list_and_no_keypath_separator(self):\n        d = {\n            'a': {\n                'b': {\n                    'c': 1,\n                    'd': 2,\n                },\n            },\n        }\n        b = KeypathDict(d, keypath_separator=None)\n        b['a', 'b', 'c'] = 3\n        with self.assertRaises(KeyError):\n            val = b['a.b.c']\n            print(val)\n        self.assertEqual(b['a', 'b', 'c'], 3)\n\n        b['a', 'b', 'd'] = 4\n        with self.assertRaises(KeyError):\n            val = b['a.b.d']\n            print(val)\n        self.assertEqual(b['a', 'b', 'd'], 4)\n\n        b['a', 'b', 'e'] = 5\n        with self.assertRaises(KeyError):\n            val = b['a.b.e']\n            print(val)\n        self.assertEqual(b['a', 'b', 'e'], 5)", "label": 1}
{"function": "def setup_span_processor():\n    set_trace_processors([SPAN_PROCESSOR_TESTING])", "label": 0}
{"function": "    def rule_schema_version(self):\n        \"\"\"Returns the schema version of the rules.\n\n        Returns:\n            int. The schema version of the rules.\n        \"\"\"\n        return self._rule_schema_version", "label": 1}
{"function": "def _SqueezeGrad(op, grad):\n  return _ReshapeToInput(op, grad)", "label": 1}
{"function": "def get_video_paths(root_path: Path, extensions: list) -> list:\n    \"\"\"\n    Get a list of video paths from the root path with the specified extensions.\n\n    Args:\n        root_path (Path): The root directory containing video files.\n        extensions (list): List of file extensions to include.\n\n    Returns:\n        list: List of video file paths.\n    \"\"\"\n    return [str(path.resolve()) for path in root_path.iterdir() if path.suffix in extensions]", "label": 0}
{"function": "    def from_partition(\n        partition,\n        data=None,\n        dataset_metadata=None,\n        indices=None,\n        metadata_version=None,\n        table_meta=None,\n        partition_keys=None,\n        logical_conjunction=None,\n    ):\n        \"\"\"\n        Transform a kartothek :class:`~kartothek.core.partition.Partition` into a\n        :class:`~kartothek.io_components.metapartition.MetaPartition`.\n\n        Parameters\n        ----------\n        partition : :class:`~kartothek.core.partition.Partition`\n            The kartothek partition to be wrapped\n        data : dict, optional\n            A dictionaries with materialised :class:`~pandas.DataFrame`\n        dataset_metadata : dict of basestring, optional\n            The metadata of the original dataset\n        indices : dict\n            The index dictionary of the dataset\n        table_meta: Union[None, Dict[String, pyarrow.Schema]]\n            Type metadata for each table, optional\n        metadata_version: int, optional\n        partition_keys: Union[None, List[String]]\n            A list of the primary partition keys\n        Returns\n        -------\n        :class:`~kartothek.io_components.metapartition.MetaPartition`\n        \"\"\"\n        return MetaPartition(\n            label=partition.label,\n            files=partition.files,\n            data=data,\n            dataset_metadata=dataset_metadata,\n            indices=indices,\n            metadata_version=metadata_version,\n            table_meta=table_meta,\n            partition_keys=partition_keys,\n            logical_conjunction=logical_conjunction,\n        )", "label": 1}
{"function": "def parse_opt():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', nargs='+', type=str, default=ROOT / 'yolo.pt', help='model path or triton URL')\n    parser.add_argument('--source', type=str, default=ROOT / 'data/images', help='file/dir/URL/glob/screen/0(webcam)')\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='(optional) dataset.yaml path')\n    parser.add_argument('--imgsz', '--img', '--img-size', nargs='+', type=int, default=[640], help='inference size h,w')\n    parser.add_argument('--conf-thres', type=float, default=0.25, help='confidence threshold')\n    parser.add_argument('--iou-thres', type=float, default=0.45, help='NMS IoU threshold')\n    parser.add_argument('--max-det', type=int, default=1000, help='maximum detections per image')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--view-img', action='store_true', help='show results')\n    parser.add_argument('--save-txt', action='store_true', help='save results to *.txt')\n    parser.add_argument('--save-conf', action='store_true', help='save confidences in --save-txt labels')\n    parser.add_argument('--save-crop', action='store_true', help='save cropped prediction boxes')\n    parser.add_argument('--nosave', action='store_true', help='do not save images/videos')\n    parser.add_argument('--classes', nargs='+', type=int, help='filter by class: --classes 0, or --classes 0 2 3')\n    parser.add_argument('--agnostic-nms', action='store_true', help='class-agnostic NMS')\n    parser.add_argument('--augment', action='store_true', help='augmented inference')\n    parser.add_argument('--visualize', action='store_true', help='visualize features')\n    parser.add_argument('--update', action='store_true', help='update all models')\n    parser.add_argument('--project', default=ROOT / 'runs/detect', help='save results to project/name')\n    parser.add_argument('--name', default='exp', help='save results to project/name')\n    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n    parser.add_argument('--line-thickness', default=3, type=int, help='bounding box thickness (pixels)')\n    parser.add_argument('--hide-labels', default=False, action='store_true', help='hide labels')\n    parser.add_argument('--hide-conf', default=False, action='store_true', help='hide confidences')\n    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')\n    parser.add_argument('--dnn', action='store_true', help='use OpenCV DNN for ONNX inference')\n    parser.add_argument('--vid-stride', type=int, default=1, help='video frame-rate stride')\n    opt = parser.parse_args()\n    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand\n    print_args(vars(opt))\n    return opt", "label": 0}
{"function": "    def cmd_internal_windows(self):\n        \"\"\"Return info for each internal window (bars, for example)\"\"\"\n        return [\n            i.info() for i in self.windows_map.values()\n            if isinstance(i, window.Internal)\n        ]", "label": 1}
{"function": "    def __init__(self, model_path) -> None:\n        self.model = AutoModel.from_pretrained(model_path, trust_remote_code=True).to(dtype=torch.float16)\n        self.tokenizer = AutoTokenizer.from_pretrained(model_path, trust_remote_code=True)\n        self.model.eval().cuda()", "label": 0}
{"function": "    def name(self):\n        return self._name", "label": 1}
{"function": "    def cffi_type(self, space):\n        state = space.fromcache(State)\n        return state.c_ulong", "label": 1}
{"function": "def parse_args():\n    parser = argparse.ArgumentParser(description=\"Run a task with a given configuration file.\")\n    parser.add_argument('--config', type=str, required=True, help='Path to the configuration file.')\n    return parser.parse_args()", "label": 0}
{"function": "    def _merge(self, parts):\n        mergewords = self.mergewords\n        mergenums = self.mergenums\n\n        # Current type (1=alpah, 2=digit)\n        last = 0\n        # Where to insert a merged term in the original list\n        insertat = 0\n        # Buffer for parts to merge\n        buf = []\n        # Iterate on a copy of the parts list so we can modify the original as\n        # we go\n\n        def insert_item(buf, at, newpos):\n            newtext = \"\".join(item[0] for item in buf)\n            newsc = buf[0][2]  # start char of first item in buffer\n            newec = buf[-1][3]  # end char of last item in buffer\n            parts.insert(insertat, (newtext, newpos, newsc, newec))\n\n        for item in list(parts):\n            # item = (text, pos, startchar, endchar)\n            text = item[0]\n            pos = item[1]\n\n            # Set the type of this part\n            if text.isalpha():\n                this = 1\n            elif text.isdigit():\n                this = 2\n            else:\n                this = None\n\n            # Is this the same type as the previous part?\n            if (buf and (this == last == 1 and mergewords)\n                or (this == last == 2 and mergenums)):\n                # This part is the same type as the previous. Add it to the\n                # buffer of parts to merge.\n                buf.append(item)\n            else:\n                # This part is different than the previous.\n                if len(buf) > 1:\n                    # If the buffer has at least two parts in it, merge them\n                    # and add them to the original list of parts.\n                    insert_item(buf, insertat, pos - 1)\n                    insertat += 1\n                # Reset the buffer\n                buf = [item]\n                last = this\n            insertat += 1\n\n        # If there are parts left in the buffer at the end, merge them and add\n        # them to the original list.\n        if len(buf) > 1:\n            insert_item(buf, len(parts), pos)", "label": 1}
{"function": "    def add_column(self, table_name, column, schema=None):\n        \"\"\"Issue an \"add column\" instruction using the current\n        migration context.\n\n        e.g.::\n\n            from alembic import op\n            from sqlalchemy import Column, String\n\n            op.add_column('organization',\n                Column('name', String())\n            )\n\n        The provided :class:`~sqlalchemy.schema.Column` object can also\n        specify a :class:`~sqlalchemy.schema.ForeignKey`, referencing\n        a remote table name.  Alembic will automatically generate a stub\n        \"referenced\" table and emit a second ALTER statement in order\n        to add the constraint separately::\n\n            from alembic import op\n            from sqlalchemy import Column, INTEGER, ForeignKey\n\n            op.add_column('organization',\n                Column('account_id', INTEGER, ForeignKey('accounts.id'))\n            )\n\n        Note that this statement uses the :class:`~sqlalchemy.schema.Column`\n        construct as is from the SQLAlchemy library.  In particular,\n        default values to be created on the database side are\n        specified using the ``server_default`` parameter, and not\n        ``default`` which only specifies Python-side defaults::\n\n            from alembic import op\n            from sqlalchemy import Column, TIMESTAMP, func\n\n            # specify \"DEFAULT NOW\" along with the column add\n            op.add_column('account',\n                Column('timestamp', TIMESTAMP, server_default=func.now())\n            )\n\n        :param table_name: String name of the parent table.\n        :param column: a :class:`sqlalchemy.schema.Column` object\n         representing the new column.\n        :param schema: Optional schema name to operate within.\n\n         .. versionadded:: 0.4.0\n\n        \"\"\"\n\n        t = self._table(table_name, column, schema=schema)\n        self.impl.add_column(\n            table_name,\n            column,\n            schema=schema\n        )\n        for constraint in t.constraints:\n            if not isinstance(constraint, sa_schema.PrimaryKeyConstraint):\n                self.impl.add_constraint(constraint)", "label": 1}
{"function": "    def __init__(self, messagebus):\n        self._location = messagebus.kafka_location\n        self._general_group = messagebus.spider_feed_group\n        self._topic = messagebus.topic_todo\n        self._max_next_requests = messagebus.max_next_requests\n        self._hostname_partitioning = messagebus.hostname_partitioning\n        self._enable_ssl = messagebus.enable_ssl\n        self._cert_path = messagebus.cert_path\n        kwargs = {\n            'bootstrap_servers': self._location,\n            'topic': self._topic,\n            'group_id': self._general_group,\n        }\n        if self._enable_ssl:\n            kwargs.update(_prepare_kafka_ssl_kwargs(self._cert_path))\n        self._offset_fetcher = OffsetsFetcherAsync(**kwargs)\n        self._codec = messagebus.codec\n        self._partitions = messagebus.spider_feed_partitions", "label": 1}
{"function": "    def fetch_markets(self):\n        response = self.webGetSpotMarketsProducts()\n        markets = response['data']\n        result = []\n        for i in range(0, len(markets)):\n            id = markets[i]['symbol']\n            baseId, quoteId = id.split('_')\n            baseIdUppercase = baseId.upper()\n            quoteIdUppercase = quoteId.upper()\n            base = self.common_currency_code(baseIdUppercase)\n            quote = self.common_currency_code(quoteIdUppercase)\n            symbol = base + '/' + quote\n            precision = {\n                'amount': markets[i]['maxSizeDigit'],\n                'price': markets[i]['maxPriceDigit'],\n            }\n            lot = math.pow(10, -precision['amount'])\n            minAmount = markets[i]['minTradeSize']\n            minPrice = math.pow(10, -precision['price'])\n            active = (markets[i]['online'] != 0)\n            baseNumericId = markets[i]['baseCurrency']\n            quoteNumericId = markets[i]['quoteCurrency']\n            market = self.extend(self.fees['trading'], {\n                'id': id,\n                'symbol': symbol,\n                'base': base,\n                'quote': quote,\n                'baseId': baseId,\n                'quoteId': quoteId,\n                'baseNumericId': baseNumericId,\n                'quoteNumericId': quoteNumericId,\n                'info': markets[i],\n                'type': 'spot',\n                'spot': True,\n                'future': False,\n                'lot': lot,\n                'active': active,\n                'precision': precision,\n                'limits': {\n                    'amount': {\n                        'min': minAmount,\n                        'max': None,\n                    },\n                    'price': {\n                        'min': minPrice,\n                        'max': None,\n                    },\n                    'cost': {\n                        'min': minAmount * minPrice,\n                        'max': None,\n                    },\n                },\n            })\n            result.append(market)\n            if (self.has['futures']) and(market['base'] in list(self.options['futures'].keys())):\n                fiats = self.options['fiats']\n                for j in range(0, len(fiats)):\n                    fiat = fiats[j]\n                    lowercaseFiat = fiat.lower()\n                    result.append(self.extend(market, {\n                        'quote': fiat,\n                        'symbol': market['base'] + '/' + fiat,\n                        'id': market['base'].lower() + '_' + lowercaseFiat,\n                        'quoteId': lowercaseFiat,\n                        'type': 'future',\n                        'spot': False,\n                        'future': True,\n                    }))\n        return result", "label": 1}
{"function": "def main():\n    args = parse_args()\n    print(args)\n    models_root_path = Path(args.model_base)\n    if not models_root_path.exists():\n        raise ValueError(f\"`models_root` not exists: {models_root_path}\")\n    \n    # Create save folder to save the samples\n    save_path = args.save_path if args.save_path_suffix==\"\" else f'{args.save_path}_{args.save_path_suffix}'\n    if not os.path.exists(save_path):\n        os.makedirs(save_path, exist_ok=True)\n\n    # Load models\n    hunyuan_video_sampler = HunyuanVideoSampler.from_pretrained(models_root_path, args=args)\n    \n    # Get the updated args\n    args = hunyuan_video_sampler.args\n\n    # Start sampling\n    # TODO: batch inference check\n    outputs = hunyuan_video_sampler.predict(\n        prompt=args.prompt, \n        height=args.video_size[0],\n        width=args.video_size[1],\n        video_length=args.video_length,\n        seed=args.seed,\n        negative_prompt=args.neg_prompt,\n        infer_steps=args.infer_steps,\n        guidance_scale=args.cfg_scale,\n        num_videos_per_prompt=args.num_videos,\n        flow_shift=args.flow_shift,\n        batch_size=args.batch_size,\n        embedded_guidance_scale=args.embedded_cfg_scale\n    )\n    samples = outputs['samples']\n    \n    # Save samples\n    if 'LOCAL_RANK' not in os.environ or int(os.environ['LOCAL_RANK']) == 0:\n        for i, sample in enumerate(samples):\n            sample = samples[i].unsqueeze(0)\n            time_flag = datetime.fromtimestamp(time.time()).strftime(\"%Y-%m-%d-%H:%M:%S\")\n            cur_save_path = f\"{save_path}/{time_flag}_seed{outputs['seeds'][i]}_{outputs['prompts'][i][:100].replace('/','')}.mp4\"\n            save_videos_grid(sample, cur_save_path, fps=24)\n            logger.info(f'Sample save to: {cur_save_path}')", "label": 0}
{"function": "def test_build_video():\n    \"\"\"Test video building (integration test)\"\"\"\n    encoder = MemvidEncoder()\n    chunks = [\n        \"Test chunk 1: Important information\",\n        \"Test chunk 2: More data here\",\n        \"Test chunk 3: Final piece of info\"\n    ]\n    encoder.add_chunks(chunks)\n    \n    with tempfile.TemporaryDirectory() as temp_dir:\n        video_file = os.path.join(temp_dir, \"test.mp4\")\n        index_file = os.path.join(temp_dir, \"test_index.json\")\n        \n        # Build video\n        stats = encoder.build_video(video_file, index_file, show_progress=False)\n        \n        # Check files exist\n        assert os.path.exists(video_file)\n        assert os.path.exists(index_file)\n        assert os.path.exists(index_file.replace('.json', '.faiss'))\n        \n        # Check stats\n        assert stats[\"total_chunks\"] == 3\n        assert stats[\"total_frames\"] == 3\n        assert stats[\"video_size_mb\"] > 0\n        assert stats[\"duration_seconds\"] > 0", "label": 0}
{"function": "    def _unwrap_object(self, space, w_obj):\n        return space.r_longlong_w(w_obj)", "label": 1}
{"function": "  def test_strip_function_parameters(self):\n    def should_match(signature, name):\n      self.assertEqual(ipr.strip_function_parameters(signature), name)\n\n    should_match(\"foo(bar)\", \"foo\"),\n    should_match(\"Foo(foomatic::(anonymous)::bar(baz))\", \"Foo\"),\n    should_match(\"v8::(anonymous ns)::bar<thing(with, parentheses)>(baz, poe)\",\n       \"v8::(anonymous ns)::bar<thing(with, parentheses)>\")", "label": 1}
{"function": "    def replace_methods(self, target_class, source_class, skip_fcns=[], only_include_fcns=None):\n        for attr_name in dir(source_class):\n            attr_value = getattr(source_class, attr_name)\n            if attr_name in source_class.__dict__:\n                attr_class_value = source_class.__dict__[attr_name]\n            else:\n                attr_class_value = attr_value\n            if (isinstance(attr_class_value, staticmethod) or isinstance(attr_class_value, classmethod)\n                    or attr_name in skip_fcns):\n                print(f\"skip replace {attr_name}\")\n                continue\n\n            if only_include_fcns is not None and attr_name not in only_include_fcns:\n                continue\n\n            elif isinstance(attr_value, types.FunctionType):\n                setattr(target_class, attr_name, attr_value)", "label": 0}
{"function": "def main(opt):\n    # check_requirements(exclude=('tensorboard', 'thop'))\n    run(**vars(opt))", "label": 0}
{"function": "        def add_fields(form, form_fields):\n            for field in form_fields:\n                field_key = \"field_%s\" % field.id\n                if \"/\" in field.field_type:\n                    field_class, field_widget = field.field_type.split(\"/\")\n                else:\n                    field_class, field_widget = field.field_type, None\n\n                if field.field_type == 'EmailVerificationField':\n                    one_email = get_setting('module', 'forms', 'one_email')\n                    if one_email:\n                        field_class = forms.EmailField\n                    else:\n                        field_class = EmailVerificationField\n\n                elif field.field_type == 'BooleanField' and len(field.choices) > 0:\n                    field_class = forms.MultipleChoiceField\n                    field_widget = 'django.forms.CheckboxSelectMultiple'\n\n                elif field.field_type == 'CountryField':\n                    field_class = CountrySelectField\n                elif field.field_type == 'StateProvinceField':\n                    field_class = getattr(forms, 'ChoiceField')\n                else:\n                    field_class = getattr(forms, field_class)\n                field_args = {\"label\": mark_safe(field.label), \"required\": field.required}\n                arg_names = field_class.__init__.__code__.co_varnames\n                if \"max_length\" in arg_names:\n                    field_args[\"max_length\"] = FIELD_MAX_LENGTH\n                if \"choices\" in arg_names and field.field_type != 'CountryField':\n                    field_args[\"choices\"] = field.get_choices()\n                    #field_args[\"choices\"] = zip(choices, choices)\n                if \"initial\" in arg_names:\n                    default = field.default.lower()\n                    if field_class == \"BooleanField\":\n                        if default == \"checked\" or default == \"true\" or \\\n                            default == \"on\" or default == \"1\":\n                                default = True\n                        else:\n                            default = False\n                    field_args[\"initial\"] = field.default\n\n                if field_widget is not None:\n                    module, widget = field_widget.rsplit(\".\", 1)\n                    # django.forms.extras moved to django.forms.widgets since Django 1.9\n                    if module == 'django.forms.extras':\n                        module = 'django.forms.widgets'\n                    field_args[\"widget\"] = getattr(import_module(module), widget)\n\n                if field.field_function == 'EmailFirstName':\n                    field_args[\"max_length\"] = FIELD_FNAME_LENGTH\n                elif field.field_function == 'EmailLastName':\n                    field_args[\"max_length\"] = FIELD_LNAME_LENGTH\n                elif field.field_function == 'EmailFullName':\n                    field_args[\"max_length\"] = FIELD_NAME_LENGTH\n                elif field.field_function == 'EmailPhoneNumber':\n                    field_args[\"max_length\"] = FIELD_PHONE_LENGTH\n                elif field.field_type == 'FileField':\n                    field_args[\"validators\"] = [FileValidator()]\n\n                form.fields[field_key] = field_class(**field_args)\n\n                if not field_class == EmailVerificationField:\n                    form.fields[field_key].widget.attrs['title'] = field.label\n                    form.fields[field_key].widget.attrs['class'] = 'formforform-field'\n                else:\n                    form.fields[field_key].widget.widgets[0].attrs['class'] += ' formforform-field'\n                    form.fields[field_key].widget.widgets[1].attrs['class'] += ' formforform-field'\n                widget_name = form.fields[field_key].widget.__class__.__name__.lower()\n                if widget_name == 'selectdatewidget':\n                    form.fields[field_key].widget.years = list(range(1920, THIS_YEAR + 10))\n                if widget_name in ('dateinput', 'selectdatewidget', 'datetimeinput'):\n                    form.fields[field_key].initial = datetime.now()", "label": 1}
{"function": "def str2gib_size(s):\n    \"\"\"Covert size-string to size in gigabytes.\"\"\"\n    size_in_bytes = str2size(s)\n    return size_in_bytes // units.Gi", "label": 1}
{"function": "def main_fold(fold):\n    import time\n    import torch.nn as nn\n    import torch.optim as optim\n    import torch_xla.core.xla_model as xm\n    from ignite.engine import Engine, Events\n\n    device = xm.xla_device(fold)\n\n    comp_model = _XlaDistModel.create_from_context()\n    assert comp_model.device() == device\n\n    model = nn.Linear(100, 10)\n\n    model.to(device)  # Move model before creating optimizer\n    optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9)\n\n    def training_step(engine, _):\n        data = torch.rand(4, 100, device=device)\n        model.train()\n        data = data.to(device)\n        optimizer.zero_grad()\n        output = model(data)\n        loss = output.sum()\n        loss.backward()\n        xm.optimizer_step(optimizer, barrier=True)\n        return loss.item()\n\n    trainer = Engine(training_step)\n\n    # THIS CAN BE A CAUSE OF CRASH if DEVICE is OTHER THAN device\n    tensor = torch.tensor([fold + 1.0], dtype=torch.float).to(comp_model.device())\n    xm.all_reduce(\"max\", [tensor,])\n\n    time.sleep(0.01 * fold)\n\n    trainer.run([0] * 100, max_epochs=2)", "label": 1}
{"function": "def passed(name=None):\n    \"\"\" Reports success \"\"\"\n    if not name:\n        name = sys._getframe().f_back.f_code.co_name\n    print(\"#educational_plugin \" + name + \" test OK\")", "label": 1}
{"function": "\tdef set_OwnerAccount(self,OwnerAccount):\n\t\tself.add_query_param('OwnerAccount',OwnerAccount)", "label": 1}
{"function": "def test__get_function_default_kwargs__empty():\n    \"\"\" Test if `_get_function_default_kwargs` handles an empty function. \"\"\"\n\n    def func():\n        pass\n\n    assert list(_get_function_default_kwargs(func).keys()) == []", "label": 1}
{"function": "    def _num_uncovered(key):\n        (total, covered, percent) = covdata[key].coverage()\n        return total - covered", "label": 1}
{"function": "    def __init__(self):\n        super(CapsuleLoss, self).__init__()\n        self.reconstruction_loss = nn.MSELoss(size_average=False)", "label": 1}
{"function": "    def _buildMultiServiceHeader(self):\n        \"\"\"\n        Service header for making a multiple tag request\n        \"\"\"\n        MultiService = 0X0A\n        MultiPathSize = 0x02\n        MutliClassType = 0x20\n        MultiClassSegment = 0x02\n        MultiInstanceType = 0x24\n        MultiInstanceSegment = 0x01\n\n        return pack('<BBBBBB',\n                    MultiService,\n                    MultiPathSize,\n                    MutliClassType,\n                    MultiClassSegment,\n                    MultiInstanceType,\n                    MultiInstanceSegment)", "label": 1}
{"function": "def test_e2e_valid_csv_conversions():\n    valid_csv_paths = get_csv_paths()\n    converter = get_converter()\n\n    for csv_path in valid_csv_paths:\n        print(f\"converting {csv_path}\")\n\n        gt_path = csv_path.parent.parent / \"groundtruth\" / \"docling_v2\" / csv_path.name\n        if csv_path.stem in (\n            \"csv-too-few-columns\",\n            \"csv-too-many-columns\",\n            \"csv-inconsistent-header\",\n        ):\n            with warns(UserWarning, match=\"Inconsistent column lengths\"):\n                conv_result: ConversionResult = converter.convert(csv_path)\n        else:\n            conv_result: ConversionResult = converter.convert(csv_path)\n\n        doc: DoclingDocument = conv_result.document\n\n        pred_md: str = doc.export_to_markdown()\n        assert verify_export(pred_md, str(gt_path) + \".md\"), \"export to md\"\n\n        pred_itxt: str = doc._export_to_indented_text(\n            max_text_len=70, explicit_tables=False\n        )\n        assert verify_export(pred_itxt, str(gt_path) + \".itxt\"), (\n            \"export to indented-text\"\n        )\n\n        assert verify_document(\n            pred_doc=doc,\n            gtfile=str(gt_path) + \".json\",\n            generate=GENERATE,\n        ), \"export to json\"", "label": 0}
{"function": "    def get_option_spec(cls):\n        spec = PyOptionSpec()\n        spec.addFloatOption(\n            'entropy_ratio',\n            'the entropy ratio we put on PolicyGradient',\n            0.01)\n        spec.addFloatOption(\n            'grad_clip_norm',\n            'gradient norm clipping',\n            0.0)\n        spec.addFloatOption(\n            'min_prob',\n            'mininal probability used in training',\n            1e-6)\n        spec.addFloatOption(\n            'ratio_clamp',\n            'maximum importance sampling ratio',\n            10.0)\n        spec.addStrListOption(\n            'policy_action_nodes',\n            'the entropy ratio we put on PolicyGradient',\n            ['pi,a'])\n        return spec", "label": 1}
{"function": "def load_state_class():\n    # Get the absolute path to the types.py file\n    src_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"src\"))\n    types_path = os.path.join(src_dir, \"graph\", \"types.py\")\n\n    # Create a namespace for the module\n    import types\n\n    module_name = \"src.graph.types_direct\"\n    spec = types.ModuleType(module_name)\n\n    # Add the module to sys.modules to avoid import loops\n    sys.modules[module_name] = spec\n\n    # Set up the namespace with required imports\n    spec.__dict__[\"operator\"] = __import__(\"operator\")\n    spec.__dict__[\"Annotated\"] = Annotated\n    spec.__dict__[\"MessagesState\"] = MessagesState\n    spec.__dict__[\"Plan\"] = Plan\n\n    # Execute the module code\n    with open(types_path, \"r\") as f:\n        module_code = f.read()\n\n    exec(module_code, spec.__dict__)\n\n    # Return the State class\n    return spec.State", "label": 0}
{"function": "    def RELEASE(self):\n        \"\"\"\n        Return the release information.\n\n        Delegate to the module function to enable easier testing.\n        \"\"\"\n        return get_release()", "label": 0}
{"function": "def run_multiple_tests(providers_to_run: list[str], keyword: str | None):\n    \"\"\"Runs tests for a list of providers.\"\"\"\n    print(f\"Running tests for providers: {', '.join(providers_to_run)}\")\n    for provider in providers_to_run:\n        run_tests(provider.strip(), keyword=keyword)\n    print(\"Finished running tests.\")", "label": 0}
{"function": "    def __init__(self, open, high, low, close):\n        pass", "label": 1}
{"function": "def server():\n    \"\"\"Start API service providing model inference interface.\"\"\"\n    from weclone.server.api_service import main as server_main\n\n    server_main()", "label": 0}
{"function": "    def __init__(self, real, timeperiod=30):\n        pass", "label": 1}
{"function": "    def create(self, values):\n        if values.get('vat'):\n            values['vat'] = self._format_vat_cl(values)\n        return super().create(values)", "label": 1}
{"function": "    def testLargePromptHint1(self):\n        local_pdf_path = os.path.join(os.path.dirname(__file__), \"gnarly_pdfs\", \"large_prompt_hint1.pdf\")\n\n        anchor_text = get_anchor_text(local_pdf_path, 4, pdf_engine=\"pdfreport\")\n\n        print(anchor_text)\n        print(len(anchor_text))\n        self.assertLessEqual(len(anchor_text), 1000)", "label": 0}
{"function": "    def digest(self):\n        ''' Removes the \"md5\" prefix '''\n        return postgres_md5.encrypt(self._data[:64],\n                                    user=self._user)[3:].decode('hex')", "label": 1}
{"function": "def get_response_obj(\n    output: list[TResponseOutputItem],\n    response_id: str | None = None,\n    usage: Usage | None = None,\n) -> Response:\n    return Response(\n        id=response_id or \"123\",\n        created_at=123,\n        model=\"test_model\",\n        object=\"response\",\n        output=output,\n        tool_choice=\"none\",\n        tools=[],\n        top_p=None,\n        parallel_tool_calls=False,\n        usage=ResponseUsage(\n            input_tokens=usage.input_tokens if usage else 0,\n            output_tokens=usage.output_tokens if usage else 0,\n            total_tokens=usage.total_tokens if usage else 0,\n            input_tokens_details=InputTokensDetails(cached_tokens=0),\n            output_tokens_details=OutputTokensDetails(reasoning_tokens=0),\n        ),\n    )", "label": 0}
{"function": "\tasync def test_registry_action_decorator(self):\n\t\t\"\"\"Test the action decorator with filters\"\"\"\n\t\tregistry = Registry()\n\n\t\t# Define actions with different filters\n\t\t@registry.action(\n\t\t\tdescription='No filter action',\n\t\t)\n\t\tdef no_filter_action():\n\t\t\tpass\n\n\t\t@registry.action(description='Domain filter action', domains=['example.com'])\n\t\tdef domain_filter_action():\n\t\t\tpass\n\n\t\t@registry.action(description='Page filter action', page_filter=lambda page: 'admin' in page.url)\n\t\tdef page_filter_action():\n\t\t\tpass\n\n\t\t# Check that system prompt only includes the no_filter_action\n\t\tsystem_description = registry.get_prompt_description()\n\t\tassert 'No filter action' in system_description\n\t\tassert 'Domain filter action' not in system_description\n\t\tassert 'Page filter action' not in system_description\n\n\t\t# Check that page-specific prompt includes the right actions\n\t\tmock_page = MagicMock(spec=Page)\n\t\tmock_page.url = 'https://example.com/admin'\n\n\t\tpage_description = registry.get_prompt_description(mock_page)\n\t\tassert 'Domain filter action' in page_description\n\t\tassert 'Page filter action' in page_description", "label": 0}
{"function": "def finger(a):\n    return numpy.dot(a.ravel(), numpy.cos(numpy.arange(a.size)))", "label": 1}
{"function": "def handle_inquiries(selected_actions: List[str], parameters: dict, llm_api_key: str):\n    \"\"\"\n    Decide which function to call based on the selected user actions.\n\n    :param selected_actions: List of actions selected by the user.\n    :param parameters: Configuration parameters dictionary.\n    :param llm_api_key: API key for the language model.\n    \"\"\"\n    try:\n        if selected_actions:\n            if \"Generate Resume\" == selected_actions:\n                logger.info(\"Crafting a standout professional resume...\")\n                create_resume_pdf(parameters, llm_api_key)\n                \n            if \"Generate Resume Tailored for Job Description\" == selected_actions:\n                logger.info(\"Customizing your resume to enhance your job application...\")\n                create_resume_pdf_job_tailored(parameters, llm_api_key)\n                \n            if \"Generate Tailored Cover Letter for Job Description\" == selected_actions:\n                logger.info(\"Designing a personalized cover letter to enhance your job application...\")\n                create_cover_letter(parameters, llm_api_key)\n\n        else:\n            logger.warning(\"No actions selected. Nothing to execute.\")\n    except Exception as e:\n        logger.exception(f\"An error occurred while handling inquiries: {e}\")\n        raise", "label": 0}
{"function": "def reduce_tensor(tensor, n):\n    rt = tensor.clone()\n    dist.all_reduce(rt, op=dist.ReduceOp.SUM)\n    rt /= n\n    return rt", "label": 1}
{"function": "    def test_err_broken_sans(self, tdata):\n        with open(tdata.path(\"mitmproxy/net/data/text_cert_weird1\"), \"rb\") as f:\n            d = f.read()\n        c = certs.Cert.from_pem(d)\n        # This breaks unless we ignore a decoding error.\n        assert c.altnames is not None", "label": 1}
{"function": "    def handle_error(self):\n        raise", "label": 1}
{"function": "    def __init__(self, code, obj, strFields=None, trace=None):\n        self.label = catalog.alert[code]['label']\n        self.code = catalog.alert[code]['code']\n        self.cat = catalog.alert[code]['cat']\n        self.url = catalog.alert[code]['url']\n        self.obj = obj\n\n        if hasattr(obj, 'type'):\n            self.type = obj.type\n        else:\n            self.type = None\n\n        if hasattr(obj, \"params\"):\n            self.name = obj.params['name'].val\n        else:\n            self.name = None\n\n        if strFields:\n            self.msg = _translate(catalog.alert[code]['msg']).format(**strFields)\n        else:\n            self.msg = _translate(catalog.alert[code]['msg'])\n\n        if trace:\n            self.trace = ''.join(traceback.format_exception(\n                trace[0], trace[1], trace[2]))\n        else:\n            self.trace = None", "label": 1}
{"function": "    def indices(self):\n        if len(self.metapartitions) > 1:\n            raise AttributeError(\n                \"Accessing `indices` attribute is not allowed while nested\"\n            )\n        return self.metapartitions[0][\"indices\"]", "label": 1}
{"function": "def fast_unpickle(path: str) -> Any:\n    with copy_to_shm(path) as tmp_path:\n        with open(tmp_path, \"rb\") as f:\n            return pickle.load(f)", "label": 0}
{"function": "def colored(text, color=None, bold=False):\n    fmt = []\n    if color== 'red':\n        fmt.append('31')\n    elif color == 'green':\n        fmt.append('32')\n    if bold:\n        fmt.append('1')\n\n    return f\"\\033[{';'.join(fmt)}m{text}\\033[0m\"", "label": 0}
{"function": "def get_db_path():\n    \"\"\"Get the database path from environment or use default\"\"\"\n    config = Config.from_env()\n    db_path = config.get(\"SQLITE_DB_PATH\", os.path.join(project_root, \"data\", \"sqlite\", \"lpm.db\"))\n    return db_path", "label": 0}
{"function": "def patched_torch_load(*args, **kwargs):\n    if 'map_location' not in kwargs:\n        kwargs['map_location'] = map_location\n    return torch_load_original(*args, **kwargs)", "label": 0}
{"function": "    def initialize_options(self):\n        \"\"\"Set default values for all the options that this command\n        supports.  Note that these defaults may be overridden by other\n        commands, by the setup script, by config files, or by the\n        command-line.  Thus, this is not the place to code dependencies\n        between options; generally, 'initialize_options()' implementations\n        are just a bunch of \"self.foo = None\" assignments.\n\n        This method must be implemented by all command classes.\n        \"\"\"\n        raise RuntimeError(\"abstract method -- subclass %s must override\"\n                           % self.__class__)", "label": 1}
{"function": "def main():\n    parser = argparse.ArgumentParser('export_quantized')\n    parser.add_argument('hf_repo')\n    parser.add_argument('new_hf_repo', nargs='?', default=None)\n\n    args = parser.parse_args()\n    api = get_api()\n\n    repo = args.hf_repo\n\n    print(\"Downloading base model.\")\n    info = loaders.CheckpointInfo.from_hf_repo(args.hf_repo)\n    print(\"Creating model.\")\n    model = info.get_moshi(fuse_lora=True, device='cuda')\n    print(\"Quantizing model.\")\n    replace_linear_with_qlinear(model)\n\n    if args.new_hf_repo is None:\n        new_repo = repo.rsplit('-', 1)[0] + '-q8'\n    else:\n        new_repo = args.new_hf_repo\n    if not api.repo_exists(new_repo):\n        api.create_repo(new_repo, repo_type='model')\n        print(\"Repo created.\")\n\n    to_copy = ['README.md']\n    for file in to_copy:\n        if not api.file_exists(repo, file):\n            continue\n        if not api.file_exists(new_repo, file):\n            print(\"File\", file, \"is missing\")\n            old_file = hf_hub_download(repo, file)\n            api.upload_file(\n                path_or_fileobj=old_file,\n                path_in_repo=file,\n                repo_id=new_repo,\n                repo_type=\"model\")\n    with tempfile.NamedTemporaryFile(suffix='.safetensors', delete=True) as file:\n        save_file(model.state_dict(), file.name)\n        size = Path(file.name).stat().st_size / 1e9\n        print(f\"Checkpoint size: {size:.1f}GB\")\n        old_name, old_ext = info.moshi_weights.name.rsplit('.', 1)\n        new_name = old_name + '.q8.' + old_ext\n        api.upload_file(\n            path_or_fileobj=file.name,\n            path_in_repo=new_name,\n            repo_id=new_repo,\n            repo_type=\"model\")\n    config = json.load(open(hf_hub_download(repo, 'config.json')))\n    config['moshi_name'] = new_name\n    config['quantize'] = True\n    if not config['mimi_name'].startswith('hf://'):\n        config['mimi_name'] = f'hf://{repo}/{config[\"mimi_name\"]}'\n    if not config['tokenizer_name'].startswith('hf://'):\n        config['tokenizer_name'] = f'hf://{repo}/{config[\"tokenizer_name\"]}'\n    with tempfile.NamedTemporaryFile(mode='w') as file:\n        json.dump(config, file, indent=2)\n        file.flush()\n        api.upload_file(\n            path_or_fileobj=file.name,\n            path_in_repo='config.json',\n            repo_id=new_repo,\n            repo_type=\"model\")", "label": 0}
{"function": "    def transcribe(self, ref_audio, language=None):\n        return transcribe(ref_audio, language)", "label": 0}
{"function": "    def get_output_video_path(self, name):\n        os.makedirs(f\"{self.work_path}/output_videos\", exist_ok=True)\n        return f\"{self.work_path}/output_videos/{name}\"", "label": 0}
{"function": "def get_requirements(path: str):\n    return [l.strip() for l in open(path)]", "label": 0}
{"function": "def process_audio():\n    with st.spinner(t(\"Generate audio tasks\")): \n        _8_1_audio_task.gen_audio_task_main()\n        _8_2_dub_chunks.gen_dub_chunks()\n    with st.spinner(t(\"Extract refer audio\")):\n        _9_refer_audio.extract_refer_audio_main()\n    with st.spinner(t(\"Generate all audio\")):\n        _10_gen_audio.gen_audio()\n    with st.spinner(t(\"Merge full audio\")):\n        _11_merge_audio.merge_full_audio()\n    with st.spinner(t(\"Merge dubbing to the video\")):\n        _12_dub_to_vid.merge_video_audio()\n    \n    st.success(t(\"Audio processing complete! \ud83c\udf87\"))\n    st.balloons()", "label": 0}
{"function": "async def test_scrape_method_unsupported_backend():\n    \"\"\"Test that the scrape method raises a ValueError when an unsupported backend is provided.\"\"\"\n    loader = ChromiumLoader([\"http://example.com\"], backend=\"unsupported\")\n    with pytest.raises(ValueError):\n        await loader.scrape(\"http://example.com\")", "label": 0}
{"function": "    def _load_tools(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        Dynamically load all tool classes from the tools directory.\n        If a dependency is missing, prompt the user to install it via uvpackagemanager.\n        \n        Returns:\n            A list of tools (dicts) containing their 'name', 'description', and 'input_schema'.\n        \"\"\"\n        tools = []\n        tools_path = getattr(Config, 'TOOLS_DIR', None)\n\n        if tools_path is None:\n            self.console.print(\"[red]TOOLS_DIR not set in Config[/red]\")\n            return tools\n\n        # Clear cached tool modules for fresh import\n        for module_name in list(sys.modules.keys()):\n            if module_name.startswith('tools.') and module_name != 'tools.base':\n                del sys.modules[module_name]\n\n        try:\n            for module_info in pkgutil.iter_modules([str(tools_path)]):\n                if module_info.name == 'base':\n                    continue\n\n                # Attempt loading the tool module\n                try:\n                    module = importlib.import_module(f'tools.{module_info.name}')\n                    self._extract_tools_from_module(module, tools)\n                except ImportError as e:\n                    # Handle missing dependencies\n                    missing_module = self._parse_missing_dependency(str(e))\n                    self.console.print(f\"\\n[yellow]Missing dependency:[/yellow] {missing_module} for tool {module_info.name}\")\n                    user_response = input(f\"Would you like to install {missing_module}? (y/n): \").lower()\n\n                    if user_response == 'y':\n                        success = self._execute_uv_install(missing_module)\n                        if success:\n                            # Retry loading the module after installation\n                            try:\n                                module = importlib.import_module(f'tools.{module_info.name}')\n                                self._extract_tools_from_module(module, tools)\n                            except Exception as retry_err:\n                                self.console.print(f\"[red]Failed to load tool after installation: {str(retry_err)}[/red]\")\n                        else:\n                            self.console.print(f\"[red]Installation of {missing_module} failed. Skipping this tool.[/red]\")\n                    else:\n                        self.console.print(f\"[yellow]Skipping tool {module_info.name} due to missing dependency[/yellow]\")\n                except Exception as mod_err:\n                    self.console.print(f\"[red]Error loading module {module_info.name}:[/red] {str(mod_err)}\")\n        except Exception as overall_err:\n            self.console.print(f\"[red]Error in tool loading process:[/red] {str(overall_err)}\")\n\n        return tools", "label": 0}
{"function": "\tdef get_EndCreateTime(self):\n\t\treturn self.get_query_params().get('EndCreateTime')", "label": 1}
{"function": "def _is_explicitly_marked(mark_name: str, metafunc: Metafunc) -> bool:\n  if hasattr(metafunc.function, 'pytestmark'):\n    for mark in metafunc.function.pytestmark:\n      if mark.name == 'parametrize' and mark.args[0] == mark_name:\n        return True\n  return False", "label": 0}
{"function": "    def __init__(self, model: Transformer, tokenizer: Tokenizer):\n        self.model = model\n        self.tokenizer = tokenizer\n        self.formatter = ChatFormat(tokenizer)", "label": 0}
{"function": "def create_mock_response(message, function_calls=[], model=\"gpt-4o\"):\n    role = message.get(\"role\", \"assistant\")\n    content = message.get(\"content\", \"\")\n    tool_calls = (\n        [\n            ChatCompletionMessageToolCall(\n                id=\"mock_tc_id\",\n                type=\"function\",\n                function=Function(\n                    name=call.get(\"name\", \"\"),\n                    arguments=json.dumps(call.get(\"args\", {})),\n                ),\n            )\n            for call in function_calls\n        ]\n        if function_calls\n        else None\n    )\n\n    return ChatCompletion(\n        id=\"mock_cc_id\",\n        created=1234567890,\n        model=model,\n        object=\"chat.completion\",\n        choices=[\n            Choice(\n                message=ChatCompletionMessage(\n                    role=role, content=content, tool_calls=tool_calls\n                ),\n                finish_reason=\"stop\",\n                index=0,\n            )\n        ],\n    )", "label": 0}
{"function": "def patched_init(self, scope, receive=None, send=None):\n    if 'session' not in scope:\n        scope['session'] = dict()\n    _original_init(self, scope, receive, send)\n    return", "label": 0}
{"function": "def print_logo():\n    print(\"\\033[96m\" + CURSOR_LOGO + \"\\033[0m\")\n    print(\"\\033[93m\" + \"Building Cursor Keep Alive...\".center(56) + \"\\033[0m\\n\")", "label": 0}
{"function": "def pad_dataproto_to_divisor(data: \"DataProto\", size_divisor: int):\n    \"\"\"Pad a DataProto to size divisible by size_divisor\n\n    Args:\n        size_divisor (int): size divisor\n\n    Returns:\n        data: (DataProto): the padded DataProto\n        pad_size (int)\n    \"\"\"\n    assert isinstance(data, DataProto), \"data must be a DataProto\"\n    if len(data) % size_divisor != 0:\n        pad_size = size_divisor - len(data) % size_divisor\n        padding_protos = []\n        remaining_pad = pad_size\n        while remaining_pad > 0:\n            take_size = min(remaining_pad, len(data))\n            padding_protos.append(data[:take_size])\n            remaining_pad -= take_size\n        data_padded = DataProto.concat([data] + padding_protos)\n    else:\n        if len(data) == 0:\n            logging.warning(\"padding a DataProto with no item, no changed made\")\n        pad_size = 0\n        data_padded = data\n    return data_padded, pad_size", "label": 0}
{"function": "\tdef get_BeginCreateTime(self):\n\t\treturn self.get_query_params().get('BeginCreateTime')", "label": 1}
{"function": "    def voice_creation(text, gender, pitch, speed):\n        \"\"\"\n        Gradio callback to create a synthetic voice with adjustable parameters.\n        - text: The input text for synthesis.\n        - gender: 'male' or 'female'.\n        - pitch/speed: Ranges mapped by LEVELS_MAP_UI.\n        \"\"\"\n        pitch_val = LEVELS_MAP_UI[int(pitch)]\n        speed_val = LEVELS_MAP_UI[int(speed)]\n        audio_output_path = run_tts(\n            text,\n            model,\n            gender=gender,\n            pitch=pitch_val,\n            speed=speed_val\n        )\n        return audio_output_path", "label": 0}
{"function": "def extract_gaussian(state: dict, req: gr.Request) -> Tuple[str, str]:\n    \"\"\"\n    Extract a Gaussian file from the 3D model.\n\n    Args:\n        state (dict): The state of the generated 3D model.\n\n    Returns:\n        str: The path to the extracted Gaussian file.\n    \"\"\"\n    user_dir = os.path.join(TMP_DIR, str(req.session_hash))\n    gs, _ = unpack_state(state)\n    gaussian_path = os.path.join(user_dir, 'sample.ply')\n    gs.save_ply(gaussian_path)\n    torch.cuda.empty_cache()\n    return gaussian_path, gaussian_path", "label": 0}
{"function": "async def test_exclude_no_types():\n    \"\"\"Test normal behavior when no types are excluded (baseline test).\"\"\"\n    graphiti = Graphiti(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD)\n\n    try:\n        await graphiti.build_indices_and_constraints()\n\n        entity_types = {\n            'Person': Person,\n            'Organization': Organization,\n        }\n\n        # Don't exclude any types\n        result = await graphiti.add_episode(\n            name='Normal Behavior',\n            episode_body='Alice Smith works at TechCorp.',\n            source_description='Normal test',\n            reference_time=datetime.now(timezone.utc),\n            entity_types=entity_types,\n            excluded_entity_types=None,  # No exclusions\n            group_id='test_exclude_none',\n        )\n\n        assert result is not None\n\n        # Search for nodes - should find entities of all types\n        search_results = await graphiti.search_(\n            query='Alice Smith TechCorp', group_ids=['test_exclude_none']\n        )\n\n        found_nodes = search_results.nodes\n        assert len(found_nodes) > 0, 'Should have found some entities'\n\n        # Should have both Person and Organization entities\n        person_nodes = [n for n in found_nodes if 'Person' in n.labels]\n        org_nodes = [n for n in found_nodes if 'Organization' in n.labels]\n\n        assert len(person_nodes) > 0, 'Should have found Person entities'\n        assert len(org_nodes) > 0, 'Should have found Organization entities'\n\n        # Clean up\n        await _cleanup_test_nodes(graphiti, 'test_exclude_none')\n\n    finally:\n        await graphiti.close()", "label": 0}
{"function": "def load_data():\n    dirname = \"cifar-10-batches-py\"\n    origin = \"http://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz\"\n    path = get_file(dirname, origin=origin, untar=True)\n\n    nb_test_samples = 10000\n    nb_train_samples = 50000\n\n    X_train = np.zeros((nb_train_samples, 3, 32, 32), dtype=\"uint8\")\n    y_train = np.zeros((nb_train_samples,), dtype=\"uint8\")\n\n    for i in range(1, 6):\n        fpath = os.path.join(path, 'data_batch_' + str(i))\n        data, labels = load_batch(fpath)\n        X_train[(i-1)*10000:i*10000, :, :, :] = data\n        y_train[(i-1)*10000:i*10000] = labels\n\n    fpath = os.path.join(path, 'test_batch')\n    X_test, y_test = load_batch(fpath)\n\n    y_train = np.reshape(y_train, (len(y_train), 1))\n    y_test = np.reshape(y_test, (len(y_test), 1))\n\n    return (X_train, y_train), (X_test, y_test)", "label": 1}
{"function": "def test(\n        weights=ROOT / 'yolo.pt',  # weights path\n        imgsz=640,  # inference size (pixels)\n        batch_size=1,  # batch size\n        data=ROOT / 'data/coco128.yaml',  # dataset.yaml path\n        device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n        half=False,  # use FP16 half-precision inference\n        test=False,  # test exports only\n        pt_only=False,  # test PyTorch only\n        hard_fail=False,  # throw error on benchmark failure\n):\n    y, t = [], time.time()\n    device = select_device(device)\n    for i, (name, f, suffix, gpu) in export.export_formats().iterrows():  # index, (name, file, suffix, gpu-capable)\n        try:\n            w = weights if f == '-' else \\\n                export.run(weights=weights, imgsz=[imgsz], include=[f], device=device, half=half)[-1]  # weights\n            assert suffix in str(w), 'export failed'\n            y.append([name, True])\n        except Exception:\n            y.append([name, False])  # mAP, t_inference\n\n    # Print results\n    LOGGER.info('\\n')\n    parse_opt()\n    notebook_init()  # print system info\n    py = pd.DataFrame(y, columns=['Format', 'Export'])\n    LOGGER.info(f'\\nExports complete ({time.time() - t:.2f}s)')\n    LOGGER.info(str(py))\n    return py", "label": 0}
{"function": "    def __delitem__(self, i):\n        \"\"\"Detect list del events and emit change events.\"\"\"\n        list.__delitem__(self, i)\n        self.changed()", "label": 1}
{"function": "def test_execute_tools_false(mock_openai_client: MockOpenAIClient):\n    expected_location = \"San Francisco\"\n\n    # set up mock to record function calls\n    get_weather_mock = Mock()\n\n    def get_weather(location):\n        get_weather_mock(location=location)\n        return \"It's sunny today.\"\n\n    agent = Agent(name=\"Test Agent\", functions=[get_weather])\n    messages = [\n        {\"role\": \"user\", \"content\": \"What's the weather like in San Francisco?\"}\n    ]\n\n    # set mock to return a response that triggers function call\n    mock_openai_client.set_sequential_responses(\n        [\n            create_mock_response(\n                message={\"role\": \"assistant\", \"content\": \"\"},\n                function_calls=[\n                    {\"name\": \"get_weather\", \"args\": {\"location\": expected_location}}\n                ],\n            ),\n            create_mock_response(\n                {\"role\": \"assistant\", \"content\": DEFAULT_RESPONSE_CONTENT}\n            ),\n        ]\n    )\n\n    # set up client and run\n    client = Swarm(client=mock_openai_client)\n    response = client.run(agent=agent, messages=messages, execute_tools=False)\n    print(response)\n\n    # assert function not called\n    get_weather_mock.assert_not_called()\n\n    # assert tool call is present in last response\n    tool_calls = response.messages[-1].get(\"tool_calls\")\n    assert tool_calls is not None and len(tool_calls) == 1\n    tool_call = tool_calls[0]\n    assert tool_call[\"function\"][\"name\"] == \"get_weather\"\n    assert json.loads(tool_call[\"function\"][\"arguments\"]) == {\n        \"location\": expected_location\n    }", "label": 0}
{"function": "    def test_string_translate(self):\n        m = str.maketrans({\"a\": \"X\", \"e\": \"Y\", \"i\": None})\n        self.check_func(lambda x: x.str.translate(m))", "label": 1}
{"function": "  def _CheckConfigureNetwork(self):\n    \"\"\"Enables RNDIS and configures it, retrying until we have connectivity.\"\"\"\n    force = False\n    for _ in range(3):\n      device_iface, host_iface = self._CheckEnableRndis(force)\n      self._ConfigureNetwork(device_iface, host_iface)\n      self.OverrideRoutingPolicy()\n      # Sometimes the first packet will wake up the connection.\n      for _ in range(3):\n        if self._TestConnectivity():\n          return\n      force = True\n    self.RestoreRoutingPolicy()\n    raise Exception('No connectivity, giving up.')", "label": 1}
{"function": "  def test_multiple_handlers(self):\n    perf_stream = StringIO.StringIO(\"\"\"\n        0000 foo(bar)\n        1234 BytecodeHandler:first\n        5678 a::random::call<to>(something, else)\n        9abc BytecodeHandler:second\n        def0 otherIrrelevant(stuff)\n        1111 entrypoint\n    \"\"\")\n    callchains = list(ipr.collapsed_callchains_generator(perf_stream, False))\n    self.assertListEqual(callchains, [\n      [\"foo\", \"BytecodeHandler:first\", \"[interpreter]\"],\n    ])", "label": 1}
{"function": "def check_env_file():\n    \"\"\"\n    \u68c0\u67e5.env\u6587\u4ef6\u662f\u5426\u5b58\u5728\uff0c\u5982\u679c\u4e0d\u5b58\u5728\u5219\u53d1\u51fa\u8b66\u544a\n    \u8fd4\u56deTrue\u8868\u793a\u5e94\u8be5\u7ee7\u7eed\u6267\u884c\uff0cFalse\u8868\u793a\u5e94\u8be5\u9000\u51fa\n    \"\"\"\n    if not os.path.exists(\".env\"):\n        warning_msg = \"\u8b66\u544a: \u5f53\u524d\u76ee\u5f55\u4e2d\u6ca1\u6709\u627e\u5230.env\u6587\u4ef6\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5f71\u54cd\u5b58\u50a8\u914d\u7f6e\u7684\u52a0\u8f7d\u3002\"\n        ASCIIColors.yellow(warning_msg)\n\n        # \u68c0\u67e5\u662f\u5426\u5728\u4ea4\u4e92\u5f0f\u7ec8\u7aef\u4e2d\u8fd0\u884c\n        if sys.stdin.isatty():\n            response = input(\"\u662f\u5426\u7ee7\u7eed\u6267\u884c? (yes/no): \")\n            if response.lower() != \"yes\":\n                ASCIIColors.red(\"\u6d4b\u8bd5\u7a0b\u5e8f\u5df2\u53d6\u6d88\")\n                return False\n    return True", "label": 0}
{"function": "    def __image_clicked_cb(self, button):\n        if self._preview_palette is None:\n            self._preview_palette = get_preview_palette(\n                self._api, self.data, relative_to=button)\n        self._preview_palette.show()", "label": 1}
{"function": "def normalize_image(x):\n    \"\"\"Rescale image pixels to span range [0, 1]\n    \"\"\"\n    ma = float(x.max().cpu().data)\n    mi = float(x.min().cpu().data)\n    d = ma - mi if ma != mi else 1e5\n    return (x - mi) / d", "label": 1}
{"function": "    def test_atomic_min_uint64(self):\n        self.check_atomic_min(dtype=np.uint64, lo=0, hi=65535)", "label": 1}
{"function": "    def do_event(self, event):\n        shortcuts = {\n            'a': (self.get_toplevel().goto_sublist,\n                  ['/u/{}'.format(self.data['author'])]),\n        }\n        if self.data.get('subreddit'):\n            shortcuts['s'] = (\n                self.get_toplevel().goto_sublist,\n                ['/r/{}'.format(self.data['subreddit'])],\n            )\n        return process_shortcuts(shortcuts, event)", "label": 1}
{"function": "def audio_processing_section():\n    st.header(t(\"c. Dubbing\"))\n    with st.container(border=True):\n        st.markdown(f\"\"\"\n        <p style='font-size: 20px;'>\n        {t(\"This stage includes the following steps:\")}\n        <p style='font-size: 20px;'>\n            1. {t(\"Generate audio tasks and chunks\")}<br>\n            2. {t(\"Extract reference audio\")}<br>\n            3. {t(\"Generate and merge audio files\")}<br>\n            4. {t(\"Merge final audio into video\")}\n        \"\"\", unsafe_allow_html=True)\n        if not os.path.exists(DUB_VIDEO):\n            if st.button(t(\"Start Audio Processing\"), key=\"audio_processing_button\"):\n                process_audio()\n                st.rerun()\n        else:\n            st.success(t(\"Audio processing is complete! You can check the audio files in the `output` folder.\"))\n            if load_key(\"burn_subtitles\"):\n                st.video(DUB_VIDEO) \n            if st.button(t(\"Delete dubbing files\"), key=\"delete_dubbing_files\"):\n                delete_dubbing_files()\n                st.rerun()\n            if st.button(t(\"Archive to 'history'\"), key=\"cleanup_in_audio_processing\"):\n                cleanup()\n                st.rerun()", "label": 0}
{"function": "def allow_model_requests():\n    with pydantic_ai.models.override_allow_model_requests(True):\n        yield", "label": 0}
{"function": "    def test_from_array_int_event(surv_arrays):\n        event, time = surv_arrays\n\n        expected = numpy.empty(dtype=[('event', bool), ('time', float)], shape=100)\n        expected['event'] = event.astype(bool)\n        expected['time'] = time\n\n        y = Surv.from_arrays(event, time)\n        assert_array_equal(y, expected)", "label": 1}
{"function": "    def set_hardcoded_usage(self, usage: Usage):\n        self.hardcoded_usage = usage", "label": 0}
{"function": "def _update_previous_errors(\n    previous_errors: List[Flake8Error], replacement_window: Tuple[int, int], replacement_n_lines: int\n) -> List[Flake8Error]:\n    \"\"\"Update the line numbers of the previous errors to what they would be after the edit window.\n    This is a helper function for `_filter_previous_errors`.\n\n    All previous errors that are inside of the edit window should not be ignored,\n    so they are removed from the previous errors list.\n\n    Args:\n        previous_errors: list of errors with old line numbers\n        replacement_window: the window of the edit/lines that will be replaced\n        replacement_n_lines: the number of lines that will be used to replace the text\n\n    Returns:\n        list of errors with updated line numbers\n    \"\"\"\n    updated = []\n    lines_added = replacement_n_lines - (replacement_window[1] - replacement_window[0] + 1)\n    for error in previous_errors:\n        if error.line_number < replacement_window[0]:\n            # no need to adjust the line number\n            updated.append(error)\n            continue\n        if replacement_window[0] <= error.line_number <= replacement_window[1]:\n            # The error is within the edit window, so let's not ignore it\n            # either way (we wouldn't know how to adjust the line number anyway)\n            continue\n        # We're out of the edit window, so we need to adjust the line number\n        updated.append(Flake8Error(error.filename, error.line_number + lines_added, error.col_number, error.problem))\n    return updated", "label": 0}
{"function": "    def mock_fun(_m=\"\"):\n        return \"mock\"", "label": 1}
{"function": "def get_arch_info(a):\n    return (a.cc, a.update_flags, a.writeback, copy_ctypes_list(a.operands[:a.op_count]))", "label": 1}
{"function": "        def on_update(rng):\n            if not rng:\n                del self.headers['content-range']\n            else:\n                self.headers['Content-Range'] = rng.to_header()", "label": 1}
{"function": "  def testDelegateUploadFileToObjectGzipEncodedComposite(self, mock_lock):\n    mock_stream = mock.Mock()\n    mock_stream.close = mock.Mock()\n\n    def DelegateUpload():\n      # Ensure the lock was not aquired before the delegate was called.\n      self.assertFalse(mock_lock.__enter__.called)\n      return 'a', 'b'\n\n    elapsed_time, uploaded_object = _DelegateUploadFileToObject(\n        DelegateUpload, 'url', mock_stream, False, True, True, None)\n    # Ensure results are passed through.\n    self.assertEqual(elapsed_time, 'a')\n    self.assertEqual(uploaded_object, 'b')\n    # Ensure close was called.\n    self.assertTrue(mock_stream.close.called)\n    # Ensure the lock was released.\n    self.assertFalse(mock_lock.__exit__.called)", "label": 1}
{"function": "    def _load_func(index):\n        y, name = ground_truth[index], images[index]\n        im = imread(archive.extractfile(name), num_channels=3)\n        x = _resize_image(im, args.width, args.height, args.mode == 'padding')\n        return x, np.array([y]).astype(np.int32)", "label": 1}
{"function": "def qa_generator():\n    \"\"\"Process chat history CSV files to generate Q&A pair datasets.\"\"\"\n    from weclone.data.qa_generator import DataProcessor\n\n    processor = DataProcessor()\n    processor.main()", "label": 0}
{"function": "def act_quant(x: torch.Tensor, block_size: int = 128) -> Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Quantizes the input tensor `x` using block-wise quantization.\n\n    Args:\n        x (torch.Tensor): The input tensor to be quantized. Must be contiguous and its last dimension size must be divisible by `block_size`.\n        block_size (int, optional): The size of the blocks to be used for quantization. Default is 128.\n\n    Returns:\n        Tuple[torch.Tensor, torch.Tensor]: A tuple containing:\n            - The quantized tensor with dtype `torch.float8_e4m3fn`.\n            - A tensor of scaling factors with dtype `torch.float32`.\n    \"\"\"\n    assert x.is_contiguous(), 'Input tensor must be contiguous'\n    assert x.size(-1) % block_size == 0, f'Last dimension size must be divisible by block_size (block_size={block_size})'\n    y = torch.empty_like(x, dtype=torch.float8_e4m3fn)\n    s = x.new_empty(*x.size()[:-1], x.size(-1) // block_size, dtype=torch.float32)\n    grid = lambda meta: (triton.cdiv(x.numel(), meta['BLOCK_SIZE']), )\n    act_quant_kernel[grid](x, y, s, BLOCK_SIZE=block_size)\n    return y, s", "label": 0}
{"function": "def setup_logging():\n    \"\"\"Configure logging system to output logs to file, memory queue, and console\"\"\"\n    # Create logs directory (if it doesn't exist)\n    logs_dir = os.path.join(os.path.dirname(__file__), \"logs\")\n    os.makedirs(logs_dir, exist_ok=True)\n\n    # Generate log filename (using current date)\n    current_date = datetime.datetime.now().strftime(\"%Y-%m-%d\")\n    log_file = os.path.join(logs_dir, f\"gradio_log_{current_date}.txt\")\n\n    # Configure root logger (captures all logs)\n    root_logger = logging.getLogger()\n\n    # Clear existing handlers to avoid duplicate logs\n    for handler in root_logger.handlers[:]:\n        root_logger.removeHandler(handler)\n\n    root_logger.setLevel(logging.INFO)\n\n    # Create file handler\n    file_handler = logging.FileHandler(log_file, encoding=\"utf-8\", mode=\"a\")\n    file_handler.setLevel(logging.INFO)\n\n    # Create console handler\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n\n    # Create formatter\n    formatter = logging.Formatter(\n        \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    )\n    file_handler.setFormatter(formatter)\n    console_handler.setFormatter(formatter)\n\n    # Add handlers to root logger\n    root_logger.addHandler(file_handler)\n    root_logger.addHandler(console_handler)\n\n    logging.info(\"Logging system initialized, log file: %s\", log_file)\n    return log_file", "label": 0}
{"function": "def resize_img():\n\tdirs = os.listdir(\"split_pic//6\")\n\tfor filename in dirs:\n\t\tim = tf.gfile.FastGFile(\"split_pic//6//{}\".format(filename), 'rb').read()\n\t\t# print(\"\u6b63\u5728\u5904\u7406\u7b2c%d\u5f20\u7167\u7247\"%counter)\n\t\twith tf.Session() as sess:\n\t\t\timg_data = tf.image.decode_jpeg(im)\n\t\t\timage_float = tf.image.convert_image_dtype(img_data, tf.float32)\n\t\t\tresized = tf.image.resize_images(image_float, [64, 64], method=3)\n\t\t\tresized_im = resized.eval()\n\t\t\t# new_mat = np.asarray(resized_im).reshape(1, 64, 64, 3)\n\t\t\tscipy.misc.imsave(\"resized_img6//{}\".format(filename),resized_im)", "label": 1}
{"function": "def load_module(m):\n    global module_in_gpu\n\n    if module_in_gpu == m:\n        return\n\n    unload_module()\n\n    model_memory = memory_management.module_size(m)\n    current_free_mem = memory_management.get_free_memory(gpu)\n    inference_memory = 1.5 * 1024 * 1024 * 1024  # memory_management.minimum_inference_memory() # TODO: connect to main memory system\n    estimated_remaining_memory = current_free_mem - model_memory - inference_memory\n\n    print(f\"[Memory Management] Current Free GPU Memory: {current_free_mem / (1024 * 1024):.2f} MB\")\n    print(f\"[Memory Management] Required Model Memory: {model_memory / (1024 * 1024):.2f} MB\")\n    print(f\"[Memory Management] Required Inference Memory: {inference_memory / (1024 * 1024):.2f} MB\")\n    print(f\"[Memory Management] Estimated Remaining GPU Memory: {estimated_remaining_memory / (1024 * 1024):.2f} MB\")\n\n    is_torch_jit = 'ScriptModule' in type(m).__name__\n\n    if is_torch_jit:\n        print(f'Detected torch jit module: {type(m).__name__}')\n\n    if (ALWAYS_SWAP or estimated_remaining_memory < 0) and not is_torch_jit:\n        print(f'Move module to SWAP: {type(m).__name__}')\n        DynamicSwapInstaller.install_model(m, target_device=gpu)\n        model_gpu_memory_when_using_cpu_swap = memory_management.compute_model_gpu_memory_when_using_cpu_swap(current_free_mem, inference_memory)\n        greedy_move_to_gpu(m, model_gpu_memory_when_using_cpu_swap)\n    else:\n        print(f'Move module to GPU: {type(m).__name__}')\n        m.to(gpu)\n\n    module_in_gpu = m\n    return", "label": 0}
{"function": "def mock_vcr_aiohttp_content(mocker: MockerFixture):\n    try:\n        from vcr.stubs import aiohttp_stubs\n    except ImportError:\n        return\n\n    # google-genai calls `self.response_stream.content.readline()` where `self.response_stream` is a `MockClientResponse`,\n    # which creates a new `MockStream` each time instead of returning the same one, resulting in the readline cursor not being respected.\n    # So we turn `content` into a cached property to return the same one each time.\n    # VCR issue: https://github.com/kevin1024/vcrpy/issues/927. Once that's is resolved, we can remove this patch.\n    cached_content = cached_property(aiohttp_stubs.MockClientResponse.content.fget)  # type: ignore\n    cached_content.__set_name__(aiohttp_stubs.MockClientResponse, 'content')\n    mocker.patch('vcr.stubs.aiohttp_stubs.MockClientResponse.content', new=cached_content)\n    mocker.patch('vcr.stubs.aiohttp_stubs.MockStream.set_exception', return_value=None)", "label": 0}
{"function": "    def files(self):\n        if len(self.metapartitions) > 1:\n            raise AttributeError(\n                \"Accessing `files` attribute is not allowed while nested\"\n            )\n        return self.metapartitions[0][\"files\"]", "label": 1}
{"function": "def get_models(name: str, device: torch.device, offload: bool, is_schnell: bool):\n    t5 = load_t5(device, max_length=256 if is_schnell else 512)\n    clip = load_clip(device)\n    model = load_flow_model(name, device=\"cpu\" if offload else device)\n    ae = load_ae(name, device=\"cpu\" if offload else device)\n    nsfw_classifier = pipeline(\"image-classification\", model=\"Falconsai/nsfw_image_detection\", device=device)\n    return model, ae, t5, clip, nsfw_classifier", "label": 0}
{"function": "        def fget(self):\n            def on_update(header_set):\n                if not header_set and name in self.headers:\n                    del self.headers[name]\n                elif header_set:\n                    self.headers[name] = header_set.to_header()\n            return parse_set_header(self.headers.get(name), on_update)", "label": 1}
{"function": "def load_env_vars():\n    \"\"\"Load environment variables and return as dictionary format\n\n    Returns:\n        dict: Environment variable dictionary, each value is a tuple containing value and source (value, source)\n    \"\"\"\n    dotenv_path = init_env_file()\n    load_dotenv(dotenv_path, override=True)\n\n    # Read environment variables from .env file\n    env_file_vars = {}\n    with open(dotenv_path, \"r\") as f:\n        for line in f:\n            line = line.strip()\n            if line and not line.startswith(\"#\"):\n                if \"=\" in line:\n                    key, value = line.split(\"=\", 1)\n                    env_file_vars[key.strip()] = value.strip().strip(\"\\\"'\")\n\n    # Get from system environment variables\n    system_env_vars = {\n        k: v\n        for k, v in os.environ.items()\n        if k not in env_file_vars and k not in WEB_FRONTEND_ENV_VARS\n    }\n\n    # Merge environment variables and mark sources\n    env_vars = {}\n\n    # Add system environment variables (lowest priority)\n    for key, value in system_env_vars.items():\n        env_vars[key] = (value, \"System\")\n\n    # Add .env file environment variables (medium priority)\n    for key, value in env_file_vars.items():\n        env_vars[key] = (value, \".env file\")\n\n    # Add frontend configured environment variables (highest priority)\n    for key, value in WEB_FRONTEND_ENV_VARS.items():\n        env_vars[key] = (value, \"Frontend configuration\")\n        # Ensure operating system environment variables are also updated\n        os.environ[key] = value\n\n    return env_vars", "label": 0}
{"function": "    def plot_containment_vs_energy(\n        self, ax=None, fractions=[0.68, 0.8, 0.95], **kwargs\n    ):\n        \"\"\"Plot containment versus energy.\"\"\"\n        import matplotlib.pyplot as plt\n\n        ax = plt.gca() if ax is None else ax\n\n        for fraction in fractions:\n            rad = self.containment_radius(self.energy, fraction)\n            label = f\"{100 * fraction:.1f}% Containment\"\n            ax.plot(self.energy.value, rad.value, label=label, **kwargs)\n\n        ax.semilogx()\n        ax.legend(loc=\"best\")\n        ax.set_xlabel(\"Energy (GeV)\")\n        ax.set_ylabel(\"Containment radius (deg)\")", "label": 1}
{"function": "    def __init__(self, translator=None):\n        self.translator = translator\n        self.accounts_file = 'cursor_accounts.txt'", "label": 0}
{"function": "    def __init__(self, max_debate_rounds=1, max_risk_discuss_rounds=1):\n        \"\"\"Initialize with configuration parameters.\"\"\"\n        self.max_debate_rounds = max_debate_rounds\n        self.max_risk_discuss_rounds = max_risk_discuss_rounds", "label": 0}
{"function": "    def prepare_inputs(batch):\n        inp = dict()\n        x = batch.pop(\"video\")\n        y = batch.pop(\"text\")\n        bs = x.shape[0]\n\n        # == encode video ==\n        with nsys.range(\"encode_video\"), timers[\"encode_video\"]:\n            # == prepare condition ==\n            if cfg.get(\"condition_config\", None) is not None:\n                # condition for i2v & v2v\n                x_0, cond = prepare_visual_condition(x, cfg.condition_config, model_ae)\n                cond = pack(cond, patch_size=cfg.get(\"patch_size\", 2))\n                inp[\"cond\"] = cond\n            else:\n                if cfg.get(\"cached_video\", False):\n                    x_0 = batch.pop(\"video_latents\").to(device=device, dtype=dtype)\n                else:\n                    x_0 = model_ae.encode(x)\n\n        # == prepare timestep ==\n        # follow SD3 time shift, shift_alpha = 1 for 256px and shift_alpha = 3 for 1024px\n        shift_alpha = get_res_lin_function()((x_0.shape[-1] * x_0.shape[-2]) // 4)\n        # add temporal influence\n        shift_alpha *= math.sqrt(x_0.shape[-3])  # for image, T=1 so no effect\n        t = torch.sigmoid(torch.randn((bs), device=device))\n        t = time_shift(shift_alpha, t).to(dtype)\n\n        if cfg.get(\"cached_text\", False):\n            # == encode text ==\n            t5_embedding = batch.pop(\"text_t5\").to(device=device, dtype=dtype)\n            clip_embedding = batch.pop(\"text_clip\").to(device=device, dtype=dtype)\n            with nsys.range(\"encode_text\"), timers[\"encode_text\"]:\n                inp_ = prepare_ids(x_0, t5_embedding, clip_embedding)\n                inp.update(inp_)\n                x_0 = pack(x_0, patch_size=cfg.get(\"patch_size\", 2))\n        else:\n            # == encode text ==\n            with nsys.range(\"encode_text\"), timers[\"encode_text\"]:\n                inp_ = prepare(\n                    model_t5,\n                    model_clip,\n                    x_0,\n                    prompt=y,\n                    seq_align=seq_align,\n                    patch_size=cfg.get(\"patch_size\", 2),\n                )\n                inp.update(inp_)\n                x_0 = pack(x_0, patch_size=cfg.get(\"patch_size\", 2))\n\n        # == dropout ==\n        if cfg.get(\"dropout_ratio\", None) is not None:\n            cur_null_txt = null_txt\n            num_pad_null_txt = inp[\"txt\"].shape[1] - cur_null_txt.shape[1]\n            if num_pad_null_txt > 0:\n                cur_null_txt = torch.cat([cur_null_txt] + [cur_null_txt[:, -1:]] * num_pad_null_txt, dim=1)\n            inp[\"txt\"] = dropout_condition(\n                cfg.dropout_ratio.get(\"t5\", 0.0),\n                inp[\"txt\"],\n                cur_null_txt,\n            )\n            inp[\"y_vec\"] = dropout_condition(\n                cfg.dropout_ratio.get(\"clip\", 0.0),\n                inp[\"y_vec\"],\n                null_vec,\n            )\n\n        # == prepare noise vector ==\n        x_1 = torch.randn_like(x_0, dtype=torch.float32).to(device, dtype)\n        t_rev = 1 - t\n        x_t = t_rev[:, None, None] * x_0 + (1 - (1 - sigma_min) * t_rev[:, None, None]) * x_1\n        inp[\"img\"] = x_t\n        inp[\"timesteps\"] = t.to(dtype)\n        inp[\"guidance\"] = torch.full((x_t.shape[0],), cfg.get(\"guidance\", 4), device=x_t.device, dtype=x_t.dtype)\n\n        return inp, x_0, x_1", "label": 0}
{"function": "    def test_engine_distinction(self):\n        \"\"\"Test that cache distinguishes between different translation engines\"\"\"\n        cache1 = cache.TranslationCache(\"engine1\")\n        cache2 = cache.TranslationCache(\"engine2\")\n\n        # Set same text with different engines\n        cache1.set(\"hello\", \"\u4f60\u597d 1\")\n        cache2.set(\"hello\", \"\u4f60\u597d 2\")\n\n        # Verify each engine gets its own translation\n        self.assertEqual(cache1.get(\"hello\"), \"\u4f60\u597d 1\")\n        self.assertEqual(cache2.get(\"hello\"), \"\u4f60\u597d 2\")", "label": 0}
{"function": "def test_asr_pipeline_conversion(test_audio_path):\n    \"\"\"Test ASR pipeline conversion using whisper_turbo model on sample_10s.mp3.\"\"\"\n    # Check if the test audio file exists\n    assert test_audio_path.exists(), f\"Test audio file not found: {test_audio_path}\"\n\n    converter = get_asr_converter()\n\n    # Convert the audio file\n    doc_result: ConversionResult = converter.convert(test_audio_path)\n\n    # Verify conversion was successful\n    assert doc_result.status == ConversionStatus.SUCCESS, (\n        f\"Conversion failed with status: {doc_result.status}\"\n    )\n\n    # Verify we have a document\n    assert doc_result.document is not None, \"No document was created\"\n\n    # Verify we have text content (transcribed audio)\n    texts = doc_result.document.texts\n    assert len(texts) > 0, \"No text content found in transcribed audio\"\n\n    # Print transcribed text for verification (optional, for debugging)\n    print(f\"Transcribed text from {test_audio_path.name}:\")\n    for i, text_item in enumerate(texts):\n        print(f\"  {i + 1}: {text_item.text}\")", "label": 0}
{"function": "    def system_methodHelp(self, method_name):\n        \"\"\"system.methodHelp('add') => \"Adds two integers together\"\n\n        Returns a string containing documentation for the specified method.\"\"\"\n\n        method = None\n        if method_name in self.funcs:\n            method = self.funcs[method_name]\n        elif self.instance is not None:\n            # Instance can implement _methodHelp to return help for a method\n            if hasattr(self.instance, '_methodHelp'):\n                return self.instance._methodHelp(method_name)\n            # if the instance has a _dispatch method then we\n            # don't have enough information to provide help\n            elif not hasattr(self.instance, '_dispatch'):\n                try:\n                    method = resolve_dotted_attribute(\n                                self.instance,\n                                method_name,\n                                self.allow_dotted_names\n                                )\n                except AttributeError:\n                    pass\n\n        # Note that we aren't checking that the method actually\n        # be a callable object of some kind\n        if method is None:\n            return \"\"\n        else:\n            return pydoc.getdoc(method)", "label": 1}
{"function": "    def test_1d_slicing4(self, flags=enable_pyobj_flags):\n        pyfunc = slicing_1d_usecase4\n        arraytype = types.Array(types.int32, 1, 'C')\n        argtys = (arraytype,)\n        cr = compile_isolated(pyfunc, argtys, flags=flags)\n        cfunc = cr.entry_point\n\n        a = np.arange(10, dtype='i4')\n        self.assertEqual(pyfunc(a), cfunc(a))\n\n        # Any\n        arraytype = types.Array(types.int32, 1, 'A')\n        argtys = (arraytype,)\n        cr = compile_isolated(pyfunc, argtys, flags=flags)\n        cfunc = cr.entry_point\n\n        a = np.arange(20, dtype='i4')[::2]\n        self.assertFalse(a.flags['C_CONTIGUOUS'])\n        self.assertFalse(a.flags['F_CONTIGUOUS'])\n        self.assertEqual(pyfunc(a), cfunc(a))", "label": 1}
{"function": "def check_nvidia_gpu():\n    install_package(\"pynvml\")\n    import pynvml\n    from translations.translations import translate as t\n    initialized = False\n    try:\n        pynvml.nvmlInit()\n        initialized = True\n        device_count = pynvml.nvmlDeviceGetCount()\n        if device_count > 0:\n            print(t(\"Detected NVIDIA GPU(s)\"))\n            for i in range(device_count):\n                handle = pynvml.nvmlDeviceGetHandleByIndex(i)\n                name = pynvml.nvmlDeviceGetName(handle)\n                print(f\"GPU {i}: {name}\")\n            return True\n        else:\n            print(t(\"No NVIDIA GPU detected\"))\n            return False\n    except pynvml.NVMLError:\n        print(t(\"No NVIDIA GPU detected or NVIDIA drivers not properly installed\"))\n        return False\n    finally:\n        if initialized:\n            pynvml.nvmlShutdown()", "label": 0}
{"function": "    def show_boxes(self, img, target):\n        bbox_np = target.bbox.data.cpu().numpy()\n        # print('image shape:', img.size())\n        np_img = np.transpose(np.uint8(img.data.cpu().numpy()), (1, 2, 0))\n        img_pil = Image.fromarray(np_img)\n        # print('bbox_np:', bbox_np)\n        draw_img = vis_image(img_pil, bbox_np)\n        draw_img.save('gt_show.jpg', 'jpeg')\n        polys = target.get_field('masks')\n        # print('polys:', polys.polygons)\n        mask_gt = vis_masks(polys.polygons, img_pil.size)\n        mask_gt.save('gt_show_masks.jpg', 'jpeg')\n\n        # print('Sleep for show...')\n        time.sleep(2)", "label": 1}
{"function": "def extract_port_from_command(cmd: str, server_type: str) -> int:\n    port_match = re.search(r\"--port[= ](\\d+)\", cmd)\n    if port_match:\n        return int(port_match.group(1))\n    return SERVER_DEFAULTS.get(server_type, ServerConfig(\"\", [], 8000)).default_port", "label": 0}
{"function": "  def test_calculate_samples_count_per_callchain(self):\n    counters = ipr.calculate_samples_count_per_callchain([\n      [\"foo\", \"BytecodeHandler:bar\"],\n      [\"foo\", \"BytecodeHandler:bar\"],\n      [\"beep\", \"BytecodeHandler:bar\"],\n      [\"hello\", \"v8::internal::Compiler\", \"[compiler]\"],\n    ])\n    self.assertItemsEqual(counters, [\n      ('BytecodeHandler:bar;foo', 2),\n      ('BytecodeHandler:bar;beep', 1),\n      ('[compiler];v8::internal::Compiler;hello', 1),\n    ])", "label": 1}
{"function": "    def test_removes_fragment(self):\n        \"\"\"Fragment should be removed per RFC 8707.\"\"\"\n        assert resource_url_from_server_url(\"https://example.com/path#fragment\") == \"https://example.com/path\"\n        assert resource_url_from_server_url(\"https://example.com/#fragment\") == \"https://example.com/\"", "label": 0}
{"function": "    def test_from_array_event_value_wrong_4(surv_arrays):\n        event, time = surv_arrays\n        event[1] = 3\n\n        with pytest.raises(ValueError,\n                           match=\"event indicator must be binary\"):\n            Surv.from_arrays(event, time)", "label": 1}
{"function": "    def test_hillclimb(self):\n        # arrange\n        initial_alignment = AlignmentInfo((0, 3, 2), None, None, None)\n\n        def neighboring_mock(a, j):\n            if a.alignment == (0, 3, 2):\n                return set(\n                    [\n                        AlignmentInfo((0, 2, 2), None, None, None),\n                        AlignmentInfo((0, 1, 1), None, None, None),\n                    ]\n                )\n            elif a.alignment == (0, 2, 2):\n                return set(\n                    [\n                        AlignmentInfo((0, 3, 3), None, None, None),\n                        AlignmentInfo((0, 4, 4), None, None, None),\n                    ]\n                )\n            return set()\n\n        def prob_t_a_given_s_mock(a):\n            prob_values = {\n                (0, 3, 2): 0.5,\n                (0, 2, 2): 0.6,\n                (0, 1, 1): 0.4,\n                (0, 3, 3): 0.6,\n                (0, 4, 4): 0.7,\n            }\n            return prob_values.get(a.alignment, 0.01)\n\n        ibm_model = IBMModel([])\n        ibm_model.neighboring = neighboring_mock\n        ibm_model.prob_t_a_given_s = prob_t_a_given_s_mock\n\n        # act\n        best_alignment = ibm_model.hillclimb(initial_alignment)\n\n        # assert: hill climbing goes from (0, 3, 2) -> (0, 2, 2) -> (0, 4, 4)\n        self.assertEqual(best_alignment.alignment, (0, 4, 4))", "label": 1}
{"function": "async def computer():\n    \"\"\"Shared Computer instance for all test cases.\"\"\"\n    # Create a remote Linux computer with C/ua\n    computer = Computer(\n        os_type=\"linux\",\n        api_key=os.getenv(\"CUA_API_KEY\"),\n        name=str(os.getenv(\"CUA_CONTAINER_NAME\")),\n        provider_type=VMProviderType.CLOUD,\n    )\n    \n    # Create a local macOS computer with C/ua\n    # computer = Computer()\n    \n    # Connect to host computer\n    # computer = Computer(use_host_computer_server=True)\n    \n    try:\n        await computer.run()\n        yield computer\n    finally:\n        await computer.disconnect()", "label": 0}
{"function": "  def get_prior_mean(self):\n    \"\"\"If un-chunked data is available, set initial level to the first value.\"\"\"\n    with variable_scope.variable_scope(self._variable_scope):\n      if self._input_statistics is not None:\n        # TODO(allenl): Better support for multivariate series here.\n        initial_value = array_ops.stack([\n            math_ops.reduce_mean(\n                self._scale_data(\n                    self._input_statistics.series_start_moments.mean)),\n            0.\n        ])\n        return initial_value + variable_scope.get_variable(\n            name=\"prior_state_mean\",\n            shape=initial_value.get_shape(),\n            initializer=init_ops.zeros_initializer(),\n            dtype=self.dtype,\n            trainable=self._configuration.trainable_start_state)\n      else:\n        return super(AdderStateSpaceModel, self).get_prior_mean()", "label": 1}
{"function": "    def hvac_action(self):\n        \"\"\"Return current operation ie. heat, cool, idle.\"\"\"\n        return self._hvac_action", "label": 1}
{"function": "def gradio_demo(\n    target_dir,\n    conf_thres=3.0,\n    frame_filter=\"All\",\n    mask_black_bg=False,\n    mask_white_bg=False,\n    show_cam=True,\n    mask_sky=False,\n    prediction_mode=\"Pointmap Regression\",\n):\n    \"\"\"\n    Perform reconstruction using the already-created target_dir/images.\n    \"\"\"\n    if not os.path.isdir(target_dir) or target_dir == \"None\":\n        return None, \"No valid target directory found. Please upload first.\", None, None\n\n    start_time = time.time()\n    gc.collect()\n    torch.cuda.empty_cache()\n\n    # Prepare frame_filter dropdown\n    target_dir_images = os.path.join(target_dir, \"images\")\n    all_files = sorted(os.listdir(target_dir_images)) if os.path.isdir(target_dir_images) else []\n    all_files = [f\"{i}: {filename}\" for i, filename in enumerate(all_files)]\n    frame_filter_choices = [\"All\"] + all_files\n\n    print(\"Running run_model...\")\n    with torch.no_grad():\n        predictions = run_model(target_dir, model)\n\n    # Save predictions\n    prediction_save_path = os.path.join(target_dir, \"predictions.npz\")\n    np.savez(prediction_save_path, **predictions)\n\n    # Handle None frame_filter\n    if frame_filter is None:\n        frame_filter = \"All\"\n\n    # Build a GLB file name\n    glbfile = os.path.join(\n        target_dir,\n        f\"glbscene_{conf_thres}_{frame_filter.replace('.', '_').replace(':', '').replace(' ', '_')}_maskb{mask_black_bg}_maskw{mask_white_bg}_cam{show_cam}_sky{mask_sky}_pred{prediction_mode.replace(' ', '_')}.glb\",\n    )\n\n    # Convert predictions to GLB\n    glbscene = predictions_to_glb(\n        predictions,\n        conf_thres=conf_thres,\n        filter_by_frames=frame_filter,\n        mask_black_bg=mask_black_bg,\n        mask_white_bg=mask_white_bg,\n        show_cam=show_cam,\n        mask_sky=mask_sky,\n        target_dir=target_dir,\n        prediction_mode=prediction_mode,\n    )\n    glbscene.export(file_obj=glbfile)\n\n    # Cleanup\n    del predictions\n    gc.collect()\n    torch.cuda.empty_cache()\n\n    end_time = time.time()\n    print(f\"Total time: {end_time - start_time:.2f} seconds (including IO)\")\n    log_msg = f\"Reconstruction Success ({len(all_files)} frames). Waiting for visualization.\"\n\n    return glbfile, log_msg, gr.Dropdown(choices=frame_filter_choices, value=frame_filter, interactive=True)", "label": 0}
{"function": "    def filter(self, *args, **kwargs):\n        \"\"\"Apply filter for querying document\n\n        Apply where filter as many as you want\n\n        Parameters\n        ---------\n        args: Tuple\n            Contain three things 1- field name, 2-operation, 3-value\n\n        kwargs:\n            keyword args Direct assign for equal filter\n\n        Returns\n        -------\n        self:\n            Return self object\n        \"\"\"\n        if args:\n            self.select_query.append(args)\n        elif kwargs:\n            for k, v in kwargs.items():\n                self.select_query.append((k, '==', v))\n        return self", "label": 1}
{"function": "    def digest(self):\n        return msdcc.encrypt(self._data[:64], user=self._user).decode('hex')", "label": 1}
{"function": "def pytest_json_runtest_metadata(item, call):\n    \"\"\"Add model and case_id to pytest-json report metadata.\"\"\"\n    metadata = {}\n    nodeid = item.nodeid\n\n    # 1. Extract model from callspec if available\n    model = item.callspec.params.get(\"model\") if hasattr(item, \"callspec\") else None\n    if model:\n        metadata[\"model\"] = model\n    else:\n        # Fallback: Try parsing from nodeid (less reliable)\n        match_model = re.search(r\"\\[(.*?)-\", nodeid)\n        if match_model:\n            model = match_model.group(1)  # Store model even if found via fallback\n            metadata[\"model\"] = model\n        else:\n            print(f\"Warning: Could not determine model for test {nodeid}\")\n            model = None  # Ensure model is None if not found\n\n    # 2. Extract case_id using the known model string if possible\n    if model:\n        # Construct a regex pattern to find the case_id *after* the model name and a hyphen.\n        # Escape the model name in case it contains regex special characters.\n        pattern = re.escape(model) + r\"-(.*?)\\]$\"\n        match_case = re.search(pattern, nodeid)\n        if match_case:\n            case_id = match_case.group(1)\n            metadata[\"case_id\"] = case_id\n        else:\n            # Fallback if the pattern didn't match (e.g., nodeid format unexpected)\n            # Try the old less specific regex as a last resort.\n            match_case_fallback = re.search(r\"-(.*?)\\]$\", nodeid)\n            if match_case_fallback:\n                case_id = match_case_fallback.group(1)\n                metadata[\"case_id\"] = case_id\n                print(f\"Warning: Used fallback regex to parse case_id from nodeid {nodeid}\")\n            else:\n                print(f\"Warning: Could not parse case_id from nodeid {nodeid} even with fallback.\")\n                if \"case\" in (item.callspec.params if hasattr(item, \"callspec\") else {}):\n                    metadata[\"case_id\"] = \"parsing_failed\"\n    elif \"case\" in (item.callspec.params if hasattr(item, \"callspec\") else {}):\n        # Cannot reliably parse case_id without model, but we know it's a case test.\n        # Try the generic fallback regex.\n        match_case_fallback = re.search(r\"-(.*?)\\]$\", nodeid)\n        if match_case_fallback:\n            case_id = match_case_fallback.group(1)\n            metadata[\"case_id\"] = case_id\n            print(f\"Warning: Used fallback regex to parse case_id from nodeid {nodeid} (model unknown)\")\n        else:\n            print(f\"Warning: Could not parse case_id from nodeid {nodeid} (model unknown)\")\n            metadata[\"case_id\"] = \"parsing_failed_no_model\"\n    # else: Not a test with a model or case param we need to handle.\n\n    return metadata", "label": 0}
{"function": "def split_line(text: str) -> List[str]:\n    \"\"\"Split text into lines based on terminal width.\"\"\"\n    term_width = shutil.get_terminal_size().columns or 80\n    if not text.strip():\n        return []\n    # Split by explicit newlines and wrap long lines\n    lines = []\n    for line in text.split('\\n'):\n        while len(line) > term_width:\n            lines.append(line[:term_width])\n            line = line[term_width:]\n        if line:\n            lines.append(line)\n    return lines", "label": 0}
{"function": "    def __init__(self, name, value=None):\n        RegistryValue.__init__(self, name, 'REG_MULTI_SZ', value)", "label": 1}
{"function": "def build_ui(model_dir, device=0):\n\n    # Initialize model\n    model = initialize_model(model_dir, device=device)\n\n    # Define callback function for voice cloning\n    def voice_clone(text, prompt_text, prompt_wav_upload, prompt_wav_record):\n        \"\"\"\n        Gradio callback to clone voice using text and optional prompt speech.\n        - text: The input text to be synthesised.\n        - prompt_text: Additional textual info for the prompt (optional).\n        - prompt_wav_upload/prompt_wav_record: Audio files used as reference.\n        \"\"\"\n        prompt_speech = prompt_wav_upload if prompt_wav_upload else prompt_wav_record\n        prompt_text_clean = None if len(prompt_text) < 2 else prompt_text\n\n        audio_output_path = run_tts(\n            text,\n            model,\n            prompt_text=prompt_text_clean,\n            prompt_speech=prompt_speech\n        )\n        return audio_output_path\n\n    # Define callback function for creating new voices\n    def voice_creation(text, gender, pitch, speed):\n        \"\"\"\n        Gradio callback to create a synthetic voice with adjustable parameters.\n        - text: The input text for synthesis.\n        - gender: 'male' or 'female'.\n        - pitch/speed: Ranges mapped by LEVELS_MAP_UI.\n        \"\"\"\n        pitch_val = LEVELS_MAP_UI[int(pitch)]\n        speed_val = LEVELS_MAP_UI[int(speed)]\n        audio_output_path = run_tts(\n            text,\n            model,\n            gender=gender,\n            pitch=pitch_val,\n            speed=speed_val\n        )\n        return audio_output_path\n\n    with gr.Blocks() as demo:\n        # Use HTML for centered title\n        gr.HTML('<h1 style=\"text-align: center;\">Spark-TTS by SparkAudio</h1>')\n        with gr.Tabs():\n            # Voice Clone Tab\n            with gr.TabItem(\"Voice Clone\"):\n                gr.Markdown(\n                    \"### Upload reference audio or recording \uff08\u4e0a\u4f20\u53c2\u8003\u97f3\u9891\u6216\u8005\u5f55\u97f3\uff09\"\n                )\n\n                with gr.Row():\n                    prompt_wav_upload = gr.Audio(\n                        sources=\"upload\",\n                        type=\"filepath\",\n                        label=\"Choose the prompt audio file, ensuring the sampling rate is no lower than 16kHz.\",\n                    )\n                    prompt_wav_record = gr.Audio(\n                        sources=\"microphone\",\n                        type=\"filepath\",\n                        label=\"Record the prompt audio file.\",\n                    )\n\n                with gr.Row():\n                    text_input = gr.Textbox(\n                        label=\"Text\", lines=3, placeholder=\"Enter text here\"\n                    )\n                    prompt_text_input = gr.Textbox(\n                        label=\"Text of prompt speech (Optional; recommended for cloning in the same language.)\",\n                        lines=3,\n                        placeholder=\"Enter text of the prompt speech.\",\n                    )\n\n                audio_output = gr.Audio(\n                    label=\"Generated Audio\", autoplay=True, streaming=True\n                )\n\n                generate_buttom_clone = gr.Button(\"Generate\")\n\n                generate_buttom_clone.click(\n                    voice_clone,\n                    inputs=[\n                        text_input,\n                        prompt_text_input,\n                        prompt_wav_upload,\n                        prompt_wav_record,\n                    ],\n                    outputs=[audio_output],\n                )\n\n            # Voice Creation Tab\n            with gr.TabItem(\"Voice Creation\"):\n                gr.Markdown(\n                    \"### Create your own voice based on the following parameters\"\n                )\n\n                with gr.Row():\n                    with gr.Column():\n                        gender = gr.Radio(\n                            choices=[\"male\", \"female\"], value=\"male\", label=\"Gender\"\n                        )\n                        pitch = gr.Slider(\n                            minimum=1, maximum=5, step=1, value=3, label=\"Pitch\"\n                        )\n                        speed = gr.Slider(\n                            minimum=1, maximum=5, step=1, value=3, label=\"Speed\"\n                        )\n                    with gr.Column():\n                        text_input_creation = gr.Textbox(\n                            label=\"Input Text\",\n                            lines=3,\n                            placeholder=\"Enter text here\",\n                            value=\"You can generate a customized voice by adjusting parameters such as pitch and speed.\",\n                        )\n                        create_button = gr.Button(\"Create Voice\")\n\n                audio_output = gr.Audio(\n                    label=\"Generated Audio\", autoplay=True, streaming=True\n                )\n                create_button.click(\n                    voice_creation,\n                    inputs=[text_input_creation, gender, pitch, speed],\n                    outputs=[audio_output],\n                )\n\n    return demo", "label": 0}
{"function": "    def from_dict(cls, conv_turn_dict: Dict):\n        raw_retrieved_info = [\n            Information.from_dict(info) for info in conv_turn_dict[\"raw_retrieved_info\"]\n        ]\n\n        return cls(\n            utterance=conv_turn_dict[\"utterance\"],\n            raw_utterance=conv_turn_dict[\"raw_utterance\"],\n            role=f\"{conv_turn_dict['role']}: {conv_turn_dict['role_description']}\",\n            queries=conv_turn_dict[\"queries\"],\n            raw_retrieved_info=raw_retrieved_info,\n            cited_info=None,\n            utterance_type=conv_turn_dict[\"utterance_type\"],\n            claim_to_make=conv_turn_dict[\"claim_to_make\"],\n        )", "label": 0}
{"function": "    def __init__(self, locale, has_enough_context, thought, title, steps):\n        self.locale = locale\n        self.has_enough_context = has_enough_context\n        self.thought = thought\n        self.title = title\n        self.steps = steps", "label": 0}
{"function": "    def initialize(self) -> None:\n        \"\"\"Initialize.\"\"\"\n        super().initialize()\n        self.door_sensor = self.args[\"mail_door_sensor\"]\n        self.slot_sensor = self.args[\"mail_slot_sensor\"]\n        self.mail_status = self.args[\"mail_status\"]\n        self.state = self.get_state(self.mail_status)\n\n        self.newState = \"\"\n        self.just_opened_door = False\n        self.just_notified = False\n        \n        self.listen_state(self.just_opened, self.args[\"door\"])\n\n        if \"mail_slot_sensor\" in self.args:\n            self.listen_state(self.mailbox_opened, self.slot_sensor)\n        if \"mail_door_sensor\" in self.args:\n            self.listen_state(self.mailbox_opened, self.door_sensor)", "label": 1}
{"function": "    def _convert_write_data(self, tag, data_type, write_values):\n        \"\"\"\n        In order to handle write requests that are larger than a single\n        packet, we'll break up the values to write into multiple lists\n        of values.  The size of each list will be calculated based on the\n        connection size, length of the tag name and the data type.\n        \"\"\"\n        # packet header is always 110 bytes\n        packet_overhead = 110\n        # calculate number of bytes tag name will occupy\n        tag_length = len(tag) + len(tag) % 2\n        # calculate the available space (in bytes) for the write values\n        space_for_payload = self.ConnectionSize - packet_overhead - tag_length\n\n        # calculate how many bytes per value are required\n        bytes_per_value  = self.CIPTypes[data_type][0]\n        # calculate the limit for values in each request\n        limit = int(space_for_payload / bytes_per_value)\n        # split the list up into multiple smaller lists\n        chunks = [write_values[x:x+limit] for x in range(0, len(write_values), limit)]\n        return chunks", "label": 1}
{"function": "def chat(prompt, model:str,llm_auth_token:str,llm_base_url:str,using_custom_llm=False,stream=True, debug=False):\n    openai.base_url = \"http://127.0.0.1:3040/v1/\"\n\n    if model == \"gpt3.5\":\n        openai.base_url = \"http://llm-freegpt35:3040/v1/\"\n    \n    if model == \"kimi\":\n        openai.base_url = \"http://llm-kimi:8000/v1/\"\n    if model == \"glm4\":\n        openai.base_url = \"http://llm-glm4:8000/v1/\"\n    if model == \"qwen\":\n        openai.base_url = \"http://llm-qwen:8000/v1/\"\n    \n\n    if llm_auth_token == '':\n        llm_auth_token = \"CUSTOM\"\n        \n    openai.api_key = llm_auth_token\n\n    if using_custom_llm:\n        openai.base_url = llm_base_url\n        openai.api_key = llm_auth_token\n\n\n    total_content = \"\"\n    for chunk in openai.chat.completions.create(\n        model=model,\n        messages=[{\n            \"role\": \"user\",\n            \"content\": prompt\n        }],\n        stream=True,\n        max_tokens=1024,temperature=0.2\n    ):\n        stream_resp = chunk.dict()\n        token = stream_resp[\"choices\"][0][\"delta\"].get(\"content\", \"\")\n        if token:\n            \n            total_content += token\n            yield token\n    if debug:\n        print(total_content)", "label": 0}
{"function": "def create_message_content(text, image_path=None):\n    content = [{\"type\": \"text\", \"text\": text}]\n    image_format = \"png\" if image_path and image_path.endswith(\".png\") else \"jpeg\"\n    if image_path:\n        from src.utils import utils\n        image_data = utils.encode_image(image_path)\n        content.append({\n            \"type\": \"image_url\",\n            \"image_url\": {\"url\": f\"data:image/{image_format};base64,{image_data}\"}\n        })\n    return content", "label": 0}
{"function": "def progress_bar(progress, total, prefix=\"\", length=50):\n    filled = int(length * progress // total)\n    bar = \"\u2588\" * filled + \"\u2591\" * (length - filled)\n    percent = f\"{100 * progress / total:.1f}\"\n    print(f\"\\r{prefix} |{bar}| {percent}% Complete\", end=\"\", flush=True)\n    if progress == total:\n        print()", "label": 0}
{"function": "    def test_delitem_with_1_invalid_key(self):\n        d = {\n            'a': 1,\n        }\n        b = KeypathDict(d)\n        with self.assertRaises(KeyError):\n            del b['b']\n        self.assertEqual(b.get('b'), None)", "label": 1}
{"function": "    def __init__(\n        self,\n        t3: T3,\n        s3gen: S3Gen,\n        ve: VoiceEncoder,\n        tokenizer: EnTokenizer,\n        device: str,\n        conds: Conditionals = None,\n    ):\n        self.sr = S3GEN_SR  # sample rate of synthesized audio\n        self.t3 = t3\n        self.s3gen = s3gen\n        self.ve = ve\n        self.tokenizer = tokenizer\n        self.device = device\n        self.conds = conds\n        self.watermarker = perth.PerthImplicitWatermarker()", "label": 0}
{"function": "  def _log_prob(self, x):\n    x = control_flow_ops.with_dependencies([check_ops.assert_positive(x)] if\n                                           self.validate_args else [], x)\n    contrib_tensor_util.assert_same_float_dtype(tensors=[x],\n                                                dtype=self.dtype)\n    return (self.alpha * math_ops.log(self.beta) +\n            (self.alpha - 1.) * math_ops.log(x) -\n            self.beta * x -\n            math_ops.lgamma(self.alpha))", "label": 1}
{"function": "    def __init__(self, serialport):\n        self.serialport = serialport\n        self.logger = logging.getLogger('umap2')\n        self.reset()", "label": 1}
{"function": "  def testExecuteUpdateJobsSuccessMultiplePendingDepsOneCloudStorageCollision(\n      self, uploader_cs_mock):\n    uploader_cs_mock.Exists.side_effect = [False, True]\n    self.fs.CreateFile(self.file_path,\n                       contents='\\n'.join(self.expected_file_lines))\n    config = dependency_manager.BaseConfig(self.file_path, writable=True)\n    config._config_data = self.final_dependencies.copy()\n    config._pending_uploads = [self.new_pending_upload,\n                               self.final_pending_upload]\n    self.assertEqual(self.final_dependencies, config._config_data)\n    self.assertTrue(config._IsDirty())\n    self.assertEqual(2, len(config._pending_uploads))\n    self.assertEqual(self.new_pending_upload, config._pending_uploads[0])\n    self.assertEqual(self.final_pending_upload, config._pending_uploads[1])\n\n    expected_exists_calls = [mock.call(self.new_bucket, self.new_remote_path),\n                             mock.call(self.final_bucket,\n                                       self.final_remote_path)]\n    expected_insert_calls = [mock.call(self.new_bucket, self.new_remote_path,\n                                       self.new_dep_path),\n                             mock.call(self.final_bucket,\n                                       self.final_remote_path,\n                                       self.final_dep_path)]\n    expected_copy_calls = [mock.call(self.final_bucket, self.final_bucket,\n                                     self.final_remote_path,\n                                     self.expected_final_backup_path)]\n\n    self.assertTrue(config.ExecuteUpdateJobs(force=True))\n    self.assertFalse(config._IsDirty())\n    self.assertFalse(config._pending_uploads)\n    self.assertEqual(self.final_dependencies, config._config_data)\n    file_module = fake_filesystem.FakeFileOpen(self.fs)\n    expected_file_lines = list(self.final_expected_file_lines)\n    for line in file_module(self.file_path):\n      self.assertEqual(expected_file_lines.pop(0), line.strip())\n    self.fs.CloseOpenFile(file_module(self.file_path))\n    self.assertFalse(config._pending_uploads)\n    self.assertEqual(expected_insert_calls,\n                     uploader_cs_mock.Insert.call_args_list)\n    self.assertEqual(expected_exists_calls,\n                     uploader_cs_mock.Exists.call_args_list)\n    self.assertEqual(expected_copy_calls,\n                     uploader_cs_mock.Copy.call_args_list)", "label": 1}
{"function": "def test_run_with_simple_message(mock_openai_client: MockOpenAIClient):\n    agent = Agent()\n    # set up client and run\n    client = Swarm(client=mock_openai_client)\n    messages = [{\"role\": \"user\", \"content\": \"Hello, how are you?\"}]\n    response = client.run(agent=agent, messages=messages)\n\n    # assert response content\n    assert response.messages[-1][\"role\"] == \"assistant\"\n    assert response.messages[-1][\"content\"] == DEFAULT_RESPONSE_CONTENT", "label": 0}
{"function": "def chat():\n    data = request.json\n    message = data.get('message', '')\n    image_data = data.get('image')  # Get the base64 image data\n    \n    # Prepare the message content\n    if image_data:\n        # Create a message with both text and image in correct order\n        message_content = [\n            {\n                \"type\": \"image\",\n                \"source\": {\n                    \"type\": \"base64\",\n                    \"media_type\": \"image/jpeg\",  # We should detect this from the image\n                    \"data\": image_data.split(',')[1] if ',' in image_data else image_data  # Remove data URL prefix if present\n                }\n            }\n        ]\n        \n        # Only add text message if there is actual text\n        if message.strip():\n            message_content.append({\n                \"type\": \"text\",\n                \"text\": message\n            })\n    else:\n        # Text-only message\n        message_content = message\n    \n    try:\n        # Handle the chat message with the appropriate content\n        response = assistant.chat(message_content)\n        \n        # Get token usage from assistant\n        token_usage = {\n            'total_tokens': assistant.total_tokens_used,\n            'max_tokens': Config.MAX_CONVERSATION_TOKENS\n        }\n        \n        # Get the last used tool from the conversation history\n        tool_name = None\n        if assistant.conversation_history:\n            for msg in reversed(assistant.conversation_history):\n                if msg.get('role') == 'assistant' and msg.get('content'):\n                    content = msg['content']\n                    if isinstance(content, list):\n                        for block in content:\n                            if isinstance(block, dict) and block.get('type') == 'tool_use':\n                                tool_name = block.get('name')\n                                break\n                    if tool_name:\n                        break\n        \n        return jsonify({\n            'response': response,\n            'thinking': False,\n            'tool_name': tool_name,\n            'token_usage': token_usage\n        })\n        \n    except Exception as e:\n        return jsonify({\n            'response': f\"Error: {str(e)}\",\n            'thinking': False,\n            'tool_name': None,\n            'token_usage': None\n        }), 200  # Return 200 even for errors to handle them gracefully in frontend", "label": 0}
{"function": "    def test_from_array_event_value_wrong_2(surv_arrays):\n        event, time = surv_arrays\n        event -= 1\n\n        with pytest.raises(ValueError,\n                           match=\"non-boolean event indicator must contain 0 and 1 only\"):\n            Surv.from_arrays(event, time)", "label": 1}
{"function": "def loader_with_dummy(monkeypatch):\n    \"\"\"Fixture returning a ChromiumLoader instance with dummy scraping methods patched.\"\"\"\n    urls = [\"http://example.com\", \"http://test.com\"]\n    loader = ChromiumLoader(urls, backend=\"playwright\", requires_js_support=False)\n    monkeypatch.setattr(loader, \"ascrape_playwright\", dummy_scraper)\n    monkeypatch.setattr(loader, \"ascrape_with_js_support\", dummy_scraper)\n    monkeypatch.setattr(loader, \"ascrape_undetected_chromedriver\", dummy_scraper)\n    return loader", "label": 0}
{"function": "def postprocess(speech, top_db=60, hop_length=220, win_length=440):\n    speech, _ = librosa.effects.trim(\n        speech, top_db=top_db,\n        frame_length=win_length,\n        hop_length=hop_length\n    )\n    if speech.abs().max() > max_val:\n        speech = speech / speech.abs().max() * max_val\n    speech = torch.concat([speech, torch.zeros(1, int(cosyvoice.sample_rate * 0.2))], dim=1)\n    return speech", "label": 0}
{"function": "    def valGranuleUR(self, obj):\n        \"\"\"Function to add GranuleUR\n\n        :param obj: element to add GranuleUR\n        \"\"\"\n        values = []\n        for i in self.parModis:\n            values.append(i.retGranuleUR())\n        for i in set(values):\n            gur = self.ElementTree.SubElement(obj, 'GranuleUR')\n            gur.text = i", "label": 1}
{"function": "    def test_preserves_query(self):\n        \"\"\"Query parameters should be preserved.\"\"\"\n        assert resource_url_from_server_url(\"https://example.com/path?foo=bar\") == \"https://example.com/path?foo=bar\"\n        assert resource_url_from_server_url(\"https://example.com/?key=value\") == \"https://example.com/?key=value\"", "label": 0}
{"function": "def load_llama3_tokenizer():\n    \"\"\"\n    https://github.com/huggingface/transformers/issues/22794#issuecomment-2092623992\n    \"\"\"\n    tokenizer_name = \"meta-llama/Llama-3.2-1B\"\n    tokenizer = AutoTokenizer.from_pretrained(tokenizer_name)\n    bos = tokenizer.bos_token\n    eos = tokenizer.eos_token\n    tokenizer._tokenizer.post_processor = TemplateProcessing(\n        single=f\"{bos}:0 $A:0 {eos}:0\",\n        pair=f\"{bos}:0 $A:0 {eos}:0 {bos}:1 $B:1 {eos}:1\",\n        special_tokens=[(f\"{bos}\", tokenizer.bos_token_id), (f\"{eos}\", tokenizer.eos_token_id)],\n    )\n\n    return tokenizer", "label": 0}
{"function": "def main(\n    ckpt_dir: str,\n    tokenizer_path: str,\n    temperature: float = 0.6,\n    top_p: float = 0.9,\n    max_seq_len: int = 128,\n    max_gen_len: int = 64,\n    max_batch_size: int = 4,\n):\n    \"\"\"\n    Examples to run with the pre-trained models (no fine-tuning). Prompts are\n    usually in the form of an incomplete text prefix that the model can then try to complete.\n\n    The context window of llama3 models is 8192 tokens, so `max_seq_len` needs to be <= 8192.\n    `max_gen_len` is needed because pre-trained models usually do not stop completions naturally.\n    \"\"\"\n    generator = Llama.build(\n        ckpt_dir=ckpt_dir,\n        tokenizer_path=tokenizer_path,\n        max_seq_len=max_seq_len,\n        max_batch_size=max_batch_size,\n    )\n\n    prompts: List[str] = [\n        # For these prompts, the expected answer is the natural continuation of the prompt\n        \"I believe the meaning of life is\",\n        \"Simply put, the theory of relativity states that \",\n        \"\"\"A brief message congratulating the team on the launch:\n\n        Hi everyone,\n\n        I just \"\"\",\n        # Few shot prompt (providing a few examples before asking model to complete more);\n        \"\"\"Translate English to French:\n\n        sea otter => loutre de mer\n        peppermint => menthe poivr\u00e9e\n        plush girafe => girafe peluche\n        cheese =>\"\"\",\n    ]\n    results = generator.text_completion(\n        prompts,\n        max_gen_len=max_gen_len,\n        temperature=temperature,\n        top_p=top_p,\n    )\n    for prompt, result in zip(prompts, results):\n        print(prompt)\n        print(f\"> {result['generation']}\")\n        print(\"\\n==================================\\n\")", "label": 0}
{"function": "\tdef history(self):\n\t\t\"\"\" Return an iterator over Row-tasks which iterates over all the\n\t\ttasks in existence, sorted by their date of creation.\"\"\"\n\t\tc = self.connection.cursor()\n\t\tc.execute(\"\"\"\n\t\t\tSELECT t.*, c.path as ctx_path\n\t\t\tFROM Task t JOIN Context c\n\t\t\tON t.context = c.id\n\t\t\tORDER BY t.created\n\t\t\"\"\")\n\t\treturn c", "label": 1}
{"function": "    def current_humidity(self):\n        \"\"\"Return the current humidity.\"\"\"\n        return self._current_humidity", "label": 1}
{"function": "def process(input_image, prompt, n_prompt, seed, total_second_length, latent_window_size, steps, cfg, gs, rs, gpu_memory_preservation, use_teacache, mp4_crf):\n    global stream\n    assert input_image is not None, 'No input image!'\n\n    yield None, None, '', '', gr.update(interactive=False), gr.update(interactive=True)\n\n    stream = AsyncStream()\n\n    async_run(worker, input_image, prompt, n_prompt, seed, total_second_length, latent_window_size, steps, cfg, gs, rs, gpu_memory_preservation, use_teacache, mp4_crf)\n\n    output_filename = None\n\n    while True:\n        flag, data = stream.output_queue.next()\n\n        if flag == 'file':\n            output_filename = data\n            yield output_filename, gr.update(), gr.update(), gr.update(), gr.update(interactive=False), gr.update(interactive=True)\n\n        if flag == 'progress':\n            preview, desc, html = data\n            yield gr.update(), gr.update(visible=True, value=preview), desc, html, gr.update(interactive=False), gr.update(interactive=True)\n\n        if flag == 'end':\n            yield output_filename, gr.update(visible=False), gr.update(), '', gr.update(interactive=True), gr.update(interactive=False)\n            break", "label": 0}
{"function": "def main():\n    torch.set_grad_enabled(False)\n    # ======================================================\n    # configs & runtime variables\n    # ======================================================\n    # == parse configs ==\n    cfg = parse_configs()\n\n    # == get dtype & device ==\n    dtype = to_torch_dtype(cfg.get(\"dtype\", \"bf16\"))\n    device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n    if is_distributed():\n        colossalai.launch_from_torch({})\n        device = get_current_device()\n    set_seed(cfg.get(\"seed\", 1024))\n\n    # == init logger ==\n    logger = create_logger()\n    logger.info(\"Inference configuration:\\n %s\", pformat(cfg.to_dict()))\n    verbose = cfg.get(\"verbose\", 1)\n\n    # ======================================================\n    # build model & loss\n    # ======================================================\n    if cfg.get(\"ckpt_path\", None) is not None:\n        cfg.model.from_pretrained = cfg.ckpt_path\n    logger.info(\"Building models...\")\n    model = build_module(cfg.model, MODELS, device_map=device, torch_dtype=dtype).eval()\n    log_model_params(model)\n\n    # ======================================================\n    # build dataset and dataloader\n    # ======================================================\n    logger.info(\"Building dataset...\")\n    # == build dataset ==\n    dataset = build_module(cfg.dataset, DATASETS)\n    logger.info(\"Dataset contains %s samples.\", len(dataset))\n    # == build dataloader ==\n    dataloader_args = dict(\n        dataset=dataset,\n        batch_size=cfg.get(\"batch_size\", None),\n        num_workers=cfg.get(\"num_workers\", 4),\n        seed=cfg.get(\"seed\", 1024),\n        shuffle=False,\n        drop_last=False,\n        pin_memory=True,\n        process_group=get_data_parallel_group(),\n        prefetch_factor=cfg.get(\"prefetch_factor\", None),\n    )\n\n    if cfg.get(\"eval_setting\", None) is not None:\n        # e.g. 32x256x256, 1x1024x1024\n        num_frames = int(cfg.eval_setting.split(\"x\")[0])\n        resolution = str(cfg.eval_setting.split(\"x\")[-1])\n        bucket_config = {\n            resolution + \"px_ar1:1\": {num_frames: (1.0, 1)},\n        }\n        print(\"eval setting:\\n\", bucket_config)\n    else:\n        bucket_config = cfg.get(\"bucket_config\", None)\n\n    dataloader, _ = prepare_dataloader(\n        bucket_config=bucket_config,\n        num_bucket_build_workers=cfg.get(\"num_bucket_build_workers\", 1),\n        **dataloader_args,\n    )\n    dataiter = iter(dataloader)\n    num_steps_per_epoch = len(dataloader)\n\n    # ======================================================\n    # inference\n    # ======================================================\n    num_samples = 0\n    running_sum = running_var = 0.0\n\n    # Iter over the dataset\n    with tqdm(\n        enumerate(dataiter),\n        disable=not is_main_process() or verbose < 1,\n        total=num_steps_per_epoch,\n        initial=0,\n    ) as pbar:\n        for _, batch in pbar:\n            # == load data ==\n            x = batch[\"video\"].to(device, dtype)  # [B, C, T, H, W]\n\n            # == vae encoding & decoding ===\n            z = model.encode(x)\n\n            num_samples += 1\n            running_sum += z.mean().item()\n            running_var += (z - running_sum / num_samples).pow(2).mean().item()\n            shift = running_sum / num_samples\n            scale = (running_var / num_samples) ** 0.5\n            pbar.set_postfix({\"mean\": shift, \"std\": scale})\n\n    logger.info(\"Mean: %.4f, std: %.4f\", shift, scale)\n    log_cuda_max_memory(\"inference\")", "label": 0}
{"function": "def main():\n    parser = argparse.ArgumentParser(description=\"Chat with MiniMind\")\n    parser.add_argument('--lora_name', default='None', type=str)\n    parser.add_argument('--out_dir', default='out', type=str)\n    parser.add_argument('--temperature', default=0.85, type=float)\n    parser.add_argument('--top_p', default=0.85, type=float)\n    parser.add_argument('--device', default='cuda' if torch.cuda.is_available() else 'cpu', type=str)\n    # \u6b64\u5904max_seq_len\uff08\u6700\u5927\u8f93\u51fa\u957f\u5ea6\uff09\u5e76\u4e0d\u610f\u5473\u6a21\u578b\u5177\u6709\u5bf9\u5e94\u7684\u957f\u6587\u672c\u7684\u6027\u80fd\uff0c\u4ec5\u9632\u6b62QA\u51fa\u73b0\u88ab\u622a\u65ad\u7684\u95ee\u9898\n    # MiniMind2-moe (145M)\uff1a(hidden_size=640, num_hidden_layers=8, use_moe=True)\n    # MiniMind2-Small (26M)\uff1a(hidden_size=512, num_hidden_layers=8)\n    # MiniMind2 (104M)\uff1a(hidden_size=768, num_hidden_layers=16)\n    parser.add_argument('--hidden_size', default=512, type=int)\n    parser.add_argument('--num_hidden_layers', default=8, type=int)\n    parser.add_argument('--max_seq_len', default=8192, type=int)\n    parser.add_argument('--use_moe', default=False, type=bool)\n    # \u643a\u5e26\u5386\u53f2\u5bf9\u8bdd\u4e0a\u4e0b\u6587\u6761\u6570\n    # history_cnt\u9700\u8981\u8bbe\u4e3a\u5076\u6570\uff0c\u5373\u3010\u7528\u6237\u95ee\u9898, \u6a21\u578b\u56de\u7b54\u3011\u4e3a1\u7ec4\uff1b\u8bbe\u7f6e\u4e3a0\u65f6\uff0c\u5373\u5f53\u524dquery\u4e0d\u643a\u5e26\u5386\u53f2\u4e0a\u6587\n    # \u6a21\u578b\u672a\u7ecf\u8fc7\u5916\u63a8\u5fae\u8c03\u65f6\uff0c\u5728\u66f4\u957f\u7684\u4e0a\u4e0b\u6587\u7684chat_template\u65f6\u96be\u514d\u51fa\u73b0\u6027\u80fd\u7684\u660e\u663e\u9000\u5316\uff0c\u56e0\u6b64\u9700\u8981\u6ce8\u610f\u6b64\u5904\u8bbe\u7f6e\n    parser.add_argument('--history_cnt', default=0, type=int)\n    parser.add_argument('--load', default=0, type=int, help=\"0: \u539f\u751ftorch\u6743\u91cd\uff0c1: transformers\u52a0\u8f7d\")\n    parser.add_argument('--model_mode', default=1, type=int,\n                        help=\"0: \u9884\u8bad\u7ec3\u6a21\u578b\uff0c1: SFT-Chat\u6a21\u578b\uff0c2: RLHF-Chat\u6a21\u578b\uff0c3: Reason\u6a21\u578b\uff0c4: RLAIF-Chat\u6a21\u578b\")\n    args = parser.parse_args()\n\n    model, tokenizer = init_model(args)\n\n    prompts = get_prompt_datas(args)\n    test_mode = int(input('[0] \u81ea\u52a8\u6d4b\u8bd5\\n[1] \u624b\u52a8\u8f93\u5165\\n'))\n    streamer = TextStreamer(tokenizer, skip_prompt=True, skip_special_tokens=True)\n\n    messages = []\n    for idx, prompt in enumerate(prompts if test_mode == 0 else iter(lambda: input('\ud83d\udc76: '), '')):\n        setup_seed(random.randint(0, 2048))\n        # setup_seed(2025)  # \u5982\u9700\u56fa\u5b9a\u6bcf\u6b21\u8f93\u51fa\u5219\u6362\u6210\u3010\u56fa\u5b9a\u3011\u7684\u968f\u673a\u79cd\u5b50\n        if test_mode == 0: print(f'\ud83d\udc76: {prompt}')\n\n        messages = messages[-args.history_cnt:] if args.history_cnt else []\n        messages.append({\"role\": \"user\", \"content\": prompt})\n\n        new_prompt = tokenizer.apply_chat_template(\n            messages,\n            tokenize=False,\n            add_generation_prompt=True\n        ) if args.model_mode != 0 else (tokenizer.bos_token + prompt)\n\n        inputs = tokenizer(\n            new_prompt,\n            return_tensors=\"pt\",\n            truncation=True\n        ).to(args.device)\n\n        print('\ud83e\udd16\ufe0f: ', end='')\n        generated_ids = model.generate(\n            inputs[\"input_ids\"],\n            max_new_tokens=args.max_seq_len,\n            num_return_sequences=1,\n            do_sample=True,\n            attention_mask=inputs[\"attention_mask\"],\n            pad_token_id=tokenizer.pad_token_id,\n            eos_token_id=tokenizer.eos_token_id,\n            streamer=streamer,\n            top_p=args.top_p,\n            temperature=args.temperature\n        )\n\n        response = tokenizer.decode(generated_ids[0][inputs[\"input_ids\"].shape[1]:], skip_special_tokens=True)\n        messages.append({\"role\": \"assistant\", \"content\": response})\n        print('\\n\\n')", "label": 0}
{"function": "    def __repr__(self):\n        return self.__class__.__name__ + ' (' \\\n               + str(self.in_features) + ' -> ' \\\n               + str(self.out_features) + ')'", "label": 1}
{"function": "    def do_event(self, event):\n        shortcuts = {\n            'u': (self._sbb.vote, [+1]),\n            'd': (self._sbb.vote, [-1]),\n            'n': (self._sbb.vote, [0]),\n            'c': (self.goto_comments.emit, []),\n            'a': (self.get_toplevel().goto_sublist,\n                  ['/u/{}'.format(self.data['author'])]),\n            's': (self.get_toplevel().goto_sublist,\n                  ['/r/{}'.format(self.data['subreddit'])]),\n        }\n        return process_shortcuts(shortcuts, event)", "label": 1}
{"function": "def generate():\n    try:\n        # Set global variable\n        global GENERATING\n        GENERATING = True\n\n        # Clean\n        clean_dir(\"../temp/\")\n        clean_dir(\"../subtitles/\")\n\n\n        # Parse JSON\n        data = request.get_json()\n        paragraph_number = int(data.get('paragraphNumber', 1))  # Default to 1 if not provided\n        ai_model = data.get('aiModel')  # Get the AI model selected by the user\n        n_threads = data.get('threads')  # Amount of threads to use for video generation\n        subtitles_position = data.get('subtitlesPosition')  # Position of the subtitles in the video\n        text_color = data.get('color') # Color of subtitle text\n\n        # Get 'useMusic' from the request data and default to False if not provided\n        use_music = data.get('useMusic', False)\n\n        # Get 'automateYoutubeUpload' from the request data and default to False if not provided\n        automate_youtube_upload = data.get('automateYoutubeUpload', False)\n\n        # Get the ZIP Url of the songs\n        songs_zip_url = data.get('zipUrl')\n\n        # Download songs\n        if use_music:\n            # Downloads a ZIP file containing popular TikTok Songs\n            if songs_zip_url:\n                fetch_songs(songs_zip_url)\n            else:\n                # Default to a ZIP file containing popular TikTok Songs\n                fetch_songs(\"https://filebin.net/2avx134kdibc4c3q/drive-download-20240209T180019Z-001.zip\")\n\n        # Print little information about the video which is to be generated\n        print(colored(\"[Video to be generated]\", \"blue\"))\n        print(colored(\"   Subject: \" + data[\"videoSubject\"], \"blue\"))\n        print(colored(\"   AI Model: \" + ai_model, \"blue\"))  # Print the AI model being used\n        print(colored(\"   Custom Prompt: \" + data[\"customPrompt\"], \"blue\"))  # Print the AI model being used\n\n\n\n        if not GENERATING:\n            return jsonify(\n                {\n                    \"status\": \"error\",\n                    \"message\": \"Video generation was cancelled.\",\n                    \"data\": [],\n                }\n            )\n        \n        voice = data[\"voice\"]\n        voice_prefix = voice[:2]\n\n\n        if not voice:\n            print(colored(\"[!] No voice was selected. Defaulting to \\\"en_us_001\\\"\", \"yellow\"))\n            voice = \"en_us_001\"\n            voice_prefix = voice[:2]\n\n\n        # Generate a script\n        script = generate_script(data[\"videoSubject\"], paragraph_number, ai_model, voice, data[\"customPrompt\"])  # Pass the AI model to the script generation\n\n        # Generate search terms\n        search_terms = get_search_terms(\n            data[\"videoSubject\"], AMOUNT_OF_STOCK_VIDEOS, script, ai_model\n        )\n\n        # Search for a video of the given search term\n        video_urls = []\n\n        # Defines how many results it should query and search through\n        it = 15\n\n        # Defines the minimum duration of each clip\n        min_dur = 10\n\n        # Loop through all search terms,\n        # and search for a video of the given search term\n        for search_term in search_terms:\n            if not GENERATING:\n                return jsonify(\n                    {\n                        \"status\": \"error\",\n                        \"message\": \"Video generation was cancelled.\",\n                        \"data\": [],\n                    }\n                )\n            found_urls = search_for_stock_videos(\n                search_term, os.getenv(\"PEXELS_API_KEY\"), it, min_dur\n            )\n            # Check for duplicates\n            for url in found_urls:\n                if url not in video_urls:\n                    video_urls.append(url)\n                    break\n\n        # Check if video_urls is empty\n        if not video_urls:\n            print(colored(\"[-] No videos found to download.\", \"red\"))\n            return jsonify(\n                {\n                    \"status\": \"error\",\n                    \"message\": \"No videos found to download.\",\n                    \"data\": [],\n                }\n            )\n            \n        # Define video_paths\n        video_paths = []\n\n        # Let user know\n        print(colored(f\"[+] Downloading {len(video_urls)} videos...\", \"blue\"))\n\n        # Save the videos\n        for video_url in video_urls:\n            if not GENERATING:\n                return jsonify(\n                    {\n                        \"status\": \"error\",\n                        \"message\": \"Video generation was cancelled.\",\n                        \"data\": [],\n                    }\n                )\n            try:\n                saved_video_path = save_video(video_url)\n                video_paths.append(saved_video_path)\n            except Exception:\n                print(colored(f\"[-] Could not download video: {video_url}\", \"red\"))\n\n        # Let user know\n        print(colored(\"[+] Videos downloaded!\", \"green\"))\n\n        # Let user know\n        print(colored(\"[+] Script generated!\\n\", \"green\"))\n\n        if not GENERATING:\n            return jsonify(\n                {\n                    \"status\": \"error\",\n                    \"message\": \"Video generation was cancelled.\",\n                    \"data\": [],\n                }\n            )\n\n        # Split script into sentences\n        sentences = script.split(\". \")\n\n        # Remove empty strings\n        sentences = list(filter(lambda x: x != \"\", sentences))\n        paths = []\n\n        # Generate TTS for every sentence\n        for sentence in sentences:\n            if not GENERATING:\n                return jsonify(\n                    {\n                        \"status\": \"error\",\n                        \"message\": \"Video generation was cancelled.\",\n                        \"data\": [],\n                    }\n                )\n            current_tts_path = f\"../temp/{uuid4()}.mp3\"\n            tts(sentence, voice, filename=current_tts_path)\n            audio_clip = AudioFileClip(current_tts_path)\n            paths.append(audio_clip)\n\n        # Combine all TTS files using moviepy\n        final_audio = concatenate_audioclips(paths)\n        tts_path = f\"../temp/{uuid4()}.mp3\"\n        final_audio.write_audiofile(tts_path)\n\n        try:\n            subtitles_path = generate_subtitles(audio_path=tts_path, sentences=sentences, audio_clips=paths, voice=voice_prefix)\n        except Exception as e:\n            print(colored(f\"[-] Error generating subtitles: {e}\", \"red\"))\n            subtitles_path = None\n\n        # Concatenate videos\n        temp_audio = AudioFileClip(tts_path)\n        combined_video_path = combine_videos(video_paths, temp_audio.duration, 5, n_threads or 2)\n\n        # Put everything together\n        try:\n            final_video_path = generate_video(combined_video_path, tts_path, subtitles_path, n_threads or 2, subtitles_position, text_color or \"#FFFF00\")\n        except Exception as e:\n            print(colored(f\"[-] Error generating final video: {e}\", \"red\"))\n            final_video_path = None\n\n        # Define metadata for the video, we will display this to the user, and use it for the YouTube upload\n        title, description, keywords = generate_metadata(data[\"videoSubject\"], script, ai_model)\n\n        print(colored(\"[-] Metadata for YouTube upload:\", \"blue\"))\n        print(colored(\"   Title: \", \"blue\"))\n        print(colored(f\"   {title}\", \"blue\"))\n        print(colored(\"   Description: \", \"blue\"))\n        print(colored(f\"   {description}\", \"blue\"))\n        print(colored(\"   Keywords: \", \"blue\"))\n        print(colored(f\"  {', '.join(keywords)}\", \"blue\"))\n\n        if automate_youtube_upload:\n            # Start Youtube Uploader\n            # Check if the CLIENT_SECRETS_FILE exists\n            client_secrets_file = os.path.abspath(\"./client_secret.json\")\n            SKIP_YT_UPLOAD = False\n            if not os.path.exists(client_secrets_file):\n                SKIP_YT_UPLOAD = True\n                print(colored(\"[-] Client secrets file missing. YouTube upload will be skipped.\", \"yellow\"))\n                print(colored(\"[-] Please download the client_secret.json from Google Cloud Platform and store this inside the /Backend directory.\", \"red\"))\n\n            # Only proceed with YouTube upload if the toggle is True  and client_secret.json exists.\n            if not SKIP_YT_UPLOAD:\n                # Choose the appropriate category ID for your videos\n                video_category_id = \"28\"  # Science & Technology\n                privacyStatus = \"private\"  # \"public\", \"private\", \"unlisted\"\n                video_metadata = {\n                    'video_path': os.path.abspath(f\"../temp/{final_video_path}\"),\n                    'title': title,\n                    'description': description,\n                    'category': video_category_id,\n                    'keywords': \",\".join(keywords),\n                    'privacyStatus': privacyStatus,\n                }\n\n                # Upload the video to YouTube\n                try:\n                    # Unpack the video_metadata dictionary into individual arguments\n                    video_response = upload_video(\n                        video_path=video_metadata['video_path'],\n                        title=video_metadata['title'],\n                        description=video_metadata['description'],\n                        category=video_metadata['category'],\n                        keywords=video_metadata['keywords'],\n                        privacy_status=video_metadata['privacyStatus']\n                    )\n                    print(f\"Uploaded video ID: {video_response.get('id')}\")\n                except HttpError as e:\n                    print(f\"An HTTP error {e.resp.status} occurred:\\n{e.content}\")\n\n        video_clip = VideoFileClip(f\"../temp/{final_video_path}\")\n        if use_music:\n            # Select a random song\n            song_path = choose_random_song()\n\n            # Add song to video at 30% volume using moviepy\n            original_duration = video_clip.duration\n            original_audio = video_clip.audio\n            song_clip = AudioFileClip(song_path).set_fps(44100)\n\n            # Set the volume of the song to 10% of the original volume\n            song_clip = song_clip.volumex(0.1).set_fps(44100)\n\n            # Add the song to the video\n            comp_audio = CompositeAudioClip([original_audio, song_clip])\n            video_clip = video_clip.set_audio(comp_audio)\n            video_clip = video_clip.set_fps(30)\n            video_clip = video_clip.set_duration(original_duration)\n            video_clip.write_videofile(f\"../{final_video_path}\", threads=n_threads or 1)\n        else:\n            video_clip.write_videofile(f\"../{final_video_path}\", threads=n_threads or 1)\n\n\n        # Let user know\n        print(colored(f\"[+] Video generated: {final_video_path}!\", \"green\"))\n\n        # Stop FFMPEG processes\n        if os.name == \"nt\":\n            # Windows\n            os.system(\"taskkill /f /im ffmpeg.exe\")\n        else:\n            # Other OS\n            os.system(\"pkill -f ffmpeg\")\n\n        GENERATING = False\n\n        # Return JSON\n        return jsonify(\n            {\n                \"status\": \"success\",\n                \"message\": \"Video generated! See MoneyPrinter/output.mp4 for result.\",\n                \"data\": final_video_path,\n            }\n        )\n    except Exception as err:\n        print(colored(f\"[-] Error: {str(err)}\", \"red\"))\n        return jsonify(\n            {\n                \"status\": \"error\",\n                \"message\": f\"Could not retrieve stock videos: {str(err)}\",\n                \"data\": [],\n            }\n        )", "label": 0}
{"function": "def get_notebooks_dir() -> Path:\n    return (Path(__file__).parent.parent / \"notebooks\").resolve()", "label": 0}
{"function": "def create_prompt(user_input: str) -> str:\n    conversation = [\n        {\n            \"role\": \"User\",\n            \"content\": user_input,\n        },\n        {\"role\": \"Assistant\", \"content\": \"\"},\n    ]\n\n    sft_format = vl_chat_processor.apply_sft_template_for_multi_turn_prompts(\n        conversations=conversation,\n        sft_format=vl_chat_processor.sft_format,\n        system_prompt=\"\",\n    )\n    prompt = sft_format + vl_chat_processor.image_start_tag\n    return prompt", "label": 0}
{"function": "def test_print():\n    print(lerobot.available_envs)\n    print(lerobot.available_tasks_per_env)\n    print(lerobot.available_datasets)\n    print(lerobot.available_datasets_per_env)\n    print(lerobot.available_real_world_datasets)\n    print(lerobot.available_policies)\n    print(lerobot.available_policies_per_env)", "label": 0}
{"function": "    def find_window(self, wid):\n        window = self.windows_map.get(wid)\n        if window:\n            if not window.group.screen:\n                self.current_screen.set_group(window.group)\n            window.group.focus(window, False)", "label": 1}
{"function": "    def get_map(self) -> Mapping[_FileObject, SelectorKey]: ...", "label": 1}
{"function": "def create_app():\n    app = Flask(__name__)\n\n    # Initialize database connection\n    try:\n        DatabaseSession.initialize()\n        logger.info(\"Database connection initialized successfully\")\n    \n    except Exception as e:\n        logger.error(f\"Failed to initialize database connection: {str(e)}\")\n        raise\n\n        # Add CORS support\n\n    @app.after_request\n    def after_request(response):\n        # Allow all origins in development environment\n        response.headers.add(\"Access-Control-Allow-Origin\", \"*\")\n        response.headers.add(\n            \"Access-Control-Allow-Headers\", \"Content-Type,Authorization\"\n        )\n        response.headers.add(\n            \"Access-Control-Allow-Methods\", \"GET,PUT,POST,DELETE,OPTIONS\"\n        )\n        return response\n\n    # Create file server handler\n    file_handler = FileServerHandler(\n        os.path.join(os.getenv(\"APP_ROOT\", \"/app\"), \"resources\", \"raw_content\")\n    )\n\n    @app.route(\"/raw_content/\", defaults={\"path\": \"\"})\n    @app.route(\"/raw_content/<path:path>\")\n    def serve_content(path=\"\"):\n        return file_handler.handle_request(path, request.path)\n\n    # Register all routes\n    init_routes(app)\n\n    # Clean up database connection only when the application shuts down\n    @app.teardown_appcontext\n    def cleanup_db(exception):\n        pass\n\n    return app", "label": 0}
{"function": "def build_vscode_extension():\n    \"\"\"Builds the VS Code extension.\"\"\"\n    vsix_path = VSCODE_EXTENSION_DIR / VSIX_FILENAME\n\n    # Check if VSCode extension build is disabled via environment variable\n    if os.environ.get('SKIP_VSCODE_BUILD', '').lower() in ('1', 'true', 'yes'):\n        print('--- Skipping VS Code extension build (SKIP_VSCODE_BUILD is set) ---')\n        if vsix_path.exists():\n            print(f'--- Using existing VS Code extension: {vsix_path} ---')\n        else:\n            print('--- No pre-built VS Code extension found ---')\n        return\n\n    # Check Node.js version - if insufficient, use pre-built extension as fallback\n    if not check_node_version():\n        print('--- Warning: Node.js version < 18 detected or Node.js not found ---')\n        print('--- Skipping VS Code extension build (requires Node.js >= 18) ---')\n        print('--- Using pre-built extension if available ---')\n\n        if not vsix_path.exists():\n            print('--- Warning: No pre-built VS Code extension found ---')\n            print('--- VS Code extension will not be available ---')\n        else:\n            print(f'--- Using pre-built VS Code extension: {vsix_path} ---')\n        return\n\n    print(f'--- Building VS Code extension in {VSCODE_EXTENSION_DIR} ---')\n\n    try:\n        # Ensure npm dependencies are installed\n        print('--- Running npm install for VS Code extension ---')\n        subprocess.run(\n            ['npm', 'install'],\n            cwd=VSCODE_EXTENSION_DIR,\n            check=True,\n            shell=os.name == 'nt',\n        )\n\n        # Package the extension\n        print(f'--- Packaging VS Code extension ({VSIX_FILENAME}) ---')\n        subprocess.run(\n            ['npm', 'run', 'package-vsix'],\n            cwd=VSCODE_EXTENSION_DIR,\n            check=True,\n            shell=os.name == 'nt',\n        )\n\n        # Verify the generated .vsix file exists\n        if not vsix_path.exists():\n            raise FileNotFoundError(\n                f'VS Code extension package not found after build: {vsix_path}'\n            )\n\n        print(f'--- VS Code extension built successfully: {vsix_path} ---')\n\n    except subprocess.CalledProcessError as e:\n        print(f'--- Warning: Failed to build VS Code extension: {e} ---')\n        print('--- Continuing without building extension ---')\n        if not vsix_path.exists():\n            print('--- Warning: No pre-built VS Code extension found ---')\n            print('--- VS Code extension will not be available ---')", "label": 0}
{"function": "def parse_args():\n    parser = argparse.ArgumentParser(description=\"Run a task with a given configuration file.\")\n    parser.add_argument('--config', type=str, required=True, help='Path to the configuration file.')\n    return parser.parse_args()", "label": 0}
{"function": "def upload_file():\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file part'}), 400\n    \n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({'error': 'No selected file'}), 400\n    \n    if file and file.filename.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.webp')):\n        filename = secure_filename(file.filename)\n        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n        file.save(filepath)\n        \n        # Get the actual media type\n        media_type = file.content_type or 'image/jpeg'  # Default to jpeg if not detected\n        \n        # Convert image to base64\n        with open(filepath, \"rb\") as image_file:\n            encoded_string = base64.b64encode(image_file.read()).decode('utf-8')\n        \n        # Clean up the file\n        os.remove(filepath)\n        \n        return jsonify({\n            'success': True,\n            'image_data': encoded_string,\n            'media_type': media_type\n        })\n    \n    return jsonify({'error': 'Invalid file type'}), 400", "label": 0}
{"function": "    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]", "label": 1}
{"function": "def precompute_freqs_cis(dim: int, end: int, theta: float = 10000.0):\n    freqs = 1.0 / (theta ** (torch.arange(0, dim, 2)[: (dim // 2)].float() / dim))\n    t = torch.arange(end, device=freqs.device, dtype=torch.float32)\n    freqs = torch.outer(t, freqs)\n    freqs_cis = torch.polar(torch.ones_like(freqs), freqs)  # complex64\n    return freqs_cis", "label": 0}
{"function": "    def consumer(self, partition_id, type):\n        \"\"\"\n        Creates spider log consumer with BaseStreamConsumer interface\n        :param partition_id: can be None or integer\n        :param type: either 'db' or 'sw'\n        :return:\n        \"\"\"\n        group = self._sw_group if type == b'sw' else self._db_group\n        c = Consumer(self._location, self._enable_ssl, self._cert_path, self._topic, group, partition_id)\n        assert len(c._consumer.partitions_for_topic(self._topic)) == self._partitions\n        return c", "label": 1}
{"function": "    def forward(self, z):\n        pass", "label": 1}
{"function": "    def post_setup(cls):\n        \"\"\"Post setup configuration.\n        This is the place where you can configure settings that require other\n        settings to be loaded.\n        \"\"\"\n        super().post_setup()\n\n        # The SENTRY_DSN setting should be available to activate sentry for an environment\n        if cls.SENTRY_DSN is not None:\n            sentry_sdk.init(\n                dsn=cls.SENTRY_DSN,\n                environment=cls.__name__.lower(),\n                release=get_release(),\n                integrations=[DjangoIntegration()],\n            )\n            sentry_sdk.set_tag(\"application\", \"backend\")\n\n            # Ignore the logs added by the DockerflowMiddleware\n            ignore_logger(\"request.summary\")\n\n        if (\n            cls.OIDC_FALLBACK_TO_EMAIL_FOR_IDENTIFICATION\n            and cls.OIDC_ALLOW_DUPLICATE_EMAILS\n        ):\n            raise ValueError(\n                \"Both OIDC_FALLBACK_TO_EMAIL_FOR_IDENTIFICATION and \"\n                \"OIDC_ALLOW_DUPLICATE_EMAILS cannot be set to True simultaneously. \"\n            )", "label": 0}
{"function": "    def remove(id: str):\n        context = AgentContext._contexts.pop(id, None)\n        if context and context.task:\n            context.task.kill()\n        return context", "label": 0}
{"function": "def test_stream():\n    data_raw = {\n        \"kb_ids\": [\n           \"KBf46828db208c4289a120a34f0fc96147\",\n           \"KBc2440f13e98f4736b5ef81cfaebef3a9\",\n           \"KBb78af28c73f74fb4ae6ad44b3c53302f\",\n           \"KB6c2b097d83be430ab809e361fa8dcc8b\",\n           \"KB69331d593f5b4b5bb555a0ea1b145e5b\",\n           \"KB3cdc79f8c8d24a14bffd27e6570c33da\"\n        ],\n        \"question\": \"\u897f\u5357\u4ea4\u901a\u5927\u5b66\u662f211\u9662\u6821\u5417\",\n        \"user_id\": \"liujx_265\",\n        \"streaming\": True,\n        \"rerank\": True,\n        \"history\": []\n    }\n    for i, chunk in enumerate(stream_requests(data_raw)):\n        if chunk:\n            chunkstr = chunk.decode(\"utf-8\")[6:]\n            chunkjs = json.loads(chunkstr)\n            print(chunkjs)", "label": 0}
{"function": "    def want_form_data_parsed(self):\n        \"\"\"Returns True if the request method carries content.  As of\n        Werkzeug 0.9 this will be the case if a content type is transmitted.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        return bool(self.environ.get('CONTENT_TYPE'))", "label": 1}
{"function": "    def get_registered_model(self, name=None, workspace=None, id=None):\n        \"\"\"\n        Retrieve an already created Registered Model. Only one of name or id can be provided.\n\n        Parameters\n        ----------\n        name : str, optional\n            Name of the Registered Model.\n        id : str, optional\n            ID of the Registered Model. This parameter cannot be provided alongside `name`.\n\n        Returns\n        -------\n        :class:`~verta._registry.model.RegisteredModel`\n        \"\"\"\n        if name is not None and id is not None:\n            raise ValueError(\"cannot specify both `name` and `id`\")\n\n        name = self._set_from_config_if_none(name, \"registered_model\")\n        if name is None and id is None:\n            raise ValueError(\"must specify either `name` or `id`\")\n        workspace = self._set_from_config_if_none(workspace, \"workspace\")\n        if workspace is None:\n            workspace = self._get_personal_workspace()\n\n        self._ctx = _Context(self._conn, self._conf)\n        self._ctx.workspace_name = workspace\n\n        if id is not None:\n            registered_model = RegisteredModel._get_by_id(self._conn, self._conf, id)\n        else:\n            registered_model =  RegisteredModel._get_by_name(self._conn, self._conf, name, self._ctx.workspace_name)\n\n        if registered_model is None:\n            raise ValueError(\"Registered model not found\")\n\n        return registered_model", "label": 1}
{"function": "def urlopen(*args, **kwargs):\n    try:\n        return request_module.urlopen(*args, **kwargs)\n    except HTTPException as e:\n        # https://bugs.python.org/issue8823\n        raise EnvironmentError(e)", "label": 1}
{"function": "def _prepare_transformer(model):\n    embed_dim = model.tok_embeddings.embedding_dim\n    model.tok_embeddings = nn.Identity()\n    model.output = nn.Identity()\n    return model, embed_dim", "label": 0}
{"function": "  def _std(self):\n    return math_ops.sqrt(self.alpha) / self.beta", "label": 1}
{"function": "def parse_args():\n    parser = argparse.ArgumentParser(description=\"Run a task with a given configuration file.\")\n    parser.add_argument('--config', type=str, required=True, help='Path to the configuration file.')\n    return parser.parse_args()", "label": 0}
{"function": "    def test_buildPose3graph(self):\n        pose3graph = gtsam.InitializePose3.buildPose3graph(self.graph)", "label": 1}
{"function": "async def auth(request: Request):\n    try:\n        access_token = await oauth.google.authorize_access_token(request)\n    except OAuthError:\n        return RedirectResponse(url=\"/\")\n    request.session[\"user\"] = dict(access_token)[\"userinfo\"]\n    return RedirectResponse(url=\"/\")", "label": 0}
{"function": "    def _Length2Mask(length):\n      return 0xFFFFFFFF & ~((1 << (32 - length)) - 1)", "label": 1}
{"function": "    def test_ignores_other_errors(self, mock_get, mock_sleep):\n        \"\"\"Test that non-429 errors are returned without retrying.\"\"\"\n        # Setup mock response: 500 error\n        mock_500_response = Mock()\n        mock_500_response.status_code = 500\n        mock_500_response.text = \"Internal Server Error\"\n        \n        mock_get.return_value = mock_500_response\n        \n        # Call the function\n        headers = {\"X-API-KEY\": \"test-key\"}\n        url = \"https://api.financialdatasets.ai/test\"\n        \n        result = _make_api_request(url, headers)\n        \n        # Verify behavior\n        assert result.status_code == 500\n        assert result.text == \"Internal Server Error\"\n        \n        # Verify requests.get was called only once\n        assert mock_get.call_count == 1\n        \n        # Verify sleep was never called\n        mock_sleep.assert_not_called()", "label": 0}
{"function": "    def cmd_prev_screen(self):\n        \"\"\"Move to the previous screen\"\"\"\n        return self.focus_screen(\n            (self.screens.index(self.current_screen) - 1) % len(self.screens)\n        )", "label": 1}
{"function": "    def test_repo_delete_noargs(self, shell):\n        \"\"\"\n        Test do_repo_delete no arguments.\n\n        :param shell:\n        :return:\n        \"\"\"\n        shell.help_repo_delete = MagicMock()\n        shell.client.channel.software.removeRepo = MagicMock()\n        shell.do_repo_list = MagicMock()\n        mprint = MagicMock()\n        logger = MagicMock()\n\n        with patch(\"spacecmd.repo.print\", mprint) as prn, \\\n                patch(\"spacecmd.repo.logging\", logger) as lgr:\n            out = spacecmd.repo.do_repo_delete(shell, \"\")\n\n        assert out is 1\n        assert not mprint.called\n        assert not logger.error.called\n        assert not shell.client.channel.software.removeRepo.called\n        assert shell.help_repo_delete.called", "label": 1}
{"function": "    def test_1d_slicing5_npm(self):\n        self.test_1d_slicing5(flags=Noflags)", "label": 1}
{"function": "def generate_response(prompt: str, ai_model: str) -> str:\n    \"\"\"\n    Generate a script for a video, depending on the subject of the video.\n\n    Args:\n        video_subject (str): The subject of the video.\n        ai_model (str): The AI model to use for generation.\n\n\n    Returns:\n\n        str: The response from the AI model.\n\n    \"\"\"\n\n    if ai_model == 'g4f':\n        # Newest G4F Architecture\n        client = Client()\n        response = client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",\n            provider=g4f.Provider.You, \n            messages=[{\"role\": \"user\", \"content\": prompt}],\n        ).choices[0].message.content\n\n    elif ai_model in [\"gpt3.5-turbo\", \"gpt4\"]:\n\n        model_name = \"gpt-3.5-turbo\" if ai_model == \"gpt3.5-turbo\" else \"gpt-4-1106-preview\"\n\n        response = openai.chat.completions.create(\n\n            model=model_name,\n\n            messages=[{\"role\": \"user\", \"content\": prompt}],\n\n        ).choices[0].message.content\n    elif ai_model == 'gemmini':\n        model = genai.GenerativeModel('gemini-pro')\n        response_model = model.generate_content(prompt)\n        response = response_model.text\n\n    else:\n\n        raise ValueError(\"Invalid AI model selected.\")\n\n    return response", "label": 0}
{"function": "    def readcmd(self):\n        '''Read a single command.'''\n\n        b = self.read(4)\n        app, verb, n = struct.unpack('<BBH', b)\n\n        if n > 0:\n            data = self.read(n)\n        else:\n            data = b''\n\n        if len(data) != n:\n            raise ValueError('Facedancer expected %d bytes but received only %d' % (n, len(data)))\n        cmd = FacedancerCommand(app, verb, data)\n        self.logger.verbose('Facedancer Rx command: %s' % cmd)\n        return cmd", "label": 1}
{"function": "    def __init__(self, seed):\n        self.seed = seed\n        self.state = None", "label": 0}
{"function": "  def _define_vars(self, params):\n    pass", "label": 1}
{"function": "def test_request_with_existing_query_params():\n    \"\"\"Test a request with existing query parameters in the URL.\"\"\"\n    request = RequestModel(\n        name=\"Request with existing query params\",\n        method=\"GET\",\n        url=\"https://example.com/api/search?existing=value\",\n        params=[\n            QueryParam(name=\"q\", value=\"test query\"),\n            QueryParam(name=\"page\", value=\"1\"),\n        ],\n    )\n\n    expected = (\n        \"curl \\\\\\n  'https://example.com/api/search?existing=value&q=test+query&page=1'\"\n    )\n    assert request.to_curl() == expected", "label": 0}
{"function": "def get_api():\n    token = input(\"Write token? \").strip()\n    api = HfApi(token=token)\n    return api", "label": 0}
{"function": "def test_chat_non_streaming_basic(request, openai_client, model, provider, verification_config, case):\n    test_name_base = get_base_test_name(request)\n    if should_skip_test(verification_config, provider, model, test_name_base):\n        pytest.skip(f\"Skipping {test_name_base} for model {model} on provider {provider} based on config.\")\n\n    response = openai_client.chat.completions.create(\n        model=model,\n        messages=case[\"input\"][\"messages\"],\n        stream=False,\n    )\n    assert response.choices[0].message.role == \"assistant\"\n    assert case[\"output\"].lower() in response.choices[0].message.content.lower()", "label": 0}
{"function": "        def init_with_suppressed_logging(self, *args, verbosity_level=LogLevel.OFF, **kwargs):\n            original_multi_step_agent_init(self, *args, verbosity_level=verbosity_level, **kwargs)", "label": 0}
{"function": "    def __init__(\n        self,\n        name: str,\n        content: Optional[str] = None,\n        parent: Optional[\"KnowledgeNode\"] = None,\n        children: Optional[List[\"KnowledgeNode\"]] = None,\n        synthesize_output: Optional[str] = None,\n        need_regenerate_synthesize_output: bool = True,\n    ):\n        \"\"\"\n        Initializes a KnowledgeNode instance.\n\n        Args:\n            name (str): The name of the node.\n            content (list, optional): A list of information uuid. Defaults to None.\n            parent (KnowledgeNode, optional): The parent node of the current node. Defaults to None.\n        \"\"\"\n        self.name = name\n        self.content: Set[int] = set(content) if content is not None else set()\n        self.children = [] if children is None else children\n        self.parent = parent\n        self.synthesize_output = synthesize_output\n        self.need_regenerate_synthesize_output = need_regenerate_synthesize_output", "label": 0}
{"function": "    def test_best_model2_alignment_handles_fertile_words(self):\n        # arrange\n        sentence_pair = AlignedSent(\n            ['i', 'really', ',', 'really', 'love', 'ham'],\n            TestIBMModel.__TEST_SRC_SENTENCE,\n        )\n        # 'bien' produces 2 target words: 'really' and another 'really'\n        translation_table = {\n            'i': {\"j'\": 0.9, 'aime': 0.05, 'bien': 0.02, 'jambon': 0.03, None: 0},\n            'really': {\"j'\": 0, 'aime': 0, 'bien': 0.9, 'jambon': 0.01, None: 0.09},\n            ',': {\"j'\": 0, 'aime': 0, 'bien': 0.3, 'jambon': 0, None: 0.7},\n            'love': {\"j'\": 0.05, 'aime': 0.9, 'bien': 0.01, 'jambon': 0.01, None: 0.03},\n            'ham': {\"j'\": 0, 'aime': 0.01, 'bien': 0, 'jambon': 0.99, None: 0},\n        }\n        alignment_table = defaultdict(\n            lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: 0.2)))\n        )\n\n        ibm_model = IBMModel([])\n        ibm_model.translation_table = translation_table\n        ibm_model.alignment_table = alignment_table\n\n        # act\n        a_info = ibm_model.best_model2_alignment(sentence_pair)\n\n        # assert\n        self.assertEqual(a_info.alignment[1:], (1, 3, 0, 3, 2, 4))\n        self.assertEqual(a_info.cepts, [[3], [1], [5], [2, 4], [6]])", "label": 1}
{"function": "def app():\n    with gr.Blocks():\n        with gr.Row():\n            with gr.Column():\n                image = gr.Image(type=\"pil\", label=\"Image\", visible=True)\n                video = gr.Video(label=\"Video\", visible=False)\n                input_type = gr.Radio(\n                    choices=[\"Image\", \"Video\"],\n                    value=\"Image\",\n                    label=\"Input Type\",\n                )\n                model_id = gr.Dropdown(\n                    label=\"Model\",\n                    choices=[\n                        \"yolov10n\",\n                        \"yolov10s\",\n                        \"yolov10m\",\n                        \"yolov10b\",\n                        \"yolov10l\",\n                        \"yolov10x\",\n                    ],\n                    value=\"yolov10m\",\n                )\n                image_size = gr.Slider(\n                    label=\"Image Size\",\n                    minimum=320,\n                    maximum=1280,\n                    step=32,\n                    value=640,\n                )\n                conf_threshold = gr.Slider(\n                    label=\"Confidence Threshold\",\n                    minimum=0.0,\n                    maximum=1.0,\n                    step=0.05,\n                    value=0.25,\n                )\n                yolov10_infer = gr.Button(value=\"Detect Objects\")\n\n            with gr.Column():\n                output_image = gr.Image(type=\"numpy\", label=\"Annotated Image\", visible=True)\n                output_video = gr.Video(label=\"Annotated Video\", visible=False)\n\n        def update_visibility(input_type):\n            image = gr.update(visible=True) if input_type == \"Image\" else gr.update(visible=False)\n            video = gr.update(visible=False) if input_type == \"Image\" else gr.update(visible=True)\n            output_image = gr.update(visible=True) if input_type == \"Image\" else gr.update(visible=False)\n            output_video = gr.update(visible=False) if input_type == \"Image\" else gr.update(visible=True)\n\n            return image, video, output_image, output_video\n\n        input_type.change(\n            fn=update_visibility,\n            inputs=[input_type],\n            outputs=[image, video, output_image, output_video],\n        )\n\n        def run_inference(image, video, model_id, image_size, conf_threshold, input_type):\n            if input_type == \"Image\":\n                return yolov10_inference(image, None, model_id, image_size, conf_threshold)\n            else:\n                return yolov10_inference(None, video, model_id, image_size, conf_threshold)\n\n\n        yolov10_infer.click(\n            fn=run_inference,\n            inputs=[image, video, model_id, image_size, conf_threshold, input_type],\n            outputs=[output_image, output_video],\n        )\n\n        gr.Examples(\n            examples=[\n                [\n                    \"ultralytics/assets/bus.jpg\",\n                    \"yolov10s\",\n                    640,\n                    0.25,\n                ],\n                [\n                    \"ultralytics/assets/zidane.jpg\",\n                    \"yolov10s\",\n                    640,\n                    0.25,\n                ],\n            ],\n            fn=yolov10_inference_for_examples,\n            inputs=[\n                image,\n                model_id,\n                image_size,\n                conf_threshold,\n            ],\n            outputs=[output_image],\n            cache_examples='lazy',\n        )", "label": 0}
{"function": "  def _prob(self, x):\n    return math_ops.exp(self._log_prob(x))", "label": 1}
{"function": "def load_audio(\n    adfile: Path,\n    sampling_rate: int = None,\n    length: int = None,\n    volume_normalize: bool = False,\n    segment_duration: int = None,\n) -> np.ndarray:\n    r\"\"\"Load audio file with target sampling rate and lsength\n\n    Args:\n        adfile (Path): path to audio file.\n        sampling_rate (int, optional): target sampling rate. Defaults to None.\n        length (int, optional): target audio length. Defaults to None.\n        volume_normalize (bool, optional): whether perform volume normalization. Defaults to False.\n        segment_duration (int): random select a segment with duration of {segment_duration}s.\n                                Defualt to None which means the whole audio will be used.\n\n    Returns:\n        audio (np.ndarray): audio\n    \"\"\"\n\n    audio, sr = soundfile.read(adfile)\n    if len(audio.shape) > 1:\n        audio = audio[:, 0]\n\n    if sampling_rate is not None and sr != sampling_rate:\n        audio = soxr.resample(audio, sr, sampling_rate, quality=\"VHQ\")\n        sr = sampling_rate\n\n    if segment_duration is not None:\n        seg_length = int(sr * segment_duration)\n        audio = random_select_audio_segment(audio, seg_length)\n\n    # Audio volume normalize\n    if volume_normalize:\n        audio = audio_volume_normalize(audio)\n    # check the audio length\n    if length is not None:\n        assert abs(audio.shape[0] - length) < 1000\n        if audio.shape[0] > length:\n            audio = audio[:length]\n        else:\n            audio = np.pad(audio, (0, int(length - audio.shape[0])))\n    return audio", "label": 0}
{"function": "\tasync def test_action_model_creation(self):\n\t\t\"\"\"Test that action models are created correctly with filters\"\"\"\n\t\tregistry = Registry()\n\n\t\t# Define actions with different filters\n\t\t@registry.action(\n\t\t\tdescription='No filter action',\n\t\t)\n\t\tdef no_filter_action():\n\t\t\tpass\n\n\t\t@registry.action(description='Domain filter action', domains=['example.com'])\n\t\tdef domain_filter_action():\n\t\t\tpass\n\n\t\t@registry.action(description='Page filter action', page_filter=lambda page: 'admin' in page.url)\n\t\tdef page_filter_action():\n\t\t\tpass\n\n\t\t@registry.action(description='Both filters action', domains=['example.com'], page_filter=lambda page: 'admin' in page.url)\n\t\tdef both_filters_action():\n\t\t\tpass\n\n\t\t# Initial action model should only include no_filter_action\n\t\tinitial_model = registry.create_action_model()\n\t\tassert 'no_filter_action' in initial_model.model_fields\n\t\tassert 'domain_filter_action' not in initial_model.model_fields\n\t\tassert 'page_filter_action' not in initial_model.model_fields\n\t\tassert 'both_filters_action' not in initial_model.model_fields\n\n\t\t# Action model with matching page should include all matching actions\n\t\tmock_page = MagicMock(spec=Page)\n\t\tmock_page.url = 'https://example.com/admin'\n\n\t\tpage_model = registry.create_action_model(page=mock_page)\n\t\tassert 'no_filter_action' in page_model.model_fields\n\t\tassert 'domain_filter_action' in page_model.model_fields\n\t\tassert 'page_filter_action' in page_model.model_fields\n\t\tassert 'both_filters_action' in page_model.model_fields\n\n\t\t# Action model with non-matching domain should exclude domain-filtered actions\n\t\tmock_page.url = 'https://other.com/admin'\n\t\tnon_matching_domain_model = registry.create_action_model(page=mock_page)\n\t\tassert 'no_filter_action' in non_matching_domain_model.model_fields\n\t\tassert 'domain_filter_action' not in non_matching_domain_model.model_fields\n\t\tassert 'page_filter_action' in non_matching_domain_model.model_fields\n\t\tassert 'both_filters_action' not in non_matching_domain_model.model_fields\n\n\t\t# Action model with non-matching page filter should exclude page-filtered actions\n\t\tmock_page.url = 'https://example.com/dashboard'\n\t\tnon_matching_page_model = registry.create_action_model(page=mock_page)\n\t\tassert 'no_filter_action' in non_matching_page_model.model_fields\n\t\tassert 'domain_filter_action' in non_matching_page_model.model_fields\n\t\tassert 'page_filter_action' not in non_matching_page_model.model_fields\n\t\tassert 'both_filters_action' not in non_matching_page_model.model_fields", "label": 0}
{"function": "def test_simple_get_request():\n    \"\"\"Test a simple GET request with no parameters.\"\"\"\n    request = RequestModel(\n        name=\"Simple GET\", method=\"GET\", url=\"https://example.com/api\"\n    )\n\n    expected = \"curl \\\\\\n  'https://example.com/api'\"\n    assert request.to_curl() == expected", "label": 0}
{"function": "def test_validation_invalid_excluded_types():\n    \"\"\"Test validation function with invalid excluded types.\"\"\"\n    entity_types = {\n        'Person': Person,\n        'Organization': Organization,\n    }\n\n    # Invalid exclusions should raise ValueError\n    with pytest.raises(ValueError, match='Invalid excluded entity types'):\n        validate_excluded_entity_types(['InvalidType'], entity_types)\n\n    with pytest.raises(ValueError, match='Invalid excluded entity types'):\n        validate_excluded_entity_types(['Person', 'NonExistentType'], entity_types)", "label": 0}
{"function": "    def handle(self, *args, **options):\n        if len(args) < 1:\n            raise CommandError(\"Invalid number of arguments\")\n\n        name = args[0].strip()\n        try:\n            profile = Profile.objects.get(name=name)\n        except Profile.DoesNotExist:\n            raise CommandError(\"Invalid profile name\")\n\n        users = []\n        try:\n            users = [AstakosUser.objects.get(pk=int(pk)) for pk in\n                     options.get('users')]\n        except AstakosUser.DoesNotExist:\n            raise CommandError(\"Invalid user id\")\n\n        groups = []\n        try:\n            groups = [Group.objects.get(pk=int(pk)) for pk in\n                      options.get('groups')]\n        except Group.DoesNotExist:\n            raise CommandError(\"Invalid group id\")\n\n        update_profile(profile, users, groups)", "label": 1}
{"function": "    def _handle_client(self, client):\n        \"\"\"Handle connected client\"\"\"\n        print(\"Client handler started\")\n        client.settimeout(None)  # No timeout\n        buffer = b''\n        \n        try:\n            while self.running:\n                # Receive data\n                try:\n                    data = client.recv(8192)\n                    if not data:\n                        print(\"Client disconnected\")\n                        break\n                    \n                    buffer += data\n                    try:\n                        # Try to parse command\n                        command = json.loads(buffer.decode('utf-8'))\n                        buffer = b''\n                        \n                        # Execute command in Blender's main thread\n                        def execute_wrapper():\n                            try:\n                                response = self.execute_command(command)\n                                response_json = json.dumps(response)\n                                try:\n                                    client.sendall(response_json.encode('utf-8'))\n                                except:\n                                    print(\"Failed to send response - client disconnected\")\n                            except Exception as e:\n                                print(f\"Error executing command: {str(e)}\")\n                                traceback.print_exc()\n                                try:\n                                    error_response = {\n                                        \"status\": \"error\",\n                                        \"message\": str(e)\n                                    }\n                                    client.sendall(json.dumps(error_response).encode('utf-8'))\n                                except:\n                                    pass\n                            return None\n                        \n                        # Schedule execution in main thread\n                        bpy.app.timers.register(execute_wrapper, first_interval=0.0)\n                    except json.JSONDecodeError:\n                        # Incomplete data, wait for more\n                        pass\n                except Exception as e:\n                    print(f\"Error receiving data: {str(e)}\")\n                    break\n        except Exception as e:\n            print(f\"Error in client handler: {str(e)}\")\n        finally:\n            try:\n                client.close()\n            except:\n                pass\n            print(\"Client handler stopped\")", "label": 0}
{"function": "def predict(image, audio, pose_weight, face_weight, lip_weight, face_expand_ratio, progress=gr.Progress(track_tqdm=True)):\n    \"\"\"\n    Create a gradio interface with the configs.\n    \"\"\"\n    _ = progress\n    config = {\n        'source_image': image,\n        'driving_audio': audio,\n        'pose_weight': pose_weight,\n        'face_weight': face_weight,\n        'lip_weight': lip_weight,\n        'face_expand_ratio': face_expand_ratio,\n        'config': 'configs/inference/default.yaml',\n        'checkpoint': None,\n        'output': \".cache/output.mp4\"\n    }\n    args = argparse.Namespace()\n    for key, value in config.items():\n        setattr(args, key, value)\n    return inference_process(args)", "label": 0}
{"function": "    def get_prompt(self) -> str:\n        \"\"\"Get the prompt for generation.\"\"\"\n        system_prompt = self.system_template.format(system_message=self.system_message)\n\n        if self.sep_style == SeparatorStyle.DeepSeek:\n            seps = [self.sep, self.sep2]\n            if system_prompt == \"\" or system_prompt is None:\n                ret = \"\"\n            else:\n                ret = system_prompt + seps[0]\n            for i, (role, message) in enumerate(self.messages):\n                if message:\n                    ret += role + \": \" + message + seps[i % 2]\n                else:\n                    ret += role + \":\"\n            return ret\n        elif self.sep_style == SeparatorStyle.LLAMA2:\n            seps = [self.sep, self.sep2]\n            if self.system_message:\n                ret = system_prompt\n            else:\n                ret = \"[INST] \"\n            for i, (role, message) in enumerate(self.messages):\n                tag = self.roles[i % 2]\n                if message:\n                    if type(message) is tuple:  # multimodal message\n                        message, _ = message\n                    if i == 0:\n                        ret += message + \" \"\n                    else:\n                        ret += tag + \" \" + message + seps[i % 2]\n                else:\n                    ret += tag\n            return ret\n        elif self.sep_style == SeparatorStyle.PLAIN:\n            seps = [self.sep, self.sep2]\n            ret = \"\"\n            for i, (role, message) in enumerate(self.messages):\n                if message:\n                    if type(message) is tuple:\n                        message, _, _ = message\n                    if i % 2 == 0:\n                        ret += message + seps[i % 2]\n                    else:\n                        ret += message + seps[i % 2]\n                else:\n                    ret += \"\"\n            return ret\n        elif self.sep_style == SeparatorStyle.ALIGNMENT:\n            seps = [self.sep, self.sep2]\n            ret = \"\"\n            for i, (role, message) in enumerate(self.messages):\n                if message:\n                    if type(message) is tuple:\n                        message, _, _ = message\n                    if i % 2 == 0:\n                        ret += \"<image>\\n\" + seps[i % 2]\n                    else:\n                        ret += message + seps[i % 2]\n                else:\n                    ret += \"\"\n            return ret\n        else:\n            raise ValueError(f\"Invalid style: {self.sep_style}\")", "label": 0}
{"function": "    def lcd(self, path):\n        path = os.path.normpath(path)\n        if not os.path.exists(path):\n            raise exceptions.EnvironmentError(\"Path '%s' does not exist on the local system\" % path)\n        os.chdir(path)", "label": 1}
{"function": "    def __init__(self, env, tools, names):\n        if not SCons.Util.is_List(tools):\n            tools = [tools]\n        if not SCons.Util.is_List(names):\n            names = [names]\n        self.env = env\n        self.tools = tools\n        self.names = names\n        self.methods = {}\n        for name in names:\n            method = ToolInitializerMethod(name, self)\n            self.methods[name] = method\n            env.AddMethod(method)", "label": 1}
{"function": "    def _wrap_object(self, space, obj):\n        return space.newlong_from_rarith_int(obj)", "label": 1}
{"function": "    def build(self, attribute_list, class_list, col_sampler, bin_structure):\n        while len(self.alive_nodes) != 0:\n\n            # scan each attribute list\n            func = partial(self._process_one_attribute_list, attribute_list, class_list)\n            pool = Pool(self.num_thread)\n            rets = pool.map(func, col_sampler.col_selected)\n            pool.close()\n\n            # process the rets\n            for ret in rets:\n                for col, uint8_threshold, tree_node_G_H in ret:\n                    for tree_node_name in tree_node_G_H.keys():\n                        # get the original tree_node by tree_node_name using self.name_to_node\n                        tree_node = self.name_to_node[tree_node_name]\n                        G, H = tree_node_G_H[tree_node_name]\n                        G_left, H_left = tree_node.get_Gleft_Hleft(col, G, H)\n                        G_total, H_total = tree_node.Grad, tree_node.Hess\n                        gain = self.calculate_split_gain(G_left, H_left, G_total, H_total)\n                        tree_node.update_best_gain(col, uint8_threshold, bin_structure[col][uint8_threshold], gain)\n\n            # once had scan all column, we can get the best (feature,threshold,gain) for each alive tree node\n            cur_level_node_size = len(self.alive_nodes)\n            new_tree_nodes = []\n            treenode_leftinds = []\n            for _ in range(cur_level_node_size):\n                tree_node = self.alive_nodes.pop(0)\n                best_feature, best_uint8_threshold, best_threshold, best_gain = tree_node.get_best_feature_threshold_gain()\n                if best_gain > 0:\n                    nan_direction = 0  # TODO\n                    left_child = TreeNode(name=2*tree_node.name, depth=tree_node.depth+1, feature_dim=attribute_list.feature_dim)\n                    right_child = TreeNode(name=2*tree_node.name+1, depth=tree_node.depth+1, feature_dim=attribute_list.feature_dim)\n                    tree_node.internal_node_setter(best_feature, best_uint8_threshold, best_threshold, nan_direction, left_child, right_child)\n\n                    # to update class_list.corresponding_tree_node one pass, we should save (tree_node,left_inds)\n                    left_inds = attribute_list[best_feature][\"index\"][0:attribute_list.attribute_list_cutting_index[best_feature][best_uint8_threshold+1]]\n                    treenode_leftinds.append((tree_node, set(left_inds)))\n\n                    new_tree_nodes.append(left_child)\n                    new_tree_nodes.append(right_child)\n                    self.name_to_node[left_child.name] = left_child\n                    self.name_to_node[right_child.name] = right_child\n\n                else:\n                    leaf_score = self.calculate_leaf_score(tree_node.Grad, tree_node.Hess)\n                    tree_node.leaf_node_setter(leaf_score)\n\n            # update class_list.corresponding_tree_node one pass\n            class_list.update_corresponding_tree_node(treenode_leftinds)\n\n            # update histogram(Grad,Hess,num_sample) for each alive(new) tree node\n            class_list.update_histogram_for_tree_node()\n\n            # process the new tree nodes\n            # satisfy max_depth? min_child_weight? min_sample_split?\n            # if yes, it is leaf node, calculate its leaf score\n            # if no, put into self.alive_node\n            while len(new_tree_nodes) != 0:\n                tree_node = new_tree_nodes.pop()\n                if tree_node.depth >= self.max_depth \\\n                        or tree_node.Hess < self.min_child_weight \\\n                        or tree_node.num_sample <= self.min_sample_split:\n                    tree_node.leaf_node_setter(self.calculate_leaf_score(tree_node.Grad, tree_node.Hess))\n                else:\n                    self.alive_nodes.append(tree_node)", "label": 1}
{"function": "    def model_dump_json(self, indent: int = 2):\n        return json.dumps(self, indent=indent)", "label": 0}
{"function": "def dataset_name(key: str, sv: SessionVariables) -> str:\n    \"\"\"Get dataset name.\"\"\"\n    return next((d for d in sv.datasets.value if d.key == key), None).name  # type: ignore", "label": 0}
{"function": "def test_parse_hparam_args__exponent():\n    hparam_args = ['--foo', 'HParams(boo=10**-6)']\n    assert parse_hparam_args(hparam_args) == {'foo': HParams(boo=10**-6)}", "label": 1}
{"function": "    def register(self, fileobj: _FileObject, events: _EventMask, data: Any = ...) -> SelectorKey: ...", "label": 1}
{"function": "    def items(self):\n        return [('spam%d' % a.num, a) for a in self.args]", "label": 1}
{"function": "def get_api():\n    token = input(\"Write token? \").strip()\n    api = HfApi(token=token)\n    return api", "label": 0}
{"function": "    def digest(self):\n        return sha3.sha3_512(self._data).digest()", "label": 1}
{"function": "    def __sub__(self, other):\n        return self + (-other)", "label": 1}
{"function": "def run_server():\n    build_dir = \"build\"\n    if platform.system() == \"Windows\":\n        server_path = os.path.join(build_dir, \"bin\", \"Release\", \"llama-server.exe\")\n        if not os.path.exists(server_path):\n            server_path = os.path.join(build_dir, \"bin\", \"llama-server\")\n    else:\n        server_path = os.path.join(build_dir, \"bin\", \"llama-server\")\n    \n    command = [\n        f'{server_path}',\n        '-m', args.model,\n        '-c', str(args.ctx_size),\n        '-t', str(args.threads),\n        '-n', str(args.n_predict),\n        '-ngl', '0',\n        '--temp', str(args.temperature),\n        '--host', args.host,\n        '--port', str(args.port),\n        '-cb'  # Enable continuous batching\n    ]\n    \n    if args.prompt:\n        command.extend(['-p', args.prompt])\n    \n    # Note: -cnv flag is removed as it's not supported by the server\n    \n    print(f\"Starting server on {args.host}:{args.port}\")\n    run_command(command)", "label": 0}
{"function": "def distribute_bn(model, world_size, reduce=False):\n    # ensure every node has the same running bn stats\n    for bn_name, bn_buf in unwrap_model(model).named_buffers(recurse=True):\n        if ('running_mean' in bn_name) or ('running_var' in bn_name):\n            if reduce:\n                # average bn stats across whole group\n                torch.distributed.all_reduce(bn_buf, op=dist.ReduceOp.SUM)\n                bn_buf /= float(world_size)\n            else:\n                # broadcast bn stats from rank 0 to whole group\n                torch.distributed.broadcast(bn_buf, 0)", "label": 1}
{"function": "def secondary_server_selector(selection):\n    return selection.with_server_descriptions(\n        [s for s in selection.server_descriptions\n         if s.server_type == SERVER_TYPE.RSSecondary])", "label": 1}
{"function": "async def is_active():\n    logger.info(\"Is active endpoint called\")\n    return {\"is_active\": interaction.is_active}", "label": 0}
{"function": "    def __init__(self, app=None, verb=None, data=None):\n        self.app = app\n        self.verb = verb\n        self.data = data", "label": 1}
{"function": "def parse_key_info(output: str) -> str:\n    \"\"\"Extract and format key information from the output\"\"\"\n    key_info = []\n\n    # Extract Args namespace\n    args_match = re.search(r\"Namespace\\(.*?\\)\", output, re.DOTALL)\n    if args_match:\n        key_info.append(args_match.group(0))\n\n    # Extract input/output token counts\n    token_matches = re.findall(r\"#(Input|Output) tokens: \\d+\", output)\n    key_info.extend(token_matches)\n\n    # Extract benchmark result section\n    result_match = re.search(\n        r\"============ Serving Benchmark Result ============.*?={50,}\",\n        output,\n        re.DOTALL,\n    )\n    if result_match:\n        key_info.append(result_match.group(0))\n\n    return \"\\n\\n\".join(key_info)", "label": 0}
{"function": "def register_conv_template(template: Conversation, override: bool = False):\n    \"\"\"Register a new conversation template.\"\"\"\n    if not override:\n        assert (\n            template.name not in conv_templates\n        ), f\"{template.name} has been registered.\"\n\n    conv_templates[template.name] = template", "label": 0}
{"function": "    def pixmap(self):\n        return self.imageLabel.pixmap()", "label": 1}
{"function": "    def system_methodSignature(self, method_name):\n        \"\"\"system.methodSignature('add') => [double, int, int]\n\n        Returns a list describing the signature of the method. In the\n        above example, the add method takes two integers as arguments\n        and returns a double result.\n\n        This server does NOT support system.methodSignature.\"\"\"\n\n        # See http://xmlrpc.usefulinc.com/doc/sysmethodsig.html\n\n        return 'signatures not supported'", "label": 1}
{"function": "    def smooth_pix(img, tx, ty):\n        if tx == args.divide * width - 1 or ty == args.divide * width - 1 or tx == 0 or ty == 0: \n            return img\n        img[tx, ty] = (img[tx, ty] + img[tx + 1, ty] + img[tx, ty + 1] + img[tx - 1, ty] + img[tx, ty - 1] + img[tx + 1, ty - 1] + img[tx - 1, ty + 1] + img[tx - 1, ty - 1] + img[tx + 1, ty + 1]) / 9\n        return img", "label": 1}
{"function": "def large2small(x):\n    # (d * width, d * width) -> (d * d, width, width)\n    x = x.reshape(args.divide, width, args.divide, width, 3)\n    x = np.transpose(x, (0, 2, 1, 3, 4))\n    x = x.reshape(canvas_cnt, width, width, 3)\n    return x", "label": 1}
{"function": "def update_profile(profile, users, groups):\n    profile.groups.all().delete()\n    profile.users.all().delete()\n    profile.groups.add(*groups)\n    profile.users.add(*users)", "label": 1}
{"function": "    def get_builder(self, env):\n        \"\"\"\n        Returns the appropriate real Builder for this method name\n        after having the associated ToolInitializer object apply\n        the appropriate Tool module.\n        \"\"\"\n        builder = getattr(env, self.__name__)\n\n        self.initializer.apply_tools(env)\n\n        builder = getattr(env, self.__name__)\n        if builder is self:\n            # There was no Builder added, which means no valid Tool\n            # for this name was found (or possibly there's a mismatch\n            # between the name we were called by and the Builder name\n            # added by the Tool module).\n            return None\n\n        self.initializer.remove_methods(env)\n\n        return builder", "label": 1}
{"function": "    def url_charset(self):\n        \"\"\"The charset that is assumed for URLs.  Defaults to the value\n        of :attr:`charset`.\n\n        .. versionadded:: 0.6\n        \"\"\"\n        return self.charset", "label": 1}
{"function": "def test_gpt4_tiktoken_equality(text):\n    text = unpack(text)\n    tokenizer = GPT4Tokenizer()\n    enc = tiktoken.get_encoding(\"cl100k_base\")\n    tiktoken_ids = enc.encode(text)\n    gpt4_tokenizer_ids = tokenizer.encode(text)\n    assert gpt4_tokenizer_ids == tiktoken_ids", "label": 0}
{"function": "def secondary_with_tags_server_selector(tag_sets, selection):\n    \"\"\"All near-enough secondaries matching the tag sets.\"\"\"\n    return apply_tag_sets(tag_sets, secondary_server_selector(selection))", "label": 1}
{"function": "    def __enter__(self):\n        return self.enter_result", "label": 1}
{"function": "    def __init__(self, color=platform.system().lower() != \"windows\"):\n        # https://stackoverflow.com/questions/2720319/python-figure-out-local-timezone\n        self.tz = datetime.now(timezone.utc).astimezone().tzinfo\n        self.color = color", "label": 0}
{"function": "def get_pipeline_options(args, config):\n  \"\"\"Returns pipeline options based on args and confs.\"\"\"\n  options = {\"project\": str(config.get(\"project\"))}\n  if args.cloud:\n    if not args.job_name:\n      raise ValueError(\"Job name must be specified for cloud runs.\")\n    if not args.job_dir:\n      raise ValueError(\"Job dir must be specified for cloud runs.\")\n    options.update({\n        \"job_name\": args.job_name,\n        \"max_num_workers\": int(config.get(\"max_num_workers\")),\n        \"setup_file\": os.path.abspath(get_relative_path(\n            \"../setup.py\")),\n        \"staging_location\": os.path.join(args.job_dir, \"staging\"),\n        \"temp_location\": os.path.join(args.job_dir, \"tmp\"),\n        \"region\": config.get(\"region\"),\n    })\n  pipeline_options = beam.pipeline.PipelineOptions(flags=[], **options)\n  return pipeline_options", "label": 1}
{"function": "    def _validate_feature_flag(self):\n        \"\"\"Validates the PlatformParameter domain object that is a feature\n        flag.\n        \"\"\"\n        if self._data_type != DATA_TYPES.bool:\n            raise utils.ValidationError(\n                'Data type of feature flags must be bool, got \\'%s\\' '\n                'instead.' % self._data_type)\n        if self._feature_stage not in ALLOWED_FEATURE_STAGES:\n            raise utils.ValidationError(\n                'Invalid feature stage, got \\'%s\\', expected one of %s.' % (\n                    self._feature_stage, ALLOWED_FEATURE_STAGES))\n\n        enabling_rules = [\n            rule for rule in self._rules if rule.value_when_matched]\n        for rule in enabling_rules:\n            server_mode_filters = [\n                server_mode_filter for server_mode_filter in rule.filters\n                if server_mode_filter.type == 'server_mode']\n            for server_mode_filter in server_mode_filters:\n                server_modes = [\n                    value for _, value in server_mode_filter.conditions]\n                if self._feature_stage == FEATURE_STAGES.dev:\n                    if (\n                            SERVER_MODES.test in server_modes or\n                            SERVER_MODES.prod in server_modes):\n                        raise utils.ValidationError(\n                            'Feature in dev stage cannot be enabled in test or'\n                            ' production environments.')\n                elif self._feature_stage == FEATURE_STAGES.test:\n                    if SERVER_MODES.prod in server_modes:\n                        raise utils.ValidationError(\n                            'Feature in test stage cannot be enabled in '\n                            'production environment.')", "label": 1}
{"function": "def _iter_encoded(iterable, charset):\n    for item in iterable:\n        if isinstance(item, text_type):\n            yield item.encode(charset)\n        else:\n            yield item", "label": 1}
{"function": "async def test_openrouter_basic_completion(monkeypatch):\n    settings = Settings(\n        ENABLE_OPENROUTER=True,\n        OPENROUTER_API_KEY=\"key\",\n        OPENROUTER_MODEL=\"test-model\",\n        LLM_KEY=\"OPENROUTER\",\n    )\n    SettingsManager.set_settings(settings)\n    importlib.reload(config_registry)\n\n    monkeypatch.setattr(app, \"ARTIFACT_MANAGER\", DummyArtifactManager())\n\n    async_mock = AsyncMock(return_value=DummyResponse('{\"result\": \"ok\"}'))\n    monkeypatch.setattr(api_handler_factory.litellm, \"acompletion\", async_mock)\n\n    handler = api_handler_factory.LLMAPIHandlerFactory.get_llm_api_handler(\"OPENROUTER\")\n    result = await handler(\"hi\", \"test\")\n    assert result == {\"result\": \"ok\"}\n    async_mock.assert_called_once()", "label": 0}
{"function": "    def test_cosine_scaled_reward(self):\n        \"\"\"Test cosine_scaled_reward with various cases.\"\"\"\n        # Test parameters\n        test_params = {\n            \"min_value_wrong\": -1.0,\n            \"max_value_wrong\": -0.5,\n            \"min_value_correct\": 0.5,\n            \"max_value_correct\": 1.0,\n            \"max_len\": 100,\n        }\n\n        test_cases = [\n            # Correct answers with different lengths\n            (\n                r\"\\boxed{\\frac{63}{400}}\",\n                r\"\\frac{63}{400}\",\n                20,\n                0.943,\n            ),  # Short correct answer\n            (\n                r\"\\boxed{\\frac{63}{400}}\",\n                r\"\\frac{63}{400}\",\n                80,\n                0.547,\n            ),  # Long correct answer\n            # Wrong answers with different lengths\n            (\n                r\"\\boxed{\\frac{64}{400}}\",\n                r\"\\frac{63}{400}\",\n                20,\n                -0.942,\n            ),  # Short wrong answer\n            (\n                r\"\\boxed{\\frac{64}{400}}\",\n                r\"\\frac{63}{400}\",\n                80,\n                -0.547,\n            ),  # Long wrong answer\n        ]\n\n        for content, solution, content_len, expected_reward in test_cases:\n            # Pad content to desired length\n            padded_content = content + \" \" * (content_len - len(content))\n            completion = [[{\"content\": padded_content}]]\n\n            rewards = get_cosine_scaled_reward(**test_params)(completion, [solution])\n            self.assertAlmostEqual(rewards[0], expected_reward, places=2)", "label": 0}
{"function": "    def _split(self, string):\n        bound = self.boundary\n\n        # Yields (startchar, endchar) pairs for each indexable substring in\n        # the given string, e.g. \"WikiWord\" -> (0, 4), (4, 8)\n\n        # Whether we're splitting on transitions (case changes, letter -> num,\n        # num -> letter, etc.)\n        splitting = self.splitting\n\n        # Make a list (dispos, for \"dispossessed\") of (startchar, endchar)\n        # pairs for runs of text between \"'s\"\n        if \"'\" in string:\n            # Split on possessive 's\n            dispos = []\n            prev = 0\n            for match in self.possessive.finditer(string):\n                dispos.append((prev, match.start()))\n                prev = match.end()\n            if prev < len(string):\n                dispos.append((prev, len(string)))\n        else:\n            # Shortcut if there's no apostrophe in the string\n            dispos = ((0, len(string)),)\n\n        # For each run between 's\n        for sc, ec in dispos:\n            # Split on boundary characters\n            for part_match in self.between.finditer(string, sc, ec):\n                part_start = part_match.start()\n                part_end = part_match.end()\n\n                if splitting:\n                    # The point to start splitting at\n                    prev = part_start\n                    # Find transitions (e.g. \"iW\" or \"a0\")\n                    for bmatch in bound.finditer(string, part_start, part_end):\n                        # The point in the middle of the transition\n                        pivot = bmatch.start() + 1\n                        # Yield from the previous match to the transition\n                        yield (prev, pivot)\n                        # Make the transition the new starting point\n                        prev = pivot\n\n                    # If there's leftover text at the end, yield it too\n                    if prev < part_end:\n                        yield (prev, part_end)\n                else:\n                    # Not splitting on transitions, just yield the part\n                    yield (part_start, part_end)", "label": 1}
{"function": "def get_relative_path(path):\n  \"\"\"Return the given path relative to this module.\"\"\"\n  module_dir = os.path.dirname(__file__)\n  return os.path.join(module_dir, path)", "label": 1}
{"function": "    def suggest_email(self, first_name, last_name):\n        \"\"\"Generate a suggested email based on first and last name with the last used domain\"\"\"\n        try:\n            # Get the last used email domain\n            domain = self.get_last_email_domain()\n            if not domain:\n                return None\n            \n            # Generate email prefix from first and last name (lowercase)\n            email_prefix = f\"{first_name.lower()}.{last_name.lower()}\"\n            \n            # Combine prefix and domain\n            suggested_email = f\"{email_prefix}@{domain}\"\n            \n            return suggested_email\n        \n        except Exception as e:\n            error_msg = self.translator.get('account.suggest_email_failed', error=str(e)) if self.translator else f'Failed to suggest email: {str(e)}'\n            print(f\"{Fore.RED}{EMOJI['ERROR']} {error_msg}{Style.RESET_ALL}\")\n            return None", "label": 0}
{"function": "    def register(self, fileobj: _FileObject, events: _EventMask, data: Any = ...) -> SelectorKey: ...", "label": 1}
{"function": "    def order(self, field_name):\n        \"\"\"Order document by field name\n\n        By default, a query retrieves all documents that satisfy the query in ascending order by document ID.\n        You can specify the sort order for your data using `order()`, and you can limit the number of documents\n        retrieved using `limit()`\n\n        Put a dash(-) in front of field name if you want to sort it in descending order. You can also combine\n        filter with order\n\n        Parameters\n        ----------\n        field_name : str\n            Name of the field on which base order is applied\n\n        Returns\n        -------\n            Self object\n        \"\"\"\n        # Save order in cursor dict for next fetch\n        if 'order' in self.cursor_dict:\n            self.cursor_dict['order'] = self.cursor_dict['order'] + ',' + field_name\n        else:\n            self.cursor_dict['order'] = field_name\n\n        order_direction = 'Asc'\n        name = field_name\n\n        # If this is in Desc order\n        if field_name[0] == '-':\n            order_direction = 'Desc'\n            name = field_name[1:]  # Get the field name after dash(-) e.g -age name will be age\n        f_name = self.model._meta.get_field(name).db_column_name\n        self.order_by.append((f_name, order_direction))\n        return self", "label": 1}
{"function": "    def clean_slug(self):\n        slug = slugify(self.cleaned_data['slug'])\n        i = 0\n        while True:\n            if i > 0:\n                if i > 1:\n                    slug = slug.rsplit(\"-\", 1)[0]\n                slug = \"%s-%s\" % (slug, i)\n            match = Form.objects.filter(slug=slug)\n            if self.instance:\n                match = match.exclude(pk=self.instance.pk)\n            if not match:\n                break\n            i += 1\n        return slug", "label": 1}
{"function": "    def test_format_reward_correct(self):\n        \"\"\"Test format_reward with correct format.\"\"\"\n        completion = [[{\"content\": \"<think>\\nSome reasoning\\n</think>\\n<answer>\\nThe answer\\n</answer>\"}]]\n        rewards = format_reward(completion)\n        self.assertEqual(rewards[0], 1.0)", "label": 0}
{"function": "    def __getattr__(self, attr):\n        return getattr(self.terminal, attr)", "label": 0}
{"function": "def run_migrations():\n    \"\"\"Run all pending database migrations\"\"\"\n    db_path = get_db_path()\n    \n    # logger.info(f\"Using database at: {db_path}\")\n    \n    # Check if database file exists\n    if not os.path.exists(db_path):\n        # logger.error(f\"Database file not found at {db_path}\")\n        return False\n    \n    try:\n        # Initialize migration manager\n        migrations_dir = os.path.join(project_root, \"lpm_kernel\", \"database\", \"migrations\")\n        manager = MigrationManager(db_path)\n        \n        # Apply migrations\n        applied = manager.apply_migrations(migrations_dir)\n        \n        # if applied:\n        #     logger.info(f\"Successfully applied {len(applied)} migrations\")\n        # else:\n        #     logger.info(\"No new migrations to apply\")\n        \n        return True\n        \n    except Exception as e:\n        logger.error(f\"Error during migrations: {e}\")\n        return False", "label": 0}
{"function": "    def testNewsPaperPromptHint(self):\n        local_pdf_path = os.path.join(os.path.dirname(__file__), \"gnarly_pdfs\", \"newspaper.pdf\")\n\n        anchor_text = get_anchor_text(local_pdf_path, 1, pdf_engine=\"pdfreport\")\n\n        print(anchor_text)\n        print(len(anchor_text))\n        self.assertLessEqual(len(anchor_text), 4000)", "label": 0}
{"function": "def extract_glimpse_handler(converter: TensorFlowConverter, tf_op: \"tf.Operation\"):\n    raise NotImplementedError(f\"[TensorFlowConverter] {tf_op.type} is not supported yet.\")", "label": 1}
{"function": "    def _write_notebook(name: str, content: dict[str, Any]) -> Path:\n        notebook_path = tmp_path / name\n        with notebook_path.open(mode=\"w\", encoding=\"utf-8\") as f:\n            json.dump(content, f)\n        return notebook_path", "label": 0}
{"function": "def main():\n    parser = argparse.ArgumentParser(description=\"Gradio WebUI for Browser Agent\")\n    parser.add_argument(\"--ip\", type=str, default=\"127.0.0.1\", help=\"IP address to bind to\")\n    parser.add_argument(\"--port\", type=int, default=7788, help=\"Port to listen on\")\n    parser.add_argument(\"--theme\", type=str, default=\"Ocean\", choices=theme_map.keys(), help=\"Theme to use for the UI\")\n    args = parser.parse_args()\n\n    demo = create_ui(theme_name=args.theme)\n    demo.queue().launch(server_name=args.ip, server_port=args.port)", "label": 0}
{"function": "async def test_controller_with_mcp():\n    import os\n    from src.controller.custom_controller import CustomController\n    from browser_use.controller.registry.views import ActionModel\n\n    mcp_server_config = {\n        \"mcpServers\": {\n            # \"markitdown\": {\n            #     \"command\": \"docker\",\n            #     \"args\": [\n            #         \"run\",\n            #         \"--rm\",\n            #         \"-i\",\n            #         \"markitdown-mcp:latest\"\n            #     ]\n            # },\n            \"desktop-commander\": {\n                \"command\": \"npx\",\n                \"args\": [\n                    \"-y\",\n                    \"@wonderwhy-er/desktop-commander\"\n                ]\n            },\n            # \"filesystem\": {\n            #     \"command\": \"npx\",\n            #     \"args\": [\n            #         \"-y\",\n            #         \"@modelcontextprotocol/server-filesystem\",\n            #         \"/Users/xxx/ai_workspace\",\n            #     ]\n            # },\n        }\n    }\n\n    controller = CustomController()\n    await controller.setup_mcp_client(mcp_server_config)\n    action_name = \"mcp.desktop-commander.execute_command\"\n    action_info = controller.registry.registry.actions[action_name]\n    param_model = action_info.param_model\n    print(param_model.model_json_schema())\n    params = {\"command\": f\"python ./tmp/test.py\"\n              }\n    validated_params = param_model(**params)\n    ActionModel_ = controller.registry.create_action_model()\n    # Create ActionModel instance with the validated parameters\n    action_model = ActionModel_(**{action_name: validated_params})\n    result = await controller.act(action_model)\n    result = result.extracted_content\n    print(result)\n    if result and \"Command is still running. Use read_output to get more output.\" in result and \"PID\" in \\\n            result.split(\"\\n\")[0]:\n        pid = int(result.split(\"\\n\")[0].split(\"PID\")[-1].strip())\n        action_name = \"mcp.desktop-commander.read_output\"\n        action_info = controller.registry.registry.actions[action_name]\n        param_model = action_info.param_model\n        print(param_model.model_json_schema())\n        params = {\"pid\": pid}\n        validated_params = param_model(**params)\n        action_model = ActionModel_(**{action_name: validated_params})\n        output_result = \"\"\n        while True:\n            time.sleep(1)\n            result = await controller.act(action_model)\n            result = result.extracted_content\n            if result:\n                pdb.set_trace()\n                output_result = result\n                break\n        print(output_result)\n        pdb.set_trace()\n    await controller.close_mcp_client()\n    pdb.set_trace()", "label": 0}
{"function": "\tdef setUp(self):\n\t\t\"\"\"Call before every test case.\"\"\"\n\t\tsuper(FailmanagerComplex, self).setUp()\n\t\tself.__failManager = FailManager()\n\t\t# down logging level for all this tests, because of extremely large failure count (several GB on heavydebug)\n\t\tself.__saved_ll = failmanager.logLevel\n\t\tfailmanager.logLevel = 3", "label": 1}
{"function": "async def test_deep_research_agent():\n    from src.agent.deep_research.deep_research_agent import DeepResearchAgent, PLAN_FILENAME, REPORT_FILENAME\n    from src.utils import llm_provider\n\n    llm = llm_provider.get_llm_model(\n        provider=\"openai\",\n        model_name=\"gpt-4o\",\n        temperature=0.5\n    )\n\n    # llm = llm_provider.get_llm_model(\n    #     provider=\"bedrock\",\n    # )\n\n    mcp_server_config = {\n        \"mcpServers\": {\n            \"desktop-commander\": {\n                \"command\": \"npx\",\n                \"args\": [\n                    \"-y\",\n                    \"@wonderwhy-er/desktop-commander\"\n                ]\n            },\n        }\n    }\n\n    browser_config = {\"headless\": False, \"window_width\": 1280, \"window_height\": 1100, \"use_own_browser\": False}\n    agent = DeepResearchAgent(llm=llm, browser_config=browser_config, mcp_server_config=mcp_server_config)\n    research_topic = \"Give me investment advices of nvidia and tesla.\"\n    task_id_to_resume = \"\"  # Set this to resume a previous task ID\n\n    print(f\"Starting research on: {research_topic}\")\n\n    try:\n        # Call run and wait for the final result dictionary\n        result = await agent.run(research_topic,\n                                 task_id=task_id_to_resume,\n                                 save_dir=\"./tmp/deep_research\",\n                                 max_parallel_browsers=1,\n                                 )\n\n        print(\"\\n--- Research Process Ended ---\")\n        print(f\"Status: {result.get('status')}\")\n        print(f\"Message: {result.get('message')}\")\n        print(f\"Task ID: {result.get('task_id')}\")\n\n        # Check the final state for the report\n        final_state = result.get('final_state', {})\n        if final_state:\n            print(\"\\n--- Final State Summary ---\")\n            print(\n                f\"  Plan Steps Completed: {sum(1 for item in final_state.get('research_plan', []) if item.get('status') == 'completed')}\")\n            print(f\"  Total Search Results Logged: {len(final_state.get('search_results', []))}\")\n            if final_state.get(\"final_report\"):\n                print(\"  Final Report: Generated (content omitted). You can find it in the output directory.\")\n                # print(\"\\n--- Final Report ---\") # Optionally print report\n                # print(final_state[\"final_report\"])\n            else:\n                print(\"  Final Report: Not generated.\")\n        else:\n            print(\"Final state information not available.\")\n\n\n    except Exception as e:\n        print(f\"\\n--- An unhandled error occurred outside the agent run ---\")\n        print(e)", "label": 0}
{"function": "        def set_value(self, value):\n            self.__value = value\n            self.changed()  # Emit signal", "label": 1}
{"function": "def greedy_move_to_gpu(model, model_gpu_memory_when_using_cpu_swap):\n    mem_counter = 0\n    memory_in_swap = 0\n    for m in model.modules():\n        if hasattr(m, \"weight\"):\n            module_mem = memory_management.module_size(m)\n            if mem_counter + module_mem < model_gpu_memory_when_using_cpu_swap:\n                m.to(gpu)\n                mem_counter += module_mem\n            else:\n                m.to(cpu)\n                memory_in_swap += module_mem\n\n    print(f\"[Memory Management] Loaded to CPU Swap: {memory_in_swap / (1024 * 1024):.2f} MB\")\n    print(f\"[Memory Management] Loaded to GPU: {mem_counter / (1024 * 1024):.2f} MB\")\n    return", "label": 0}
{"function": "def random_select_audio_segment(audio: np.ndarray, length: int) -> np.ndarray:\n    \"\"\"get an audio segment given the length\n\n    Args:\n        audio (np.ndarray):\n        length (int): audio length = sampling_rate * duration\n    \"\"\"\n    if audio.shape[0] < length:\n        audio = np.pad(audio, (0, int(length - audio.shape[0])))\n    start_index = random.randint(0, audio.shape[0] - length)\n    end_index = int(start_index + length)\n\n    return audio[start_index:end_index]", "label": 0}
{"function": "    def execute_trade(self, ticker: str, action: str, quantity: float, current_price: float):\n        \"\"\"\n        Execute trades with support for both long and short positions.\n        `quantity` is the number of shares the agent wants to buy/sell/short/cover.\n        We will only trade integer shares to keep it simple.\n        \"\"\"\n        if quantity <= 0:\n            return 0\n\n        quantity = int(quantity)  # force integer shares\n        position = self.portfolio[\"positions\"][ticker]\n\n        if action == \"buy\":\n            cost = quantity * current_price\n            if cost <= self.portfolio[\"cash\"]:\n                # Weighted average cost basis for the new total\n                old_shares = position[\"long\"]\n                old_cost_basis = position[\"long_cost_basis\"]\n                new_shares = quantity\n                total_shares = old_shares + new_shares\n\n                if total_shares > 0:\n                    total_old_cost = old_cost_basis * old_shares\n                    total_new_cost = cost\n                    position[\"long_cost_basis\"] = (total_old_cost + total_new_cost) / total_shares\n\n                position[\"long\"] += quantity\n                self.portfolio[\"cash\"] -= cost\n                return quantity\n            else:\n                # Calculate maximum affordable quantity\n                max_quantity = int(self.portfolio[\"cash\"] / current_price)\n                if max_quantity > 0:\n                    cost = max_quantity * current_price\n                    old_shares = position[\"long\"]\n                    old_cost_basis = position[\"long_cost_basis\"]\n                    total_shares = old_shares + max_quantity\n\n                    if total_shares > 0:\n                        total_old_cost = old_cost_basis * old_shares\n                        total_new_cost = cost\n                        position[\"long_cost_basis\"] = (total_old_cost + total_new_cost) / total_shares\n\n                    position[\"long\"] += max_quantity\n                    self.portfolio[\"cash\"] -= cost\n                    return max_quantity\n                return 0\n\n        elif action == \"sell\":\n            # You can only sell as many as you own\n            quantity = min(quantity, position[\"long\"])\n            if quantity > 0:\n                # Realized gain/loss using average cost basis\n                avg_cost_per_share = position[\"long_cost_basis\"] if position[\"long\"] > 0 else 0\n                realized_gain = (current_price - avg_cost_per_share) * quantity\n                self.portfolio[\"realized_gains\"][ticker][\"long\"] += realized_gain\n\n                position[\"long\"] -= quantity\n                self.portfolio[\"cash\"] += quantity * current_price\n\n                if position[\"long\"] == 0:\n                    position[\"long_cost_basis\"] = 0.0\n\n                return quantity\n\n        elif action == \"short\":\n            \"\"\"\n            Typical short sale flow:\n              1) Receive proceeds = current_price * quantity\n              2) Post margin_required = proceeds * margin_ratio\n              3) Net effect on cash = +proceeds - margin_required\n            \"\"\"\n            proceeds = current_price * quantity\n            margin_required = proceeds * self.portfolio[\"margin_requirement\"]\n            if margin_required <= self.portfolio[\"cash\"]:\n                # Weighted average short cost basis\n                old_short_shares = position[\"short\"]\n                old_cost_basis = position[\"short_cost_basis\"]\n                new_shares = quantity\n                total_shares = old_short_shares + new_shares\n\n                if total_shares > 0:\n                    total_old_cost = old_cost_basis * old_short_shares\n                    total_new_cost = current_price * new_shares\n                    position[\"short_cost_basis\"] = (total_old_cost + total_new_cost) / total_shares\n\n                position[\"short\"] += quantity\n\n                # Update margin usage\n                position[\"short_margin_used\"] += margin_required\n                self.portfolio[\"margin_used\"] += margin_required\n\n                # Increase cash by proceeds, then subtract the required margin\n                self.portfolio[\"cash\"] += proceeds\n                self.portfolio[\"cash\"] -= margin_required\n                return quantity\n            else:\n                # Calculate maximum shortable quantity\n                margin_ratio = self.portfolio[\"margin_requirement\"]\n                if margin_ratio > 0:\n                    max_quantity = int(self.portfolio[\"cash\"] / (current_price * margin_ratio))\n                else:\n                    max_quantity = 0\n\n                if max_quantity > 0:\n                    proceeds = current_price * max_quantity\n                    margin_required = proceeds * margin_ratio\n\n                    old_short_shares = position[\"short\"]\n                    old_cost_basis = position[\"short_cost_basis\"]\n                    total_shares = old_short_shares + max_quantity\n\n                    if total_shares > 0:\n                        total_old_cost = old_cost_basis * old_short_shares\n                        total_new_cost = current_price * max_quantity\n                        position[\"short_cost_basis\"] = (total_old_cost + total_new_cost) / total_shares\n\n                    position[\"short\"] += max_quantity\n                    position[\"short_margin_used\"] += margin_required\n                    self.portfolio[\"margin_used\"] += margin_required\n\n                    self.portfolio[\"cash\"] += proceeds\n                    self.portfolio[\"cash\"] -= margin_required\n                    return max_quantity\n                return 0\n\n        elif action == \"cover\":\n            \"\"\"\n            When covering shares:\n              1) Pay cover cost = current_price * quantity\n              2) Release a proportional share of the margin\n              3) Net effect on cash = -cover_cost + released_margin\n            \"\"\"\n            quantity = min(quantity, position[\"short\"])\n            if quantity > 0:\n                cover_cost = quantity * current_price\n                avg_short_price = position[\"short_cost_basis\"] if position[\"short\"] > 0 else 0\n                realized_gain = (avg_short_price - current_price) * quantity\n\n                if position[\"short\"] > 0:\n                    portion = quantity / position[\"short\"]\n                else:\n                    portion = 1.0\n\n                margin_to_release = portion * position[\"short_margin_used\"]\n\n                position[\"short\"] -= quantity\n                position[\"short_margin_used\"] -= margin_to_release\n                self.portfolio[\"margin_used\"] -= margin_to_release\n\n                # Pay the cost to cover, but get back the released margin\n                self.portfolio[\"cash\"] += margin_to_release\n                self.portfolio[\"cash\"] -= cover_cost\n\n                self.portfolio[\"realized_gains\"][ticker][\"short\"] += realized_gain\n\n                if position[\"short\"] == 0:\n                    position[\"short_cost_basis\"] = 0.0\n                    position[\"short_margin_used\"] = 0.0\n\n                return quantity\n\n        return 0", "label": 0}
{"function": "    def is_absolute(self) -> bool: ...", "label": 1}
{"function": "    def __init__(self, framework):\n        self.framework = framework", "label": 1}
{"function": "    def __init__(self, real, timeperiod=14):\n        pass", "label": 1}
{"function": "    def stop(self):\n        self.running = False\n        \n        # Close socket\n        if self.socket:\n            try:\n                self.socket.close()\n            except:\n                pass\n            self.socket = None\n        \n        # Wait for thread to finish\n        if self.server_thread:\n            try:\n                if self.server_thread.is_alive():\n                    self.server_thread.join(timeout=1.0)\n            except:\n                pass\n            self.server_thread = None\n        \n        print(\"BlenderMCP server stopped\")", "label": 0}
{"function": "\tdef purge(self, before):\n\t\t\"\"\" Remove all done tasks that were created before `before`. Remove\n\t\tall done tasks if `before` is None.\"\"\"\n\t\tc = self.connection.cursor()\n\t\tquery = \"\"\"\n\t\t\tDELETE FROM Task\n\t\t\tWHERE done IS NOT NULL\n\t\t\"\"\"\n\t\tif before is not None:\n\t\t\tquery += \"\"\"\n\t\t\t\tAND created < ?\n\t\t\t\"\"\"\n\t\t\tvalues = (before,)\n\t\telse:\n\t\t\tvalues = ()\n\t\tc.execute(query, values)\n\t\treturn c.rowcount", "label": 1}
{"function": "    def test_iterconsume(self, _iterconsume, n='test_iterconsume'):\n        c = compat.Consumer(self.connection, queue=n, exchange=n)\n        cs = compat.ConsumerSet(self.connection, consumers=[c])\n        cs.iterconsume(limit=10, no_ack=True)\n        _iterconsume.assert_called_with(c.connection, cs, True, 10)", "label": 1}
{"function": "    def map_class_id_to_class_name(self, class_id):\n        return RotationMaskDataset.CLASSES[class_id]", "label": 1}
{"function": "    def test_pause_instance(self):\n        self._test_compute_api('pause_instance', 'cast',\n                               instance=self.fake_instance_obj)", "label": 1}
{"function": "def fetch_requirements(paths) -> List[str]:\n    \"\"\"\n    This function reads the requirements file.\n\n    Args:\n        path (str): the path to the requirements file.\n\n    Returns:\n        The lines in the requirements file.\n    \"\"\"\n    if not isinstance(paths, list):\n        paths = [paths]\n    requirements = []\n    for path in paths:\n        with open(path, \"r\") as fd:\n            requirements += [r.strip() for r in fd.readlines()]\n    return requirements", "label": 0}
{"function": "    def test_repo_updatessl_non_interactive(self, shell):\n        \"\"\"\n        Test do_repo_updatessl non-interactive.\n\n        :param shell:\n        :return:\n        \"\"\"\n        shell.help_repo_rename = MagicMock()\n        shell.client.channel.software.updateRepoSsl = MagicMock()\n        shell.do_repo_list = MagicMock()\n        mprint = MagicMock()\n        logger = MagicMock()\n        prompter = MagicMock(return_value=\"\")\n\n        with patch(\"spacecmd.repo.print\", mprint) as prn, \\\n                patch(\"spacecmd.repo.prompt_user\", prompter) as prn, \\\n                patch(\"spacecmd.repo.logging\", logger) as lgr:\n            out = spacecmd.repo.do_repo_updatessl(shell, \"--name name --ca ca --cert cert --key key\")\n\n        assert out is 0\n        assert not mprint.called\n        assert not logger.error.called\n        assert shell.client.channel.software.updateRepoSsl.called\n\n        assert_args_expect(shell.client.channel.software.updateRepoSsl.call_args_list,\n                           [((shell.session, \"name\", \"ca\", \"cert\", \"key\"), {})])", "label": 1}
{"function": "  def _GetHostAddresses(self, iface):\n    \"\"\"Returns the IP addresses on host's interfaces, breaking out |iface|.\"\"\"\n    interface_list = self._EnumerateHostInterfaces()\n    addresses = []\n    iface_address = None\n    found_iface = False\n    for line in interface_list:\n      if not line.startswith((' ', '\\t')):\n        found_iface = iface in line\n      match = re.search(r'(?<=inet )\\S+', line)\n      if match:\n        address = match.group(0)\n        if '/' in address:\n          address = self._IpPrefix2AddressMask(address)\n        else:\n          match = re.search(r'(?<=netmask )\\S+', line)\n          address = self._Ip2Long(address), int(match.group(0), 16)\n        if found_iface:\n          assert not iface_address, (\n            'Found %s twice when parsing host interfaces.' % iface)\n          iface_address = address\n        else:\n          addresses.append(address)\n    return addresses, iface_address", "label": 1}
{"function": "  def testNoSlashPrefixExactMatch(self, mock_gsutil_api):\n    mock_gsutil_api.ListObjects.return_value = iter([\n        CloudApi.CsObjectOrPrefix('folder/',\n                                  CloudApi.CsObjectOrPrefixType.PREFIX)\n    ])\n    (exp_url, have_existing_dst_container) = ExpandUrlToSingleBlr(\n        'gs://test/folder', mock_gsutil_api, 'project_id', False,\n        CreateOrGetGsutilLogger('copy_test'))\n\n    self.assertTrue(have_existing_dst_container)\n    self.assertEqual(exp_url, StorageUrlFromString('gs://test/folder'))", "label": 1}
{"function": "def collect_video_folder_paths(root_path: Path) -> list:\n    \"\"\"\n    Collect all video folder paths from the root path.\n\n    Args:\n        root_path (Path): The root directory containing video folders.\n\n    Returns:\n        list: List of video folder paths.\n    \"\"\"\n    return [frames_dir.resolve() for frames_dir in root_path.iterdir() if frames_dir.is_dir()]", "label": 0}
{"function": "async def test_read_write_text(computer):\n    tmp_path = \"test_rw_text.txt\"\n    content = \"sample text\"\n    await computer.interface.write_text(tmp_path, content)\n    read = await computer.interface.read_text(tmp_path)\n    assert read == content, \"File content should match\"\n    await computer.interface.delete_file(tmp_path)", "label": 0}
{"function": "async def process_query(request: QueryRequest):\n    global is_generating, query_resp_history\n    logger.info(f\"Processing query: {request.query}\")\n    query_resp = QueryResponse(\n        done=\"false\",\n        answer=\"\",\n        reasoning=\"\",\n        agent_name=\"Unknown\",\n        success=\"false\",\n        blocks={},\n        status=\"Ready\",\n        uid=str(uuid.uuid4())\n    )\n    if is_generating:\n        logger.warning(\"Another query is being processed, please wait.\")\n        return JSONResponse(status_code=429, content=query_resp.jsonify())\n\n    try:\n        is_generating = True\n        success = await think_wrapper(interaction, request.query)\n        is_generating = False\n\n        if not success:\n            query_resp.answer = interaction.last_answer\n            query_resp.reasoning = interaction.last_reasoning\n            return JSONResponse(status_code=400, content=query_resp.jsonify())\n\n        if interaction.current_agent:\n            blocks_json = {f'{i}': block.jsonify() for i, block in enumerate(interaction.current_agent.get_blocks_result())}\n        else:\n            logger.error(\"No current agent found\")\n            blocks_json = {}\n            query_resp.answer = \"Error: No current agent\"\n            return JSONResponse(status_code=400, content=query_resp.jsonify())\n\n        logger.info(f\"Answer: {interaction.last_answer}\")\n        logger.info(f\"Blocks: {blocks_json}\")\n        query_resp.done = \"true\"\n        query_resp.answer = interaction.last_answer\n        query_resp.reasoning = interaction.last_reasoning\n        query_resp.agent_name = interaction.current_agent.agent_name\n        query_resp.success = str(interaction.last_success)\n        query_resp.blocks = blocks_json\n        \n        query_resp_dict = {\n            \"done\": query_resp.done,\n            \"answer\": query_resp.answer,\n            \"agent_name\": query_resp.agent_name,\n            \"success\": query_resp.success,\n            \"blocks\": query_resp.blocks,\n            \"status\": query_resp.status,\n            \"uid\": query_resp.uid\n        }\n        query_resp_history.append(query_resp_dict)\n\n        logger.info(\"Query processed successfully\")\n        return JSONResponse(status_code=200, content=query_resp.jsonify())\n    except Exception as e:\n        logger.error(f\"An error occurred: {str(e)}\")\n        sys.exit(1)\n    finally:\n        logger.info(\"Processing finished\")\n        if config.getboolean('MAIN', 'save_session'):\n            interaction.save_session()", "label": 0}
{"function": "    def test_repo_setfilters_wrong_filters_syntax(self, shell):\n        \"\"\"\n        Test do_repo_setfilters with wrong filters syntax\n\n        :param shell:\n        :return:\n        \"\"\"\n        shell.help_repo_setfilters = MagicMock()\n        shell.client.channel.software.setRepoFilters = MagicMock()\n        mprint = MagicMock()\n        logger = MagicMock()\n\n        with patch(\"spacecmd.repo.print\", mprint) as prn, \\\n                patch(\"spacecmd.repo.logging\", logger) as lgr:\n            out = spacecmd.repo.do_repo_setfilters(shell, \"repo foo bar\")\n\n        assert out is 1\n        assert not mprint.called\n        assert not shell.client.channel.software.setRepoFilters.called\n        assert not shell.help_repo_setfilters.called\n        assert logger.error.called\n\n        assert_expect(logger.error.call_args_list, \"Each filter must start with + or -\")", "label": 1}
{"function": "    def unregister(self, fileobj: _FileObject) -> SelectorKey: ...", "label": 1}
{"function": "    def test_execute_tool_valid_parameters(self):\n        \"\"\"Test executing a registered tool with valid parameters.\"\"\"\n        self.tool_manager._add_tool(get_current_temperature, TemperatureParams)\n        tool_call = {\n            \"id\": \"call_1\",\n            \"function\": {\n                \"name\": \"get_current_temperature\",\n                \"arguments\": {\"location\": \"San Francisco\", \"unit\": \"Celsius\"},\n            },\n        }\n        result, result_message = self.tool_manager.execute_tool(tool_call)\n\n        # Assuming result is returned as a list with a single dictionary\n        result_dict = result[0] if isinstance(result, list) else result\n\n        # Check that the result matches expected output\n        self.assertEqual(result_dict[\"location\"], \"San Francisco\")\n        self.assertEqual(result_dict[\"unit\"], \"Celsius\")\n        self.assertEqual(result_dict[\"temperature\"], \"72\")", "label": 0}
{"function": "def apply_tag_sets(tag_sets, selection):\n    \"\"\"All servers match a list of tag sets.\n\n    tag_sets is a list of dicts. The empty tag set {} matches any server,\n    and may be provided at the end of the list as a fallback. So\n    [{'a': 'value'}, {}] expresses a preference for servers tagged\n    {'a': 'value'}, but accepts any server if none matches the first\n    preference.\n    \"\"\"\n    for tag_set in tag_sets:\n        with_tag_set = apply_single_tag_set(tag_set, selection)\n        if with_tag_set:\n            return with_tag_set\n\n    return selection.with_server_descriptions([])", "label": 1}
{"function": "def requires_gpus(count: int = 1, min_gb: float = 0.0) -> pytest.MarkDecorator:\n    \"\"\"Decorator to skip a test if the required number of GPUs is not available.\n\n    Args:\n        count (int): The number of GPUs required for the test. Defaults to 1.\n        min_gb: Min required GPU VRAM in GB-s. Has no effect if zero or negative.\n\n    Returns:\n        pytest.MarkDecorator: A decorator that skips the test if the required\n            number of GPUs is not available.\n    \"\"\"\n\n    if not torch.cuda.is_available():\n        return pytest.mark.skip(reason=\"CUDA is not available\")\n\n    gpu_count = torch.cuda.device_count()\n\n    error_message = \"\"\n    if gpu_count < count:\n        error_message = (\n            f\"Not enough GPUs to run the test: requires '{count}',\"\n            f\" got '{torch.cuda.device_count()}'\"\n        )\n    elif min_gb > 0.0:\n        eps = 1e-2  # relative tolerance\n        for device_idx in range(gpu_count):\n            _, total_memory = torch.cuda.mem_get_info(device_idx)\n            total_memory_gb = float(total_memory) / float(1024 * 1024 * 1024)\n            if total_memory_gb < min_gb * (1 - eps):\n                device_name = torch.cuda.get_device_name(device_idx)\n                error_message = (\n                    \"Not enough GPU memory to run the test: \"\n                    f\"requires {min_gb:.3f}GB, got {total_memory_gb:.3f}GB. \"\n                    f\"GPU: {device_name}\"\n                ) + (f\" ({device_idx + 1} of {gpu_count})\" if gpu_count > 1 else \"\")\n\n    return pytest.mark.skipif(len(error_message) > 0, reason=error_message)", "label": 0}
{"function": "    def test_1d_slicing7_npm(self):\n        self.test_1d_slicing7(flags=Noflags)", "label": 1}
{"function": "def merge(ids, pair, idx):\n    \"\"\"\n    In the list of integers (ids), replace all consecutive occurrences\n    of pair with the new integer token idx\n    Example: ids=[1, 2, 3, 1, 2], pair=(1, 2), idx=4 -> [4, 3, 4]\n    \"\"\"\n    newids = []\n    i = 0\n    while i < len(ids):\n        # if not at the very last position AND the pair matches, replace it\n        if ids[i] == pair[0] and i < len(ids) - 1 and ids[i+1] == pair[1]:\n            newids.append(idx)\n            i += 2\n        else:\n            newids.append(ids[i])\n            i += 1\n    return newids", "label": 0}
{"function": "    def test_from_array_int_time(surv_arrays):\n        event, time = surv_arrays\n        time += 1\n        time *= time\n\n        expected = numpy.empty(dtype=[('event', bool), ('time', float)], shape=100)\n        expected['event'] = event.astype(bool)\n        expected['time'] = time.astype(int)\n\n        y = Surv.from_arrays(event.astype(bool), time.astype(int))\n        assert_array_equal(y, expected)", "label": 1}
{"function": "\tdef get_ResourceOwnerAccount(self):\n\t\treturn self.get_query_params().get('ResourceOwnerAccount')", "label": 1}
{"function": "    def prep(self, shared):\n        files_data = shared[\"files\"]\n        project_name = shared[\"project_name\"]  # Get project name\n        language = shared.get(\"language\", \"english\")  # Get language\n        use_cache = shared.get(\"use_cache\", True)  # Get use_cache flag, default to True\n        max_abstraction_num = shared.get(\"max_abstraction_num\", 10)  # Get max_abstraction_num, default to 10\n\n        # Helper to create context from files, respecting limits (basic example)\n        def create_llm_context(files_data):\n            context = \"\"\n            file_info = []  # Store tuples of (index, path)\n            for i, (path, content) in enumerate(files_data):\n                entry = f\"--- File Index {i}: {path} ---\\n{content}\\n\\n\"\n                context += entry\n                file_info.append((i, path))\n\n            return context, file_info  # file_info is list of (index, path)\n\n        context, file_info = create_llm_context(files_data)\n        # Format file info for the prompt (comment is just a hint for LLM)\n        file_listing_for_prompt = \"\\n\".join(\n            [f\"- {idx} # {path}\" for idx, path in file_info]\n        )\n        return (\n            context,\n            file_listing_for_prompt,\n            len(files_data),\n            project_name,\n            language,\n            use_cache,\n            max_abstraction_num,\n        )  # Return all parameters", "label": 0}
{"function": "async def test_graph_undirected_property(storage):\n    \"\"\"\n    \u4e13\u95e8\u6d4b\u8bd5\u56fe\u5b58\u50a8\u7684\u65e0\u5411\u56fe\u7279\u6027:\n    1. \u9a8c\u8bc1\u63d2\u5165\u4e00\u4e2a\u65b9\u5411\u7684\u8fb9\u540e\uff0c\u53cd\u5411\u67e5\u8be2\u662f\u5426\u80fd\u83b7\u5f97\u76f8\u540c\u7684\u7ed3\u679c\n    2. \u9a8c\u8bc1\u8fb9\u7684\u5c5e\u6027\u5728\u6b63\u5411\u548c\u53cd\u5411\u67e5\u8be2\u4e2d\u662f\u5426\u4e00\u81f4\n    3. \u9a8c\u8bc1\u5220\u9664\u4e00\u4e2a\u65b9\u5411\u7684\u8fb9\u540e\uff0c\u53e6\u4e00\u4e2a\u65b9\u5411\u7684\u8fb9\u662f\u5426\u4e5f\u88ab\u5220\u9664\n    4. \u9a8c\u8bc1\u6279\u91cf\u64cd\u4f5c\u4e2d\u7684\u65e0\u5411\u56fe\u7279\u6027\n    \"\"\"\n    try:\n        # 1. \u63d2\u5165\u6d4b\u8bd5\u6570\u636e\n        # \u63d2\u5165\u8282\u70b91: \u8ba1\u7b97\u673a\u79d1\u5b66\n        node1_id = \"\u8ba1\u7b97\u673a\u79d1\u5b66\"\n        node1_data = {\n            \"entity_id\": node1_id,\n            \"description\": \"\u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u7814\u7a76\u8ba1\u7b97\u673a\u53ca\u5176\u5e94\u7528\u7684\u79d1\u5b66\u3002\",\n            \"keywords\": \"\u8ba1\u7b97\u673a,\u79d1\u5b66,\u6280\u672f\",\n            \"entity_type\": \"\u5b66\u79d1\",\n        }\n        print(f\"\u63d2\u5165\u8282\u70b91: {node1_id}\")\n        await storage.upsert_node(node1_id, node1_data)\n\n        # \u63d2\u5165\u8282\u70b92: \u6570\u636e\u7ed3\u6784\n        node2_id = \"\u6570\u636e\u7ed3\u6784\"\n        node2_data = {\n            \"entity_id\": node2_id,\n            \"description\": \"\u6570\u636e\u7ed3\u6784\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u7684\u4e00\u4e2a\u57fa\u7840\u6982\u5ff5\uff0c\u7528\u4e8e\u7ec4\u7ec7\u548c\u5b58\u50a8\u6570\u636e\u3002\",\n            \"keywords\": \"\u6570\u636e,\u7ed3\u6784,\u7ec4\u7ec7\",\n            \"entity_type\": \"\u6982\u5ff5\",\n        }\n        print(f\"\u63d2\u5165\u8282\u70b92: {node2_id}\")\n        await storage.upsert_node(node2_id, node2_data)\n\n        # \u63d2\u5165\u8282\u70b93: \u7b97\u6cd5\n        node3_id = \"\u7b97\u6cd5\"\n        node3_data = {\n            \"entity_id\": node3_id,\n            \"description\": \"\u7b97\u6cd5\u662f\u89e3\u51b3\u95ee\u9898\u7684\u6b65\u9aa4\u548c\u65b9\u6cd5\u3002\",\n            \"keywords\": \"\u7b97\u6cd5,\u6b65\u9aa4,\u65b9\u6cd5\",\n            \"entity_type\": \"\u6982\u5ff5\",\n        }\n        print(f\"\u63d2\u5165\u8282\u70b93: {node3_id}\")\n        await storage.upsert_node(node3_id, node3_data)\n\n        # 2. \u6d4b\u8bd5\u63d2\u5165\u8fb9\u540e\u7684\u65e0\u5411\u56fe\u7279\u6027\n        print(\"\\n== \u6d4b\u8bd5\u63d2\u5165\u8fb9\u540e\u7684\u65e0\u5411\u56fe\u7279\u6027\")\n\n        # \u63d2\u5165\u8fb91: \u8ba1\u7b97\u673a\u79d1\u5b66 -> \u6570\u636e\u7ed3\u6784\n        edge1_data = {\n            \"relationship\": \"\u5305\u542b\",\n            \"weight\": 1.0,\n            \"description\": \"\u8ba1\u7b97\u673a\u79d1\u5b66\u5305\u542b\u6570\u636e\u7ed3\u6784\u8fd9\u4e2a\u6982\u5ff5\",\n        }\n        print(f\"\u63d2\u5165\u8fb91: {node1_id} -> {node2_id}\")\n        await storage.upsert_edge(node1_id, node2_id, edge1_data)\n\n        # \u9a8c\u8bc1\u6b63\u5411\u67e5\u8be2\n        forward_edge = await storage.get_edge(node1_id, node2_id)\n        print(f\"\u6b63\u5411\u8fb9\u5c5e\u6027: {forward_edge}\")\n        assert forward_edge is not None, f\"\u672a\u80fd\u8bfb\u53d6\u6b63\u5411\u8fb9\u5c5e\u6027: {node1_id} -> {node2_id}\"\n\n        # \u9a8c\u8bc1\u53cd\u5411\u67e5\u8be2\n        reverse_edge = await storage.get_edge(node2_id, node1_id)\n        print(f\"\u53cd\u5411\u8fb9\u5c5e\u6027: {reverse_edge}\")\n        assert reverse_edge is not None, f\"\u672a\u80fd\u8bfb\u53d6\u53cd\u5411\u8fb9\u5c5e\u6027: {node2_id} -> {node1_id}\"\n\n        # \u9a8c\u8bc1\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u5c5e\u6027\u662f\u5426\u4e00\u81f4\n        assert (\n            forward_edge == reverse_edge\n        ), \"\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u5c5e\u6027\u4e0d\u4e00\u81f4\uff0c\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u5931\u8d25\"\n        print(\"\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u6210\u529f\uff1a\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u5c5e\u6027\u4e00\u81f4\")\n\n        # 3. \u6d4b\u8bd5\u8fb9\u7684\u5ea6\u6570\u7684\u65e0\u5411\u56fe\u7279\u6027\n        print(\"\\n== \u6d4b\u8bd5\u8fb9\u7684\u5ea6\u6570\u7684\u65e0\u5411\u56fe\u7279\u6027\")\n\n        # \u63d2\u5165\u8fb92: \u8ba1\u7b97\u673a\u79d1\u5b66 -> \u7b97\u6cd5\n        edge2_data = {\n            \"relationship\": \"\u5305\u542b\",\n            \"weight\": 1.0,\n            \"description\": \"\u8ba1\u7b97\u673a\u79d1\u5b66\u5305\u542b\u7b97\u6cd5\u8fd9\u4e2a\u6982\u5ff5\",\n        }\n        print(f\"\u63d2\u5165\u8fb92: {node1_id} -> {node3_id}\")\n        await storage.upsert_edge(node1_id, node3_id, edge2_data)\n\n        # \u9a8c\u8bc1\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u7684\u5ea6\u6570\n        forward_degree = await storage.edge_degree(node1_id, node2_id)\n        reverse_degree = await storage.edge_degree(node2_id, node1_id)\n        print(f\"\u6b63\u5411\u8fb9 {node1_id} -> {node2_id} \u7684\u5ea6\u6570: {forward_degree}\")\n        print(f\"\u53cd\u5411\u8fb9 {node2_id} -> {node1_id} \u7684\u5ea6\u6570: {reverse_degree}\")\n        assert (\n            forward_degree == reverse_degree\n        ), \"\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u7684\u5ea6\u6570\u4e0d\u4e00\u81f4\uff0c\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u5931\u8d25\"\n        print(\"\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u6210\u529f\uff1a\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u7684\u5ea6\u6570\u4e00\u81f4\")\n\n        # 4. \u6d4b\u8bd5\u5220\u9664\u8fb9\u7684\u65e0\u5411\u56fe\u7279\u6027\n        print(\"\\n== \u6d4b\u8bd5\u5220\u9664\u8fb9\u7684\u65e0\u5411\u56fe\u7279\u6027\")\n\n        # \u5220\u9664\u6b63\u5411\u8fb9\n        print(f\"\u5220\u9664\u8fb9: {node1_id} -> {node2_id}\")\n        await storage.remove_edges([(node1_id, node2_id)])\n\n        # \u9a8c\u8bc1\u6b63\u5411\u8fb9\u662f\u5426\u88ab\u5220\u9664\n        forward_edge = await storage.get_edge(node1_id, node2_id)\n        print(f\"\u5220\u9664\u540e\u67e5\u8be2\u6b63\u5411\u8fb9\u5c5e\u6027 {node1_id} -> {node2_id}: {forward_edge}\")\n        assert forward_edge is None, f\"\u8fb9 {node1_id} -> {node2_id} \u5e94\u5df2\u88ab\u5220\u9664\"\n\n        # \u9a8c\u8bc1\u53cd\u5411\u8fb9\u662f\u5426\u4e5f\u88ab\u5220\u9664\n        reverse_edge = await storage.get_edge(node2_id, node1_id)\n        print(f\"\u5220\u9664\u540e\u67e5\u8be2\u53cd\u5411\u8fb9\u5c5e\u6027 {node2_id} -> {node1_id}: {reverse_edge}\")\n        assert (\n            reverse_edge is None\n        ), f\"\u53cd\u5411\u8fb9 {node2_id} -> {node1_id} \u4e5f\u5e94\u88ab\u5220\u9664\uff0c\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u5931\u8d25\"\n        print(\"\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u6210\u529f\uff1a\u5220\u9664\u4e00\u4e2a\u65b9\u5411\u7684\u8fb9\u540e\uff0c\u53cd\u5411\u8fb9\u4e5f\u88ab\u5220\u9664\")\n\n        # 5. \u6d4b\u8bd5\u6279\u91cf\u64cd\u4f5c\u4e2d\u7684\u65e0\u5411\u56fe\u7279\u6027\n        print(\"\\n== \u6d4b\u8bd5\u6279\u91cf\u64cd\u4f5c\u4e2d\u7684\u65e0\u5411\u56fe\u7279\u6027\")\n\n        # \u91cd\u65b0\u63d2\u5165\u8fb9\n        await storage.upsert_edge(node1_id, node2_id, edge1_data)\n\n        # \u6279\u91cf\u83b7\u53d6\u8fb9\u5c5e\u6027\n        edge_dicts = [\n            {\"src\": node1_id, \"tgt\": node2_id},\n            {\"src\": node1_id, \"tgt\": node3_id},\n        ]\n        reverse_edge_dicts = [\n            {\"src\": node2_id, \"tgt\": node1_id},\n            {\"src\": node3_id, \"tgt\": node1_id},\n        ]\n\n        edges_dict = await storage.get_edges_batch(edge_dicts)\n        reverse_edges_dict = await storage.get_edges_batch(reverse_edge_dicts)\n\n        print(f\"\u6279\u91cf\u83b7\u53d6\u6b63\u5411\u8fb9\u5c5e\u6027\u7ed3\u679c: {edges_dict.keys()}\")\n        print(f\"\u6279\u91cf\u83b7\u53d6\u53cd\u5411\u8fb9\u5c5e\u6027\u7ed3\u679c: {reverse_edges_dict.keys()}\")\n\n        # \u9a8c\u8bc1\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u7684\u5c5e\u6027\u662f\u5426\u4e00\u81f4\n        for (src, tgt), props in edges_dict.items():\n            assert (\n                tgt,\n                src,\n            ) in reverse_edges_dict, f\"\u53cd\u5411\u8fb9 {tgt} -> {src} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n            assert (\n                props == reverse_edges_dict[(tgt, src)]\n            ), f\"\u8fb9 {src} -> {tgt} \u548c\u53cd\u5411\u8fb9 {tgt} -> {src} \u7684\u5c5e\u6027\u4e0d\u4e00\u81f4\"\n\n        print(\"\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u6210\u529f\uff1a\u6279\u91cf\u83b7\u53d6\u7684\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u5c5e\u6027\u4e00\u81f4\")\n\n        # 6. \u6d4b\u8bd5\u6279\u91cf\u83b7\u53d6\u8282\u70b9\u8fb9\u7684\u65e0\u5411\u56fe\u7279\u6027\n        print(\"\\n== \u6d4b\u8bd5\u6279\u91cf\u83b7\u53d6\u8282\u70b9\u8fb9\u7684\u65e0\u5411\u56fe\u7279\u6027\")\n\n        nodes_edges = await storage.get_nodes_edges_batch([node1_id, node2_id])\n        print(f\"\u6279\u91cf\u83b7\u53d6\u8282\u70b9\u8fb9\u7ed3\u679c: {nodes_edges.keys()}\")\n\n        # \u68c0\u67e5\u8282\u70b91\u7684\u8fb9\u662f\u5426\u5305\u542b\u6240\u6709\u76f8\u5173\u7684\u8fb9\uff08\u65e0\u8bba\u65b9\u5411\uff09\n        node1_edges = nodes_edges[node1_id]\n        node2_edges = nodes_edges[node2_id]\n\n        # \u68c0\u67e5\u8282\u70b91\u662f\u5426\u6709\u5230\u8282\u70b92\u548c\u8282\u70b93\u7684\u8fb9\n        has_edge_to_node2 = any(\n            (src == node1_id and tgt == node2_id) for src, tgt in node1_edges\n        )\n        has_edge_to_node3 = any(\n            (src == node1_id and tgt == node3_id) for src, tgt in node1_edges\n        )\n\n        assert has_edge_to_node2, f\"\u8282\u70b9 {node1_id} \u7684\u8fb9\u5217\u8868\u4e2d\u5e94\u5305\u542b\u5230 {node2_id} \u7684\u8fb9\"\n        assert has_edge_to_node3, f\"\u8282\u70b9 {node1_id} \u7684\u8fb9\u5217\u8868\u4e2d\u5e94\u5305\u542b\u5230 {node3_id} \u7684\u8fb9\"\n\n        # \u68c0\u67e5\u8282\u70b92\u662f\u5426\u6709\u5230\u8282\u70b91\u7684\u8fb9\n        has_edge_to_node1 = any(\n            (src == node2_id and tgt == node1_id)\n            or (src == node1_id and tgt == node2_id)\n            for src, tgt in node2_edges\n        )\n        assert (\n            has_edge_to_node1\n        ), f\"\u8282\u70b9 {node2_id} \u7684\u8fb9\u5217\u8868\u4e2d\u5e94\u5305\u542b\u4e0e {node1_id} \u7684\u8fde\u63a5\"\n\n        print(\"\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u6210\u529f\uff1a\u6279\u91cf\u83b7\u53d6\u7684\u8282\u70b9\u8fb9\u5305\u542b\u6240\u6709\u76f8\u5173\u7684\u8fb9\uff08\u65e0\u8bba\u65b9\u5411\uff09\")\n\n        print(\"\\n\u65e0\u5411\u56fe\u7279\u6027\u6d4b\u8bd5\u5b8c\u6210\")\n        return True\n\n    except Exception as e:\n        ASCIIColors.red(f\"\u6d4b\u8bd5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u9519\u8bef: {str(e)}\")\n        return False", "label": 0}
{"function": "\tdef set_EndCreateTime(self,EndCreateTime):\n\t\tself.add_query_param('EndCreateTime',EndCreateTime)", "label": 1}
{"function": "def get_configs_dir() -> Path:\n    return (Path(__file__).parent.parent / \"configs\").resolve()", "label": 0}
{"function": "def test_js_execution(tester: Crawl4AiTester):\n    print(\"\\n=== Testing JS Execution ===\")\n    request = {\n        \"urls\": [\"https://www.nbcnews.com/business\"],\n        \"priority\": 8,\n        \"js_code\": [\n            \"const loadMoreButton = Array.from(document.querySelectorAll('button')).find(button => button.textContent.includes('Load More')); loadMoreButton && loadMoreButton.click();\"\n        ],\n        \"wait_for\": \"article.tease-card:nth-child(10)\",\n        \"crawler_params\": {\"headless\": True},\n    }\n\n    result = tester.submit_and_wait(request)\n    print(f\"JS execution result length: {len(result['result']['markdown'])}\")\n    assert result[\"result\"][\"success\"]", "label": 0}
{"function": "    def setImage(self, image):\n        \"\"\" Records the original image selected by the user, creates a color\n            separation, and enables the invert image checkbox.\n        \"\"\"\n        self.originalImage = image\n        self.createImage()\n        self.invertButton.setEnabled(True)", "label": 1}
{"function": "    def __init__(self, dist):\n        \"\"\"Create and initialize a new Command object.  Most importantly,\n        invokes the 'initialize_options()' method, which is the real\n        initializer and depends on the actual command being\n        instantiated.\n        \"\"\"\n        # late import because of mutual dependence between these classes\n        from distutils.dist import Distribution\n\n        if not isinstance(dist, Distribution):\n            raise TypeError(\"dist must be a Distribution instance\")\n        if self.__class__ is Command:\n            raise RuntimeError(\"Command is an abstract class\")\n\n        self.distribution = dist\n        self.initialize_options()\n\n        # Per-command versions of the global flags, so that the user can\n        # customize Distutils' behaviour command-by-command and let some\n        # commands fall back on the Distribution's behaviour.  None means\n        # \"not defined, check self.distribution's copy\", while 0 or 1 mean\n        # false and true (duh).  Note that this means figuring out the real\n        # value of each flag is a touch complicated -- hence \"self._dry_run\"\n        # will be handled by __getattr__, below.\n        # XXX This needs to be fixed.\n        self._dry_run = None\n\n        # verbose is largely ignored, but needs to be set for\n        # backwards compatibility (I think)?\n        self.verbose = dist.verbose\n\n        # Some commands define a 'self.force' option to ignore file\n        # timestamps, but methods defined *here* assume that\n        # 'self.force' exists for all commands.  So define it here\n        # just to be safe.\n        self.force = None\n\n        # The 'help' flag is just used for command-line parsing, so\n        # none of that complicated bureaucracy is needed.\n        self.help = 0\n\n        # 'finalized' records whether or not 'finalize_options()' has been\n        # called.  'finalize_options()' itself should not pay attention to\n        # this flag: it is the business of 'ensure_finalized()', which\n        # always calls 'finalize_options()', to respect/update it.\n        self.finalized = 0", "label": 1}
{"function": "  def _mean(self):\n    return self.alpha / self.beta", "label": 1}
{"function": "    def show_extended_status_menu(self):\n        from gui.status import get_state_choices\n\n        m = SimpleMenu(self, skinkey = skin.get('%s.MenuSkin'%self.skinkey))\n\n        for status in get_state_choices():\n            statusname, statuslabel = status\n\n            def onclick(item, state=statusname):\n                self.change_state(state)#, change_text = self.status_state == self.GetValue())\n\n            m.AppendItem(SimpleMenuItem([StatusMessage.icon_for(statusname), statuslabel],\n                                        method = onclick))\n\n        if m.GetCount() > 0:\n            m.Display(self.cbutton)", "label": 1}
{"function": "def draw_bounding_boxes_handler(converter: TensorFlowConverter, tf_op: \"tf.Operation\"):\n    raise NotImplementedError(f\"[TensorFlowConverter] {tf_op.type} is not supported yet.\")", "label": 1}
{"function": "    def test_1d_slicing6_npm(self):\n        self.test_1d_slicing6(flags=Noflags)", "label": 1}
{"function": "    def __init__(self, open, high, low, close):\n        pass", "label": 1}
{"function": "def test_asciidocs_examples():\n    fnames = sorted(glob.glob(\"./tests/data/asciidoc/*.asciidoc\"))\n\n    for fname in fnames:\n        print(f\"reading {fname}\")\n\n        bname = os.path.basename(fname)\n        gname = os.path.join(\"./tests/data/groundtruth/docling_v2/\", bname + \".md\")\n\n        doc_backend = _get_backend(Path(fname))\n        doc = doc_backend.convert()\n\n        pred_itdoc = doc._export_to_indented_text(max_text_len=16)\n        print(\"\\n\\n\", pred_itdoc)\n\n        pred_mddoc = doc.export_to_markdown()\n        print(\"\\n\\n\", pred_mddoc)\n\n        if os.path.exists(gname):\n            with open(gname) as fr:\n                fr.read()\n\n            # assert pred_mddoc == true_mddoc, \"pred_mddoc!=true_mddoc for asciidoc\"\n        else:\n            with open(gname, \"w\") as fw:\n                fw.write(pred_mddoc)\n\n            # print(\"\\n\\n\", doc.export_to_markdown())\n\n    assert True", "label": 0}
{"function": "def clear_argv(func):\n    \"\"\"\n    Decorator: Clear sys.argv before calling the decorated function, keeping only the script name. Restore original sys.argv after calling.\n    Used to prevent arguments from being parsed by Hugging Face HfArgumentParser causing ValueError.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        original_argv = sys.argv.copy()\n        sys.argv = [original_argv[0]]  # Keep only script name\n        try:\n            return func(*args, **kwargs)\n        finally:\n            sys.argv = original_argv  # Restore original sys.argv\n\n    return wrapper", "label": 0}
{"function": "def cancel():\n    print(colored(\"[!] Received cancellation request...\", \"yellow\"))\n\n    global GENERATING\n    GENERATING = False\n\n    return jsonify({\"status\": \"success\", \"message\": \"Cancelled video generation.\"})", "label": 0}
{"function": "  def test_get_supported_models(self):\n    for case in test_cases:\n      with self.subTest(f\"{case.name}_short_names\"):\n        result = get_supported_models(case.engine_lists)\n        self._verify_results(case, result)\n\n      with self.subTest(f\"{case.name}_class_names\"):\n        class_name_lists = expand_engine_lists(case.engine_lists)\n        result = get_supported_models(class_name_lists)\n        self._verify_results(case, result)", "label": 0}
{"function": "def text_processing_section():\n    st.header(t(\"b. Translate and Generate Subtitles\"))\n    with st.container(border=True):\n        st.markdown(f\"\"\"\n        <p style='font-size: 20px;'>\n        {t(\"This stage includes the following steps:\")}\n        <p style='font-size: 20px;'>\n            1. {t(\"WhisperX word-level transcription\")}<br>\n            2. {t(\"Sentence segmentation using NLP and LLM\")}<br>\n            3. {t(\"Summarization and multi-step translation\")}<br>\n            4. {t(\"Cutting and aligning long subtitles\")}<br>\n            5. {t(\"Generating timeline and subtitles\")}<br>\n            6. {t(\"Merging subtitles into the video\")}\n        \"\"\", unsafe_allow_html=True)\n\n        if not os.path.exists(SUB_VIDEO):\n            if st.button(t(\"Start Processing Subtitles\"), key=\"text_processing_button\"):\n                process_text()\n                st.rerun()\n        else:\n            if load_key(\"burn_subtitles\"):\n                st.video(SUB_VIDEO)\n            download_subtitle_zip_button(text=t(\"Download All Srt Files\"))\n            \n            if st.button(t(\"Archive to 'history'\"), key=\"cleanup_in_text_processing\"):\n                cleanup()\n                st.rerun()\n            return True", "label": 0}
{"function": "    def has_child(self, child_node_name: str):\n        \"\"\"\n        Check if the node has the child of given name.\n        \"\"\"\n        return child_node_name in [child.name for child in self.children]", "label": 0}
{"function": "        def extract_index(s):\n            return int(index_capture.match(s).groups()[0])", "label": 1}
{"function": "    def group_fetch(self, limit=None):\n        super().set_group_collection(True)\n        return self.fetch(limit)", "label": 1}
{"function": "def simulate_progress(message, duration=1.0, steps=20):\n    print(f\"\\033[94m{message}\\033[0m\")\n    for i in range(steps + 1):\n        time.sleep(duration / steps)\n        progress_bar(i, steps, prefix=\"Progress:\", length=40)", "label": 0}
{"function": "    def kill_process(self):\n        if self.task:\n            self.task.kill()", "label": 0}
{"function": "    def test_inject_network_info(self):\n        self._test_compute_api('inject_network_info', 'cast',\n                instance=self.fake_instance_obj)", "label": 1}
{"function": "  def OverrideRoutingPolicy(self):\n    \"\"\"Override any routing policy that could prevent\n    packets from reaching the rndis interface\n    \"\"\"\n    policies = self._device.RunShellCommand(['ip', 'rule'], check_return=True)\n    if len(policies) > 1 and not 'lookup main' in policies[1]:\n      self._device.RunShellCommand(\n          ['ip', 'rule', 'add', 'prio', '1', 'from', 'all', 'table', 'main'],\n          check_return=True)\n      self._device.RunShellCommand(\n          ['ip', 'route', 'flush', 'cache'], check_return=True)", "label": 1}
{"function": "    def __radd__(self, other):\n        return self + other", "label": 1}
{"function": "    def is_child_left(self, ind):\n        # Check if first child exists\n        return self.child_left(ind) < len(self.array)", "label": 1}
{"function": "    def test_repo_updatessl_interactive(self, shell):\n        \"\"\"\n        Test do_repo_updatessl interactive.\n\n        :param shell:\n        :return:\n        \"\"\"\n        shell.help_repo_rename = MagicMock()\n        shell.client.channel.software.updateRepoSsl = MagicMock()\n        shell.do_repo_list = MagicMock()\n        mprint = MagicMock()\n        logger = MagicMock()\n        prompter = MagicMock(side_effect=[\"name\", \"ca\", \"cert\", \"key\"])\n\n        with patch(\"spacecmd.repo.print\", mprint) as prn, \\\n                patch(\"spacecmd.repo.prompt_user\", prompter) as prn, \\\n                patch(\"spacecmd.repo.logging\", logger) as lgr:\n            out = spacecmd.repo.do_repo_updatessl(shell, \"\")\n\n        assert out is 0\n        assert not mprint.called\n        assert not logger.error.called\n        assert shell.client.channel.software.updateRepoSsl.called\n\n        assert_args_expect(shell.client.channel.software.updateRepoSsl.call_args_list,\n                           [((shell.session, \"name\", \"ca\", \"cert\", \"key\"), {})])", "label": 1}
{"function": "  def testDelegateUploadFileToObjectZipped(self, mock_unlink):\n    mock_stream = mock.Mock()\n    mock_stream.close = mock.Mock()\n    mock_upload_url = mock.Mock()\n    mock_upload_url.object_name = 'Sample'\n\n    def DelegateUpload():\n      return 'a', 'b'\n\n    elapsed_time, uploaded_object = _DelegateUploadFileToObject(\n        DelegateUpload, mock_upload_url, mock_stream, True, False, False, None)\n    # Ensure results are passed through.\n    self.assertEqual(elapsed_time, 'a')\n    self.assertEqual(uploaded_object, 'b')\n    # Ensure the file was unlinked.\n    self.assertTrue(mock_unlink.called)\n    # Ensure close was called.\n    self.assertTrue(mock_stream.close.called)", "label": 1}
{"function": "def test_is_in_or_part_overlap_with_area_ratio(box1: tuple, box2: tuple, target_bool: bool) -> None:\n    out_bool = _is_in_or_part_overlap_with_area_ratio(box1, box2)\n    assert target_bool == out_bool", "label": 0}
{"function": "  def setUp(self):\n    self.addTypeEqualityFunc(uploader.CloudStorageUploader,\n                             uploader.CloudStorageUploader.__eq__)\n    self.setUpPyfakefs()\n\n    self.cs_bucket = 'bucket1'\n    self.cs_base_folder = 'dependencies_folder'\n    self.cs_hash = 'hash12'\n    self.download_path = '../../relative/dep1/path2'\n    self.local_paths = ['../../../relative/local/path21',\n                        '../../../relative/local/path22']\n    self.platform_dict = {'cloud_storage_hash': self.cs_hash,\n                          'download_path': self.download_path,\n                          'local_paths': self.local_paths}\n    self.dependencies = {\n        'dep1': {\n            'cloud_storage_bucket': self.cs_bucket,\n            'cloud_storage_base_folder': self.cs_base_folder,\n            'file_info': {\n                'plat1': {\n                    'cloud_storage_hash': 'hash11',\n                    'download_path': '../../relative/dep1/path1',\n                    'local_paths': ['../../../relative/local/path11',\n                                    '../../../relative/local/path12']},\n                'plat2': self.platform_dict\n            }\n        },\n        'dep2': {\n            'cloud_storage_bucket': 'bucket2',\n            'file_info': {\n                'plat1': {\n                    'cloud_storage_hash': 'hash21',\n                    'download_path': '../../relative/dep2/path1',\n                    'local_paths': ['../../../relative/local/path31',\n                                    '../../../relative/local/path32']},\n                'plat2': {\n                    'cloud_storage_hash': 'hash22',\n                    'download_path': '../../relative/dep2/path2'}}}}\n\n    self.file_path = os.path.abspath(os.path.join(\n        'path', 'to', 'config', 'file'))\n\n\n    self.expected_file_lines = [\n      # pylint: disable=bad-continuation\n      '{', '\"config_type\": \"BaseConfig\",', '\"dependencies\": {',\n        '\"dep1\": {', '\"cloud_storage_base_folder\": \"dependencies_folder\",',\n          '\"cloud_storage_bucket\": \"bucket1\",', '\"file_info\": {',\n            '\"plat1\": {', '\"cloud_storage_hash\": \"hash11\",',\n              '\"download_path\": \"../../relative/dep1/path1\",',\n              '\"local_paths\": [', '\"../../../relative/local/path11\",',\n                              '\"../../../relative/local/path12\"', ']', '},',\n            '\"plat2\": {', '\"cloud_storage_hash\": \"hash12\",',\n              '\"download_path\": \"../../relative/dep1/path2\",',\n              '\"local_paths\": [', '\"../../../relative/local/path21\",',\n                              '\"../../../relative/local/path22\"', ']',\n              '}', '}', '},',\n        '\"dep2\": {', '\"cloud_storage_bucket\": \"bucket2\",', '\"file_info\": {',\n            '\"plat1\": {', '\"cloud_storage_hash\": \"hash21\",',\n              '\"download_path\": \"../../relative/dep2/path1\",',\n              '\"local_paths\": [', '\"../../../relative/local/path31\",',\n                              '\"../../../relative/local/path32\"', ']', '},',\n            '\"plat2\": {', '\"cloud_storage_hash\": \"hash22\",',\n              '\"download_path\": \"../../relative/dep2/path2\"', '}', '}', '}',\n      '}', '}']\n    self.fs.CreateFile(self.file_path,\n                       contents='\\n'.join(self.expected_file_lines))", "label": 1}
{"function": "    def __init__(self):\n        if not getattr(Config, 'ANTHROPIC_API_KEY', None):\n            raise ValueError(\"No ANTHROPIC_API_KEY found in environment variables\")\n\n        # Initialize Anthropics client\n        self.client = anthropic.Anthropic(api_key=Config.ANTHROPIC_API_KEY)\n\n        self.conversation_history: List[Dict[str, Any]] = []\n        self.console = Console()\n\n        self.thinking_enabled = getattr(Config, 'ENABLE_THINKING', False)\n        self.temperature = getattr(Config, 'DEFAULT_TEMPERATURE', 0.7)\n        self.total_tokens_used = 0\n\n        self.tools = self._load_tools()", "label": 0}
{"function": "def build():\n    # Clear screen\n    os.system(\"cls\" if platform.system().lower() == \"windows\" else \"clear\")\n\n    # Print logo\n    print_logo()\n\n    system = platform.system().lower()\n    spec_file = os.path.join(\"CursorKeepAlive.spec\")\n\n    # if system not in [\"darwin\", \"windows\"]:\n    #     print(f\"\\033[91mUnsupported operating system: {system}\\033[0m\")\n    #     return\n\n    output_dir = f\"dist/{system if system != 'darwin' else 'mac'}\"\n\n    # Create output directory\n    os.makedirs(output_dir, exist_ok=True)\n    simulate_progress(\"Creating output directory...\", 0.5)\n\n    # Run PyInstaller with loading animation\n    pyinstaller_command = [\n        \"pyinstaller\",\n        spec_file,\n        \"--distpath\",\n        output_dir,\n        \"--workpath\",\n        f\"build/{system}\",\n        \"--noconfirm\",\n    ]\n\n    loading = LoadingAnimation()\n    try:\n        simulate_progress(\"Running PyInstaller...\", 2.0)\n        loading.start(\"Building in progress\")\n        result = subprocess.run(\n            pyinstaller_command, check=True, capture_output=True, text=True\n        )\n        loading.stop()\n\n        if result.stderr:\n            filtered_errors = [\n                line\n                for line in result.stderr.split(\"\\n\")\n                if any(\n                    keyword in line.lower()\n                    for keyword in [\"error:\", \"failed:\", \"completed\", \"directory:\"]\n                )\n            ]\n            if filtered_errors:\n                print(\"\\033[93mBuild Warnings/Errors:\\033[0m\")\n                print(\"\\n\".join(filtered_errors))\n\n    except subprocess.CalledProcessError as e:\n        loading.stop()\n        print(f\"\\033[91mBuild failed with error code {e.returncode}\\033[0m\")\n        if e.stderr:\n            print(\"\\033[91mError Details:\\033[0m\")\n            print(e.stderr)\n        return\n    except FileNotFoundError:\n        loading.stop()\n        print(\n            \"\\033[91mError: Please ensure PyInstaller is installed (pip install pyinstaller)\\033[0m\"\n        )\n        return\n    except KeyboardInterrupt:\n        loading.stop()\n        print(\"\\n\\033[91mBuild cancelled by user\\033[0m\")\n        return\n    finally:\n        loading.stop()\n\n    # Copy config file\n    if os.path.exists(\"config.ini.example\"):\n        simulate_progress(\"Copying configuration file...\", 0.5)\n        if system == \"windows\":\n            subprocess.run(\n                [\"copy\", \"config.ini.example\", f\"{output_dir}\\\\config.ini\"], shell=True\n            )\n        else:\n            subprocess.run([\"cp\", \"config.ini.example\", f\"{output_dir}/config.ini\"])\n\n    # Copy .env.example file\n    if os.path.exists(\".env.example\"):\n        simulate_progress(\"Copying environment file...\", 0.5)\n        if system == \"windows\":\n            subprocess.run([\"copy\", \".env.example\", f\"{output_dir}\\\\.env\"], shell=True)\n        else:\n            subprocess.run([\"cp\", \".env.example\", f\"{output_dir}/.env\"])\n\n    print(\n        f\"\\n\\033[92mBuild completed successfully! Output directory: {output_dir}\\033[0m\"\n    )", "label": 0}
{"function": "    def _drawHorizontalCorteLine(self):\n        self.html += '<hr />'", "label": 1}
{"function": "    def table_psf_in_energy_band(self, energy_band, spectrum=None, n_bins=11, **kwargs):\n        \"\"\"Average PSF in a given energy band.\n\n        Expected counts in sub energy bands given the given exposure\n        and spectrum are used as weights.\n\n        Parameters\n        ----------\n        energy_band : `~astropy.units.Quantity`\n            Energy band\n        spectrum : `~gammapy.modeling.models.SpectralModel`\n            Spectral model used for weighting the PSF. Default is a power law\n            with index=2.\n        n_bins : int\n            Number of energy points in the energy band, used to compute the\n            weigthed PSF.\n\n        Returns\n        -------\n        psf : `TablePSF`\n            Table PSF\n        \"\"\"\n        from gammapy.modeling.models import PowerLawSpectralModel, TemplateSpectralModel\n\n        if spectrum is None:\n            spectrum = PowerLawSpectralModel()\n\n        exposure = TemplateSpectralModel(self.energy, self.exposure)\n\n        e_min, e_max = energy_band\n        energy = MapAxis.from_energy_bounds(e_min, e_max, n_bins).edges\n\n        weights = spectrum(energy) * exposure(energy)\n        weights /= weights.sum()\n\n        psf_value = self.evaluate(energy=energy)\n        psf_value_weighted = weights[:, np.newaxis] * psf_value\n        return TablePSF(self.rad, psf_value_weighted.sum(axis=0), **kwargs)", "label": 1}
{"function": "def generate_audio(tts_text, mode_checkbox_group, sft_dropdown, prompt_text, prompt_wav_upload, prompt_wav_record, instruct_text,\n                   seed, stream, speed):\n    if prompt_wav_upload is not None:\n        prompt_wav = prompt_wav_upload\n    elif prompt_wav_record is not None:\n        prompt_wav = prompt_wav_record\n    else:\n        prompt_wav = None\n    # if instruct mode, please make sure that model is iic/CosyVoice-300M-Instruct and not cross_lingual mode\n    if mode_checkbox_group in ['\u81ea\u7136\u8bed\u8a00\u63a7\u5236']:\n        if cosyvoice.instruct is False:\n            gr.Warning('\u60a8\u6b63\u5728\u4f7f\u7528\u81ea\u7136\u8bed\u8a00\u63a7\u5236\u6a21\u5f0f, {}\u6a21\u578b\u4e0d\u652f\u6301\u6b64\u6a21\u5f0f, \u8bf7\u4f7f\u7528iic/CosyVoice-300M-Instruct\u6a21\u578b'.format(args.model_dir))\n            yield (cosyvoice.sample_rate, default_data)\n        if instruct_text == '':\n            gr.Warning('\u60a8\u6b63\u5728\u4f7f\u7528\u81ea\u7136\u8bed\u8a00\u63a7\u5236\u6a21\u5f0f, \u8bf7\u8f93\u5165instruct\u6587\u672c')\n            yield (cosyvoice.sample_rate, default_data)\n        if prompt_wav is not None or prompt_text != '':\n            gr.Info('\u60a8\u6b63\u5728\u4f7f\u7528\u81ea\u7136\u8bed\u8a00\u63a7\u5236\u6a21\u5f0f, prompt\u97f3\u9891/prompt\u6587\u672c\u4f1a\u88ab\u5ffd\u7565')\n    # if cross_lingual mode, please make sure that model is iic/CosyVoice-300M and tts_text prompt_text are different language\n    if mode_checkbox_group in ['\u8de8\u8bed\u79cd\u590d\u523b']:\n        if cosyvoice.instruct is True:\n            gr.Warning('\u60a8\u6b63\u5728\u4f7f\u7528\u8de8\u8bed\u79cd\u590d\u523b\u6a21\u5f0f, {}\u6a21\u578b\u4e0d\u652f\u6301\u6b64\u6a21\u5f0f, \u8bf7\u4f7f\u7528iic/CosyVoice-300M\u6a21\u578b'.format(args.model_dir))\n            yield (cosyvoice.sample_rate, default_data)\n        if instruct_text != '':\n            gr.Info('\u60a8\u6b63\u5728\u4f7f\u7528\u8de8\u8bed\u79cd\u590d\u523b\u6a21\u5f0f, instruct\u6587\u672c\u4f1a\u88ab\u5ffd\u7565')\n        if prompt_wav is None:\n            gr.Warning('\u60a8\u6b63\u5728\u4f7f\u7528\u8de8\u8bed\u79cd\u590d\u523b\u6a21\u5f0f, \u8bf7\u63d0\u4f9bprompt\u97f3\u9891')\n            yield (cosyvoice.sample_rate, default_data)\n        gr.Info('\u60a8\u6b63\u5728\u4f7f\u7528\u8de8\u8bed\u79cd\u590d\u523b\u6a21\u5f0f, \u8bf7\u786e\u4fdd\u5408\u6210\u6587\u672c\u548cprompt\u6587\u672c\u4e3a\u4e0d\u540c\u8bed\u8a00')\n    # if in zero_shot cross_lingual, please make sure that prompt_text and prompt_wav meets requirements\n    if mode_checkbox_group in ['3s\u6781\u901f\u590d\u523b', '\u8de8\u8bed\u79cd\u590d\u523b']:\n        if prompt_wav is None:\n            gr.Warning('prompt\u97f3\u9891\u4e3a\u7a7a\uff0c\u60a8\u662f\u5426\u5fd8\u8bb0\u8f93\u5165prompt\u97f3\u9891\uff1f')\n            yield (cosyvoice.sample_rate, default_data)\n        if torchaudio.info(prompt_wav).sample_rate < prompt_sr:\n            gr.Warning('prompt\u97f3\u9891\u91c7\u6837\u7387{}\u4f4e\u4e8e{}'.format(torchaudio.info(prompt_wav).sample_rate, prompt_sr))\n            yield (cosyvoice.sample_rate, default_data)\n    # sft mode only use sft_dropdown\n    if mode_checkbox_group in ['\u9884\u8bad\u7ec3\u97f3\u8272']:\n        if instruct_text != '' or prompt_wav is not None or prompt_text != '':\n            gr.Info('\u60a8\u6b63\u5728\u4f7f\u7528\u9884\u8bad\u7ec3\u97f3\u8272\u6a21\u5f0f\uff0cprompt\u6587\u672c/prompt\u97f3\u9891/instruct\u6587\u672c\u4f1a\u88ab\u5ffd\u7565\uff01')\n        if sft_dropdown == '':\n            gr.Warning('\u6ca1\u6709\u53ef\u7528\u7684\u9884\u8bad\u7ec3\u97f3\u8272\uff01')\n            yield (cosyvoice.sample_rate, default_data)\n    # zero_shot mode only use prompt_wav prompt text\n    if mode_checkbox_group in ['3s\u6781\u901f\u590d\u523b']:\n        if prompt_text == '':\n            gr.Warning('prompt\u6587\u672c\u4e3a\u7a7a\uff0c\u60a8\u662f\u5426\u5fd8\u8bb0\u8f93\u5165prompt\u6587\u672c\uff1f')\n            yield (cosyvoice.sample_rate, default_data)\n        if instruct_text != '':\n            gr.Info('\u60a8\u6b63\u5728\u4f7f\u75283s\u6781\u901f\u590d\u523b\u6a21\u5f0f\uff0c\u9884\u8bad\u7ec3\u97f3\u8272/instruct\u6587\u672c\u4f1a\u88ab\u5ffd\u7565\uff01')\n\n    if mode_checkbox_group == '\u9884\u8bad\u7ec3\u97f3\u8272':\n        logging.info('get sft inference request')\n        set_all_random_seed(seed)\n        for i in cosyvoice.inference_sft(tts_text, sft_dropdown, stream=stream, speed=speed):\n            yield (cosyvoice.sample_rate, i['tts_speech'].numpy().flatten())\n    elif mode_checkbox_group == '3s\u6781\u901f\u590d\u523b':\n        logging.info('get zero_shot inference request')\n        prompt_speech_16k = postprocess(load_wav(prompt_wav, prompt_sr))\n        set_all_random_seed(seed)\n        for i in cosyvoice.inference_zero_shot(tts_text, prompt_text, prompt_speech_16k, stream=stream, speed=speed):\n            yield (cosyvoice.sample_rate, i['tts_speech'].numpy().flatten())\n    elif mode_checkbox_group == '\u8de8\u8bed\u79cd\u590d\u523b':\n        logging.info('get cross_lingual inference request')\n        prompt_speech_16k = postprocess(load_wav(prompt_wav, prompt_sr))\n        set_all_random_seed(seed)\n        for i in cosyvoice.inference_cross_lingual(tts_text, prompt_speech_16k, stream=stream, speed=speed):\n            yield (cosyvoice.sample_rate, i['tts_speech'].numpy().flatten())\n    else:\n        logging.info('get instruct inference request')\n        set_all_random_seed(seed)\n        for i in cosyvoice.inference_instruct(tts_text, sft_dropdown, instruct_text, stream=stream, speed=speed):\n            yield (cosyvoice.sample_rate, i['tts_speech'].numpy().flatten())", "label": 0}
{"function": "    def set_user_mapping_level(username: str, level: str) -> User:\n        \"\"\"\n        Sets the users mapping level\n        :raises: UserServiceError\n        \"\"\"\n        try:\n            requested_level = MappingLevel[level.upper()]\n        except KeyError:\n            raise UserServiceError(\n                f\"Unknown role {level} accepted values are BEGINNER, INTERMEDIATE, ADVANCED\"\n            )\n\n        user = UserService.get_user_by_username(username)\n        user.set_mapping_level(requested_level)\n\n        return user", "label": 1}
{"function": "def test__xla_dist_model_create_from_context_in_child_proc(xmp_executor):\n    n = int(os.environ[\"NUM_TPU_WORKERS\"])\n    xmp_executor(_test__xla_dist_model_create_from_context_in_child_proc, args=(), nprocs=n)", "label": 1}
{"function": "    def to_dict(self):\n        raw_retrieved_info = [info.to_dict() for info in self.raw_retrieved_info]\n        return {\n            \"utterance\": self.utterance,\n            \"raw_utterance\": self.raw_utterance,\n            \"role\": self.role,\n            \"role_description\": self.role_description,\n            \"queries\": self.queries,\n            \"utterance_type\": self.utterance_type,\n            \"claim_to_make\": self.claim_to_make,\n            \"raw_retrieved_info\": raw_retrieved_info,\n            \"cited_info\": None,\n        }", "label": 0}
{"function": "    def fileno(self) -> int: ...", "label": 1}
{"function": "def _ReshapeToInput(op, grad):\n  \"\"\"Reshapes the gradient to the shape of the original input.\"\"\"\n  return array_ops.reshape(grad, array_ops.shape(op.inputs[0]))", "label": 1}
{"function": "  async def _run_async_impl(self, invocation_context):\n    yield Event(\n        invocation_id=invocation_context.invocation_id,\n        author=self.name,\n        content=types.Content(\n            role=\"model\", parts=[types.Part(text=\"Test LLM response\")]\n        ),\n    )", "label": 0}
{"function": "async def status(uid: str):\n    save_file_path = os.path.join(SAVE_DIR, f'{uid}.glb')\n    print(save_file_path, os.path.exists(save_file_path))\n    if not os.path.exists(save_file_path):\n        response = {'status': 'processing'}\n        return JSONResponse(response, status_code=200)\n    else:\n        base64_str = base64.b64encode(open(save_file_path, 'rb').read()).decode()\n        response = {'status': 'completed', 'model_base64': base64_str}\n        return JSONResponse(response, status_code=200)", "label": 0}
{"function": "    def __init__(self, plotly_name=\"hoverinfo\", parent_name=\"sankey.node\", **kwargs):\n        super(HoverinfoValidator, self).__init__(\n            plotly_name=plotly_name,\n            parent_name=parent_name,\n            edit_type=kwargs.pop(\"edit_type\", \"calc\"),\n            role=kwargs.pop(\"role\", \"info\"),\n            values=kwargs.pop(\"values\", [\"all\", \"none\", \"skip\"]),\n            **kwargs\n        )", "label": 1}
{"function": "def run_tests(provider, keyword=None):\n    \"\"\"Run pytest for a specific provider and save results\"\"\"\n    print(f\"Running tests for provider: {provider}\")\n\n    timestamp = int(time.time())\n    # Use a constant filename for the final result and temp file\n    result_file = RESULTS_DIR / f\"{provider}.json\"\n    temp_json_file = RESULTS_DIR / f\"temp_{provider}.json\"\n\n    # Determine project root directory relative to this script\n    project_root = Path(__file__).parent.parent.parent\n\n    # Run pytest with JSON output\n    cmd = [\n        \"python\",\n        \"-m\",\n        \"pytest\",\n        \"tests/verifications/openai_api/test_chat_completion.py\",\n        f\"--provider={provider}\",\n        \"-v\",\n        \"--json-report\",\n        f\"--json-report-file={temp_json_file}\",\n    ]\n\n    # Append -k argument if provided\n    if keyword:\n        cmd.extend([\"-k\", keyword])\n\n    try:\n        # Run subprocess with cwd set to project root\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=project_root)\n        print(f\"Pytest exit code: {result.returncode}\")\n\n        # Check if the JSON file was created\n        if temp_json_file.exists():\n            with open(temp_json_file) as f:\n                test_results = json.load(f)\n\n            test_results[\"run_timestamp\"] = timestamp\n\n            # Save results to the final (overwritten) file\n            with open(result_file, \"w\") as f:\n                json.dump(test_results, f, indent=2)\n                f.write(\"\\n\")  # Add a trailing newline for precommit\n\n            # Clean up temp file\n            temp_json_file.unlink()\n\n            print(f\"Test results saved to {result_file}\")\n            return result_file\n        else:\n            print(f\"Error: JSON report file not created for {provider}\")\n            print(f\"Command stdout: {result.stdout}\")\n            print(f\"Command stderr: {result.stderr}\")\n            return None\n    except Exception as e:\n        print(f\"Error running tests for {provider}: {e}\")\n        return None", "label": 0}
{"function": "\tdef get_OwnerAccount(self):\n\t\treturn self.get_query_params().get('OwnerAccount')", "label": 1}
{"function": "def init_model(lm_config):\n    tokenizer = AutoTokenizer.from_pretrained('../model')\n    model = MiniMindForCausalLM(lm_config)\n    moe_path = '_moe' if lm_config.use_moe else ''\n    ckp = f'{args.save_dir}/rlhf_{lm_config.hidden_size}{moe_path}.pth'\n    state_dict = torch.load(ckp, map_location=args.device)\n    model.load_state_dict(state_dict, strict=False)\n    Logger(f'LLM\u603b\u53c2\u6570\u91cf\uff1a{sum(p.numel() for p in model.parameters() if p.requires_grad) / 1e6:.3f} \u767e\u4e07')\n    model = model.to(args.device)\n    return model, tokenizer", "label": 0}
{"function": "    def label(self):\n        if len(self.metapartitions) > 1:\n            raise AttributeError(\n                \"Accessing `label` attribute is not allowed while nested\"\n            )\n        assert isinstance(self.metapartitions[0], dict), self.metapartitions[0]\n        return self.metapartitions[0][\"label\"]", "label": 1}
{"function": "    def exec(self, prep_res):\n        if prep_res[\"repo_url\"]:\n            print(f\"Crawling repository: {prep_res['repo_url']}...\")\n            result = crawl_github_files(\n                repo_url=prep_res[\"repo_url\"],\n                token=prep_res[\"token\"],\n                include_patterns=prep_res[\"include_patterns\"],\n                exclude_patterns=prep_res[\"exclude_patterns\"],\n                max_file_size=prep_res[\"max_file_size\"],\n                use_relative_paths=prep_res[\"use_relative_paths\"],\n            )\n        else:\n            print(f\"Crawling directory: {prep_res['local_dir']}...\")\n\n            result = crawl_local_files(\n                directory=prep_res[\"local_dir\"],\n                include_patterns=prep_res[\"include_patterns\"],\n                exclude_patterns=prep_res[\"exclude_patterns\"],\n                max_file_size=prep_res[\"max_file_size\"],\n                use_relative_paths=prep_res[\"use_relative_paths\"]\n            )\n\n        # Convert dict to list of tuples: [(path, content), ...]\n        files_list = list(result.get(\"files\", {}).items())\n        if len(files_list) == 0:\n            raise (ValueError(\"Failed to fetch files\"))\n        print(f\"Fetched {len(files_list)} files.\")\n        return files_list", "label": 0}
{"function": "async def send_request(round_, files):\n    print(len(files))\n    url = 'http://0.0.0.0:8777/api/local_doc_qa/upload_files'\n    data = aiohttp.FormData()\n    data.add_field('user_id', 'default')\n    data.add_field('kb_id', kb_id)\n    data.add_field('mode', 'soft')\n\n    total_size = 0\n    for file_path in files:\n        # print(file_path)\n        file_size = os.path.getsize(file_path)\n        total_size += file_size\n        data.add_field('files', open(file_path, 'rb'))\n    print('size:', total_size / (1024 * 1024))\n    for _ in range(1):\n        try:\n            start_time = time.time()\n            async with aiohttp.ClientSession(timeout=timeout) as session:\n                async with session.post(url, data=data) as response:\n                    end_time = time.time()\n                    response_times.append(end_time - start_time)\n                    print(f\"round_:{round_}, \u54cd\u5e94\u72b6\u6001\u7801: {response.status}, \u54cd\u5e94\u65f6\u95f4: {end_time - start_time}\u79d2\")\n                    if response.status != 200:\n                        continue\n        except Exception as e:\n            print(f\"\u8bf7\u6c42\u53d1\u9001\u5931\u8d25: {e}\")", "label": 0}
{"function": "def str2size(s, scale=1024):\n    \"\"\"Convert size-string.\n\n    String format: <value>[:space:]<B | K | M | ...> to bytes.\n\n    :param s: size-string\n    :param scale: base size\n    \"\"\"\n    if not s:\n        return 0\n\n    if isinstance(s, six.integer_types):\n        return s\n\n    match = re.match(r'^([\\.\\d]+)\\s*([BbKkMmGgTtPpEeZzYy]?)', s)\n    if match is None:\n        raise ValueError(_('Invalid value: %(value)s')\n                         % {'value': s})\n\n    groups = match.groups()\n    value = float(groups[0])\n    suffix = groups[1].upper() if groups[1] else 'B'\n\n    types = ('B', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')\n    for i, t in enumerate(types):\n        if suffix == t:\n            return int(value * pow(scale, i))", "label": 1}
{"function": "\tdef get_descendants(self, path=''):\n\t\t\"\"\" Return an iterator over Row-contexts that are in the descendance\n\t\tof the context pointed to by `path`. The iterator is agnostic of\n\t\tvisibility and the contexts are sorted by their path. The first\n\t\telement of the iterator is the given context itself. \"\"\"\n\t\tc = self.connection.cursor()\n\t\tc.execute(\"\"\"\n\t\t\tSELECT c.*, COUNT(own.id) as own_tasks, (\n\t\t\t\tSELECT COUNT(t.id)\n\t\t\t\tFROM Context c1\n\t\t\t\tLEFT JOIN Task t\n\t\t\t\t  ON t.context = c1.id\n\t\t\t\t AND t.start <= (datetime('now'))\n\t\t\t\t AND t.done IS NULL\n\t\t\t\tWHERE c1.path LIKE c.path||'%' \n\t\t\t) as total_tasks\n\t\t\tFROM Context c\n\t\t\tLEFT JOIN Task own\n\t\t\t  ON own.context = c.id\n\t\t\t AND own.start <= (datetime('now'))\n\t\t\t AND own.done IS NULL\n\t\t\tWHERE path LIKE ?\n\t\t\tGROUP BY c.id\n\t\t\tORDER BY\n\t\t\t  c.path\n\t\t\"\"\", ('{}%'.format(path),))\n\t\treturn c", "label": 1}
{"function": "        def add_pricing_fields(form, formforform):\n            # include pricing options if any\n            if (formforform.custom_payment or formforform.recurring_payment) and formforform.pricing_set.all():\n\n                #currency_symbol = get_setting('site', 'global', 'currencysymbol')\n\n                pricing_options = []\n                for pricing in formforform.pricing_set.all():\n\n                    if pricing.price is None:\n                        pricing_options.append(\n                            (pricing.pk, mark_safe(\n                                '<input type=\"text\" class=\"custom-price\" name=\"custom_price_%s\" value=\"%s\"/> <strong>%s</strong><br>%s' %\n                                (pricing.pk, form.data.get('custom_price_%s' %pricing.pk, str()), pricing.label, pricing.description)))\n                        )\n                    else:\n                        if formforform.recurring_payment:\n                            pricing_options.append(\n                                (pricing.pk, mark_safe('<strong>%s per %s %s - %s</strong><br>%s' %\n                                                        (tcurrency(pricing.price),\n                                                         pricing.billing_frequency, pricing.billing_period,\n                                                         pricing.label, pricing.description)))\n                            )\n                        else:\n                            pricing_options.append(\n                                (pricing.pk, mark_safe('<strong>%s %s</strong><br>%s' %\n                                                       (tcurrency(pricing.price),\n                                                        pricing.label, pricing.description)))\n                            )\n\n                form.fields['pricing_option'] = forms.ChoiceField(\n                    label=formforform.pricing_name or _('Pricing'),\n                    choices = pricing_options,\n                    widget=forms.RadioSelect(attrs={'class': 'pricing-field'})\n                )\n\n                form.fields['payment_option'] = forms.ModelChoiceField(\n                        label=_('Payment Method'),\n                        empty_label=None,\n                        queryset=formforform.payment_methods.all(),\n                        widget=forms.RadioSelect(attrs={'class': 'payment-field'}),\n                        initial=1,\n                    )", "label": 1}
{"function": "  def testDelegateUploadFileToObjectGzipEncoded(self, mock_lock):\n    mock_stream = mock.Mock()\n    mock_stream.close = mock.Mock()\n\n    def DelegateUpload():\n      # Ensure the lock was aquired before the delegate was called.\n      self.assertTrue(mock_lock.__enter__.called)\n      return 'a', 'b'\n\n    elapsed_time, uploaded_object = _DelegateUploadFileToObject(\n        DelegateUpload, 'url', mock_stream, False, True, False, None)\n    # Ensure results are passed through.\n    self.assertEqual(elapsed_time, 'a')\n    self.assertEqual(uploaded_object, 'b')\n    # Ensure close was called.\n    self.assertTrue(mock_stream.close.called)\n    # Ensure the lock was released.\n    self.assertTrue(mock_lock.__exit__.called)", "label": 1}
{"function": "    def get_current_charlen(self):\n        return self._mCurrentCharLen", "label": 1}
{"function": "def get_prompt_datas(args):\n    if args.model_mode == 0:\n        # pretrain\u6a21\u578b\u7684\u63a5\u9f99\u80fd\u529b\uff08\u65e0\u6cd5\u5bf9\u8bdd\uff09\n        prompt_datas = [\n            '\u9a6c\u514b\u601d\u4e3b\u4e49\u57fa\u672c\u539f\u7406',\n            '\u4eba\u7c7b\u5927\u8111\u7684\u4e3b\u8981\u529f\u80fd',\n            '\u4e07\u6709\u5f15\u529b\u539f\u7406\u662f',\n            '\u4e16\u754c\u4e0a\u6700\u9ad8\u7684\u5c71\u5cf0\u662f',\n            '\u4e8c\u6c27\u5316\u78b3\u5728\u7a7a\u6c14\u4e2d',\n            '\u5730\u7403\u4e0a\u6700\u5927\u7684\u52a8\u7269\u6709',\n            '\u676d\u5dde\u5e02\u7684\u7f8e\u98df\u6709'\n        ]\n    else:\n        if args.lora_name == 'None':\n            # \u901a\u7528\u5bf9\u8bdd\u95ee\u9898\n            prompt_datas = [\n                '\u8bf7\u4ecb\u7ecd\u4e00\u4e0b\u81ea\u5df1\u3002',\n                '\u4f60\u66f4\u64c5\u957f\u54ea\u4e00\u4e2a\u5b66\u79d1\uff1f',\n                '\u9c81\u8fc5\u7684\u300a\u72c2\u4eba\u65e5\u8bb0\u300b\u662f\u5982\u4f55\u6279\u5224\u5c01\u5efa\u793c\u6559\u7684\uff1f',\n                '\u6211\u54b3\u55fd\u5df2\u7ecf\u6301\u7eed\u4e86\u4e24\u5468\uff0c\u9700\u8981\u53bb\u533b\u9662\u68c0\u67e5\u5417\uff1f',\n                '\u8be6\u7ec6\u7684\u4ecb\u7ecd\u5149\u901f\u7684\u7269\u7406\u6982\u5ff5\u3002',\n                '\u63a8\u8350\u4e00\u4e9b\u676d\u5dde\u7684\u7279\u8272\u7f8e\u98df\u5427\u3002',\n                '\u8bf7\u4e3a\u6211\u8bb2\u89e3\u201c\u5927\u8bed\u8a00\u6a21\u578b\u201d\u8fd9\u4e2a\u6982\u5ff5\u3002',\n                '\u5982\u4f55\u7406\u89e3ChatGPT\uff1f',\n                'Introduce the history of the United States, please.'\n            ]\n        else:\n            # \u7279\u5b9a\u9886\u57df\u95ee\u9898\n            lora_prompt_datas = {\n                'lora_identity': [\n                    \"\u4f60\u662fChatGPT\u5427\u3002\",\n                    \"\u4f60\u53eb\u4ec0\u4e48\u540d\u5b57\uff1f\",\n                    \"\u4f60\u548copenai\u662f\u4ec0\u4e48\u5173\u7cfb\uff1f\"\n                ],\n                'lora_medical': [\n                    '\u6211\u6700\u8fd1\u7ecf\u5e38\u611f\u5230\u5934\u6655\uff0c\u53ef\u80fd\u662f\u4ec0\u4e48\u539f\u56e0\uff1f',\n                    '\u6211\u54b3\u55fd\u5df2\u7ecf\u6301\u7eed\u4e86\u4e24\u5468\uff0c\u9700\u8981\u53bb\u533b\u9662\u68c0\u67e5\u5417\uff1f',\n                    '\u670d\u7528\u6297\u751f\u7d20\u65f6\u9700\u8981\u6ce8\u610f\u54ea\u4e9b\u4e8b\u9879\uff1f',\n                    '\u4f53\u68c0\u62a5\u544a\u4e2d\u663e\u793a\u80c6\u56fa\u9187\u504f\u9ad8\uff0c\u6211\u8be5\u600e\u4e48\u529e\uff1f',\n                    '\u5b55\u5987\u5728\u996e\u98df\u4e0a\u9700\u8981\u6ce8\u610f\u4ec0\u4e48\uff1f',\n                    '\u8001\u5e74\u4eba\u5982\u4f55\u9884\u9632\u9aa8\u8d28\u758f\u677e\uff1f',\n                    '\u6211\u6700\u8fd1\u603b\u662f\u611f\u5230\u7126\u8651\uff0c\u5e94\u8be5\u600e\u4e48\u7f13\u89e3\uff1f',\n                    '\u5982\u679c\u6709\u4eba\u7a81\u7136\u6655\u5012\uff0c\u5e94\u8be5\u5982\u4f55\u6025\u6551\uff1f'\n                ],\n            }\n            prompt_datas = lora_prompt_datas[args.lora_name]\n\n    return prompt_datas", "label": 0}
{"function": "            def get_keys_from_config(cfg_key):\n                api_keys = config.app.get(cfg_key, [])\n                if isinstance(api_keys, str):\n                    api_keys = [api_keys]\n                api_key = \", \".join(api_keys)\n                return api_key", "label": 0}
{"function": "    def forward(self, x):\n        hx = x\n\n        hxin = self.rebnconvin(hx)\n\n        hx1 = self.rebnconv1(hxin)\n        hx = self.pool1(hx1)\n\n        hx2 = self.rebnconv2(hx)\n        hx = self.pool2(hx2)\n\n        hx3 = self.rebnconv3(hx)\n        hx = self.pool3(hx3)\n\n        hx4 = self.rebnconv4(hx)\n\n        hx5 = self.rebnconv5(hx4)\n\n        hx4d = self.rebnconv4d(torch.cat((hx5, hx4), 1))\n        hx4dup = _upsample_like(hx4d, hx3)\n\n        hx3d = self.rebnconv3d(torch.cat((hx4dup, hx3), 1))\n        hx3dup = _upsample_like(hx3d, hx2)\n\n        hx2d = self.rebnconv2d(torch.cat((hx3dup, hx2), 1))\n        hx2dup = _upsample_like(hx2d, hx1)\n\n        hx1d = self.rebnconv1d(torch.cat((hx2dup, hx1), 1))\n\n        return hx1d + hxin", "label": 0}
{"function": "async def test_excluded_types_parameter_validation_in_add_episode():\n    \"\"\"Test that add_episode validates excluded_entity_types parameter.\"\"\"\n    graphiti = Graphiti(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD)\n\n    try:\n        entity_types = {\n            'Person': Person,\n        }\n\n        # Should raise ValueError for invalid excluded type\n        with pytest.raises(ValueError, match='Invalid excluded entity types'):\n            await graphiti.add_episode(\n                name='Invalid Test',\n                episode_body='Test content',\n                source_description='Test',\n                reference_time=datetime.now(timezone.utc),\n                entity_types=entity_types,\n                excluded_entity_types=['NonExistentType'],\n                group_id='test_validation',\n            )\n\n    finally:\n        await graphiti.close()", "label": 0}
{"function": "    def __init__(self):\n        pass", "label": 1}
{"function": "    def evaluate(self, context):\n        \"\"\"Evaluates the value of the platform parameter in the given context.\n        The value of first matched rule is returned as the result.\n\n        Args:\n            context: EvaluationContext. The context for evaluation.\n\n        Returns:\n            *. The evaluate result of the platform parameter.\n        \"\"\"\n        for rule in self._rules:\n            if rule.evaluate(context):\n                return rule.value_when_matched\n        return self._default_value", "label": 1}
{"function": "    def test_add_participant_not_owner(self):\n        \"\"\"non-owner can't add participant\"\"\"\n        ThreadParticipant.objects.add_participants(self.thread, [self.user])\n\n        response = self.patch(\n            self.api_link,\n            [{\"op\": \"add\", \"path\": \"participants\", \"value\": self.user.username}],\n        )\n        self.assertEqual(response.status_code, 400)\n        self.assertEqual(\n            response.json(),\n            {\n                \"id\": self.thread.pk,\n                \"detail\": [\n                    \"You have to be thread owner to add new participants to it.\"\n                ],\n            },\n        )", "label": 1}
{"function": "    def register(self, fileobj: _FileObject, events: _EventMask, data: Any = ...) -> SelectorKey: ...", "label": 1}
{"function": "def preprocess_images(images: List[Tuple[Image.Image, str]]) -> List[Image.Image]:\n    \"\"\"\n    Preprocess a list of input images.\n    \n    Args:\n        images (List[Tuple[Image.Image, str]]): The input images.\n        \n    Returns:\n        List[Image.Image]: The preprocessed images.\n    \"\"\"\n    images = [image[0] for image in images]\n    processed_images = [pipeline.preprocess_image(image) for image in images]\n    return processed_images", "label": 0}
{"function": "    def __init__(self, high, low, close):\n        pass", "label": 1}
{"function": "    def test_vocabularies_are_initialized_even_with_empty_corpora(self):\n        parallel_corpora = []\n\n        ibm_model = IBMModel(parallel_corpora)\n        self.assertEqual(len(ibm_model.src_vocab), 1)  # addition of NULL token\n        self.assertEqual(len(ibm_model.trg_vocab), 0)", "label": 1}
{"function": "  def _verify_results(self, case, result):\n    if case.expected_models_contains:\n      for model in case.expected_models_contains:\n        self.assertIn(model, result)\n\n    if case.min_count:\n      self.assertGreater(len(result), case.min_count)\n\n    if case.exact_count is not None:\n      self.assertEqual(len(result), case.exact_count)\n\n    # Special case for distinct lists test\n    if case.name == \"distinct_engine_lists\":\n      self.assertLess(len(result), 15)\n      self.assertNotIn(\"mistral-nemo\", result)\n\n    if case.max_count:\n      self.assertLess(len(result), case.max_count)", "label": 0}
{"function": "def test_request_with_basic_auth():\n    \"\"\"Test a request with basic authentication.\"\"\"\n    request = RequestModel(\n        name=\"Request with basic auth\",\n        method=\"GET\",\n        url=\"https://example.com/api/secure\",\n        auth=Auth.basic_auth(\"username\", \"password\"),\n    )\n\n    expected = (\n        \"curl \\\\\\n  -u 'username:password' \\\\\\n  'https://example.com/api/secure'\"\n    )\n    assert request.to_curl() == expected", "label": 0}
{"function": "async def run_all_searches(query: str, sv: SessionVariables) -> list[SearchResult]:\n    \"\"\"Run all search engines and return the results.\"\"\"\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n    tasks = []\n    if sv.include_drift_search.value:\n        tasks.append(\n            run_drift_search(\n                query=query,\n                sv=sv,\n            )\n        )\n\n    if sv.include_basic_rag.value:\n        tasks.append(\n            run_basic_search(\n                query=query,\n                sv=sv,\n            )\n        )\n    if sv.include_local_search.value:\n        tasks.append(\n            run_local_search(\n                query=query,\n                sv=sv,\n            )\n        )\n    if sv.include_global_search.value:\n        tasks.append(\n            run_global_search(\n                query=query,\n                sv=sv,\n            )\n        )\n\n    return await asyncio.gather(*tasks)", "label": 0}
{"function": "    def test_get_found(self):\n        \"\"\"Test retrieving a value that exists and has not expired.\"\"\"\n        cache = TimedCache(datetime.timedelta(seconds=10))\n        key, value = \"test_key\", \"test_value\"\n\n        # Set a future expiration time\n        future = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(\n            seconds=30\n        )\n        cache.cache[key] = (value, future)\n\n        # The value should be returned\n        assert cache.get(key) == value", "label": 0}
{"function": "def generate(args):\n    rank = int(os.getenv(\"RANK\", 0))\n    world_size = int(os.getenv(\"WORLD_SIZE\", 1))\n    local_rank = int(os.getenv(\"LOCAL_RANK\", 0))\n    device = local_rank\n    _init_logging(rank)\n\n    if args.offload_model is None:\n        args.offload_model = False if world_size > 1 else True\n        logging.info(\n            f\"offload_model is not specified, set to {args.offload_model}.\")\n    if world_size > 1:\n        torch.cuda.set_device(local_rank)\n        dist.init_process_group(\n            backend=\"nccl\",\n            init_method=\"env://\",\n            rank=rank,\n            world_size=world_size)\n    else:\n        assert not (\n            args.t5_fsdp or args.dit_fsdp\n        ), f\"t5_fsdp and dit_fsdp are not supported in non-distributed environments.\"\n        assert not (\n            args.ulysses_size > 1 or args.ring_size > 1\n        ), f\"context parallel are not supported in non-distributed environments.\"\n\n    if args.ulysses_size > 1 or args.ring_size > 1:\n        assert args.ulysses_size * args.ring_size == world_size, f\"The number of ulysses_size and ring_size should be equal to the world size.\"\n        from xfuser.core.distributed import (\n            init_distributed_environment,\n            initialize_model_parallel,\n        )\n        init_distributed_environment(\n            rank=dist.get_rank(), world_size=dist.get_world_size())\n\n        initialize_model_parallel(\n            sequence_parallel_degree=dist.get_world_size(),\n            ring_degree=args.ring_size,\n            ulysses_degree=args.ulysses_size,\n        )\n\n    if args.use_prompt_extend:\n        if args.prompt_extend_method == \"dashscope\":\n            prompt_expander = DashScopePromptExpander(\n                model_name=args.prompt_extend_model,\n                is_vl=\"i2v\" in args.task or \"flf2v\" in args.task)\n        elif args.prompt_extend_method == \"local_qwen\":\n            prompt_expander = QwenPromptExpander(\n                model_name=args.prompt_extend_model,\n                is_vl=\"i2v\" in args.task,\n                device=rank)\n        else:\n            raise NotImplementedError(\n                f\"Unsupport prompt_extend_method: {args.prompt_extend_method}\")\n\n    cfg = WAN_CONFIGS[args.task]\n    if args.ulysses_size > 1:\n        assert cfg.num_heads % args.ulysses_size == 0, f\"`{cfg.num_heads=}` cannot be divided evenly by `{args.ulysses_size=}`.\"\n\n    logging.info(f\"Generation job args: {args}\")\n    logging.info(f\"Generation model config: {cfg}\")\n\n    if dist.is_initialized():\n        base_seed = [args.base_seed] if rank == 0 else [None]\n        dist.broadcast_object_list(base_seed, src=0)\n        args.base_seed = base_seed[0]\n\n    if \"t2v\" in args.task or \"t2i\" in args.task:\n        if args.prompt is None:\n            args.prompt = EXAMPLE_PROMPT[args.task][\"prompt\"]\n        logging.info(f\"Input prompt: {args.prompt}\")\n        if args.use_prompt_extend:\n            logging.info(\"Extending prompt ...\")\n            if rank == 0:\n                prompt_output = prompt_expander(\n                    args.prompt,\n                    tar_lang=args.prompt_extend_target_lang,\n                    seed=args.base_seed)\n                if prompt_output.status == False:\n                    logging.info(\n                        f\"Extending prompt failed: {prompt_output.message}\")\n                    logging.info(\"Falling back to original prompt.\")\n                    input_prompt = args.prompt\n                else:\n                    input_prompt = prompt_output.prompt\n                input_prompt = [input_prompt]\n            else:\n                input_prompt = [None]\n            if dist.is_initialized():\n                dist.broadcast_object_list(input_prompt, src=0)\n            args.prompt = input_prompt[0]\n            logging.info(f\"Extended prompt: {args.prompt}\")\n\n        logging.info(\"Creating WanT2V pipeline.\")\n        wan_t2v = wan.WanT2V(\n            config=cfg,\n            checkpoint_dir=args.ckpt_dir,\n            device_id=device,\n            rank=rank,\n            t5_fsdp=args.t5_fsdp,\n            dit_fsdp=args.dit_fsdp,\n            use_usp=(args.ulysses_size > 1 or args.ring_size > 1),\n            t5_cpu=args.t5_cpu,\n        )\n\n        logging.info(\n            f\"Generating {'image' if 't2i' in args.task else 'video'} ...\")\n        video = wan_t2v.generate(\n            args.prompt,\n            size=SIZE_CONFIGS[args.size],\n            frame_num=args.frame_num,\n            shift=args.sample_shift,\n            sample_solver=args.sample_solver,\n            sampling_steps=args.sample_steps,\n            guide_scale=args.sample_guide_scale,\n            seed=args.base_seed,\n            offload_model=args.offload_model)\n\n    elif \"i2v\" in args.task:\n        if args.prompt is None:\n            args.prompt = EXAMPLE_PROMPT[args.task][\"prompt\"]\n        if args.image is None:\n            args.image = EXAMPLE_PROMPT[args.task][\"image\"]\n        logging.info(f\"Input prompt: {args.prompt}\")\n        logging.info(f\"Input image: {args.image}\")\n\n        img = Image.open(args.image).convert(\"RGB\")\n        if args.use_prompt_extend:\n            logging.info(\"Extending prompt ...\")\n            if rank == 0:\n                prompt_output = prompt_expander(\n                    args.prompt,\n                    tar_lang=args.prompt_extend_target_lang,\n                    image=img,\n                    seed=args.base_seed)\n                if prompt_output.status == False:\n                    logging.info(\n                        f\"Extending prompt failed: {prompt_output.message}\")\n                    logging.info(\"Falling back to original prompt.\")\n                    input_prompt = args.prompt\n                else:\n                    input_prompt = prompt_output.prompt\n                input_prompt = [input_prompt]\n            else:\n                input_prompt = [None]\n            if dist.is_initialized():\n                dist.broadcast_object_list(input_prompt, src=0)\n            args.prompt = input_prompt[0]\n            logging.info(f\"Extended prompt: {args.prompt}\")\n\n        logging.info(\"Creating WanI2V pipeline.\")\n        wan_i2v = wan.WanI2V(\n            config=cfg,\n            checkpoint_dir=args.ckpt_dir,\n            device_id=device,\n            rank=rank,\n            t5_fsdp=args.t5_fsdp,\n            dit_fsdp=args.dit_fsdp,\n            use_usp=(args.ulysses_size > 1 or args.ring_size > 1),\n            t5_cpu=args.t5_cpu,\n        )\n\n        logging.info(\"Generating video ...\")\n        video = wan_i2v.generate(\n            args.prompt,\n            img,\n            max_area=MAX_AREA_CONFIGS[args.size],\n            frame_num=args.frame_num,\n            shift=args.sample_shift,\n            sample_solver=args.sample_solver,\n            sampling_steps=args.sample_steps,\n            guide_scale=args.sample_guide_scale,\n            seed=args.base_seed,\n            offload_model=args.offload_model)\n    elif \"flf2v\" in args.task:\n        if args.prompt is None:\n            args.prompt = EXAMPLE_PROMPT[args.task][\"prompt\"]\n        if args.first_frame is None or args.last_frame is None:\n            args.first_frame = EXAMPLE_PROMPT[args.task][\"first_frame\"]\n            args.last_frame = EXAMPLE_PROMPT[args.task][\"last_frame\"]\n        logging.info(f\"Input prompt: {args.prompt}\")\n        logging.info(f\"Input first frame: {args.first_frame}\")\n        logging.info(f\"Input last frame: {args.last_frame}\")\n        first_frame = Image.open(args.first_frame).convert(\"RGB\")\n        last_frame = Image.open(args.last_frame).convert(\"RGB\")\n        if args.use_prompt_extend:\n            logging.info(\"Extending prompt ...\")\n            if rank == 0:\n                prompt_output = prompt_expander(\n                    args.prompt,\n                    tar_lang=args.prompt_extend_target_lang,\n                    image=[first_frame, last_frame],\n                    seed=args.base_seed)\n                if prompt_output.status == False:\n                    logging.info(\n                        f\"Extending prompt failed: {prompt_output.message}\")\n                    logging.info(\"Falling back to original prompt.\")\n                    input_prompt = args.prompt\n                else:\n                    input_prompt = prompt_output.prompt\n                input_prompt = [input_prompt]\n            else:\n                input_prompt = [None]\n            if dist.is_initialized():\n                dist.broadcast_object_list(input_prompt, src=0)\n            args.prompt = input_prompt[0]\n            logging.info(f\"Extended prompt: {args.prompt}\")\n\n        logging.info(\"Creating WanFLF2V pipeline.\")\n        wan_flf2v = wan.WanFLF2V(\n            config=cfg,\n            checkpoint_dir=args.ckpt_dir,\n            device_id=device,\n            rank=rank,\n            t5_fsdp=args.t5_fsdp,\n            dit_fsdp=args.dit_fsdp,\n            use_usp=(args.ulysses_size > 1 or args.ring_size > 1),\n            t5_cpu=args.t5_cpu,\n        )\n\n        logging.info(\"Generating video ...\")\n        video = wan_flf2v.generate(\n            args.prompt,\n            first_frame,\n            last_frame,\n            max_area=MAX_AREA_CONFIGS[args.size],\n            frame_num=args.frame_num,\n            shift=args.sample_shift,\n            sample_solver=args.sample_solver,\n            sampling_steps=args.sample_steps,\n            guide_scale=args.sample_guide_scale,\n            seed=args.base_seed,\n            offload_model=args.offload_model)\n    elif \"vace\" in args.task:\n        if args.prompt is None:\n            args.prompt = EXAMPLE_PROMPT[args.task][\"prompt\"]\n            args.src_video = EXAMPLE_PROMPT[args.task].get(\"src_video\", None)\n            args.src_mask = EXAMPLE_PROMPT[args.task].get(\"src_mask\", None)\n            args.src_ref_images = EXAMPLE_PROMPT[args.task].get(\n                \"src_ref_images\", None)\n\n        logging.info(f\"Input prompt: {args.prompt}\")\n        if args.use_prompt_extend and args.use_prompt_extend != 'plain':\n            logging.info(\"Extending prompt ...\")\n            if rank == 0:\n                prompt = prompt_expander.forward(args.prompt)\n                logging.info(\n                    f\"Prompt extended from '{args.prompt}' to '{prompt}'\")\n                input_prompt = [prompt]\n            else:\n                input_prompt = [None]\n            if dist.is_initialized():\n                dist.broadcast_object_list(input_prompt, src=0)\n            args.prompt = input_prompt[0]\n            logging.info(f\"Extended prompt: {args.prompt}\")\n\n        logging.info(\"Creating VACE pipeline.\")\n        wan_vace = wan.WanVace(\n            config=cfg,\n            checkpoint_dir=args.ckpt_dir,\n            device_id=device,\n            rank=rank,\n            t5_fsdp=args.t5_fsdp,\n            dit_fsdp=args.dit_fsdp,\n            use_usp=(args.ulysses_size > 1 or args.ring_size > 1),\n            t5_cpu=args.t5_cpu,\n        )\n\n        src_video, src_mask, src_ref_images = wan_vace.prepare_source(\n            [args.src_video], [args.src_mask], [\n                None if args.src_ref_images is None else\n                args.src_ref_images.split(',')\n            ], args.frame_num, SIZE_CONFIGS[args.size], device)\n\n        logging.info(f\"Generating video...\")\n        video = wan_vace.generate(\n            args.prompt,\n            src_video,\n            src_mask,\n            src_ref_images,\n            size=SIZE_CONFIGS[args.size],\n            frame_num=args.frame_num,\n            shift=args.sample_shift,\n            sample_solver=args.sample_solver,\n            sampling_steps=args.sample_steps,\n            guide_scale=args.sample_guide_scale,\n            seed=args.base_seed,\n            offload_model=args.offload_model)\n    else:\n        raise ValueError(f\"Unkown task type: {args.task}\")\n\n    if rank == 0:\n        if args.save_file is None:\n            formatted_time = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            formatted_prompt = args.prompt.replace(\" \", \"_\").replace(\"/\",\n                                                                     \"_\")[:50]\n            suffix = '.png' if \"t2i\" in args.task else '.mp4'\n            args.save_file = f\"{args.task}_{args.size.replace('*','x') if sys.platform=='win32' else args.size}_{args.ulysses_size}_{args.ring_size}_{formatted_prompt}_{formatted_time}\" + suffix\n\n        if \"t2i\" in args.task:\n            logging.info(f\"Saving generated image to {args.save_file}\")\n            cache_image(\n                tensor=video.squeeze(1)[None],\n                save_file=args.save_file,\n                nrow=1,\n                normalize=True,\n                value_range=(-1, 1))\n        else:\n            logging.info(f\"Saving generated video to {args.save_file}\")\n            cache_video(\n                tensor=video[None],\n                save_file=args.save_file,\n                fps=cfg.sample_fps,\n                nrow=1,\n                normalize=True,\n                value_range=(-1, 1))\n    logging.info(\"Finished.\")", "label": 0}
{"function": "  def testGlobalAvgPool(self):\n    data_formats = ['NHWC', 'NCHW']\n    inputs = tf.placeholder(tf.float32, (5, 10, 20, 10))\n    for data_format in data_formats:\n      output = nasnet_utils.global_avg_pool(\n          inputs, data_format)\n      self.assertEqual(output.shape, [5, 10])", "label": 1}
{"function": "def is_musa_available() -> bool:\n    return IS_MUSA_AVAILABLE", "label": 0}
{"function": "def write_notebook(tmp_path: Path) -> WriteNotebookFunc:\n    \"\"\"Provide a helper function to write a ``.ipynb`` notebook file with the given content.\n\n    Parameters\n    ----------\n    tmp_path : Path\n        The temporary directory path provided by the ``tmp_path`` fixture.\n\n    Returns\n    -------\n    WriteNotebookFunc\n        A callable that accepts a filename and a dictionary (representing JSON notebook data), writes it to a\n        ``.ipynb`` file, and returns the path to the file.\n\n    \"\"\"\n\n    def _write_notebook(name: str, content: dict[str, Any]) -> Path:\n        notebook_path = tmp_path / name\n        with notebook_path.open(mode=\"w\", encoding=\"utf-8\") as f:\n            json.dump(content, f)\n        return notebook_path\n\n    return _write_notebook", "label": 0}
{"function": "    def testAnchorImage(self):\n        local_pdf_path = os.path.join(os.path.dirname(__file__), \"gnarly_pdfs\", \"some_ocr1.pdf\")\n\n        report = _pdf_report(local_pdf_path, 1)\n\n        print(report)\n\n        print(get_anchor_text(local_pdf_path, 1, pdf_engine=\"pdfreport\"))", "label": 0}
{"function": "def main():\n    # ======================================================\n    # 1. configs & runtime variables\n    # ======================================================\n    # == parse configs ==\n    cfg = parse_configs()\n\n    # == get dtype & device ==\n    dtype = to_torch_dtype(cfg.get(\"dtype\", \"bf16\"))\n    device, coordinator = setup_device()\n    checkpoint_io = CheckpointIO()\n    set_seed(cfg.get(\"seed\", 1024))\n    PinMemoryCache.force_dtype = dtype\n    pin_memory_cache_pre_alloc_numels = cfg.get(\"pin_memory_cache_pre_alloc_numels\", None)\n    PinMemoryCache.pre_alloc_numels = pin_memory_cache_pre_alloc_numels\n\n    # == init ColossalAI booster ==\n    plugin_type = cfg.get(\"plugin\", \"zero2\")\n    plugin_config = cfg.get(\"plugin_config\", {})\n    plugin = (\n        create_colossalai_plugin(\n            plugin=plugin_type,\n            dtype=cfg.get(\"dtype\", \"bf16\"),\n            grad_clip=cfg.get(\"grad_clip\", 0),\n            **plugin_config,\n        )\n        if plugin_type != \"none\"\n        else None\n    )\n    booster = Booster(plugin=plugin)\n\n    # == init exp_dir ==\n    exp_name, exp_dir = create_experiment_workspace(\n        cfg.get(\"outputs\", \"./outputs\"),\n        model_name=config_to_name(cfg),\n        config=cfg.to_dict(),\n    )\n    if is_log_process(plugin_type, plugin_config):\n        print(f\"changing {exp_dir} to share\")\n        os.system(f\"chgrp -R share {exp_dir}\")\n\n    # == init logger, tensorboard & wandb ==\n    logger = create_logger(exp_dir)\n    logger.info(\"Training configuration:\\n %s\", pformat(cfg.to_dict()))\n    tb_writer = None\n    if coordinator.is_master():\n        tb_writer = create_tensorboard_writer(exp_dir)\n        if cfg.get(\"wandb\", False):\n            wandb.init(\n                project=cfg.get(\"wandb_project\", \"Open-Sora\"),\n                name=cfg.get(\"wandb_expr_name\", exp_name),\n                config=cfg.to_dict(),\n                dir=exp_dir,\n            )\n\n    # ======================================================\n    # 2. build dataset and dataloader\n    # ======================================================\n    logger.info(\"Building dataset...\")\n    # == build dataset ==\n    dataset = build_module(cfg.dataset, DATASETS)\n    logger.info(\"Dataset contains %s samples.\", len(dataset))\n\n    # == build dataloader ==\n    cache_pin_memory = pin_memory_cache_pre_alloc_numels is not None\n    dataloader_args = dict(\n        dataset=dataset,\n        batch_size=cfg.get(\"batch_size\", None),\n        num_workers=cfg.get(\"num_workers\", 4),\n        seed=cfg.get(\"seed\", 1024),\n        shuffle=True,\n        drop_last=True,\n        pin_memory=True,\n        process_group=get_data_parallel_group(),\n        prefetch_factor=cfg.get(\"prefetch_factor\", None),\n        cache_pin_memory=cache_pin_memory,\n    )\n    dataloader, sampler = prepare_dataloader(\n        bucket_config=cfg.get(\"bucket_config\", None),\n        num_bucket_build_workers=cfg.get(\"num_bucket_build_workers\", 1),\n        **dataloader_args,\n    )\n    num_steps_per_epoch = len(dataloader)\n\n    # ======================================================\n    # 3. build model\n    # ======================================================\n    logger.info(\"Building models...\")\n\n    # == build vae model ==\n    model = build_module(cfg.model, MODELS, device_map=device, torch_dtype=dtype).train()\n    log_model_params(model)\n\n    if cfg.get(\"grad_checkpoint\", False):\n        set_grad_checkpoint(model)\n    vae_loss_fn = VAELoss(**cfg.vae_loss_config, device=device, dtype=dtype)\n\n    # == build EMA model ==\n    if cfg.get(\"ema_decay\", None) is not None:\n        ema = deepcopy(model).cpu().eval().requires_grad_(False)\n        ema_shape_dict = record_model_param_shape(ema)\n        logger.info(\"EMA model created.\")\n    else:\n        ema = ema_shape_dict = None\n        logger.info(\"No EMA model created.\")\n\n    # == build discriminator model ==\n    use_discriminator = cfg.get(\"discriminator\", None) is not None\n    if use_discriminator:\n        discriminator = build_module(cfg.discriminator, MODELS).to(device, dtype).train()\n        log_model_params(discriminator)\n        generator_loss_fn = GeneratorLoss(**cfg.gen_loss_config)\n        discriminator_loss_fn = DiscriminatorLoss(**cfg.disc_loss_config)\n\n    # == setup optimizer ==\n    optimizer = create_optimizer(model, cfg.optim)\n\n    # == setup lr scheduler ==\n    lr_scheduler = create_lr_scheduler(\n        optimizer=optimizer, num_steps_per_epoch=num_steps_per_epoch, epochs=cfg.get(\"epochs\", 1000), **cfg.lr_scheduler\n    )\n\n    # == setup discriminator optimizer ==\n    if use_discriminator:\n        disc_optimizer = create_optimizer(discriminator, cfg.optim_discriminator)\n        disc_lr_scheduler = create_lr_scheduler(\n            optimizer=disc_optimizer,\n            num_steps_per_epoch=num_steps_per_epoch,\n            epochs=cfg.get(\"epochs\", 1000),\n            **cfg.disc_lr_scheduler,\n        )\n\n    # =======================================================\n    # 4. distributed training preparation with colossalai\n    # =======================================================\n    logger.info(\"Preparing for distributed training...\")\n    # == boosting ==\n    torch.set_default_dtype(dtype)\n    model, optimizer, _, dataloader, lr_scheduler = booster.boost(\n        model=model,\n        optimizer=optimizer,\n        lr_scheduler=lr_scheduler,\n        dataloader=dataloader,\n    )\n\n    if use_discriminator:\n        discriminator, disc_optimizer, _, _, disc_lr_scheduler = booster.boost(\n            model=discriminator,\n            optimizer=disc_optimizer,\n            lr_scheduler=disc_lr_scheduler,\n        )\n    torch.set_default_dtype(torch.float)\n    logger.info(\"Boosted model for distributed training\")\n\n    # == global variables ==\n    cfg_epochs = cfg.get(\"epochs\", 1000)\n    mixed_strategy = cfg.get(\"mixed_strategy\", None)\n    mixed_image_ratio = cfg.get(\"mixed_image_ratio\", 0.0)\n    # modulate mixed image ratio since we force rank 0 to be video\n    num_ranks = dist.get_world_size()\n    modulated_mixed_image_ratio = (\n        num_ranks * mixed_image_ratio / (num_ranks - 1) if num_ranks > 1 else mixed_image_ratio\n    )\n    if is_log_process(plugin_type, plugin_config):\n        print(\"modulated mixed image ratio:\", modulated_mixed_image_ratio)\n\n    start_epoch = start_step = log_step = acc_step = 0\n    running_loss = dict(  # loss accumulated over config.log_every steps\n        all=0.0,\n        nll=0.0,\n        nll_rec=0.0,\n        nll_per=0.0,\n        kl=0.0,\n        gen=0.0,\n        gen_w=0.0,\n        disc=0.0,\n        debug=0.0,\n    )\n\n    def log_loss(name, loss, loss_dict, use_video):\n        # only calculate loss for video\n        if use_video == 0:\n            loss.data = torch.tensor(0.0, device=device, dtype=dtype)\n        all_reduce_sum(loss.data)\n        num_video = torch.tensor(use_video, device=device, dtype=dtype)\n        all_reduce_sum(num_video)\n        loss_item = loss.item() / num_video.item()\n        loss_dict[name] = loss_item\n        running_loss[name] += loss_item\n\n    logger.info(\"Training for %s epochs with %s steps per epoch\", cfg_epochs, num_steps_per_epoch)\n\n    # == resume ==\n    if cfg.get(\"load\", None) is not None:\n        logger.info(\"Loading checkpoint from %s\", cfg.load)\n        start_epoch = cfg.get(\"start_epoch\", None)\n        start_step = cfg.get(\"start_step\", None)\n        ret = checkpoint_io.load(\n            booster,\n            cfg.load,\n            model=model,\n            ema=ema,\n            optimizer=optimizer,\n            lr_scheduler=lr_scheduler,\n            sampler=(\n                None if start_step is not None else sampler\n            ),  # if specify start step, set last_micro_batch_access_index of a new sampler instead\n        )\n        if start_step is not None:\n            # if start step exceeds data length, go to next epoch\n            if start_step > num_steps_per_epoch:\n                start_epoch = (\n                    start_epoch + start_step // num_steps_per_epoch\n                    if start_epoch is not None\n                    else start_step // num_steps_per_epoch\n                )\n                start_step = start_step % num_steps_per_epoch\n            sampler.set_step(start_step)\n\n        start_epoch = start_epoch if start_epoch is not None else ret[0]\n        start_step = start_step if start_step is not None else ret[1]\n\n        if (\n            use_discriminator\n            and os.path.exists(os.path.join(cfg.load, \"discriminator\"))\n            and not cfg.get(\"restart_disc\", False)\n        ):\n            booster.load_model(discriminator, os.path.join(cfg.load, \"discriminator\"))\n            if cfg.get(\"load_optimizer\", True):\n                booster.load_optimizer(disc_optimizer, os.path.join(cfg.load, \"disc_optimizer\"))\n                if disc_lr_scheduler is not None:\n                    booster.load_lr_scheduler(disc_lr_scheduler, os.path.join(cfg.load, \"disc_lr_scheduler\"))\n                if cfg.get(\"disc_lr\", None) is not None:\n                    set_lr(disc_optimizer, disc_lr_scheduler, cfg.disc_lr)\n\n        logger.info(\"Loaded checkpoint %s at epoch %s step %s\", cfg.load, start_epoch, start_step)\n\n        if cfg.get(\"lr\", None) is not None:\n            set_lr(optimizer, lr_scheduler, cfg.lr, cfg.get(\"initial_lr\", None))\n\n        if cfg.get(\"update_warmup_steps\", False):\n            assert (\n                cfg.lr_scheduler.get(\"warmup_steps\", None) is not None\n            ), \"you need to set lr_scheduler.warmup_steps in order to pass --update-warmup-steps True\"\n            set_warmup_steps(lr_scheduler, cfg.lr_scheduler.warmup_steps)\n            if use_discriminator:\n                assert (\n                    cfg.disc_lr_scheduler.get(\"warmup_steps\", None) is not None\n                ), \"you need to set disc_lr_scheduler.warmup_steps in order to pass --update-warmup-steps True\"\n                set_warmup_steps(disc_lr_scheduler, cfg.disc_lr_scheduler.warmup_steps)\n\n    # == sharding EMA model ==\n    if ema is not None:\n        model_sharding(ema)\n        ema = ema.to(device)\n\n    if cfg.get(\"freeze_layers\", None) == \"all\":\n        for param in model.module.parameters():\n            param.requires_grad = False\n        print(\"all layers frozen\")\n\n    # model.module.requires_grad_(False)\n    # =======================================================\n    # 5. training loop\n    # =======================================================\n    dist.barrier()\n    accumulation_steps = int(cfg.get(\"accumulation_steps\", 1))\n    for epoch in range(start_epoch, cfg_epochs):\n        # == set dataloader to new epoch ==\n        sampler.set_epoch(epoch)\n        dataiter = iter(dataloader)\n        logger.info(\"Beginning epoch %s...\", epoch)\n        random.seed(1024 + dist.get_rank())  # load vid/img for each rank\n\n        # == training loop in an epoch ==\n        with tqdm(\n            enumerate(dataiter, start=start_step),\n            desc=f\"Epoch {epoch}\",\n            disable=not coordinator.is_master(),\n            total=num_steps_per_epoch,\n            initial=start_step,\n        ) as pbar:\n            pbar_iter = iter(pbar)\n\n            def fetch_data():\n                step, batch = next(pbar_iter)\n                pinned_video = batch[\"video\"]\n                batch[\"video\"] = pinned_video.to(device, dtype, non_blocking=True)\n                return batch, step, pinned_video\n\n            batch_, step_, pinned_video_ = fetch_data()\n\n            profiler_ctxt = (\n                profile(\n                    activities=[ProfilerActivity.CPU, ProfilerActivity.CUDA],\n                    schedule=my_schedule,\n                    on_trace_ready=torch.profiler.tensorboard_trace_handler(\"./log/profile\"),\n                    record_shapes=True,\n                    profile_memory=True,\n                    with_stack=True,\n                )\n                if cfg.get(\"profile\", False)\n                else nullcontext()\n            )\n\n            with profiler_ctxt:\n                for _ in range(start_step, num_steps_per_epoch):\n                    if cfg.get(\"profile\", False) and _ == WARMUP + ACTIVE + WAIT + 3:\n                        break\n\n                    # == load data ===\n                    batch, step, pinned_video = batch_, step_, pinned_video_\n                    if step + 1 < num_steps_per_epoch:\n                        batch_, step_, pinned_video_ = fetch_data()\n\n                    # == log config ==\n                    global_step = epoch * num_steps_per_epoch + step\n                    actual_update_step = (global_step + 1) // accumulation_steps\n                    log_step += 1\n                    acc_step += 1\n\n                    # == mixed strategy ==\n                    x = batch[\"video\"]\n                    t_length = x.size(2)\n                    use_video = 1\n                    if mixed_strategy == \"mixed_video_image\":\n                        if random.random() < modulated_mixed_image_ratio and dist.get_rank() != 0:\n                            # NOTE: enable the first rank to use video\n                            t_length = 1\n                            use_video = 0\n                    elif mixed_strategy == \"mixed_video_random\":\n                        t_length = random.randint(1, x.size(2))\n                    x = x[:, :, :t_length, :, :]\n\n                    with Timer(\"model\", log=True) if cfg.get(\"profile\", False) else nullcontext():\n                        # == forward pass ==\n                        x_rec, posterior, z = model(x)\n\n                        if cfg.get(\"profile\", False):\n                            profiler_ctxt.step()\n\n                        if cache_pin_memory:\n                            dataiter.remove_cache(pinned_video)\n\n                        # == loss initialization ==\n                        vae_loss = torch.tensor(0.0, device=device, dtype=dtype)\n                        loss_dict = {}  # loss at every step\n\n                        # == reconstruction loss ==\n                        ret = vae_loss_fn(x, x_rec, posterior)\n                        nll_loss = ret[\"nll_loss\"]\n                        kl_loss = ret[\"kl_loss\"]\n                        recon_loss = ret[\"recon_loss\"]\n                        perceptual_loss = ret[\"perceptual_loss\"]\n                        vae_loss += nll_loss + kl_loss\n\n                        # == generator loss ==\n                        if use_discriminator:\n                            # turn off grad update for disc\n                            discriminator.requires_grad_(False)\n                            fake_logits = discriminator(x_rec.contiguous())\n\n                            generator_loss, g_loss = generator_loss_fn(\n                                fake_logits,\n                                nll_loss,\n                                model.module.get_last_layer(),\n                                actual_update_step,\n                                is_training=model.training,\n                            )\n                            # print(f\"generator_loss: {generator_loss}, recon_loss: {recon_loss}, perceptual_loss: {perceptual_loss}\")\n\n                            vae_loss += generator_loss\n                            # turn on disc training\n                            discriminator.requires_grad_(True)\n\n                        # == generator backward & update ==\n                        ctx = (\n                            booster.no_sync(model, optimizer)\n                            if cfg.get(\"plugin\", \"zero2\") in (\"zero1\", \"zero1-seq\")\n                            and (step + 1) % accumulation_steps != 0\n                            else nullcontext()\n                        )\n                        with Timer(\"backward\", log=True) if cfg.get(\"profile\", False) else nullcontext():\n                            with ctx:\n                                booster.backward(loss=vae_loss / accumulation_steps, optimizer=optimizer)\n\n                        with Timer(\"optimizer\", log=True) if cfg.get(\"profile\", False) else nullcontext():\n                            if (step + 1) % accumulation_steps == 0:\n                                optimizer.step()\n                                optimizer.zero_grad()\n                                if lr_scheduler is not None:\n                                    lr_scheduler.step(\n                                        actual_update_step,\n                                    )\n                                # == update EMA ==\n                                if ema is not None:\n                                    update_ema(\n                                        ema,\n                                        model.unwrap(),\n                                        optimizer=optimizer,\n                                        decay=cfg.get(\"ema_decay\", 0.9999),\n                                    )\n\n                    # == logging ==\n                    log_loss(\"all\", vae_loss, loss_dict, use_video)\n                    log_loss(\"nll\", nll_loss, loss_dict, use_video)\n                    log_loss(\"nll_rec\", recon_loss, loss_dict, use_video)\n                    log_loss(\"nll_per\", perceptual_loss, loss_dict, use_video)\n                    log_loss(\"kl\", kl_loss, loss_dict, use_video)\n                    if use_discriminator:\n                        log_loss(\"gen_w\", generator_loss, loss_dict, use_video)\n                        log_loss(\"gen\", g_loss, loss_dict, use_video)\n\n                    # == loss: discriminator adversarial ==\n                    if use_discriminator:\n                        real_logits = discriminator(x.detach().contiguous())\n                        fake_logits = discriminator(x_rec.detach().contiguous())\n                        disc_loss = discriminator_loss_fn(\n                            real_logits,\n                            fake_logits,\n                            actual_update_step,\n                        )\n\n                        # == discriminator backward & update ==\n                        ctx = (\n                            booster.no_sync(discriminator, disc_optimizer)\n                            if cfg.get(\"plugin\", \"zero2\") in (\"zero1\", \"zero1-seq\")\n                            and (step + 1) % accumulation_steps != 0\n                            else nullcontext()\n                        )\n                        with ctx:\n                            booster.backward(loss=disc_loss / accumulation_steps, optimizer=disc_optimizer)\n                        if (step + 1) % accumulation_steps == 0:\n                            disc_optimizer.step()\n                            disc_optimizer.zero_grad()\n                            if disc_lr_scheduler is not None:\n                                disc_lr_scheduler.step(actual_update_step)\n\n                        # log\n                        log_loss(\"disc\", disc_loss, loss_dict, use_video)\n\n                    # == logging ==\n                    if (global_step + 1) % accumulation_steps == 0:\n                        if coordinator.is_master() and actual_update_step % cfg.get(\"log_every\", 1) == 0:\n                            avg_loss = {k: v / log_step for k, v in running_loss.items()}\n                            # progress bar\n                            pbar.set_postfix(\n                                {\n                                    # \"step\": step,\n                                    # \"global_step\": global_step,\n                                    # \"actual_update_step\": actual_update_step,\n                                    # \"lr\": optimizer.param_groups[0][\"lr\"],\n                                    **{k: f\"{v:.2f}\" for k, v in avg_loss.items()},\n                                }\n                            )\n                            # tensorboard\n                            tb_writer.add_scalar(\"loss\", vae_loss.item(), actual_update_step)\n                            # wandb\n                            if cfg.get(\"wandb\", False):\n                                wandb.log(\n                                    {\n                                        \"iter\": global_step,\n                                        \"epoch\": epoch,\n                                        \"lr\": optimizer.param_groups[0][\"lr\"],\n                                        \"avg_loss_\": avg_loss,\n                                        \"avg_loss\": avg_loss[\"all\"],\n                                        \"loss_\": loss_dict,\n                                        \"loss\": vae_loss.item(),\n                                        \"global_grad_norm\": optimizer.get_grad_norm(),\n                                    },\n                                    step=actual_update_step,\n                                )\n\n                            running_loss = {k: 0.0 for k in running_loss}\n                            log_step = 0\n\n                        # == checkpoint saving ==\n                        ckpt_every = cfg.get(\"ckpt_every\", 0)\n                        if ckpt_every > 0 and actual_update_step % ckpt_every == 0 and coordinator.is_master():\n                            subprocess.run(\"sudo drop_cache\", shell=True)\n\n                        if ckpt_every > 0 and actual_update_step % ckpt_every == 0:\n                            # mannually garbage collection\n                            gc.collect()\n\n                            save_dir = checkpoint_io.save(\n                                booster,\n                                exp_dir,\n                                model=model,\n                                ema=ema,\n                                optimizer=optimizer,\n                                lr_scheduler=lr_scheduler,\n                                sampler=sampler,\n                                epoch=epoch,\n                                step=step + 1,\n                                global_step=global_step + 1,\n                                batch_size=cfg.get(\"batch_size\", None),\n                                actual_update_step=actual_update_step,\n                                ema_shape_dict=ema_shape_dict,\n                                async_io=True,\n                            )\n\n                            if is_log_process(plugin_type, plugin_config):\n                                os.system(f\"chgrp -R share {save_dir}\")\n\n                            if use_discriminator:\n                                booster.save_model(discriminator, os.path.join(save_dir, \"discriminator\"), shard=True)\n                                booster.save_optimizer(\n                                    disc_optimizer,\n                                    os.path.join(save_dir, \"disc_optimizer\"),\n                                    shard=True,\n                                    size_per_shard=4096,\n                                )\n                                if disc_lr_scheduler is not None:\n                                    booster.save_lr_scheduler(\n                                        disc_lr_scheduler, os.path.join(save_dir, \"disc_lr_scheduler\")\n                                    )\n                            dist.barrier()\n\n                            logger.info(\n                                \"Saved checkpoint at epoch %s, step %s, global_step %s to %s\",\n                                epoch,\n                                step + 1,\n                                actual_update_step,\n                                save_dir,\n                            )\n\n                            # remove old checkpoints\n                            rm_checkpoints(exp_dir, keep_n_latest=cfg.get(\"keep_n_latest\", -1))\n                            logger.info(\n                                \"Removed old checkpoints and kept %s latest ones.\", cfg.get(\"keep_n_latest\", -1)\n                            )\n\n            if cfg.get(\"profile\", False):\n                profiler_ctxt.export_chrome_trace(\"./log/profile/trace.json\")\n\n        sampler.reset()\n        start_step = 0", "label": 0}
{"function": "def test_output_to_file(shared_tmp_dir, test_vector) -> None:\n    \"\"\"Test that the CLI outputs to a file correctly.\"\"\"\n\n    output_file = os.path.join(shared_tmp_dir, test_vector.filename + \".output\")\n    result = subprocess.run(\n        [\n            \"python\",\n            \"-m\",\n            \"markitdown\",\n            \"-o\",\n            output_file,\n            os.path.join(TEST_FILES_DIR, test_vector.filename),\n        ],\n        capture_output=True,\n        text=True,\n    )\n\n    assert result.returncode == 0, f\"CLI exited with error: {result.stderr}\"\n    assert os.path.exists(output_file), f\"Output file not created: {output_file}\"\n\n    with open(output_file, \"r\") as f:\n        output_data = f.read()\n        for test_string in test_vector.must_include:\n            assert test_string in output_data\n        for test_string in test_vector.must_not_include:\n            assert test_string not in output_data\n\n    os.remove(output_file)\n    assert not os.path.exists(output_file), f\"Output file not deleted: {output_file}\"", "label": 0}
{"function": "        def _build_path(self):\n            for variable in re_path_template.findall(self.path):\n                name = variable.strip('{}')\n\n                try:\n                    value = quote(self.parameters[name])\n                except KeyError:\n                    raise Exception('No parameter value found for path variable: %s' % name)\n                del self.parameters[name]\n\n                self.path = self.path.replace(variable, value)\n\n            if self.api.format:\n                self.path = self.path + '.%s' % self.api.format\n            else:\n                self.path = self.path", "label": 1}
{"function": "def _whats_your_job():\n    return 'ping'", "label": 1}
{"function": "    def generate(self, messages, tools_to_call_from=None, stop_sequences=None):\n        if len(messages) < 3:\n            return ChatMessage(\n                role=MessageRole.ASSISTANT,\n                content=\"\",\n                tool_calls=[\n                    ChatMessageToolCall(\n                        id=\"call_0\",\n                        type=\"function\",\n                        function=ChatMessageToolCallFunction(\n                            name=\"python_interpreter\", arguments={\"code\": \"2*3.6452\"}\n                        ),\n                    )\n                ],\n            )\n        else:\n            return ChatMessage(\n                role=MessageRole.ASSISTANT,\n                content=\"\",\n                tool_calls=[\n                    ChatMessageToolCall(\n                        id=\"call_1\",\n                        type=\"function\",\n                        function=ChatMessageToolCallFunction(name=\"final_answer\", arguments={\"answer\": \"7.2904\"}),\n                    )\n                ],\n            )", "label": 0}
{"function": "def test_post_request_with_body():\n    \"\"\"Test a POST request with a JSON body.\"\"\"\n    request = RequestModel(\n        name=\"POST with body\",\n        method=\"POST\",\n        url=\"https://example.com/api/users\",\n        body=RequestBody(content='{\"name\": \"John Doe\", \"email\": \"john@example.com\"}'),\n    )\n\n    expected = 'curl \\\\\\n  -X POST \\\\\\n  -d \\'{\"name\": \"John Doe\", \"email\": \"john@example.com\"}\\' \\\\\\n  \\'https://example.com/api/users\\''\n    assert request.to_curl() == expected", "label": 0}
{"function": "  async def on_user_message_callback(\n      self,\n      *,\n      invocation_context: InvocationContext,\n      user_message: types.Content,\n  ) -> Optional[types.Content]:\n    if not self.enable_user_message_callback:\n      return None\n    return types.Content(\n        role=\"model\",\n        parts=[types.Part(text=self.ON_USER_CALLBACK_MSG)],\n    )", "label": 0}
{"function": "def app():\n    Fire(main)", "label": 0}
{"function": "    def target_temperature_high(self):\n        \"\"\"Return the highbound target temperature we try to reach.\"\"\"\n        return self._target_temperature_high", "label": 1}
{"function": "def seterr(all=None, divide=None, over=None, under=None, invalid=None):\n    \"\"\"\n    Set how floating-point errors are handled.\n\n    Note that operations on integer scalar types (such as `int16`) are\n    handled like floating point, and are affected by these settings.\n\n    Parameters\n    ----------\n    all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Set treatment for all types of floating-point errors at once:\n\n        - ignore: Take no action when the exception occurs.\n        - warn: Print a `RuntimeWarning` (via the Python `warnings` module).\n        - raise: Raise a `FloatingPointError`.\n        - call: Call a function specified using the `seterrcall` function.\n        - print: Print a warning directly to ``stdout``.\n        - log: Record error in a Log object specified by `seterrcall`.\n\n        The default is not to change the current behavior.\n    divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for division by zero.\n    over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point overflow.\n    under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point underflow.\n    invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for invalid floating-point operation.\n\n    Returns\n    -------\n    old_settings : dict\n        Dictionary containing the old settings.\n\n    See also\n    --------\n    seterrcall : Set a callback function for the 'call' mode.\n    geterr, geterrcall, errstate\n\n    Notes\n    -----\n    The floating-point exceptions are defined in the IEEE 754 standard [1]_:\n\n    - Division by zero: infinite result obtained from finite numbers.\n    - Overflow: result too large to be expressed.\n    - Underflow: result so close to zero that some precision\n      was lost.\n    - Invalid operation: result is not an expressible number, typically\n      indicates that a NaN was produced.\n\n    .. [1] http://en.wikipedia.org/wiki/IEEE_754\n\n    Examples\n    --------\n    >>> old_settings = np.seterr(all='ignore')  #seterr to known value\n    >>> np.seterr(over='raise')\n    {'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore',\n     'under': 'ignore'}\n    >>> np.seterr(**old_settings)  # reset to default\n    {'over': 'raise', 'divide': 'ignore', 'invalid': 'ignore',\n     'under': 'ignore'}\n\n    >>> np.int16(32000) * np.int16(3)\n    30464\n    >>> old_settings = np.seterr(all='warn', over='raise')\n    >>> np.int16(32000) * np.int16(3)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    FloatingPointError: overflow encountered in short_scalars\n\n    >>> old_settings = np.seterr(all='print')\n    >>> np.geterr()\n    {'over': 'print', 'divide': 'print', 'invalid': 'print', 'under': 'print'}\n    >>> np.int16(32000) * np.int16(3)\n    Warning: overflow encountered in short_scalars\n    30464\n\n    \"\"\"\n\n    pyvals = umath.geterrobj()\n    old = geterr()\n\n    if divide is None:\n        divide = all or old['divide']\n    if over is None:\n        over = all or old['over']\n    if under is None:\n        under = all or old['under']\n    if invalid is None:\n        invalid = all or old['invalid']\n\n    maskvalue = ((_errdict[divide] << SHIFT_DIVIDEBYZERO) +\n                 (_errdict[over] << SHIFT_OVERFLOW) +\n                 (_errdict[under] << SHIFT_UNDERFLOW) +\n                 (_errdict[invalid] << SHIFT_INVALID))\n\n    pyvals[1] = maskvalue\n    umath.seterrobj(pyvals)\n    return old", "label": 1}
{"function": "    def register(self, callback, *args, **kwds):\n        return self.callback(callback, *args, **kwds)", "label": 1}
{"function": "    async def _raise(*args, **kwargs):\n        raise DummyAPIError()", "label": 0}
{"function": "def test_request_with_headers():\n    \"\"\"Test a request with custom headers.\"\"\"\n    request = RequestModel(\n        name=\"Request with headers\",\n        method=\"GET\",\n        url=\"https://example.com/api\",\n        headers=[\n            Header(name=\"Content-Type\", value=\"application/json\"),\n            Header(name=\"Authorization\", value=\"Bearer token123\"),\n            Header(name=\"Disabled-Header\", value=\"value\", enabled=False),\n        ],\n    )\n\n    expected = \"curl \\\\\\n  -H 'Content-Type: application/json' \\\\\\n  -H 'Authorization: Bearer token123' \\\\\\n  'https://example.com/api'\"\n    assert request.to_curl() == expected", "label": 0}
{"function": "def colored(text, color=None, bold=False):\n    fmt = []\n    if color== 'red':\n        fmt.append('31')\n    elif color == 'green':\n        fmt.append('32')\n    if bold:\n        fmt.append('1')\n\n    return f\"\\033[{';'.join(fmt)}m{text}\\033[0m\"", "label": 0}
{"function": "def parse_opt():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', nargs='+', type=str, default=ROOT / 'yolo.pt', help='model path or triton URL')\n    parser.add_argument('--source', type=str, default=ROOT / 'data/images', help='file/dir/URL/glob/screen/0(webcam)')\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='(optional) dataset.yaml path')\n    parser.add_argument('--imgsz', '--img', '--img-size', nargs='+', type=int, default=[640], help='inference size h,w')\n    parser.add_argument('--conf-thres', type=float, default=0.25, help='confidence threshold')\n    parser.add_argument('--iou-thres', type=float, default=0.45, help='NMS IoU threshold')\n    parser.add_argument('--max-det', type=int, default=1000, help='maximum detections per image')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--view-img', action='store_true', help='show results')\n    parser.add_argument('--save-txt', action='store_true', help='save results to *.txt')\n    parser.add_argument('--save-conf', action='store_true', help='save confidences in --save-txt labels')\n    parser.add_argument('--save-crop', action='store_true', help='save cropped prediction boxes')\n    parser.add_argument('--nosave', action='store_true', help='do not save images/videos')\n    parser.add_argument('--classes', nargs='+', type=int, help='filter by class: --classes 0, or --classes 0 2 3')\n    parser.add_argument('--agnostic-nms', action='store_true', help='class-agnostic NMS')\n    parser.add_argument('--augment', action='store_true', help='augmented inference')\n    parser.add_argument('--visualize', action='store_true', help='visualize features')\n    parser.add_argument('--update', action='store_true', help='update all models')\n    parser.add_argument('--project', default=ROOT / 'runs/detect', help='save results to project/name')\n    parser.add_argument('--name', default='exp', help='save results to project/name')\n    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n    parser.add_argument('--line-thickness', default=3, type=int, help='bounding box thickness (pixels)')\n    parser.add_argument('--hide-labels', default=False, action='store_true', help='hide labels')\n    parser.add_argument('--hide-conf', default=False, action='store_true', help='hide confidences')\n    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')\n    parser.add_argument('--dnn', action='store_true', help='use OpenCV DNN for ONNX inference')\n    parser.add_argument('--vid-stride', type=int, default=1, help='video frame-rate stride')\n    opt = parser.parse_args()\n    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand\n    print_args(vars(opt))\n    return opt", "label": 0}
{"function": "def main(opt):\n    test(**vars(opt)) if opt.test else run(**vars(opt))", "label": 0}
{"function": "    def forward(self, x, y=None):\n        h = self.encoder(x).squeeze().transpose(0, 1)\n\n        y_hat = (h ** 2).sum(dim=-1) ** 0.5\n        y_hat = F.softmax(y_hat, dim=-1)\n\n        if y is None:\n            # In all batches, get the most active capsule.\n            _, max_length_indices = y_hat.max(dim=1)\n            y = Variable(torch.eye(p.NUM_LABELS))\n            if self.use_cuda:\n                y = y.cuda()\n            y = y.index_select(dim=0, index=max_length_indices.data)\n\n        x_hat = self.decoder((h * y[:, :, None]).view(x.size(0), -1))\n\n        return y_hat, x_hat", "label": 1}
{"function": "def pack_state(gs: Gaussian, mesh: MeshExtractResult) -> dict:\n    return {\n        'gaussian': {\n            **gs.init_params,\n            '_xyz': gs._xyz.cpu().numpy(),\n            '_features_dc': gs._features_dc.cpu().numpy(),\n            '_scaling': gs._scaling.cpu().numpy(),\n            '_rotation': gs._rotation.cpu().numpy(),\n            '_opacity': gs._opacity.cpu().numpy(),\n        },\n        'mesh': {\n            'vertices': mesh.vertices.cpu().numpy(),\n            'faces': mesh.faces.cpu().numpy(),\n        },\n    }", "label": 0}
{"function": "def create_temp_dir():\n    \"\"\"\u521b\u5efa\u4e34\u65f6\u76ee\u5f55\u7528\u4e8e\u5b58\u50a8\u5904\u7406\u6587\u4ef6\"\"\"\n    temp_dir = Path(\"temp\")\n    temp_dir.mkdir(exist_ok=True)\n    return temp_dir", "label": 0}
{"function": "def create_tutorial_flow():\n    \"\"\"Creates and returns the codebase tutorial generation flow.\"\"\"\n\n    # Instantiate nodes\n    fetch_repo = FetchRepo()\n    identify_abstractions = IdentifyAbstractions(max_retries=5, wait=20)\n    analyze_relationships = AnalyzeRelationships(max_retries=5, wait=20)\n    order_chapters = OrderChapters(max_retries=5, wait=20)\n    write_chapters = WriteChapters(max_retries=5, wait=20) # This is a BatchNode\n    combine_tutorial = CombineTutorial()\n\n    # Connect nodes in sequence based on the design\n    fetch_repo >> identify_abstractions\n    identify_abstractions >> analyze_relationships\n    analyze_relationships >> order_chapters\n    order_chapters >> write_chapters\n    write_chapters >> combine_tutorial\n\n    # Create the flow starting with FetchRepo\n    tutorial_flow = Flow(start=fetch_repo)\n\n    return tutorial_flow", "label": 0}
{"function": "    def __comments_clicked_cb(self, button):\n        self.goto_comments.emit()", "label": 1}
{"function": "    def test_clear(self):\n        \"\"\"Test that the cache can be cleared.\"\"\"\n        cache = TimedCache(datetime.timedelta(seconds=10))\n\n        # Add some items\n        cache.set(\"key1\", \"value1\")\n        cache.set(\"key2\", \"value2\")\n        assert len(cache.cache) == 2\n\n        # Clear the cache\n        cache.clear()\n        assert len(cache.cache) == 0", "label": 0}
{"function": "def sig_algs_to_ids(names):\n    \"\"\"Convert a string with signature algorithm names to list of IDs.\n\n    :type names: str\n    :param names: whitespace separated list of names of hash algorithm\n        names. Names can be specified as the legacy (TLS1.2) hash algorithm\n        and hash type pairs (e.g. ``sha256+rsa``), as a pair of numbers (e.g\n        ``4+1``) or as the new TLS 1.3 signature scheme (e.g.\n        ``rsa_pkcs1_sha256``).\n        Full parameter string then can look like: ``sha256+rsa 5+rsa\n        rsa_pss_pss_sha256``.\n    :raises AttributeError: when the specified identifier is not defined in\n        HashAlgorithm, SignatureAlgorithm or SignatureScheme\n    :return: list of tuples\n    \"\"\"\n    ids = []\n\n    for name in names.split():\n        if '+' in name:\n            h_alg, s_alg = name.split('+')\n\n            hash_id = _hash_name_to_id(h_alg)\n            sign_id = _sign_alg_name_to_id(s_alg)\n\n            ids.append((hash_id, sign_id))\n        else:\n            ids.append(getattr(SignatureScheme, name))\n\n    return ids", "label": 1}
{"function": "async def generate(request: Request):\n    logger.info(\"Worker send...\")\n    params = await request.json()\n    uid = uuid.uuid4()\n    threading.Thread(target=worker.generate, args=(uid, params,)).start()\n    ret = {\"uid\": str(uid)}\n    return JSONResponse(ret, status_code=200)", "label": 0}
{"function": "    def test_string_split(self):\n        self.check_func_on_series(lambda x: x.str.split().apply(str), self.pser[:-1])\n        self.check_func_on_series(lambda x: x.str.split(r\"p*\").apply(str), self.pser[:-1])\n        pser = pd.Series([\"This is a sentence.\", \"This-is-a-long-word.\"])\n        self.check_func_on_series(lambda x: x.str.split(n=2).apply(str), pser)\n        self.check_func_on_series(lambda x: x.str.split(pat=\"-\", n=2).apply(str), pser)\n        self.check_func_on_series(lambda x: x.str.split(n=2, expand=True), pser, almost=True)\n        with self.assertRaises(NotImplementedError):\n            self.check_func(lambda x: x.str.split(expand=True))", "label": 1}
{"function": "    def ensure_finalized(self):\n        if not self.finalized:\n            self.finalize_options()\n        self.finalized = 1", "label": 1}
{"function": "    def _onFavoritesChanged(self, preference_key: str) -> None:\n        \"\"\"Triggered when any preference changes, but only handles it when the list of favourites is changed. \"\"\"\n\n        if preference_key != \"cura/favorite_materials\":\n            return\n        self._onChanged()", "label": 1}
{"function": "def test__xla_dist_model_run_parallel_n_threads_without_sync():\n    # tests issue : https://github.com/pytorch/ignite/issues/1096\n    from joblib import Parallel, delayed\n\n    import torch_xla.core.xla_model as xm\n\n    devices = xm.get_xla_supported_devices()\n    folds = 1\n    d = 0\n    if len(devices) > 5:\n        folds = 5\n        d = 1\n    Parallel(n_jobs=folds, backend=\"threading\")(delayed(main_fold)(i + d) for i in range(folds))", "label": 1}
{"function": "    def test_preserves_path(self):\n        \"\"\"Path should be preserved.\"\"\"\n        assert (\n            resource_url_from_server_url(\"https://example.com/path/to/resource\")\n            == \"https://example.com/path/to/resource\"\n        )\n        assert resource_url_from_server_url(\"https://example.com/\") == \"https://example.com/\"\n        assert resource_url_from_server_url(\"https://example.com\") == \"https://example.com\"", "label": 0}
{"function": "    def fetch_trades(self, symbol, since=None, limit=None, params={}):\n        self.load_markets()\n        market = self.market(symbol)\n        method = 'publicGet'\n        request = {\n            'symbol': market['id'],\n        }\n        if market['future']:\n            method += 'Future'\n            request['contract_type'] = 'this_week'  # next_week, quarter\n        method += 'Trades'\n        response = getattr(self, method)(self.extend(request, params))\n        return self.parse_trades(response, market, since, limit)", "label": 1}
{"function": "    def on_status_button_left_up(self, e = None):\n        if not self.searching:\n            self.button_timer.Stop()\n        if e: e.Skip(True)", "label": 1}
{"function": "    def containment_radius(self, energy, fraction=0.68):\n        \"\"\"Containment radius.\n\n        Parameters\n        ----------\n        energy : `~astropy.units.Quantity`\n            Energy\n        fraction : float\n            Containment fraction.\n\n        Returns\n        -------\n        rad : `~astropy.units.Quantity`\n            Containment radius in deg\n        \"\"\"\n        # upsamle for better precision\n        rad_max = Angle(np.linspace(0, self.rad[-1].value, 10 * len(self.rad)), \"rad\")\n        containment = self.containment(energy=energy, rad_max=rad_max)\n\n        # find nearest containment value\n        fraction_idx = np.argmin(np.abs(containment - fraction), axis=1)\n        return rad_max[fraction_idx].to(\"deg\")", "label": 1}
{"function": "    def b2a_base64(data: _Bytes, *, newline: bool = ...) -> bytes: ...", "label": 1}
{"function": "    def valPGEVersion(self, obj):\n        \"\"\"Function to add PGEVersion\n\n        :param obj: element to add PGEVersion\n        \"\"\"\n        values = []\n        for i in self.parModis:\n            values.append(i.retPGEVersion())\n        for i in set(values):\n            pge = self.ElementTree.SubElement(obj, 'PGEVersion')\n            pge.text = i", "label": 1}
{"function": "def parse_args() -> argparse.Namespace:\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Run the MCP Agent\")\n    parser.add_argument(\n        \"--connection\",\n        \"-c\",\n        choices=[\"stdio\", \"sse\"],\n        default=\"stdio\",\n        help=\"Connection type: stdio or sse\",\n    )\n    parser.add_argument(\n        \"--server-url\",\n        default=\"http://127.0.0.1:8000/sse\",\n        help=\"URL for SSE connection\",\n    )\n    parser.add_argument(\n        \"--interactive\", \"-i\", action=\"store_true\", help=\"Run in interactive mode\"\n    )\n    parser.add_argument(\"--prompt\", \"-p\", help=\"Single prompt to execute and exit\")\n    return parser.parse_args()", "label": 0}
{"function": "    def __call__(self, env, *args, **kw):\n        \"\"\"\n        \"\"\"\n        builder = self.get_builder(env)\n        if builder is None:\n            return [], []\n        return builder(*args, **kw)", "label": 1}
{"function": "def test_stream_info_operations() -> None:\n    \"\"\"Test operations performed on StreamInfo objects.\"\"\"\n\n    stream_info_original = StreamInfo(\n        mimetype=\"mimetype.1\",\n        extension=\"extension.1\",\n        charset=\"charset.1\",\n        filename=\"filename.1\",\n        local_path=\"local_path.1\",\n        url=\"url.1\",\n    )\n\n    # Check updating all attributes by keyword\n    keywords = [\"mimetype\", \"extension\", \"charset\", \"filename\", \"local_path\", \"url\"]\n    for keyword in keywords:\n        updated_stream_info = stream_info_original.copy_and_update(\n            **{keyword: f\"{keyword}.2\"}\n        )\n\n        # Make sure the targted attribute is updated\n        assert getattr(updated_stream_info, keyword) == f\"{keyword}.2\"\n\n        # Make sure the other attributes are unchanged\n        for k in keywords:\n            if k != keyword:\n                assert getattr(stream_info_original, k) == getattr(\n                    updated_stream_info, k\n                )\n\n    # Check updating all attributes by passing a new StreamInfo object\n    keywords = [\"mimetype\", \"extension\", \"charset\", \"filename\", \"local_path\", \"url\"]\n    for keyword in keywords:\n        updated_stream_info = stream_info_original.copy_and_update(\n            StreamInfo(**{keyword: f\"{keyword}.2\"})\n        )\n\n        # Make sure the targted attribute is updated\n        assert getattr(updated_stream_info, keyword) == f\"{keyword}.2\"\n\n        # Make sure the other attributes are unchanged\n        for k in keywords:\n            if k != keyword:\n                assert getattr(stream_info_original, k) == getattr(\n                    updated_stream_info, k\n                )\n\n    # Check mixing and matching\n    updated_stream_info = stream_info_original.copy_and_update(\n        StreamInfo(extension=\"extension.2\", filename=\"filename.2\"),\n        mimetype=\"mimetype.3\",\n        charset=\"charset.3\",\n    )\n    assert updated_stream_info.extension == \"extension.2\"\n    assert updated_stream_info.filename == \"filename.2\"\n    assert updated_stream_info.mimetype == \"mimetype.3\"\n    assert updated_stream_info.charset == \"charset.3\"\n    assert updated_stream_info.local_path == \"local_path.1\"\n    assert updated_stream_info.url == \"url.1\"\n\n    # Check multiple StreamInfo objects\n    updated_stream_info = stream_info_original.copy_and_update(\n        StreamInfo(extension=\"extension.4\", filename=\"filename.5\"),\n        StreamInfo(mimetype=\"mimetype.6\", charset=\"charset.7\"),\n    )\n    assert updated_stream_info.extension == \"extension.4\"\n    assert updated_stream_info.filename == \"filename.5\"\n    assert updated_stream_info.mimetype == \"mimetype.6\"\n    assert updated_stream_info.charset == \"charset.7\"\n    assert updated_stream_info.local_path == \"local_path.1\"\n    assert updated_stream_info.url == \"url.1\"", "label": 0}
{"function": "async def test_ascrape_playwright_scroll(mock_playwright):\n    \"\"\"Test the ascrape_playwright_scroll method with various configurations.\"\"\"\n    mock_pw, mock_browser, mock_context, mock_page = mock_playwright\n\n    url = \"http://example.com\"\n    loader = ChromiumLoader([url], backend=\"playwright\")\n\n    # Test with default parameters\n    mock_page.evaluate.side_effect = [1000, 2000, 2000]  # Simulate scrolling\n    result = await loader.ascrape_playwright_scroll(url)\n\n    assert mock_page.goto.call_count == 1\n    assert mock_page.wait_for_load_state.call_count == 1\n    assert mock_page.mouse.wheel.call_count > 0\n    assert mock_page.content.call_count == 1\n\n    # Test with custom parameters\n    mock_page.evaluate.side_effect = [1000, 2000, 3000, 4000, 4000]\n    result = await loader.ascrape_playwright_scroll(\n        url, timeout=10, scroll=10000, sleep=1, scroll_to_bottom=True\n    )\n\n    assert mock_page.goto.call_count == 2\n    assert mock_page.wait_for_load_state.call_count == 2\n    assert mock_page.mouse.wheel.call_count > 0\n    assert mock_page.content.call_count == 2", "label": 0}
{"function": "async def favicon():\n    return FileResponse(gradio_app._favicon)", "label": 0}
{"function": "def eval_model():\n    \"\"\"Evaluate using validation set split from training data.\"\"\"\n    from weclone.eval.eval_model import main as evaluate_main\n\n    evaluate_main()", "label": 0}
{"function": "        def _do_api_request(self, url, method='GET', body=None,\n                            json_body=None, headers=None):\n            headers = headers or {}\n            if self.signature and self.api.app_secret is not None:\n                secret = self.api.app_secret\n                signature = hmac.new(secret, sha256).hexdigest()\n                headers['X-Weixin-Forwarded-For'] = '|'.join([signature])\n            response = OAuth2Request(self.api).make_request(\n                url, method=method, body=body,\n                json_body=json_body, headers=headers)\n            status_code = response.status_code\n            try:\n                content_obj = simplejson.loads(response.content)\n            except ValueError:\n                raise WeixinClientError(\n                    'Unable to parse response, not valid JSON.',\n                    status_code=status_code)\n\n            api_responses = []\n            if status_code == 200:\n                if not self.objectify_response:\n                    return content_obj, None\n\n                if self.response_type == 'list':\n                    for entry in content_obj['data']:\n                        if self.return_json:\n                            api_responses.append(entry)\n                elif self.response_type == 'entry':\n                    data = content_obj\n                    if self.return_json:\n                        api_responses = data\n                elif self.response_type == 'empty':\n                    pass\n                return api_responses, self._build_pagination_info(content_obj)\n            else:\n                raise WeixinAPIError(\n                    status_code, content_obj['errcode'], content_obj['errmsg'])", "label": 1}
{"function": "    def set_args(\n        self,\n        names,\n        pixels_per_meter=10,\n        view_img=False,\n        line_thickness=2,\n        line_color=(255, 255, 0),\n        centroid_color=(255, 0, 255),\n    ):\n        \"\"\"\n        Configures the distance calculation and display parameters.\n\n        Args:\n            names (dict): object detection classes names\n            pixels_per_meter (int): Number of pixels in meter\n            view_img (bool): Flag indicating frame display\n            line_thickness (int): Line thickness for bounding boxes.\n            line_color (RGB): color of centroids line\n            centroid_color (RGB): colors of bbox centroids\n        \"\"\"\n        self.names = names\n        self.pixel_per_meter = pixels_per_meter\n        self.view_img = view_img\n        self.line_thickness = line_thickness\n        self.line_color = line_color\n        self.centroid_color = centroid_color", "label": 0}
{"function": "def apply_audio_delay(\n    audio_BxTxC: torch.Tensor,\n    pad_value: int,\n    bos_value: int,\n    precomp: tp.Tuple[torch.Tensor, torch.Tensor],\n) -> torch.Tensor:\n    \"\"\"\n    Applies the delay pattern to batched audio tokens using precomputed indices,\n    inserting BOS where t_idx < 0 and PAD where t_idx >= T.\n\n    Args:\n        audio_BxTxC: [B, T, C] int16 audio tokens (or int32/float)\n        pad_value: the padding token\n        bos_value: the BOS token\n        precomp:  (t_idx_BxTxC, indices_BTCx3) from build_delay_indices\n\n    Returns:\n        result_BxTxC: [B, T, C] delayed audio tokens\n    \"\"\"\n    device = audio_BxTxC.device  # Get device from input tensor\n    t_idx_BxTxC, indices_BTCx3 = precomp\n    t_idx_BxTxC = t_idx_BxTxC.to(device)  # Move precomputed indices to device\n    indices_BTCx3 = indices_BTCx3.to(device)\n\n    # Equivalent of tf.gather_nd using advanced indexing\n    # Ensure indices are long type if not already (build_delay_indices should handle this)\n    gathered_flat = audio_BxTxC[indices_BTCx3[:, 0], indices_BTCx3[:, 1], indices_BTCx3[:, 2]]\n    gathered_BxTxC = gathered_flat.view(audio_BxTxC.shape)\n\n    # Create masks on the correct device\n    mask_bos = t_idx_BxTxC < 0  # => place bos_value\n    mask_pad = t_idx_BxTxC >= audio_BxTxC.shape[1]  # => place pad_value\n\n    # Create scalar tensors on the correct device\n    bos_tensor = torch.tensor(bos_value, dtype=audio_BxTxC.dtype, device=device)\n    pad_tensor = torch.tensor(pad_value, dtype=audio_BxTxC.dtype, device=device)\n\n    # If mask_bos, BOS; else if mask_pad, PAD; else original gather\n    # All tensors should now be on the same device\n    result_BxTxC = torch.where(mask_bos, bos_tensor, torch.where(mask_pad, pad_tensor, gathered_BxTxC))\n\n    return result_BxTxC", "label": 0}
{"function": "def _CheckNumericsGrad(_, grad):\n  \"\"\"Gradient for check_numerics op.\"\"\"\n  return grad", "label": 1}
{"function": "    def test_1d_slicing5(self, flags=enable_pyobj_flags):\n        pyfunc = slicing_1d_usecase5\n        self.check_1d_slicing_with_arg(pyfunc, flags)", "label": 1}
{"function": "    def is_user_blocked(user_id: int) -> bool:\n        \"\"\" Determines if a user is blocked \"\"\"\n        user = UserService.get_user_by_id(user_id)\n\n        if UserRole(user.role) == UserRole.READ_ONLY:\n            return True\n\n        return False", "label": 1}
{"function": "    def copy(self):\n        return MemSetFn(self._ass)", "label": 1}
{"function": "def make_request(\n    url: str, data: Dict[str, Any], stream: bool = False, check_status: bool = True\n) -> requests.Response:\n    \"\"\"Send an HTTP request with retry mechanism\n    Args:\n        url: Request URL\n        data: Request data\n        stream: Whether to use streaming response\n        check_status: Whether to check HTTP status code (default: True)\n    Returns:\n        requests.Response: Response object\n\n    Raises:\n        requests.exceptions.RequestException: Request failed after all retries\n        requests.exceptions.HTTPError: HTTP status code is not 200 (when check_status is True)\n    \"\"\"\n    server_config = CONFIG[\"server\"]\n    max_retries = server_config[\"max_retries\"]\n    retry_delay = server_config[\"retry_delay\"]\n    timeout = server_config[\"timeout\"]\n\n    for attempt in range(max_retries):\n        try:\n            response = requests.post(url, json=data, stream=stream, timeout=timeout)\n            if check_status and response.status_code != 200:\n                response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            if attempt == max_retries - 1:  # Last retry\n                raise\n            print(f\"\\nRequest failed, retrying in {retry_delay} seconds: {str(e)}\")\n            time.sleep(retry_delay)", "label": 0}
{"function": "def handle_message(data):\n    logger.info(f\"User message: {data}\")\n    message = data.get('message')\n    base_model = data.get('base_model')\n    project_name = data.get('project_name')\n    search_engine = data.get('search_engine').lower()\n\n    agent = Agent(base_model=base_model, search_engine=search_engine)\n\n    state = AgentState.get_latest_state(project_name)\n    if not state:\n        thread = Thread(target=lambda: agent.execute(message, project_name))\n        thread.start()\n    else:\n        if AgentState.is_agent_completed(project_name):\n            thread = Thread(target=lambda: agent.subsequent_execute(message, project_name))\n            thread.start()\n        else:\n            emit_agent(\"info\", {\"type\": \"warning\", \"message\": \"previous agent doesn't completed it's task.\"})\n            last_state = AgentState.get_latest_state(project_name)\n            if last_state[\"agent_is_active\"] or not last_state[\"completed\"]:\n                thread = Thread(target=lambda: agent.execute(message, project_name))\n                thread.start()\n            else:\n                thread = Thread(target=lambda: agent.subsequent_execute(message, project_name))\n                thread.start()", "label": 0}
{"function": "def unload_module():\n    global module_in_gpu\n\n    if module_in_gpu is None:\n        return\n\n    DynamicSwapInstaller.uninstall_model(module_in_gpu)\n    module_in_gpu.to(cpu)\n    print(f'Move module to CPU: {type(module_in_gpu).__name__}')\n\n    module_in_gpu = None\n    memory_management.soft_empty_cache()\n    return", "label": 0}
{"function": "    def register_introspection_functions(self):\n        \"\"\"Registers the XML-RPC introspection methods in the system\n        namespace.\n\n        see http://xmlrpc.usefulinc.com/doc/reserved.html\n        \"\"\"\n\n        self.funcs.update({'system.listMethods' : self.system_listMethods,\n                      'system.methodSignature' : self.system_methodSignature,\n                      'system.methodHelp' : self.system_methodHelp})", "label": 1}
{"function": "async def list_models():\n    global model_args\n    model_card = ModelCard(id=\"gpt-3.5-turbo\")\n    return ModelList(data=[model_card])", "label": 0}
{"function": "def test_docs_examples(example: CodeExample, eval_example: EvalExample):\n    ruff_ignore: list[str] = [\"F841\", \"I001\", \"F821\"]  # F821: undefined names (snippets lack imports)\n\n    # Use project's actual line length of 120\n    eval_example.set_config(ruff_ignore=ruff_ignore, target_version=\"py310\", line_length=120)\n\n    # Use Ruff for both formatting and linting (skip Black)\n    if eval_example.update_examples:  # pragma: no cover\n        eval_example.format_ruff(example)\n    else:\n        eval_example.lint_ruff(example)", "label": 0}
{"function": "    async def scheduler(self, stop_event):\n        self.stop_event = stop_event\n        while not stop_event.is_set():\n            self.now = datetime.datetime.now(pytz.timezone(config.time_zone))\n            await self.main()\n            next_time = self.now + datetime.timedelta(hours=config.update_interval)\n            print(f\"\ud83d\udd52 Next update time: {next_time:%Y-%m-%d %H:%M:%S}\")\n            try:\n                await asyncio.wait_for(stop_event.wait(), timeout=config.update_interval * 3600)\n            except asyncio.TimeoutError:\n                continue", "label": 0}
{"function": "def test_coordinates_as_bytes():\n    pubkey = UmbralPrivateKey.gen_key().pubkey\n    point = pubkey.point_key\n    stamp = SignatureStamp(verifying_key=pubkey)\n\n    x, y = point.to_affine()\n    x = x.to_bytes(32, 'big')\n    y = y.to_bytes(32, 'big')\n\n    for p in (point, pubkey, stamp):\n        assert get_coordinates_as_bytes(p) == x + y\n        assert get_coordinates_as_bytes(p, x_coord=False) == y\n        assert get_coordinates_as_bytes(p, y_coord=False) == x\n        with pytest.raises(ValueError):\n            _ = get_coordinates_as_bytes(p, x_coord=False, y_coord=False)", "label": 1}
{"function": "  def testLocalFileDirectory(self, mock_StorageUrlFromString, mock_gsutil_api):\n    mock_storage_url = mock.Mock()\n    mock_storage_url.isFileUrl.return_value = True\n    mock_storage_url.IsDirectory.return_value = True\n    mock_StorageUrlFromString.return_value = mock_storage_url\n    (exp_url, have_existing_dst_container) = ExpandUrlToSingleBlr(\n        '/home/test', mock_gsutil_api, 'project_id', False,\n        CreateOrGetGsutilLogger('copy_test'))\n\n    self.assertTrue(have_existing_dst_container)\n    self.assertEqual(exp_url, mock_storage_url)", "label": 1}
{"function": "    def drawBoletoCarneDuplo(self, boletoDados1, boletoDados2=None):\n        \"\"\"Imprime um boleto tipo carn\u00ea com 2 boletos por p\u00e1gina.\n\n        :param boletoDados1: Objeto com os dados do boleto a ser preenchido.\n            Deve ser subclasse de :class:`pyboleto.data.BoletoData`\n        :param boletoDados2: Objeto com os dados do boleto a ser preenchido.\n            Deve ser subclasse de :class:`pyboleto.data.BoletoData`\n        :type boletoDados1: :class:`pyboleto.data.BoletoData`\n        :type boletoDados2: :class:`pyboleto.data.BoletoData`\n\n        \"\"\"\n        raise NotImplementedError('Em desenvolvimento')", "label": 1}
{"function": "async def run_global_search_question_generation(\n    query: str,\n    sv: SessionVariables,\n) -> SearchResult:\n    \"\"\"Run global search question generation process.\"\"\"\n    empty_context_data: dict[str, pd.DataFrame] = {}\n\n    response, context_data = await api.global_search(\n        config=sv.graphrag_config.value,\n        entities=sv.entities.value,\n        communities=sv.communities.value,\n        community_reports=sv.community_reports.value,\n        dynamic_community_selection=True,\n        response_type=\"Single paragraph\",\n        community_level=sv.dataset_config.value.community_level,\n        query=query,\n    )\n\n    # display response and reference context to UI\n    return SearchResult(\n        search_type=SearchType.Global,\n        response=str(response),\n        context=context_data if isinstance(context_data, dict) else empty_context_data,\n    )", "label": 0}
{"function": "def run_inference(\n    text_input: str,\n    audio_prompt_text_input: str,\n    audio_prompt_input: Optional[Tuple[int, np.ndarray]],\n    max_new_tokens: int,\n    cfg_scale: float,\n    temperature: float,\n    top_p: float,\n    cfg_filter_top_k: int,\n    speed_factor: float,\n    seed: Optional[int] = None,\n):\n    \"\"\"\n    Runs Nari inference using the globally loaded model and provided inputs.\n    Uses temporary files for text and audio prompt compatibility with inference.generate.\n    \"\"\"\n    global model, device  # Access global model, config, device\n    console_output_buffer = io.StringIO()\n\n    with contextlib.redirect_stdout(console_output_buffer):\n        # Prepend transcript text if audio_prompt provided\n        if audio_prompt_input and audio_prompt_text_input and not audio_prompt_text_input.isspace():\n            text_input = audio_prompt_text_input + \"\\n\" + text_input\n            text_input = text_input.strip()\n\n        if audio_prompt_input and (not audio_prompt_text_input or audio_prompt_text_input.isspace()):\n            raise gr.Error(\"Audio Prompt Text input cannot be empty.\")\n\n        if not text_input or text_input.isspace():\n            raise gr.Error(\"Text input cannot be empty.\")\n\n        # Preprocess Audio\n        temp_txt_file_path = None\n        temp_audio_prompt_path = None\n        output_audio = (44100, np.zeros(1, dtype=np.float32))\n\n        try:\n            prompt_path_for_generate = None\n            if audio_prompt_input is not None:\n                sr, audio_data = audio_prompt_input\n                # Check if audio_data is valid\n                if audio_data is None or audio_data.size == 0 or audio_data.max() == 0:  # Check for silence/empty\n                    gr.Warning(\"Audio prompt seems empty or silent, ignoring prompt.\")\n                else:\n                    # Save prompt audio to a temporary WAV file\n                    with tempfile.NamedTemporaryFile(mode=\"wb\", suffix=\".wav\", delete=False) as f_audio:\n                        temp_audio_prompt_path = f_audio.name  # Store path for cleanup\n\n                        # Basic audio preprocessing for consistency\n                        # Convert to float32 in [-1, 1] range if integer type\n                        if np.issubdtype(audio_data.dtype, np.integer):\n                            max_val = np.iinfo(audio_data.dtype).max\n                            audio_data = audio_data.astype(np.float32) / max_val\n                        elif not np.issubdtype(audio_data.dtype, np.floating):\n                            gr.Warning(f\"Unsupported audio prompt dtype {audio_data.dtype}, attempting conversion.\")\n                            # Attempt conversion, might fail for complex types\n                            try:\n                                audio_data = audio_data.astype(np.float32)\n                            except Exception as conv_e:\n                                raise gr.Error(f\"Failed to convert audio prompt to float32: {conv_e}\")\n\n                        # Ensure mono (average channels if stereo)\n                        if audio_data.ndim > 1:\n                            if audio_data.shape[0] == 2:  # Assume (2, N)\n                                audio_data = np.mean(audio_data, axis=0)\n                            elif audio_data.shape[1] == 2:  # Assume (N, 2)\n                                audio_data = np.mean(audio_data, axis=1)\n                            else:\n                                gr.Warning(\n                                    f\"Audio prompt has unexpected shape {audio_data.shape}, taking first channel/axis.\"\n                                )\n                                audio_data = (\n                                    audio_data[0] if audio_data.shape[0] < audio_data.shape[1] else audio_data[:, 0]\n                                )\n                            audio_data = np.ascontiguousarray(audio_data)  # Ensure contiguous after slicing/mean\n\n                        # Write using soundfile\n                        try:\n                            sf.write(\n                                temp_audio_prompt_path, audio_data, sr, subtype=\"FLOAT\"\n                            )  # Explicitly use FLOAT subtype\n                            prompt_path_for_generate = temp_audio_prompt_path\n                            print(f\"Created temporary audio prompt file: {temp_audio_prompt_path} (orig sr: {sr})\")\n                        except Exception as write_e:\n                            print(f\"Error writing temporary audio file: {write_e}\")\n                            raise gr.Error(f\"Failed to save audio prompt: {write_e}\")\n\n            # Set and Display Generation Seed\n            if seed is None or seed < 0:\n                seed = random.randint(0, 2**32 - 1)\n                print(f\"\\nNo seed provided, generated random seed: {seed}\\n\")\n            else:\n                print(f\"\\nUsing user-selected seed: {seed}\\n\")\n            set_seed(seed)\n\n            # Run Generation\n            print(f'Generating speech: \\n\"{text_input}\"\\n')\n\n            start_time = time.time()\n\n            # Use torch.inference_mode() context manager for the generation call\n            with torch.inference_mode():\n                output_audio_np = model.generate(\n                    text_input,\n                    max_tokens=max_new_tokens,\n                    cfg_scale=cfg_scale,\n                    temperature=temperature,\n                    top_p=top_p,\n                    cfg_filter_top_k=cfg_filter_top_k,  # Pass the value here\n                    use_torch_compile=False,  # Keep False for Gradio stability\n                    audio_prompt=prompt_path_for_generate,\n                    verbose=True,\n                )\n\n            end_time = time.time()\n            print(f\"Generation finished in {end_time - start_time:.2f} seconds.\\n\")\n\n            # 4. Convert Codes to Audio\n            if output_audio_np is not None:\n                # Get sample rate from the loaded DAC model\n                output_sr = 44100\n\n                # --- Slow down audio ---\n                original_len = len(output_audio_np)\n                # Ensure speed_factor is positive and not excessively small/large to avoid issues\n                speed_factor = max(0.1, min(speed_factor, 5.0))\n                target_len = int(original_len / speed_factor)  # Target length based on speed_factor\n                if target_len != original_len and target_len > 0:  # Only interpolate if length changes and is valid\n                    x_original = np.arange(original_len)\n                    x_resampled = np.linspace(0, original_len - 1, target_len)\n                    resampled_audio_np = np.interp(x_resampled, x_original, output_audio_np)\n                    output_audio = (\n                        output_sr,\n                        resampled_audio_np.astype(np.float32),\n                    )  # Use resampled audio\n                    print(\n                        f\"Resampled audio from {original_len} to {target_len} samples for {speed_factor:.2f}x speed.\"\n                    )\n                else:\n                    output_audio = (\n                        output_sr,\n                        output_audio_np,\n                    )  # Keep original if calculation fails or no change\n                    print(f\"Skipping audio speed adjustment (factor: {speed_factor:.2f}).\")\n                # --- End slowdown ---\n\n                print(f\"Audio conversion successful. Final shape: {output_audio[1].shape}, Sample Rate: {output_sr}\")\n\n                # Explicitly convert to int16 to prevent Gradio warning\n                if output_audio[1].dtype == np.float32 or output_audio[1].dtype == np.float64:\n                    audio_for_gradio = np.clip(output_audio[1], -1.0, 1.0)\n                    audio_for_gradio = (audio_for_gradio * 32767).astype(np.int16)\n                    output_audio = (output_sr, audio_for_gradio)\n                    print(\"Converted audio to int16 for Gradio output.\")\n\n            else:\n                print(\"\\nGeneration finished, but no valid tokens were produced.\")\n                # Return default silence\n                gr.Warning(\"Generation produced no output.\")\n\n        except Exception as e:\n            print(f\"Error during inference: {e}\")\n            import traceback\n\n            traceback.print_exc()\n            # Re-raise as Gradio error to display nicely in the UI\n            raise gr.Error(f\"Inference failed: {e}\")\n\n        finally:\n            # Cleanup Temporary Files defensively\n            if temp_txt_file_path and Path(temp_txt_file_path).exists():\n                try:\n                    Path(temp_txt_file_path).unlink()\n                    print(f\"Deleted temporary text file: {temp_txt_file_path}\")\n                except OSError as e:\n                    print(f\"Warning: Error deleting temporary text file {temp_txt_file_path}: {e}\")\n            if temp_audio_prompt_path and Path(temp_audio_prompt_path).exists():\n                try:\n                    Path(temp_audio_prompt_path).unlink()\n                    print(f\"Deleted temporary audio prompt file: {temp_audio_prompt_path}\")\n                except OSError as e:\n                    print(f\"Warning: Error deleting temporary audio prompt file {temp_audio_prompt_path}: {e}\")\n\n        # After generation, capture the printed output\n        console_output = console_output_buffer.getvalue()\n\n    return output_audio, seed, console_output", "label": 0}
{"function": "def check_couchbase_buckets_items(_item, params, data):\n\n    total_items = data.get(\"curr_items_tot\")\n    if total_items is not None:\n        yield check_levels(\n            int(total_items),\n            \"items_count\",\n            params.get('curr_items_tot'),\n            infoname=\"Total items in vBuckets\",\n            human_readable_func=str,\n        )\n\n    write_queue = data.get(\"disk_write_queue\")\n    if write_queue is not None:\n        yield check_levels(\n            int(write_queue),\n            \"disk_write_ql\",\n            params.get(\"disk_write_ql\"),\n            infoname=\"Items in disk write queue\",\n            human_readable_func=str,\n        )\n\n    fetched = data.get(\"ep_bg_fetched\")\n    if fetched is not None:\n        yield check_levels(\n            int(fetched),\n            \"fetched_items\",\n            params.get(\"fetched_items\"),\n            infoname=\"Items fetched from disk\",\n            human_readable_func=str,\n        )\n\n    queue_fill = data.get(\"ep_diskqueue_fill\")\n    if queue_fill is not None:\n        yield check_levels(\n            queue_fill,\n            \"disk_fill_rate\",\n            params.get(\"disk_fill_rate\"),\n            unit=\"/s\",\n            infoname=\"Disk queue fill rate\",\n        )\n\n    queue_drain = data.get(\"ep_diskqueue_drain\")\n    if queue_drain is not None:\n        yield check_levels(\n            queue_drain,\n            \"disk_drain_rate\",\n            params.get(\"disk_drain_rate\"),\n            unit=\"/s\",\n            infoname=\"Disk queue drain rate\",\n        )", "label": 1}
{"function": "    def setUp(self):\n        self.test_db = cache.init_test_db()", "label": 0}
{"function": "    def __init__(self, real, timeperiod=30):\n        pass", "label": 1}
{"function": "    def on_status_button(self, button):\n        '''\n        Invoked when the user clicks the state button to the left of the\n        dropdown.\n        '''\n        # toggle the control's status state\n        isavail = StatusMessage.is_available_state(self.status_state)\n\n        # do we need to change the shown text?\n        needs_change = self._shown_status in StatusMessage.SpecialStatuses or not self._shown_status.editable\n\n        self.oldValue = None\n\n        self.change_state(state = 'Away' if isavail else 'Available',)", "label": 1}
{"function": "def update_module_description(module_name: str) -> str:\n    \"\"\"Return the description of the selected module\"\"\"\n    return MODULE_DESCRIPTIONS.get(module_name, \"No description available\")", "label": 0}
{"function": "def do_not_run_on_check():\n    \"\"\"\n    Do not execute task file on check\n    \"\"\"\n    print(\"#educational_plugin DO_NOT_RUN_ON_CHECK\")", "label": 1}
{"function": "    def test_query_level_multiple(self):\n        \"\"\"\n        wineventlog - Query by level (error, warning)\n        \"\"\"\n        self.write_event_log(\n            \"success\", level=win32evtlog.EVENTLOG_SUCCESS)  # Level 0, Info\n        self.write_event_log(\n            \"error\", level=win32evtlog.EVENTLOG_ERROR_TYPE)  # Level 2\n        self.write_event_log(\n            \"warning\", level=win32evtlog.EVENTLOG_WARNING_TYPE)  # Level 3\n        self.write_event_log(\n            \"information\", level=win32evtlog.EVENTLOG_INFORMATION_TYPE)  # Level 4\n        evts = self.read_events(config={\n            \"event_logs\": [\n                {\n                    \"name\": self.providerName,\n                    \"api\": self.api,\n                    \"level\": \"error, warning\"\n                }\n            ]\n        }, expected_events=2)\n        self.assertTrue(len(evts), 2)\n        self.assertEqual(evts[0][\"log.level\"], \"error\")\n        self.assertEqual(evts[1][\"log.level\"], \"warning\")", "label": 1}
{"function": "    def add_role_to_user(admin_user_id: int, username: str, role: str):\n        \"\"\"\n        Add role to user\n        :param admin_user_id: ID of admin attempting to add the role\n        :param username: Username of user the role should be added to\n        :param role: The requested role\n        :raises UserServiceError\n        \"\"\"\n        try:\n            requested_role = UserRole[role.upper()]\n        except KeyError:\n            raise UserServiceError(\n                f\"Unknown role {role} accepted values are ADMIN, PROJECT_MANAGER, VALIDATOR\"\n            )\n\n        admin = UserService.get_user_by_id(admin_user_id)\n        admin_role = UserRole(admin.role)\n\n        if admin_role != UserRole.ADMIN and requested_role == UserRole.ADMIN:\n            raise UserServiceError(\"You must be an Admin to assign Admin role\")\n\n        user = UserService.get_user_by_username(username)\n        user.set_user_role(requested_role)", "label": 1}
{"function": "def apply_single_tag_set(tag_set, selection):\n    \"\"\"All servers matching one tag set.\n\n    A tag set is a dict. A server matches if its tags are a superset:\n    A server tagged {'a': '1', 'b': '2'} matches the tag set {'a': '1'}.\n\n    The empty tag set {} matches any server.\n    \"\"\"\n    def tags_match(server_tags):\n        for key, value in tag_set.items():\n            if key not in server_tags or server_tags[key] != value:\n                return False\n\n        return True\n\n    return selection.with_server_descriptions(\n        [s for s in selection.server_descriptions if tags_match(s.tags)])", "label": 1}
{"function": "    def digest(self):\n        return lmhash.encrypt(self._data[:15]).decode('hex')", "label": 1}
{"function": "    def export_spectrogram(self, spec, file_spec):\n        save_spectrogram(spec, file_spec)", "label": 0}
{"function": "    def repr_set(self, x, level):\n        if not x:\n            return 'set()'\n        x = _possibly_sorted(x)\n        return self._repr_iterable(x, level, '{', '}', self.maxset)", "label": 1}
{"function": "def test_is_in_or_part_overlap(box1: tuple, box2: tuple, target_bool: bool) -> None:\n    \"\"\"\n    box1: \u5750\u6807\u6570\u7ec4\n    box2: \u5750\u6807\u6570\u7ec4\n    \"\"\"\n    assert target_bool == _is_in_or_part_overlap(box1, box2)", "label": 0}
{"function": "def start_server(host, port, processor):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind((host, port))\n        s.listen()\n        logger.info(f\"Server started on {host}:{port}\")\n        while True:\n            conn, addr = s.accept()\n            logger.info(f\"Connected by {addr}\")\n            handle_client(conn, processor)", "label": 0}
{"function": "    def __mul__(self, other):\n        if isinstance(other, Quaternion):\n            return self.__class__(array=np.dot(self._q_matrix(), other.q))\n        return self * self.__class__(other)", "label": 1}
{"function": "def load_json_file(json_file: str) -> dict:\n    with open(json_file, 'r', encoding='utf-8') as file:\n        return json.load(file)", "label": 0}
{"function": "    def set_repository(self, *args, **kwargs):\n        \"\"\"\n        Alias for :meth:`Client.get_or_create_repository()`.\n\n        \"\"\"\n        return self.get_or_create_repository(*args, **kwargs)", "label": 1}
{"function": "    def testBadUTFSurrogatePairsGeneration(self):\n        local_pdf_path = os.path.join(os.path.dirname(__file__), \"gnarly_pdfs\", \"badlines.pdf\")\n\n        anchor_text = get_anchor_text(local_pdf_path, 4, pdf_engine=\"pdfreport\")\n\n        jsondata = json.dumps({\"text\": anchor_text})\n\n        import pyarrow as pa\n        import pyarrow.compute as pc\n        import pyarrow.json as paj\n\n        buffer = io.BytesIO(jsondata.encode(\"utf-8\"))\n        paj.read_json(buffer, read_options=paj.ReadOptions(use_threads=False, block_size=len(jsondata)))", "label": 0}
{"function": "def test_record_and_resume(tmp_path):\n    robot_cfg = MockRobotConfig()\n    teleop_cfg = MockTeleopConfig()\n    dataset_cfg = DatasetRecordConfig(\n        repo_id=DUMMY_REPO_ID,\n        single_task=\"Dummy task\",\n        root=tmp_path / \"record\",\n        num_episodes=1,\n        episode_time_s=0.1,\n        reset_time_s=0,\n        push_to_hub=False,\n    )\n    cfg = RecordConfig(\n        robot=robot_cfg,\n        dataset=dataset_cfg,\n        teleop=teleop_cfg,\n        play_sounds=False,\n    )\n\n    dataset = record(cfg)\n\n    assert dataset.fps == 30\n    assert dataset.meta.total_episodes == dataset.num_episodes == 1\n    assert dataset.meta.total_frames == dataset.num_frames == 3\n    assert dataset.meta.total_tasks == 1\n\n    cfg.resume = True\n    dataset = record(cfg)\n\n    assert dataset.meta.total_episodes == dataset.num_episodes == 2\n    assert dataset.meta.total_frames == dataset.num_frames == 6\n    assert dataset.meta.total_tasks == 1", "label": 0}
{"function": "  def _log_cdf(self, x):\n    x = control_flow_ops.with_dependencies([check_ops.assert_positive(x)] if\n                                           self.validate_args else [], x)\n    contrib_tensor_util.assert_same_float_dtype(tensors=[x], dtype=self.dtype)\n    # Note that igamma returns the regularized incomplete gamma function,\n    # which is what we want for the CDF.\n    return math_ops.log(math_ops.igamma(self.alpha, self.beta * x))", "label": 1}
{"function": "def clean_bigvgan_model():\r\n    global bigvgan_model\r\n    if bigvgan_model:\r\n        bigvgan_model = bigvgan_model.cpu()\r\n        bigvgan_model = None\r\n        try:\r\n            torch.cuda.empty_cache()\r\n        except:\r\n            pass\r", "label": 0}
{"function": "def clear_span_processor():\n    SPAN_PROCESSOR_TESTING.force_flush()\n    SPAN_PROCESSOR_TESTING.shutdown()\n    SPAN_PROCESSOR_TESTING.clear()", "label": 0}
{"function": "def union_tensor_dict(tensor_dict1: TensorDict, tensor_dict2: TensorDict) -> TensorDict:\n    \"\"\"Union two tensordicts.\"\"\"\n    assert tensor_dict1.batch_size == tensor_dict2.batch_size, \\\n        f'Two tensor dict must have identical batch size. Got {tensor_dict1.batch_size} and {tensor_dict2.batch_size}'\n    for key in tensor_dict2.keys():\n        if key not in tensor_dict1.keys():\n            tensor_dict1[key] = tensor_dict2[key]\n        else:\n            assert tensor_dict1[key].equal(tensor_dict2[key]), \\\n                f'{key} in tensor_dict1 and tensor_dict2 are not the same object'\n\n    return tensor_dict1", "label": 0}
{"function": "    def clean(self):\n        cleaned_data = self.cleaned_data\n        field_function = cleaned_data.get(\"field_function\")\n        choices = cleaned_data.get(\"choices\")\n        field_type = cleaned_data.get(\"field_type\")\n        #required = cleaned_data.get(\"required\")\n        visible = cleaned_data.get(\"visible\")\n\n        if field_function == \"GroupSubscription\":\n            if field_type != \"BooleanField\":\n                raise forms.ValidationError(_(\"This field's function requires Checkbox as a field type\"))\n            if not choices:\n                raise forms.ValidationError(_(\"This field's function requires at least 1 group specified.\"))\n            else:\n                for val in choices.split(','):\n                    try:\n                        g = Group.objects.get(name=val.strip())\n                        if not g.allow_self_add:\n                            raise forms.ValidationError(_(\"The group \\\"%(val)s\\\" does not allow self-add.\" % { 'val' : val }))\n                    except Group.DoesNotExist:\n                        raise forms.ValidationError(_(\"The group \\\"%(val)s\\\" does not exist\" % { 'val' : val }))\n\n        if field_function == \"GroupSubscriptionAuto\":\n            # field_type doesn't matter since this field shouldn't be rendered anyway.\n            if visible:\n                raise forms.ValidationError(_(\"This field must not be visible to users.\"))\n            if not choices:\n                raise forms.ValidationError(_(\"This field's function requires at least 1 group specified.\"))\n            else:\n                for val in choices.split(','):\n                    try:\n                        g = Group.objects.get(name=val.strip())\n                        if not g.allow_self_add:\n                            raise forms.ValidationError(_(\"The group \\\"%(val)s\\\" does not allow self-add.\" % { 'val' : val }))\n                    except Group.DoesNotExist:\n                        raise forms.ValidationError(_(\"The group \\\"%(val)s\\\" does not exist\" % { 'val' : val }))\n\n        if field_function == \"Recipients\":\n            if (field_type != \"MultipleChoiceField/django.forms.CheckboxSelectMultiple\" and\n                field_type != \"MultipleChoiceField\" and\n                field_type != \"BooleanField\" and\n                field_type != \"ChoiceField\"):\n                raise forms.ValidationError(_(\"The \\\"Email to Recipients\\\" function requires Multi-select - Checkboxes \"\n                                            + \"or Multi-select - Select Many as field type\"))\n\n            if field_type == \"BooleanField\":\n                if not choices:\n                    raise forms.ValidationError(_(\"The \\\"Email to Recipients\\\" function requires at least 1 email specified.\"))\n                else:\n                    for val in choices.split(','):\n                        if not validate_email(val.strip()):\n                            raise forms.ValidationError(_(\"\\\"%(val)s\\\" is not a valid email address\" % {'val':val}))\n            else:\n                if not choices:\n                    raise forms.ValidationError(_(\"The \\\"Email to Recipients\\\" function requires at least 1 choice specified.\"))\n                else:\n                    for val in choices.split(','):\n                        val = val.split(':')\n                        if len(val) < 2:\n                            raise forms.ValidationError(_(\"The \\\"Email to Recipients\\\" function requires choices to be in the following format: <choice_label>:<email_address>.\"))\n                        if not validate_email(val[1].strip()):\n                            raise forms.ValidationError(_(\"\\\"%(val)s\\\" is not a valid email address\" % {'val':val[1]}))\n\n        if field_function is not None and field_function.startswith(\"Email\"):\n            if field_type != \"CharField\":\n                raise forms.ValidationError(_(\"This field's function requires Text as a field type\"))\n\n        #unrequire the display only fields\n        if field_type == \"CharField/tendenci.apps.forms_builder.forms.widgets.Description\":\n            cleaned_data['required'] = False\n        elif field_type == \"CharField/tendenci.apps.forms_builder.forms.widgets.Header\":\n            cleaned_data['required'] = False\n\n        return cleaned_data", "label": 1}
{"function": "    def _unwrap_object(self, space, w_obj):\n        return space.uint_w(w_obj)", "label": 1}
{"function": "    def __init__(\n        self,\n        role: str,\n        raw_utterance: str,\n        utterance_type: str,\n        claim_to_make: Optional[str] = None,\n        utterance: Optional[str] = None,\n        queries: Optional[List[str]] = None,\n        raw_retrieved_info: Optional[List[Information]] = None,\n        cited_info: Optional[List[Information]] = None,\n    ):\n        self.utterance = utterance if utterance is not None else raw_utterance\n        self.raw_utterance = raw_utterance\n        self.role = role if \":\" not in role else role.split(\":\")[0]\n        self.role_description = \"\" if \":\" not in role else role.split(\":\")[1]\n        self.queries = queries if queries is not None else []\n        self.raw_retrieved_info = (\n            raw_retrieved_info if raw_retrieved_info is not None else []\n        )\n        self.cited_info = cited_info if cited_info is not None else {}\n        self.utterance_type = utterance_type\n        self.claim_to_make = claim_to_make if claim_to_make is not None else \"\"", "label": 0}
{"function": "    def is_child_right(self, ind):\n        # Check if second child exists\n        return self.child_right(ind) < len(self.array)", "label": 1}
{"function": "    def test_repo_updateurl_noargs(self, shell):\n        \"\"\"\n        Test do_repo_updateurl no arguments.\n\n        :param shell:\n        :return:\n        \"\"\"\n        for arg in [\"\", \"repo\", \"http://foo\", \"http://bar\"]:\n            shell.help_repo_updateurl = MagicMock()\n            shell.client.channel.software.updateRepUrl = MagicMock()\n            shell.do_repo_list = MagicMock()\n            mprint = MagicMock()\n            logger = MagicMock()\n\n            with patch(\"spacecmd.repo.print\", mprint) as prn, \\\n                    patch(\"spacecmd.repo.logging\", logger) as lgr:\n                out = spacecmd.repo.do_repo_updateurl(shell, \"\")\n\n            assert out is 1\n            assert not mprint.called\n            assert not logger.error.called\n            assert not shell.client.channel.software.updateRepUrl.called\n            assert shell.help_repo_updateurl.called", "label": 1}
{"function": "def normalizer_en_nemo_text() -> Callable[[str], str]:\n    from nemo_text_processing.text_normalization.normalize import Normalizer\n\n    return partial(\n        Normalizer(input_case=\"cased\", lang=\"en\").normalize,\n        verbose=False,\n        punct_post_process=True,\n    )", "label": 0}
{"function": "    def _load_dotted_module_py2(self, short_name, full_name, searchpaths=None):\n        import imp\n\n        splitname = short_name.split('.')\n        index = 0\n        srchpths = searchpaths\n        for item in splitname:\n            file, path, desc = imp.find_module(item, srchpths)\n            mod = imp.load_module(full_name, file, path, desc)\n            srchpths = [path]\n        return mod, file", "label": 1}
{"function": "def save_json_file(json_file: str, data: dict) -> None:\n    with open(json_file, 'w', encoding='utf-8') as file:\n        json.dump(data, file, ensure_ascii=False, indent=4)", "label": 0}
{"function": "def wrap_question_for_omni_lmm(question, image_token_len, tokenizer):\n    question = expand_question_into_multimodal(\n        question, image_token_len, DEFAULT_IM_START_TOKEN, DEFAULT_IM_END_TOKEN, DEFAULT_IMAGE_PATCH_TOKEN)\n\n    conversation = question\n    data_dict = omni_preprocess(sources=[conversation],\n                                  tokenizer=tokenizer,\n                                  generation=True)\n\n    data_dict = dict(input_ids=data_dict[\"input_ids\"][0],\n                     labels=data_dict[\"labels\"][0])\n    return data_dict", "label": 0}
{"function": "    def _tool_module(self):\n        oldpythonpath = sys.path\n        sys.path = self.toolpath + sys.path\n        # sys.stderr.write(\"Tool:%s\\nPATH:%s\\n\"%(self.name,sys.path))\n\n        # From: http://stackoverflow.com/questions/67631/how-to-import-a-module-given-the-full-path/67692#67692\n        # import importlib.util\n        # spec = importlib.util.spec_from_file_location(\"module.name\", \"/path/to/file.py\")\n        # foo = importlib.util.module_from_spec(spec)\n        # spec.loader.exec_module(foo)\n        # foo.MyClass()\n        # Py 3 code\n\n\n        # sys.stderr.write(\"toolpath:%s\\n\" % self.toolpath)\n        # sys.stderr.write(\"SCONS.TOOL path:%s\\n\" % sys.modules['SCons.Tool'].__path__)\n        debug = False\n        spec = None\n        found_name = self.name\n        add_to_scons_tools_namespace = False\n        for path in self.toolpath:\n            sepname = self.name.replace('.', os.path.sep)\n            file_path = os.path.join(path, \"%s.py\" % sepname)\n            file_package = os.path.join(path, sepname)\n\n            if debug: sys.stderr.write(\"Trying:%s %s\\n\" % (file_path, file_package))\n\n            if os.path.isfile(file_path):\n                spec = importlib.util.spec_from_file_location(self.name, file_path)\n                if debug: print(\"file_Path:%s FOUND\" % file_path)\n                break\n            elif os.path.isdir(file_package):\n                file_package = os.path.join(file_package, '__init__.py')\n                spec = importlib.util.spec_from_file_location(self.name, file_package)\n                if debug: print(\"PACKAGE:%s Found\" % file_package)\n                break\n\n            else:\n                continue\n\n        if spec is None:\n            if debug: sys.stderr.write(\"NO SPEC :%s\\n\" % self.name)\n            spec = importlib.util.find_spec(\".\" + self.name, package='SCons.Tool')\n            if spec:\n                found_name = 'SCons.Tool.' + self.name\n                add_to_scons_tools_namespace = True\n            if debug: sys.stderr.write(\"Spec Found? .%s :%s\\n\" % (self.name, spec))\n\n        if spec is None:\n            sconstools = os.path.normpath(sys.modules['SCons.Tool'].__path__[0])\n            if self.toolpath:\n                sconstools = \", \".join(self.toolpath) + \", \" + sconstools\n            error_string = \"No tool module '%s' found in %s\" % (self.name, sconstools)\n            raise SCons.Errors.UserError(error_string)\n\n        module = importlib.util.module_from_spec(spec)\n        if module is None:\n            if debug: print(\"MODULE IS NONE:%s\" % self.name)\n            error_string = \"Tool module '%s' failed import\" % self.name\n            raise SCons.Errors.SConsEnvironmentError(error_string)\n\n        # Don't reload a tool we already loaded.\n        sys_modules_value = sys.modules.get(found_name, False)\n\n        found_module = None\n        if sys_modules_value and sys_modules_value.__file__ == spec.origin:\n            found_module = sys.modules[found_name]\n        else:\n            # Not sure what to do in the case that there already\n            # exists sys.modules[self.name] but the source file is\n            # different.. ?\n            module = spec.loader.load_module(spec.name)\n\n            sys.modules[found_name] = module\n            if add_to_scons_tools_namespace:\n                # If we found it in SCons.Tool, then add it to the module\n                setattr(SCons.Tool, self.name, module)\n\n            found_module = module\n\n        if found_module is not None:\n            sys.path = oldpythonpath\n            return found_module\n\n        sys.path = oldpythonpath\n\n        full_name = 'SCons.Tool.' + self.name\n        try:\n            return sys.modules[full_name]\n        except KeyError:\n            try:\n                smpath = sys.modules['SCons.Tool'].__path__\n                try:\n                    module, file = self._load_dotted_module_py2(self.name, full_name, smpath)\n                    setattr(SCons.Tool, self.name, module)\n                    if file:\n                        file.close()\n                    return module\n                except ImportError as e:\n                    if str(e) != \"No module named %s\" % self.name:\n                        raise SCons.Errors.SConsEnvironmentError(e)\n                    try:\n                        import zipimport\n                        importer = zipimport.zipimporter(sys.modules['SCons.Tool'].__path__[0])\n                        module = importer.load_module(full_name)\n                        setattr(SCons.Tool, self.name, module)\n                        return module\n                    except ImportError as e:\n                        m = \"No tool named '%s': %s\" % (self.name, e)\n                        raise SCons.Errors.SConsEnvironmentError(m)\n            except ImportError as e:\n                m = \"No tool named '%s': %s\" % (self.name, e)\n                raise SCons.Errors.SConsEnvironmentError(m)", "label": 1}
{"function": "    def __init__(self, content: str):\n        super().__init__({\"choices\": [{\"message\": {\"content\": content}}], \"usage\": {}})\n        self.choices = [types.SimpleNamespace(message=types.SimpleNamespace(content=content))]", "label": 0}
{"function": "def signal_handler(sig, frame):\n    print(\"Ctrl+C pressed, shutting down server...\")\n    sys.exit(0)", "label": 0}
{"function": "    def test_atomic_max_nan_val(self):\n        res = np.random.randint(0, 128, size=1).astype(np.float64)\n        gold = res.copy()\n        vals = np.zeros((1, 1), np.float64) + np.nan\n        cuda_func = cuda.jit('void(float64[:], float64[:,:])')(atomic_max)\n        cuda_func[1, 1](res, vals)\n\n        np.testing.assert_equal(res, gold)", "label": 1}
{"function": "    def __le__(self, other: Any) -> bool: ...", "label": 1}
{"function": "    def coerce(cls, key, value):\n        \"\"\"Convert plain lists to MutableList.\"\"\"\n        if not isinstance(value, MutableList):\n            if isinstance(value, list):\n                return MutableList(value)\n\n            # this call will raise ValueError\n            return mutable.Mutable.coerce(key, value)\n        return value", "label": 1}
{"function": "def test_cli_writes_file(\n    tmp_path: Path,\n    monkeypatch: pytest.MonkeyPatch,\n    *,\n    cli_args: list[str],\n    expect_file: bool,\n) -> None:\n    \"\"\"Run the CLI and verify that the SARIF file is created (or not).\"\"\"\n    expectes_exit_code = 0\n    # Work inside an isolated temp directory\n    monkeypatch.chdir(tmp_path)\n\n    result = _invoke_isolated_cli_runner(cli_args)\n\n    assert result.exit_code == expectes_exit_code, result.stderr\n\n    # Summary line should be on STDOUT\n    stdout_lines = result.stdout.splitlines()\n    assert f\"Analysis complete! Output written to: {OUTPUT_FILE_NAME}\" in stdout_lines\n\n    # File side-effect\n    sarif_file = tmp_path / OUTPUT_FILE_NAME\n    assert sarif_file.exists() is expect_file, f\"{OUTPUT_FILE_NAME} existence did not match expectation\"", "label": 0}
{"function": "    def _buildTagListRequest(self, programName):\n        \"\"\"\n        Build the request for the PLC tags\n        Program scoped tags will pass the program name for the request\n        \"\"\"\n        Service = 0x55\n        PathSegment = b\"\"\n\n        # If we're dealing with program scoped tags...\n        if programName:\n            PathSegment = pack('<BB', 0x91, len(programName)) + programName.encode('utf-8')\n            # if odd number of characters, need to add a byte to the end.\n            if len(programName) % 2:\n                PathSegment += pack('<B', 0x00)\n\n        PathSegment += pack('<H', 0x6B20)\n\n        if self.Offset < 256:\n            PathSegment += pack('<BB', 0x24, self.Offset)\n        else:\n            PathSegment += pack('<HH', 0x25, self.Offset)\n\n        PathSegmentLen = int(len(PathSegment)/2)\n        AttributeCount = 0x03\n        SymbolType = 0x02\n        ByteCount = 0x08\n        SymbolName = 0x01\n        Attributes = pack('<HHHH', AttributeCount, SymbolName, SymbolType, ByteCount)\n        TagListRequest = pack('<BB', Service, PathSegmentLen)\n        TagListRequest += PathSegment + Attributes\n\n        return TagListRequest", "label": 1}
{"function": "def is_full(*items):  # \u4efb\u610f\u4e00\u9879\u4e3a\u7a7a\u8fd4\u56deFalse\r\n    for item in items:\r\n        if item is None or item == \"\":\r\n            return False\r\n    return True\r", "label": 0}
{"function": "async def run() -> None:\n    file_name = \"skyvern_screenshot.png\"\n    png_file_path = f\"{get_skyvern_temp_dir()}/{file_name}\"\n\n    while True:\n        # run subprocess to take screenshot\n        subprocess.run(\n            f\"xwd -root | xwdtopnm 2>/dev/null | pnmtopng > {png_file_path}\", shell=True, env={\"DISPLAY\": \":99\"}\n        )\n\n        # FIXME: upload screenshot to S3 with correct organization id\n        try:\n            await app.STORAGE.save_streaming_file(\"placeholder_org\", file_name)\n        except Exception:\n            LOG.info(\"Failed to save screenshot\")\n\n        await asyncio.sleep(INTERVAL)", "label": 0}
{"function": "    def dump_options(self, header=None, indent=\"\"):\n        from distutils.fancy_getopt import longopt_xlate\n        if header is None:\n            header = \"command options for '%s':\" % self.get_command_name()\n        self.announce(indent + header, level=log.INFO)\n        indent = indent + \"  \"\n        for (option, _, _) in self.user_options:\n            option = option.translate(longopt_xlate)\n            if option[-1] == \"=\":\n                option = option[:-1]\n            value = getattr(self, option)\n            self.announce(indent + \"%s = %s\" % (option, value),\n                          level=log.INFO)", "label": 1}
{"function": "async def run_drift_search(\n    query: str,\n    sv: SessionVariables,\n) -> SearchResult:\n    \"\"\"Run drift search.\"\"\"\n    print(f\"Drift search query: {query}\")  # noqa T201\n\n    # build drift search engine\n    response_placeholder = st.session_state[\n        f\"{SearchType.Drift.value.lower()}_response_placeholder\"\n    ]\n    response_container = st.session_state[f\"{SearchType.Drift.value.lower()}_container\"]\n\n    with response_placeholder, st.spinner(\"Generating answer using drift search...\"):\n        empty_context_data: dict[str, pd.DataFrame] = {}\n\n        response, context_data = await api.drift_search(\n            config=sv.graphrag_config.value,\n            entities=sv.entities.value,\n            communities=sv.communities.value,\n            community_reports=sv.community_reports.value,\n            text_units=sv.text_units.value,\n            relationships=sv.relationships.value,\n            community_level=sv.dataset_config.value.community_level,\n            response_type=\"Multiple Paragraphs\",\n            query=query,\n        )\n\n        print(f\"Drift Response: {response}\")  # noqa T201\n        print(f\"Context data: {context_data}\")  # noqa T201\n\n    # display response and reference context to UI\n    search_result = SearchResult(\n        search_type=SearchType.Drift,\n        response=str(response),\n        context=context_data if isinstance(context_data, dict) else empty_context_data,\n    )\n\n    display_search_result(\n        container=response_container, result=search_result, stats=None\n    )\n\n    if \"response_lengths\" not in st.session_state:\n        st.session_state.response_lengths = []\n\n    st.session_state[\"response_lengths\"].append({\n        \"result\": None,\n        \"search\": SearchType.Drift.value.lower(),\n    })\n\n    return search_result", "label": 0}
{"function": "    def append_message(self, role: str, message: str):\n        \"\"\"Append a new message.\"\"\"\n        self.messages.append([role, message])", "label": 0}
{"function": "def register_get():\n    return {}", "label": 1}
{"function": "def get_content_for_indices(files_data, indices):\n    content_map = {}\n    for i in indices:\n        if 0 <= i < len(files_data):\n            path, content = files_data[i]\n            content_map[f\"{i} # {path}\"] = (\n                content  # Use index + path as key for context\n            )\n    return content_map", "label": 0}
{"function": "def elbo(q, p, sample_dim=None, batch_dim=None, alpha=0.1,\n         size_average=True, reduce=True):\n    r\"\"\"Calculates an importance weighted Monte Carlo estimate of the\n    semi-supervised evidence lower bound (ELBO)\n\n    .. math:: \\frac{1}{B} \\sum_{b=1}^B\n              \\log \\left[\n                \\frac{1}{S} \\sum_{s=1}^S\n                \\frac{p(x^{(b)}, y^{(b)}, z^{(s,b)})}\n                     {q(z^{(s,b)} | x^{(b)})}\n              \\right]\n              + \\frac{\\alpha}{B} \\sum_{b=1}^B\n              \\log \\left[\n                \\frac{1}{S} \\sum_{s=1}^S\n                \\frac{q(y^{(b)}, z^{(s,b)} | x^{(b)})}\n                     {q(z^{(s,b)} | x^{(b)})}\n              \\right]\n\n    The sets of variables :math:`x`, :math:`y` and :math:`z` refer to:\n\n        :math:`x`: The set of conditioned nodes that are present in `p` but\n        are not present in `q`.\n\n        :math:`y`: The set of conditioned nodes in `q`, which may or may\n        not also be present in `q`.\n\n        :math:`z`: The set of sampled nodes present in both `q` and `p`.\n\n    Arguments:\n        q(:obj:`Trace`): The encoder trace.\n        p(:obj:`Trace`): The decoder trace.\n        sample_dim(int, optional): The dimension containing individual samples.\n        batch_dim(int, optional): The dimension containing batch items.\n        alpha(float, default 0.1): Coefficient for the ML term.\n        size_average (bool, optional): By default, the objective is averaged\n            over items in the minibatch. When set to false, the objective is\n            instead summed over the minibatch.\n        reduce (bool, optional): By default, the objective is averaged or\n           summed over items in the minibatch. When reduce is False, losses\n           are returned without averaging or summation.\n    \"\"\"\n    z = [n for n in q.sampled() if n in p]\n    log_pxyz = p.log_joint(sample_dim, batch_dim)\n    log_qz = q.log_joint(sample_dim, batch_dim, z)\n    log_qy = q.log_joint(sample_dim, batch_dim, q.conditioned())\n    log_pq = (log_pxyz - log_qz)\n    if sample_dim is None:\n        objective = log_pq + alpha * log_qy\n    else:\n        objective = log_mean_exp(log_pq, 0)\n        if not isinstance(log_qy, Number):\n            objective = objective + alpha * log_mean_exp(log_qy, 0)\n    if reduce:\n        objective = objective.mean() if size_average else objective.sum()\n    return objective", "label": 1}
{"function": "def _assert_not_shallow(request):\n    if request.shallow:\n        raise RuntimeError('A shallow request tried to consume '\n                           'form data.  If you really want to do '\n                           'that, set `shallow` to False.')", "label": 1}
{"function": "async def test_simple_echo():\n    \"\"\"Test the simple echo server\"\"\"\n    from examples.simple_echo import mcp\n\n    async with Client(mcp) as client:\n        result = await client.call_tool_mcp(\"echo\", {\"text\": \"hello\"})\n        assert len(result.content) == 1\n        assert result.content[0].text == \"hello\"  # type: ignore[attr-defined]", "label": 0}
{"function": "def _test__xla_dist_model_create_from_context_in_child_proc(index):\n    model = _XlaDistModel.create_from_context()\n\n    assert model.backend() == \"xla-tpu\"\n\n    import torch_xla.core.xla_model as xm\n\n    _assert_model(\n        model,\n        {\n            \"device\": xm.xla_device(),\n            \"local_rank\": index,\n            \"rank\": xm.get_ordinal(),\n            \"world_size\": xm.xrt_world_size(),\n            \"node_index\": 0,\n            \"nnodes\": 1,\n            \"nproc_per_node\": xm.xrt_world_size(),\n        },\n    )", "label": 1}
{"function": "def create_resume_pdf(parameters: dict, llm_api_key: str):\n    \"\"\"\n    Logic to create a CV.\n    \"\"\"\n    try:\n        logger.info(\"Generating a CV based on provided parameters.\")\n\n        # Load the plain text resume\n        with open(parameters[\"uploads\"][\"plainTextResume\"], \"r\", encoding=\"utf-8\") as file:\n            plain_text_resume = file.read()\n\n        # Initialize StyleManager\n        style_manager = StyleManager()\n        available_styles = style_manager.get_styles()\n\n        if not available_styles:\n            logger.warning(\"No styles available. Proceeding without style selection.\")\n        else:\n            # Present style choices to the user\n            choices = style_manager.format_choices(available_styles)\n            questions = [\n                inquirer.List(\n                    \"style\",\n                    message=\"Select a style for the resume:\",\n                    choices=choices,\n                )\n            ]\n            style_answer = inquirer.prompt(questions)\n            if style_answer and \"style\" in style_answer:\n                selected_choice = style_answer[\"style\"]\n                for style_name, (file_name, author_link) in available_styles.items():\n                    if selected_choice.startswith(style_name):\n                        style_manager.set_selected_style(style_name)\n                        logger.info(f\"Selected style: {style_name}\")\n                        break\n            else:\n                logger.warning(\"No style selected. Proceeding with default style.\")\n\n        # Initialize the Resume Generator\n        resume_generator = ResumeGenerator()\n        resume_object = Resume(plain_text_resume)\n        driver = init_browser()\n        resume_generator.set_resume_object(resume_object)\n\n        # Create the ResumeFacade\n        resume_facade = ResumeFacade(\n            api_key=llm_api_key,\n            style_manager=style_manager,\n            resume_generator=resume_generator,\n            resume_object=resume_object,\n            output_path=Path(\"data_folder/output\"),\n        )\n        resume_facade.set_driver(driver)\n        result_base64 = resume_facade.create_resume_pdf()\n\n        # Decode Base64 to binary data\n        try:\n            pdf_data = base64.b64decode(result_base64)\n        except base64.binascii.Error as e:\n            logger.error(\"Error decoding Base64: %s\", e)\n            raise\n\n        # Define the output directory using `suggested_name`\n        output_dir = Path(parameters[\"outputFileDirectory\"])\n\n        # Write the PDF file\n        output_path = output_dir / \"resume_base.pdf\"\n        try:\n            with open(output_path, \"wb\") as file:\n                file.write(pdf_data)\n            logger.info(f\"Resume saved at: {output_path}\")\n        except IOError as e:\n            logger.error(\"Error writing file: %s\", e)\n            raise\n    except Exception as e:\n        logger.exception(f\"An error occurred while creating the CV: {e}\")\n        raise", "label": 0}
{"function": "    def __init__(self):\n        self.on_npu = npu_is_available\n        self.node_world_size = self.N_NPU_PER_NODE\n        self.profiling = False\n        self.profiling_step = 5\n        self.enable_FA = True\n        self.enable_FP32 = False\n        self.load_pickle = True\n        self.use_small_dataset = False\n        self.current_run_dtype = None\n        self.original_run_dtype = None\n        self.zp_manager = zp_manager\n        self.replaced_type = torch.float32\n        self.conv_dtype = torch.float16\n        if self.enable_FA and self.enable_FP32:\n            self.inf_float = -10000.0\n        else:\n            self.inf_float = -10000.0\n\n        if self.use_small_dataset:\n            self.load_pickle = False\n\n        self._loss = []\n        self.work_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n        self.pickle_save_path = f\"{self.work_path}/pickles\"\n        self.mm = dict()\n\n        if self.on_npu:\n            import deepspeed\n            import sys\n            torch_npu.npu.set_compile_mode(jit_compile=False)\n\n            import deepspeed.runtime.utils as utils\n            from opensora.adaptor.utils import all_gather_dp_groups, all_gather_into_tensor_dp_groups\n            utils.all_gather_dp_groups = all_gather_dp_groups\n\n            import deepspeed.runtime.bf16_optimizer as bf16_optimizer\n            from opensora.adaptor.bf16_optimizer import BF16_Optimizer\n            self.replace_methods(bf16_optimizer.BF16_Optimizer, BF16_Optimizer)\n\n            from opensora.adaptor.stage_1_and_2 import DeepSpeedZeroOptimizer\n            import deepspeed.runtime.zero.stage_1_and_2 as stage_1_and_2\n            self.replace_methods(stage_1_and_2.DeepSpeedZeroOptimizer, DeepSpeedZeroOptimizer, ['_has_inf_or_nan'])\n\n            import deepspeed.runtime.engine as engine\n            from opensora.adaptor.engine import DeepSpeedEngine\n            self.replace_methods(engine.DeepSpeedEngine, DeepSpeedEngine, skip_fcns=['__init__', '_copy_recovery_script', '_change_recovery_script_permissions'])\n\n        if \"RANK\" in os.environ:\n            self.rank = int(os.environ[\"RANK\"])\n            self.world_size = int(os.environ[\"WORLD_SIZE\"])\n            torch_npu.npu.set_device(self.get_local_rank())\n        else:\n            self.rank = torch.cuda.current_device()\n            self.world_size = self.N_NPU_PER_NODE\n        self.print_with_rank(f\"The npu_config.on_npu is {self.on_npu}\")\n        self.bind_thread_to_cpu()\n        gc.set_threshold(700, 10, 10000)", "label": 0}
{"function": "    def chat_completion(\n        self,\n        dialogs: List[Dialog],\n        temperature: float = 0.6,\n        top_p: float = 0.9,\n        max_gen_len: Optional[int] = None,\n        logprobs: bool = False,\n    ) -> List[ChatPrediction]:\n        \"\"\"\n        Generate assistant responses for a list of conversational dialogs using the language generation model.\n\n        Args:\n            dialogs (List[Dialog]): List of conversational dialogs, where each dialog is a list of messages.\n            temperature (float, optional): Temperature value for controlling randomness in sampling. Defaults to 0.6.\n            top_p (float, optional): Top-p probability threshold for nucleus sampling. Defaults to 0.9.\n            max_gen_len (Optional[int], optional): Maximum length of the generated response sequence.\n                If not provided, it's set to the model's maximum sequence length minus 1.\n            logprobs (bool, optional): Flag indicating whether to compute token log probabilities. Defaults to False.\n\n        Returns:\n            List[ChatPrediction]: List of chat predictions, each containing the assistant's generated response.\n\n        Note:\n            This method generates assistant responses for the provided conversational dialogs.\n            It employs nucleus sampling to introduce controlled randomness in text generation.\n            If logprobs is True, token log probabilities are computed for each generated token.\n        \"\"\"\n        if max_gen_len is None:\n            max_gen_len = self.model.params.max_seq_len - 1\n\n        prompt_tokens = [\n            self.formatter.encode_dialog_prompt(dialog) for dialog in dialogs\n        ]\n        generation_tokens, generation_logprobs = self.generate(\n            prompt_tokens=prompt_tokens,\n            max_gen_len=max_gen_len,\n            temperature=temperature,\n            top_p=top_p,\n            logprobs=logprobs,\n        )\n        if logprobs:\n            return [\n                {\n                    \"generation\": {\n                        \"role\": \"assistant\",\n                        \"content\": self.tokenizer.decode(t),\n                    },\n                    \"tokens\": [self.tokenizer.decode([x]) for x in t],\n                    \"logprobs\": logprobs_i,\n                }\n                for t, logprobs_i in zip(generation_tokens, generation_logprobs)\n            ]\n        return [\n            {\n                \"generation\": {\n                    \"role\": \"assistant\",\n                    \"content\": self.tokenizer.decode(t),\n                },\n            }\n            for t in generation_tokens\n        ]", "label": 0}
{"function": "def _ExpandDimsGrad(op, grad):\n  return [_ReshapeToInput(op, grad), None]", "label": 1}
{"function": "def test_llm_with_ollama(tester: Crawl4AiTester):\n    print(\"\\n=== Testing LLM with Ollama ===\")\n    schema = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"article_title\": {\n                \"type\": \"string\",\n                \"description\": \"The main title of the news article\",\n            },\n            \"summary\": {\n                \"type\": \"string\",\n                \"description\": \"A brief summary of the article content\",\n            },\n            \"main_topics\": {\n                \"type\": \"array\",\n                \"items\": {\"type\": \"string\"},\n                \"description\": \"Main topics or themes discussed in the article\",\n            },\n        },\n    }\n\n    request = {\n        \"urls\": [\"https://www.nbcnews.com/business\"],\n        \"priority\": 8,\n        \"extraction_config\": {\n            \"type\": \"llm\",\n            \"params\": {\n                \"provider\": \"ollama/llama2\",\n                \"schema\": schema,\n                \"extraction_type\": \"schema\",\n                \"instruction\": \"Extract the main article information including title, summary, and main topics.\",\n            },\n        },\n        \"extra\": {\"word_count_threshold\": 1},\n        \"crawler_params\": {\"verbose\": True},\n    }\n\n    try:\n        result = tester.submit_and_wait(request)\n        extracted = json.loads(result[\"result\"][\"extracted_content\"])\n        print(\"Extracted content:\", json.dumps(extracted, indent=2))\n        assert result[\"result\"][\"success\"]\n    except Exception as e:\n        print(f\"Ollama extraction test failed: {str(e)}\")", "label": 0}
{"function": "def rename_colmap_recons_and_rescale_camera(\n    reconstruction, image_paths, original_coords, img_size, shift_point2d_to_original_res=False, shared_camera=False\n):\n    rescale_camera = True\n\n    for pyimageid in reconstruction.images:\n        # Reshaped the padded&resized image to the original size\n        # Rename the images to the original names\n        pyimage = reconstruction.images[pyimageid]\n        pycamera = reconstruction.cameras[pyimage.camera_id]\n        pyimage.name = image_paths[pyimageid - 1]\n\n        if rescale_camera:\n            # Rescale the camera parameters\n            pred_params = copy.deepcopy(pycamera.params)\n\n            real_image_size = original_coords[pyimageid - 1, -2:]\n            resize_ratio = max(real_image_size) / img_size\n            pred_params = pred_params * resize_ratio\n            real_pp = real_image_size / 2\n            pred_params[-2:] = real_pp  # center of the image\n\n            pycamera.params = pred_params\n            pycamera.width = real_image_size[0]\n            pycamera.height = real_image_size[1]\n\n        if shift_point2d_to_original_res:\n            # Also shift the point2D to original resolution\n            top_left = original_coords[pyimageid - 1, :2]\n\n            for point2D in pyimage.points2D:\n                point2D.xy = (point2D.xy - top_left) * resize_ratio\n\n        if shared_camera:\n            # If shared_camera, all images share the same camera\n            # no need to rescale any more\n            rescale_camera = False\n\n    return reconstruction", "label": 0}
{"function": "    def failing_version(*args, **kwargs):\n        pytest.fail(\"Real models should not be used in tests!\")", "label": 0}
{"function": "    def test_handles_single_rate_limit(self, mock_get, mock_sleep):\n        \"\"\"Test that API retries once after a 429 and succeeds.\"\"\"\n        # Setup mock responses: first 429, then 200\n        mock_429_response = Mock()\n        mock_429_response.status_code = 429\n        \n        mock_200_response = Mock()\n        mock_200_response.status_code = 200\n        mock_200_response.text = \"Success\"\n        \n        mock_get.side_effect = [mock_429_response, mock_200_response]\n        \n        # Call the function\n        headers = {\"X-API-KEY\": \"test-key\"}\n        url = \"https://api.financialdatasets.ai/test\"\n        \n        result = _make_api_request(url, headers)\n        \n        # Verify behavior\n        assert result.status_code == 200\n        assert result.text == \"Success\"\n        \n        # Verify requests.get was called twice\n        assert mock_get.call_count == 2\n        mock_get.assert_has_calls([\n            call(url, headers=headers),\n            call(url, headers=headers)\n        ])\n        \n        # Verify sleep was called once with 60 seconds (first retry)\n        mock_sleep.assert_called_once_with(60)", "label": 0}
{"function": "def index():\n    return {}", "label": 1}
{"function": "    def test_neighboring_returns_neighbors_with_pegged_alignment(self):\n        # arrange\n        a_info = AlignmentInfo(\n            (0, 3, 2),\n            (None, 'des', '\u0153ufs', 'verts'),\n            ('UNUSED', 'green', 'eggs'),\n            [[], [], [2], [1]],\n        )\n        ibm_model = IBMModel([])\n\n        # act: peg 'eggs' to align with '\u0153ufs'\n        neighbors = ibm_model.neighboring(a_info, 2)\n\n        # assert\n        neighbor_alignments = set()\n        for neighbor in neighbors:\n            neighbor_alignments.add(neighbor.alignment)\n        expected_alignments = set(\n            [\n                # moves\n                (0, 0, 2),\n                (0, 1, 2),\n                (0, 2, 2),\n                # no swaps\n                # original alignment\n                (0, 3, 2),\n            ]\n        )\n        self.assertEqual(neighbor_alignments, expected_alignments)", "label": 1}
{"function": "def generate_metadata(video_subject: str, script: str, ai_model: str) -> Tuple[str, str, List[str]]:  \n    \"\"\"  \n    Generate metadata for a YouTube video, including the title, description, and keywords.  \n  \n    Args:  \n        video_subject (str): The subject of the video.  \n        script (str): The script of the video.  \n        ai_model (str): The AI model to use for generation.  \n  \n    Returns:  \n        Tuple[str, str, List[str]]: The title, description, and keywords for the video.  \n    \"\"\"  \n  \n    # Build prompt for title  \n    title_prompt = f\"\"\"  \n    Generate a catchy and SEO-friendly title for a YouTube shorts video about {video_subject}.  \n    \"\"\"  \n  \n    # Generate title  \n    title = generate_response(title_prompt, ai_model).strip()  \n    \n    # Build prompt for description  \n    description_prompt = f\"\"\"  \n    Write a brief and engaging description for a YouTube shorts video about {video_subject}.  \n    The video is based on the following script:  \n    {script}  \n    \"\"\"  \n  \n    # Generate description  \n    description = generate_response(description_prompt, ai_model).strip()  \n  \n    # Generate keywords  \n    keywords = get_search_terms(video_subject, 6, script, ai_model)  \n\n    return title, description, keywords  ", "label": 0}
{"function": "        def check_channels(channels):\n            for channel, should_receive in channels:\n                dg = Datagram.create([channel], 123456789, 5858)\n                dg.add_uint16(channel) # For some semblance of uniqueness\n\n                self.c2.send(dg)\n\n                if should_receive:\n                    self.expect(self.c1, dg)\n                    self.expectNone(self.c1) # No repeats!\n                else:\n                    self.expectNone(self.c1)\n\n                # And, of course, l1 receives all of these:\n                self.expect(self.l1, dg)", "label": 1}
{"function": "    def setColor(self):\n        \"\"\" Separate the current image into cyan, magenta, and yellow\n            components.  Create a representation of how each component might\n            appear when applied to a blank white piece of paper.\n        \"\"\"\n        newColor = QColorDialog.getColor(self.paintColor)\n\n        if newColor.isValid():\n            self.paintColor = newColor\n            palette = QPalette(self.colorButton.palette())\n            palette.setColor(QPalette.Button, self.paintColor)\n            self.colorButton.setPalette(palette)\n            self.createImage()\n            self.imageChanged.emit()", "label": 1}
{"function": "    def test_subscribe(self):\n        self.l1.flush()\n        self.c1.flush()\n        self.c2.flush()\n\n        # Subscribe to a channel...\n        dg = Datagram.create_add_channel(12345654321)\n        self.c1.send(dg)\n        self.expectNone(self.c1)\n        # Make sure the MD subscribes to its parent.\n        self.expect(self.l1, dg)\n\n        # Send a test datagram on second connection...\n        dg = Datagram()\n        dg = Datagram.create([12345654321], 0, 1234)\n        dg.add_uint32(0xDEADBEEF)\n        self.c2.send(dg)\n        self.expect(self.c1, dg)\n        # MD will, of course, relay this datagram upward.\n        self.expect(self.l1, dg)\n\n        # Subscribe on the second connection...\n        dg = Datagram.create_add_channel(12345654321)\n        self.c2.send(dg)\n        self.expectNone(self.c2)\n        # MD should not ask for the channel a second time.\n        self.expectNone(self.l1)\n\n        # Send a test datagram on first connection...\n        dg = Datagram.create([12345654321], 0, 1234)\n        dg.add_uint32(0xDEADBEEF)\n        self.c1.send(dg)\n        self.expect(self.c2, dg) # Should be relayed to second.\n        self.expect(self.l1, dg) # Should be sent upward.\n        #self.expectNone(self.c1) # Should NOT be echoed back.\n\n        # Unsubscribe on the first connection...\n        dg = Datagram.create_remove_channel(12345654321)\n        self.c1.send(dg)\n        self.expectNone(self.c1)\n        self.expectNone(self.c2)\n        # MD should NOT unsubscribe from parent!\n        self.expectNone(self.l1)\n\n        # Send another test datagram on second connection...\n        dg = Datagram.create([12345654321], 0, 1234)\n        dg.add_uint32(0xDEADBEEF)\n        self.c2.send(dg)\n        self.expect(self.l1, dg) # Should be sent upward.\n        self.expectNone(self.c2) # Should NOT be relayed.\n        self.expectNone(self.c1) # Should NOT be echoed back.\n\n        # Abandon the second connection, which should auto-unsubscribe it.\n        self.c2.close()\n        self.__class__.c2 = self.connectToServer()\n        self.expectNone(self.c1)\n        # MD should unsubscribe from parent.\n        self.expect(self.l1, Datagram.create_remove_channel(12345654321))", "label": 1}
{"function": "def filter_output(output):\n    \"\"\"ImportantMessage\"\"\"\n    if not output:\n        return \"\"\n    important_lines = []\n    for line in output.split(\"\\n\"):\n        # Only keep lines containing specific keywords\n        if any(\n            keyword in line.lower()\n            for keyword in [\"error:\", \"failed:\", \"completed\", \"directory:\"]\n        ):\n            important_lines.append(line)\n    return \"\\n\".join(important_lines)", "label": 0}
{"function": "    def __eq__(self, other):\n        if not isinstance(other, MetaPartition):\n            return False\n\n        if self.metadata_version != other.metadata_version:\n            return False\n\n        for table, meta in self.table_meta.items():\n            # https://issues.apache.org/jira/browse/ARROW-5873\n            other_meta = other.table_meta.get(table, None)\n            if other_meta is None:\n                return False\n            if not meta.equals(other_meta):\n                return False\n\n        if self.dataset_metadata != other.dataset_metadata:\n            return False\n\n        if len(self.metapartitions) != len(other.metapartitions):\n            return False\n\n        # In the case both MetaPartitions are nested, we need to ensure a match\n        # for all sub-partitions.\n        # Since the label is unique, this can be used as a distinguishing key to sort and compare\n        # the nested metapartitions.\n        if len(self.metapartitions) > 1:\n            for mp_self, mp_other in zip(\n                sorted(self.metapartitions, key=lambda x: x[\"label\"]),\n                sorted(other.metapartitions, key=lambda x: x[\"label\"]),\n            ):\n                if mp_self == mp_other:\n                    continue\n                # If a single metapartition does not match, the whole object is considered different\n                return False\n            return True\n\n        # This is unnested only\n\n        self_keys = set(self.data.keys())\n        other_keys = set(other.data.keys())\n        if not (self_keys == other_keys):\n            return False\n\n        if self.label != other.label:\n            return False\n\n        if self.files != other.files:\n            return False\n\n        for label, df in self.data.items():\n            if not (df.equals(other.data[label])):\n                return False\n\n        return True", "label": 1}
{"function": "def gpu_wrapped_execute_image_retargeting(*args, **kwargs):\n    return gradio_pipeline.execute_image_retargeting(*args, **kwargs)", "label": 0}
{"function": "def remove_full_width_characters(s):\n    # \u5339\u914d\u5168\u89d2\u5b57\u7b26\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\n    pattern = re.compile(r'[\\uFF00-\\uFFEF]')\n    # \u66ff\u6362\u5b57\u7b26\u4e32\u4e2d\u7684\u5168\u89d2\u5b57\u7b26\u4e3a\u7a7a\u5b57\u7b26\u4e32\n    return pattern.sub('', s)", "label": 0}
{"function": "def event_loop() -> Iterator[None]:\n    new_loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(new_loop)\n    yield\n    new_loop.close()", "label": 0}
{"function": "def apply_common_decorators(capture_output_enabled=False):\n    \"\"\"\n    A unified decorator for applications\n    \"\"\"\n\n    def decorator(original_cmd_func):\n        @functools.wraps(original_cmd_func)\n        def new_runtime_wrapper(*args, **kwargs):\n            if cli_config and cli_config.full_log:\n                return capture_output(original_cmd_func)(*args, **kwargs)\n            else:\n                return original_cmd_func(*args, **kwargs)\n\n        func_with_clear_argv = clear_argv(new_runtime_wrapper)\n\n        return functools.wraps(original_cmd_func)(func_with_clear_argv)\n\n    return decorator", "label": 0}
{"function": "def test_parse_s3path(s3_path: str, target_data: str):\n    \"\"\"\n    s3_path: s3\u8def\u5f84\n        \u5982\u679c\u4e3a\u65e0\u6548\u8def\u5f84\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94\u7684bucket\u540d\u5b57\u548c\u5176\u4f59\u90e8\u5206\n        \u5982\u679c\u4e3a\u5f02\u5e38\u8def\u5f84 \u4f8b\u5982\uff1afile2.txt\uff0c\u5219\u62a5\u5f02\u5e38\n    \"\"\"\n    bucket_name, key = parse_s3path(s3_path)\n    assert target_data == bucket_name", "label": 0}
{"function": "    def get_rocm_bare_metal_version(self, rocm_dir):\n        \"\"\"\n        Get the ROCm version from the ROCm installation directory.\n\n        Args:\n            rocm_dir: Path to the ROCm installation directory\n\n        Returns:\n            A string representation of the ROCm version (e.g., \"63\" for ROCm 6.3)\n        \"\"\"\n        try:\n            # Try using rocm_agent_enumerator to get version info\n            raw_output = subprocess.check_output(\n                [rocm_dir + \"/bin/rocminfo\", \"--version\"],\n                universal_newlines=True,\n                stderr=subprocess.STDOUT)\n            # Extract version number from output\n            match = re.search(r'(\\d+\\.\\d+)', raw_output)\n            if match:\n                version_str = match.group(1)\n                version = parse(version_str)\n                rocm_version = f\"{version.major}{version.minor}\"\n                return rocm_version\n        except (subprocess.CalledProcessError, FileNotFoundError):\n            # If rocminfo --version fails, try alternative methods\n            pass\n\n        try:\n            # Try reading version from release file\n            with open(os.path.join(rocm_dir, \"share/doc/hip/version.txt\"), \"r\") as f:\n                version_str = f.read().strip()\n                version = parse(version_str)\n                rocm_version = f\"{version.major}{version.minor}\"\n                return rocm_version\n        except (FileNotFoundError, IOError):\n            pass\n\n        # If all else fails, try to extract from directory name\n        dir_name = os.path.basename(os.path.normpath(rocm_dir))\n        match = re.search(r'rocm-(\\d+\\.\\d+)', dir_name)\n        if match:\n            version_str = match.group(1)\n            version = parse(version_str)\n            rocm_version = f\"{version.major}{version.minor}\"\n            return rocm_version\n\n        # Fallback to extracting from hipcc version\n        try:\n            raw_output = subprocess.check_output(\n                [rocm_dir + \"/bin/hipcc\", \"--version\"],\n                universal_newlines=True,\n                stderr=subprocess.STDOUT)\n            match = re.search(r'HIP version: (\\d+\\.\\d+)', raw_output)\n            if match:\n                version_str = match.group(1)\n                version = parse(version_str)\n                rocm_version = f\"{version.major}{version.minor}\"\n                return rocm_version\n        except (subprocess.CalledProcessError, FileNotFoundError):\n            pass\n\n        # If we still can't determine the version, raise an error\n        raise ValueError(f\"Could not determine ROCm version from directory: {rocm_dir}\")", "label": 0}
{"function": "    def test_discard_all_filterfunc_not_supported(self, n='xjf21j21'):\n        c = compat.Consumer(self.connection, queue=n, exchange=n,\n                            routing_key='rkey')\n        with pytest.raises(NotImplementedError):\n            c.discard_all(filterfunc=lambda x: x)\n        c.close()", "label": 1}
{"function": "def get_afm_cache_path() -> str:\n    \"\"\"\n    Gets the path to the Affiliate Marketing cache file.\n\n    Returns:\n        path (str): The path to the AFM cache folder\n    \"\"\"\n    return os.path.join(get_cache_path(), 'afm.json')", "label": 0}
{"function": "    def homogeneous_noncommutative_variables(self,la):\n        r\"\"\"\n        Give the homogeneous function indexed by `la`, viewed inside the Nil-Coxeter algebra.\n        This is only defined in finite type `A`, `B` and affine types `A^{(1)}`, `B^{(1)}`, `C^{(1)}`, `D^{(1)}`.\n\n        INPUT:\n\n        - ``la`` -- a partition with first part bounded by the rank of the Weyl group\n\n        EXAMPLES::\n\n            sage: U = NilCoxeterAlgebra(WeylGroup(['B',2,1]))\n            sage: U.homogeneous_noncommutative_variables([2,1])\n            u[1,2,0] + 2*u[2,1,0] + u[0,2,0] + u[0,2,1] + u[1,2,1] + u[2,1,2] + u[2,0,2] + u[1,0,2]\n\n        TESTS::\n\n            sage: U = NilCoxeterAlgebra(WeylGroup(['B',2,1]))\n            sage: U.homogeneous_noncommutative_variables([])\n            1\n\n        \"\"\"\n        return prod(self.homogeneous_generator_noncommutative_variables(p) for p in la)", "label": 1}
{"function": "def setup_seed(seed):\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False", "label": 0}
{"function": "    def close(self, rm_all_containers: bool | None = True):\n        super().close()\n\n        if self.attach_to_existing:\n            return\n\n        if self.devbox:\n            self.runloop_api_client.devboxes.shutdown(self.devbox.id)", "label": 0}
{"function": "    def b2a_uu(data: _Bytes, *, backtick: bool = ...) -> bytes: ...", "label": 1}
{"function": "def repo_exists_true(mocker: MockerFixture) -> AsyncMock:\n    \"\"\"Patch ``gitingest.clone.check_repo_exists`` to always return ``True``.\"\"\"\n    return mocker.patch(\"gitingest.clone.check_repo_exists\", return_value=True)", "label": 0}
{"function": "    def to_dict(self):\n        \"\"\"Returns a dict representation of the PlatformParameter domain\n        object.\n\n        Returns:\n            dict. A dict mapping of all fields of PlatformParameter object.\n        \"\"\"\n        return {\n            'name': self._name,\n            'description': self._description,\n            'data_type': self._data_type,\n            'rules': [rule.to_dict() for rule in self._rules],\n            'rule_schema_version': self._rule_schema_version,\n            'default_value': self._default_value,\n            'is_feature': self._is_feature,\n            'feature_stage': self._feature_stage\n        }", "label": 1}
{"function": "    def test_live_migration_abort(self):\n        self._test_compute_api('live_migration_abort', 'cast',\n                instance=self.fake_instance_obj,\n                migration_id='1', version='5.0')", "label": 1}
{"function": "    def __len__(self):\n        return len(self.ids)", "label": 1}
{"function": "    def _drawReciboSacado(self, boletoDados):\n        \"\"\"Imprime o Recibo do Sacado para modelo de p\u00e1gina inteira\n\n        :param boletoDados: Objeto com os dados do boleto a ser preenchido.\n            Deve ser subclasse de :class:`pyboleto.data.BoletoData`\n        :type boletoDados: :class:`pyboleto.data.BoletoData`\n\n        \"\"\"\n        tpl = string.Template(self._load_template('recibo_sacado.html'))\n        tpl_data = {}\n\n        # Cabe\u00e7alho\n        tpl_data['logo_img'] = ''\n        if boletoDados.logo_image:\n            img = codecs.open(self._load_image(boletoDados.logo_image))\n            aux = img.read()\n            aux = base64.b64encode(aux)\n            img_base64 = 'data:image/jpeg;base64,{0}'.format(aux)\n            tpl_data['logo_img'] = img_base64\n        tpl_data['codigo_dv_banco'] = boletoDados.codigo_dv_banco\n\n        # Corpo\n        tpl_data['cedente'] = boletoDados.cedente\n        tpl_data['agencia_conta_cedente'] = boletoDados.agencia_conta_cedente\n        tpl_data['cedente_documento'] = boletoDados.cedente_documento\n\n        data_vencimento = boletoDados.data_vencimento\n        tpl_data['data_vencimento'] = data_vencimento.strftime('%d/%m/%Y')\n        tpl_data['sacado'] = boletoDados.sacado[0]\n        tpl_data['nosso_numero_format'] = boletoDados.format_nosso_numero()\n        tpl_data['numero_documento'] = boletoDados.numero_documento\n\n        data_documento = boletoDados.data_documento\n        tpl_data['data_documento'] = data_documento.strftime('%d/%m/%Y')\n        tpl_data['cedente_endereco'] = boletoDados.cedente_endereco\n\n        valor_doc = self._formataValorParaExibir(boletoDados.valor_documento)\n        tpl_data['valor_documento'] = valor_doc\n\n        # Demonstrativo\n        tpl_data['demonstrativo'] = ''\n        for dm in boletoDados.demonstrativo:\n            tpl_data['demonstrativo'] += '<p>{0}</p>'.format(dm)\n\n        self.html += tpl.substitute(tpl_data)", "label": 1}
{"function": "    def cmd_to_screen(self, n):\n        \"\"\"Warp focus to screen n, where n is a 0-based screen number\n\n        Examples\n        ========\n\n            to_screen(0)\n        \"\"\"\n        return self.focus_screen(n)", "label": 1}
{"function": "def generate_script(video_subject: str, paragraph_number: int, ai_model: str, voice: str, customPrompt: str) -> str:\n\n    \"\"\"\n    Generate a script for a video, depending on the subject of the video, the number of paragraphs, and the AI model.\n\n\n\n    Args:\n\n        video_subject (str): The subject of the video.\n\n        paragraph_number (int): The number of paragraphs to generate.\n\n        ai_model (str): The AI model to use for generation.\n\n\n\n    Returns:\n\n        str: The script for the video.\n\n    \"\"\"\n\n    # Build prompt\n    \n    if customPrompt:\n        prompt = customPrompt\n    else:\n        prompt = \"\"\"\n            Generate a script for a video, depending on the subject of the video.\n\n            The script is to be returned as a string with the specified number of paragraphs.\n\n            Here is an example of a string:\n            \"This is an example string.\"\n\n            Do not under any circumstance reference this prompt in your response.\n\n            Get straight to the point, don't start with unnecessary things like, \"welcome to this video\".\n\n            Obviously, the script should be related to the subject of the video.\n\n            YOU MUST NOT INCLUDE ANY TYPE OF MARKDOWN OR FORMATTING IN THE SCRIPT, NEVER USE A TITLE.\n            YOU MUST WRITE THE SCRIPT IN THE LANGUAGE SPECIFIED IN [LANGUAGE].\n            ONLY RETURN THE RAW CONTENT OF THE SCRIPT. DO NOT INCLUDE \"VOICEOVER\", \"NARRATOR\" OR SIMILAR INDICATORS OF WHAT SHOULD BE SPOKEN AT THE BEGINNING OF EACH PARAGRAPH OR LINE. YOU MUST NOT MENTION THE PROMPT, OR ANYTHING ABOUT THE SCRIPT ITSELF. ALSO, NEVER TALK ABOUT THE AMOUNT OF PARAGRAPHS OR LINES. JUST WRITE THE SCRIPT.\n\n        \"\"\"\n\n    prompt += f\"\"\"\n    \n    Subject: {video_subject}\n    Number of paragraphs: {paragraph_number}\n    Language: {voice}\n\n    \"\"\"\n\n    # Generate script\n    response = generate_response(prompt, ai_model)\n\n    print(colored(response, \"cyan\"))\n\n    # Return the generated script\n    if response:\n        # Clean the script\n        # Remove asterisks, hashes\n        response = response.replace(\"*\", \"\")\n        response = response.replace(\"#\", \"\")\n\n        # Remove markdown syntax\n        response = re.sub(r\"\\[.*\\]\", \"\", response)\n        response = re.sub(r\"\\(.*\\)\", \"\", response)\n\n        # Split the script into paragraphs\n        paragraphs = response.split(\"\\n\\n\")\n\n        # Select the specified number of paragraphs\n        selected_paragraphs = paragraphs[:paragraph_number]\n\n        # Join the selected paragraphs into a single string\n        final_script = \"\\n\\n\".join(selected_paragraphs)\n\n        # Print to console the number of paragraphs used\n        print(colored(f\"Number of paragraphs used: {len(selected_paragraphs)}\", \"green\"))\n\n        return final_script\n    else:\n        print(colored(\"[-] GPT returned an empty response.\", \"red\"))\n        return None", "label": 0}
{"function": "def get_latest_logs(max_lines=100, queue_source=None):\n    \"\"\"Get the latest log lines from the queue, or read directly from the file if the queue is empty\n\n    Args:\n        max_lines: Maximum number of lines to return\n        queue_source: Specify which queue to use, default is LOG_QUEUE\n\n    Returns:\n        str: Log content\n    \"\"\"\n    logs = []\n    log_queue = queue_source if queue_source else LOG_QUEUE\n\n    # Create a temporary queue to store logs so we can process them without removing them from the original queue\n    temp_queue = queue.Queue()\n    temp_logs = []\n\n    try:\n        # Try to get all available log lines from the queue\n        while not log_queue.empty() and len(temp_logs) < max_lines:\n            log = log_queue.get_nowait()\n            temp_logs.append(log)\n            temp_queue.put(log)  # Put the log back into the temporary queue\n    except queue.Empty:\n        pass\n\n    # Process conversation records\n    logs = temp_logs\n\n    # If there are no new logs or not enough logs, try to read the last few lines directly from the file\n    if len(logs) < max_lines and LOG_FILE and os.path.exists(LOG_FILE):\n        try:\n            with open(LOG_FILE, \"r\", encoding=\"utf-8\") as f:\n                all_lines = f.readlines()\n                # If there are already some logs in the queue, only read the remaining needed lines\n                remaining_lines = max_lines - len(logs)\n                file_logs = (\n                    all_lines[-remaining_lines:]\n                    if len(all_lines) > remaining_lines\n                    else all_lines\n                )\n\n                # Add file logs before queue logs\n                logs = file_logs + logs\n        except Exception as e:\n            error_msg = f\"Error reading log file: {str(e)}\"\n            logging.error(error_msg)\n            if not logs:  # Only add error message if there are no logs\n                logs = [error_msg]\n\n    # If there are still no logs, return a prompt message\n    if not logs:\n        return \"Initialization in progress...\"\n\n    # Filter logs, only keep logs with 'camel.agents.chat_agent - INFO'\n    filtered_logs = []\n    for log in logs:\n        if \"camel.agents.chat_agent - INFO\" in log:\n            filtered_logs.append(log)\n\n    # If there are no logs after filtering, return a prompt message\n    if not filtered_logs:\n        return \"No conversation records yet.\"\n\n    # Process log content, extract the latest user and assistant messages\n    simplified_logs = []\n\n    # Use a set to track messages that have already been processed, to avoid duplicates\n    processed_messages = set()\n\n    def process_message(role, content):\n        # Create a unique identifier to track messages\n        msg_id = f\"{role}:{content}\"\n        if msg_id in processed_messages:\n            return None\n\n        processed_messages.add(msg_id)\n        content = content.replace(\"\\\\n\", \"\\n\")\n        lines = [line.strip() for line in content.split(\"\\n\")]\n        content = \"\\n\".join(lines)\n\n        role_emoji = \"\ud83d\ude4b\" if role.lower() == \"user\" else \"\ud83e\udd16\"\n        return f\"\"\"### {role_emoji} {role.title()} Agent\n\n{content}\"\"\"\n\n    for log in filtered_logs:\n        formatted_messages = []\n        # Try to extract message array\n        messages_match = re.search(\n            r\"Model (.*?), index (\\d+), processed these messages: (\\[.*\\])\", log\n        )\n\n        if messages_match:\n            try:\n                messages = json.loads(messages_match.group(3))\n                for msg in messages:\n                    if msg.get(\"role\") in [\"user\", \"assistant\"]:\n                        formatted_msg = process_message(\n                            msg.get(\"role\"), msg.get(\"content\", \"\")\n                        )\n                        if formatted_msg:\n                            formatted_messages.append(formatted_msg)\n            except json.JSONDecodeError:\n                pass\n\n        # If JSON parsing fails or no message array is found, try to extract conversation content directly\n        if not formatted_messages:\n            user_pattern = re.compile(r\"\\{'role': 'user', 'content': '(.*?)'\\}\")\n            assistant_pattern = re.compile(\n                r\"\\{'role': 'assistant', 'content': '(.*?)'\\}\"\n            )\n\n            for content in user_pattern.findall(log):\n                formatted_msg = process_message(\"user\", content)\n                if formatted_msg:\n                    formatted_messages.append(formatted_msg)\n\n            for content in assistant_pattern.findall(log):\n                formatted_msg = process_message(\"assistant\", content)\n                if formatted_msg:\n                    formatted_messages.append(formatted_msg)\n\n        if formatted_messages:\n            simplified_logs.append(\"\\n\\n\".join(formatted_messages))\n\n    # Format log output, ensure appropriate separation between each conversation record\n    formatted_logs = []\n    for i, log in enumerate(simplified_logs):\n        # Remove excess whitespace characters from beginning and end\n        log = log.strip()\n\n        formatted_logs.append(log)\n\n        # Ensure each conversation record ends with a newline\n        if not log.endswith(\"\\n\"):\n            formatted_logs.append(\"\\n\")\n\n    return \"\\n\".join(formatted_logs)", "label": 0}
{"function": "    def __init__(self, api_key, base_url, model):\n        self.client = OpenAI(\n            api_key=api_key,\n            base_url=base_url,\n        )\n        self.model = model", "label": 0}
{"function": "def test_llm_extraction(tester: Crawl4AiTester):\n    print(\"\\n=== Testing LLM Extraction ===\")\n    schema = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"model_name\": {\n                \"type\": \"string\",\n                \"description\": \"Name of the OpenAI model.\",\n            },\n            \"input_fee\": {\n                \"type\": \"string\",\n                \"description\": \"Fee for input token for the OpenAI model.\",\n            },\n            \"output_fee\": {\n                \"type\": \"string\",\n                \"description\": \"Fee for output token for the OpenAI model.\",\n            },\n        },\n        \"required\": [\"model_name\", \"input_fee\", \"output_fee\"],\n    }\n\n    request = {\n        \"urls\": [\"https://openai.com/api/pricing\"],\n        \"priority\": 8,\n        \"extraction_config\": {\n            \"type\": \"llm\",\n            \"params\": {\n                \"provider\": \"openai/gpt-4o-mini\",\n                \"api_token\": os.getenv(\"OPENAI_API_KEY\"),\n                \"schema\": schema,\n                \"extraction_type\": \"schema\",\n                \"instruction\": \"\"\"From the crawled content, extract all mentioned model names along with their fees for input and output tokens.\"\"\",\n            },\n        },\n        \"crawler_params\": {\"word_count_threshold\": 1},\n    }\n\n    try:\n        result = tester.submit_and_wait(request)\n        extracted = json.loads(result[\"result\"][\"extracted_content\"])\n        print(f\"Extracted {len(extracted)} model pricing entries\")\n        print(\"Sample entry:\", json.dumps(extracted[0], indent=2))\n        assert result[\"result\"][\"success\"]\n    except Exception as e:\n        print(f\"LLM extraction test failed (might be due to missing API key): {str(e)}\")", "label": 0}
{"function": "    def drop_index(self, name, tablename=None, schema=None):\n        \"\"\"Issue a \"drop index\" instruction using the current\n        migration context.\n\n\n        e.g.::\n\n            drop_index(\"accounts\")\n\n        :param name: name of the index.\n        :param tablename: name of the owning table.  Some\n         backends such as Microsoft SQL Server require this.\n        :param schema: Optional schema name to operate within.\n\n         .. versionadded:: 0.4.0\n\n        \"\"\"\n        # need a dummy column name here since SQLAlchemy\n        # 0.7.6 and further raises on Index with no columns\n        self.impl.drop_index(\n            self._index(name, tablename, ['x'], schema=schema)\n        )", "label": 1}
{"function": "    def from_line(cls, line: str):\n        try:\n            prefix, _sep, problem = line.partition(\": \")\n            filename, line_number, col_number = prefix.split(\":\")\n        except (ValueError, IndexError) as e:\n            msg = f\"Invalid flake8 error line: {line}\"\n            raise ValueError(msg) from e\n        return cls(filename, int(line_number), int(col_number), problem)", "label": 0}
{"function": "    def get_children(self):\n        \"\"\"\n        Returns the children of the current node.\n\n        Returns:\n            list: A list of child KnowledgeNode instances.\n        \"\"\"\n        return self.children", "label": 0}
{"function": "def register():\n    bpy.types.Scene.blendermcp_port = IntProperty(\n        name=\"Port\",\n        description=\"Port for the BlenderMCP server\",\n        default=9876,\n        min=1024,\n        max=65535\n    )\n    \n    bpy.types.Scene.blendermcp_server_running = bpy.props.BoolProperty(\n        name=\"Server Running\",\n        default=False\n    )\n    \n    bpy.types.Scene.blendermcp_use_polyhaven = bpy.props.BoolProperty(\n        name=\"Use Poly Haven\",\n        description=\"Enable Poly Haven asset integration\",\n        default=False\n    )\n\n    bpy.types.Scene.blendermcp_use_hyper3d = bpy.props.BoolProperty(\n        name=\"Use Hyper3D Rodin\",\n        description=\"Enable Hyper3D Rodin generatino integration\",\n        default=False\n    )\n\n    bpy.types.Scene.blendermcp_hyper3d_mode = bpy.props.EnumProperty(\n        name=\"Rodin Mode\",\n        description=\"Choose the platform used to call Rodin APIs\",\n        items=[\n            (\"MAIN_SITE\", \"hyper3d.ai\", \"hyper3d.ai\"),\n            (\"FAL_AI\", \"fal.ai\", \"fal.ai\"),\n        ],\n        default=\"MAIN_SITE\"\n    )\n\n    bpy.types.Scene.blendermcp_hyper3d_api_key = bpy.props.StringProperty(\n        name=\"Hyper3D API Key\",\n        subtype=\"PASSWORD\",\n        description=\"API Key provided by Hyper3D\",\n        default=\"\"\n    )\n    \n    bpy.types.Scene.blendermcp_use_sketchfab = bpy.props.BoolProperty(\n        name=\"Use Sketchfab\",\n        description=\"Enable Sketchfab asset integration\",\n        default=False\n    )\n\n    bpy.types.Scene.blendermcp_sketchfab_api_key = bpy.props.StringProperty(\n        name=\"Sketchfab API Key\",\n        subtype=\"PASSWORD\",\n        description=\"API Key provided by Sketchfab\",\n        default=\"\"\n    )\n    \n    bpy.utils.register_class(BLENDERMCP_PT_Panel)\n    bpy.utils.register_class(BLENDERMCP_OT_SetFreeTrialHyper3DAPIKey)\n    bpy.utils.register_class(BLENDERMCP_OT_StartServer)\n    bpy.utils.register_class(BLENDERMCP_OT_StopServer)\n    \n    print(\"BlenderMCP addon registered\")", "label": 0}
{"function": "async def test_alazy_load(loader_with_dummy):\n    \"\"\"Test that alazy_load asynchronously yields Document objects with dummy content and proper metadata.\"\"\"\n    docs = [doc async for doc in loader_with_dummy.alazy_load()]\n    assert len(docs) == 2\n    for doc, url in zip(docs, loader_with_dummy.urls):\n        assert isinstance(doc, Document)\n        assert f\"dummy content for {url}\" in doc.page_content\n        assert doc.metadata[\"source\"] == url", "label": 0}
{"function": "    def __init__(self, in_ch=3, out_ch=3, dirate=1, stride=1):\n        super(REBNCONV, self).__init__()\n\n        self.conv_s1 = nn.Conv2d(\n            in_ch, out_ch, 3, padding=1 * dirate, dilation=1 * dirate, stride=stride\n        )\n        self.bn_s1 = nn.BatchNorm2d(out_ch)\n        self.relu_s1 = nn.ReLU(inplace=True)", "label": 0}
{"function": "def create_demo(\n    model_name: str,\n    device: str = \"cuda\" if torch.cuda.is_available() else \"cpu\",\n    offload: bool = False,\n    track_usage: bool = False,\n):\n    generator = FluxGenerator(model_name, device, offload, track_usage)\n    is_schnell = model_name == \"flux-schnell\"\n\n    with gr.Blocks() as demo:\n        gr.Markdown(f\"# Flux Image Generation Demo - Model: {model_name}\")\n\n        with gr.Row():\n            with gr.Column():\n                prompt = gr.Textbox(\n                    label=\"Prompt\",\n                    value='a photo of a forest with mist swirling around the tree trunks. The word \"FLUX\" is painted over it in big, red brush strokes with visible texture',\n                )\n                do_img2img = gr.Checkbox(label=\"Image to Image\", value=False, interactive=not is_schnell)\n                init_image = gr.Image(label=\"Input Image\", visible=False)\n                image2image_strength = gr.Slider(\n                    0.0, 1.0, 0.8, step=0.1, label=\"Noising strength\", visible=False\n                )\n\n                with gr.Accordion(\"Advanced Options\", open=False):\n                    width = gr.Slider(128, 8192, 1360, step=16, label=\"Width\")\n                    height = gr.Slider(128, 8192, 768, step=16, label=\"Height\")\n                    num_steps = gr.Slider(1, 50, 4 if is_schnell else 50, step=1, label=\"Number of steps\")\n                    guidance = gr.Slider(\n                        1.0, 10.0, 3.5, step=0.1, label=\"Guidance\", interactive=not is_schnell\n                    )\n                    seed = gr.Textbox(-1, label=\"Seed (-1 for random)\")\n                    add_sampling_metadata = gr.Checkbox(\n                        label=\"Add sampling parameters to metadata?\", value=True\n                    )\n\n                generate_btn = gr.Button(\"Generate\")\n\n            with gr.Column():\n                output_image = gr.Image(label=\"Generated Image\")\n                seed_output = gr.Number(label=\"Used Seed\")\n                warning_text = gr.Textbox(label=\"Warning\", visible=False)\n                download_btn = gr.File(label=\"Download full-resolution\")\n\n        def update_img2img(do_img2img):\n            return {\n                init_image: gr.update(visible=do_img2img),\n                image2image_strength: gr.update(visible=do_img2img),\n            }\n\n        do_img2img.change(update_img2img, do_img2img, [init_image, image2image_strength])\n\n        generate_btn.click(\n            fn=generator.generate_image,\n            inputs=[\n                width,\n                height,\n                num_steps,\n                guidance,\n                seed,\n                prompt,\n                init_image,\n                image2image_strength,\n                add_sampling_metadata,\n            ],\n            outputs=[output_image, seed_output, download_btn, warning_text],\n        )\n\n    return demo", "label": 0}
{"function": "    def start(self):\n        if self.running:\n            print(\"Server is already running\")\n            return\n            \n        self.running = True\n        \n        try:\n            # Create socket\n            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            self.socket.bind((self.host, self.port))\n            self.socket.listen(1)\n            \n            # Start server thread\n            self.server_thread = threading.Thread(target=self._server_loop)\n            self.server_thread.daemon = True\n            self.server_thread.start()\n            \n            print(f\"BlenderMCP server started on {self.host}:{self.port}\")\n        except Exception as e:\n            print(f\"Failed to start server: {str(e)}\")\n            self.stop()", "label": 0}
{"function": "def raise_if_exception(e: Any) -> None:\n    if isinstance(e, Exception):\n        raise e", "label": 0}
{"function": "def get_current_temperature(location: str, unit: str = \"Celsius\") -> Dict[str, str]:\n    \"\"\"Gets the current temperature for a specific location and unit.\"\"\"\n    return {\"location\": location, \"unit\": unit, \"temperature\": \"72\"}", "label": 0}
{"function": "    def digest(self):\n        return nthash.encrypt(self._data[:127]).decode('hex')", "label": 1}
{"function": "  def testGetChannelDim(self):\n    data_formats = ['NHWC', 'NCHW']\n    shape = [10, 20, 30, 40]\n    for data_format in data_formats:\n      dim = nasnet_utils.get_channel_dim(shape, data_format)\n      correct_dim = shape[3] if data_format == 'NHWC' else shape[1]\n      self.assertEqual(dim, correct_dim)", "label": 1}
{"function": "    def test_start_handshake_nonce_callback(self, mock_queue, *_):\n        deferred = Deferred()\n        self.server.resource_manager.add_file.return_value = deferred\n        self.server.start_handshake(\n            key_id=self.key_id,\n            task_id=self.task_id,\n        )\n\n        exception = False\n\n        def exception_on_error(error):\n            nonlocal exception\n            exception = error\n\n        deferred.addErrback(exception_on_error)\n        deferred.callback(('result', None))\n\n        if exception:\n            raise Exception(exception)\n\n        mock_queue.assert_called_once_with(\n            node_id=self.key_id, msg=mock.ANY, timeout=mock.ANY)", "label": 1}
{"function": "    def __init__(self, real0, real1):\n        pass", "label": 1}
{"function": "async def test_graph_special_characters(storage):\n    \"\"\"\n    \u6d4b\u8bd5\u56fe\u6570\u636e\u5e93\u5bf9\u7279\u6b8a\u5b57\u7b26\u7684\u5904\u7406:\n    1. \u6d4b\u8bd5\u8282\u70b9\u540d\u79f0\u548c\u63cf\u8ff0\u4e2d\u5305\u542b\u5355\u5f15\u53f7\u3001\u53cc\u5f15\u53f7\u548c\u53cd\u659c\u6760\n    2. \u6d4b\u8bd5\u8fb9\u7684\u63cf\u8ff0\u4e2d\u5305\u542b\u5355\u5f15\u53f7\u3001\u53cc\u5f15\u53f7\u548c\u53cd\u659c\u6760\n    3. \u9a8c\u8bc1\u7279\u6b8a\u5b57\u7b26\u662f\u5426\u88ab\u6b63\u786e\u4fdd\u5b58\u548c\u68c0\u7d22\n    \"\"\"\n    try:\n        # 1. \u6d4b\u8bd5\u8282\u70b9\u540d\u79f0\u4e2d\u7684\u7279\u6b8a\u5b57\u7b26\n        node1_id = \"\u5305\u542b'\u5355\u5f15\u53f7'\u7684\u8282\u70b9\"\n        node1_data = {\n            \"entity_id\": node1_id,\n            \"description\": \"\u8fd9\u4e2a\u63cf\u8ff0\u5305\u542b'\u5355\u5f15\u53f7'\u3001\\\"\u53cc\u5f15\u53f7\\\"\u548c\\\\\u53cd\u659c\u6760\",\n            \"keywords\": \"\u7279\u6b8a\u5b57\u7b26,\u5f15\u53f7,\u8f6c\u4e49\",\n            \"entity_type\": \"\u6d4b\u8bd5\u8282\u70b9\",\n        }\n        print(f\"\u63d2\u5165\u5305\u542b\u7279\u6b8a\u5b57\u7b26\u7684\u8282\u70b91: {node1_id}\")\n        await storage.upsert_node(node1_id, node1_data)\n\n        # 2. \u6d4b\u8bd5\u8282\u70b9\u540d\u79f0\u4e2d\u7684\u53cc\u5f15\u53f7\n        node2_id = '\u5305\u542b\"\u53cc\u5f15\u53f7\"\u7684\u8282\u70b9'\n        node2_data = {\n            \"entity_id\": node2_id,\n            \"description\": \"\u8fd9\u4e2a\u63cf\u8ff0\u540c\u65f6\u5305\u542b'\u5355\u5f15\u53f7'\u548c\\\"\u53cc\u5f15\u53f7\\\"\u4ee5\u53ca\\\\\u53cd\u659c\u6760\\\\\u8def\u5f84\",\n            \"keywords\": \"\u7279\u6b8a\u5b57\u7b26,\u5f15\u53f7,JSON\",\n            \"entity_type\": \"\u6d4b\u8bd5\u8282\u70b9\",\n        }\n        print(f\"\u63d2\u5165\u5305\u542b\u7279\u6b8a\u5b57\u7b26\u7684\u8282\u70b92: {node2_id}\")\n        await storage.upsert_node(node2_id, node2_data)\n\n        # 3. \u6d4b\u8bd5\u8282\u70b9\u540d\u79f0\u4e2d\u7684\u53cd\u659c\u6760\n        node3_id = \"\u5305\u542b\\\\\u53cd\u659c\u6760\\\\\u7684\u8282\u70b9\"\n        node3_data = {\n            \"entity_id\": node3_id,\n            \"description\": \"\u8fd9\u4e2a\u63cf\u8ff0\u5305\u542bWindows\u8def\u5f84C:\\\\Program Files\\\\\u548c\u8f6c\u4e49\u5b57\u7b26\\\\n\\\\t\",\n            \"keywords\": \"\u53cd\u659c\u6760,\u8def\u5f84,\u8f6c\u4e49\",\n            \"entity_type\": \"\u6d4b\u8bd5\u8282\u70b9\",\n        }\n        print(f\"\u63d2\u5165\u5305\u542b\u7279\u6b8a\u5b57\u7b26\u7684\u8282\u70b93: {node3_id}\")\n        await storage.upsert_node(node3_id, node3_data)\n\n        # 4. \u6d4b\u8bd5\u8fb9\u63cf\u8ff0\u4e2d\u7684\u7279\u6b8a\u5b57\u7b26\n        edge1_data = {\n            \"relationship\": \"\u7279\u6b8a'\u5173\u7cfb'\",\n            \"weight\": 1.0,\n            \"description\": \"\u8fd9\u4e2a\u8fb9\u63cf\u8ff0\u5305\u542b'\u5355\u5f15\u53f7'\u3001\\\"\u53cc\u5f15\u53f7\\\"\u548c\\\\\u53cd\u659c\u6760\",\n        }\n        print(f\"\u63d2\u5165\u5305\u542b\u7279\u6b8a\u5b57\u7b26\u7684\u8fb9: {node1_id} -> {node2_id}\")\n        await storage.upsert_edge(node1_id, node2_id, edge1_data)\n\n        # 5. \u6d4b\u8bd5\u8fb9\u63cf\u8ff0\u4e2d\u7684\u66f4\u590d\u6742\u7279\u6b8a\u5b57\u7b26\u7ec4\u5408\n        edge2_data = {\n            \"relationship\": '\u590d\u6742\"\u5173\u7cfb\"\\\\\u7c7b\u578b',\n            \"weight\": 0.8,\n            \"description\": \"\u5305\u542bSQL\u6ce8\u5165\u5c1d\u8bd5: SELECT * FROM users WHERE name='admin'--\",\n        }\n        print(f\"\u63d2\u5165\u5305\u542b\u590d\u6742\u7279\u6b8a\u5b57\u7b26\u7684\u8fb9: {node2_id} -> {node3_id}\")\n        await storage.upsert_edge(node2_id, node3_id, edge2_data)\n\n        # 6. \u9a8c\u8bc1\u8282\u70b9\u7279\u6b8a\u5b57\u7b26\u662f\u5426\u6b63\u786e\u4fdd\u5b58\n        print(\"\\n== \u9a8c\u8bc1\u8282\u70b9\u7279\u6b8a\u5b57\u7b26\")\n        for node_id, original_data in [\n            (node1_id, node1_data),\n            (node2_id, node2_data),\n            (node3_id, node3_data),\n        ]:\n            node_props = await storage.get_node(node_id)\n            if node_props:\n                print(f\"\u6210\u529f\u8bfb\u53d6\u8282\u70b9: {node_id}\")\n                print(f\"\u8282\u70b9\u63cf\u8ff0: {node_props.get('description', '\u65e0\u63cf\u8ff0')}\")\n\n                # \u9a8c\u8bc1\u8282\u70b9ID\u662f\u5426\u6b63\u786e\u4fdd\u5b58\n                assert (\n                    node_props.get(\"entity_id\") == node_id\n                ), f\"\u8282\u70b9ID\u4e0d\u5339\u914d: \u671f\u671b {node_id}, \u5b9e\u9645 {node_props.get('entity_id')}\"\n\n                # \u9a8c\u8bc1\u63cf\u8ff0\u662f\u5426\u6b63\u786e\u4fdd\u5b58\n                assert (\n                    node_props.get(\"description\") == original_data[\"description\"]\n                ), f\"\u8282\u70b9\u63cf\u8ff0\u4e0d\u5339\u914d: \u671f\u671b {original_data['description']}, \u5b9e\u9645 {node_props.get('description')}\"\n\n                print(f\"\u8282\u70b9 {node_id} \u7279\u6b8a\u5b57\u7b26\u9a8c\u8bc1\u6210\u529f\")\n            else:\n                print(f\"\u8bfb\u53d6\u8282\u70b9\u5c5e\u6027\u5931\u8d25: {node_id}\")\n                assert False, f\"\u672a\u80fd\u8bfb\u53d6\u8282\u70b9\u5c5e\u6027: {node_id}\"\n\n        # 7. \u9a8c\u8bc1\u8fb9\u7279\u6b8a\u5b57\u7b26\u662f\u5426\u6b63\u786e\u4fdd\u5b58\n        print(\"\\n== \u9a8c\u8bc1\u8fb9\u7279\u6b8a\u5b57\u7b26\")\n        edge1_props = await storage.get_edge(node1_id, node2_id)\n        if edge1_props:\n            print(f\"\u6210\u529f\u8bfb\u53d6\u8fb9: {node1_id} -> {node2_id}\")\n            print(f\"\u8fb9\u5173\u7cfb: {edge1_props.get('relationship', '\u65e0\u5173\u7cfb')}\")\n            print(f\"\u8fb9\u63cf\u8ff0: {edge1_props.get('description', '\u65e0\u63cf\u8ff0')}\")\n\n            # \u9a8c\u8bc1\u8fb9\u5173\u7cfb\u662f\u5426\u6b63\u786e\u4fdd\u5b58\n            assert (\n                edge1_props.get(\"relationship\") == edge1_data[\"relationship\"]\n            ), f\"\u8fb9\u5173\u7cfb\u4e0d\u5339\u914d: \u671f\u671b {edge1_data['relationship']}, \u5b9e\u9645 {edge1_props.get('relationship')}\"\n\n            # \u9a8c\u8bc1\u8fb9\u63cf\u8ff0\u662f\u5426\u6b63\u786e\u4fdd\u5b58\n            assert (\n                edge1_props.get(\"description\") == edge1_data[\"description\"]\n            ), f\"\u8fb9\u63cf\u8ff0\u4e0d\u5339\u914d: \u671f\u671b {edge1_data['description']}, \u5b9e\u9645 {edge1_props.get('description')}\"\n\n            print(f\"\u8fb9 {node1_id} -> {node2_id} \u7279\u6b8a\u5b57\u7b26\u9a8c\u8bc1\u6210\u529f\")\n        else:\n            print(f\"\u8bfb\u53d6\u8fb9\u5c5e\u6027\u5931\u8d25: {node1_id} -> {node2_id}\")\n            assert False, f\"\u672a\u80fd\u8bfb\u53d6\u8fb9\u5c5e\u6027: {node1_id} -> {node2_id}\"\n\n        edge2_props = await storage.get_edge(node2_id, node3_id)\n        if edge2_props:\n            print(f\"\u6210\u529f\u8bfb\u53d6\u8fb9: {node2_id} -> {node3_id}\")\n            print(f\"\u8fb9\u5173\u7cfb: {edge2_props.get('relationship', '\u65e0\u5173\u7cfb')}\")\n            print(f\"\u8fb9\u63cf\u8ff0: {edge2_props.get('description', '\u65e0\u63cf\u8ff0')}\")\n\n            # \u9a8c\u8bc1\u8fb9\u5173\u7cfb\u662f\u5426\u6b63\u786e\u4fdd\u5b58\n            assert (\n                edge2_props.get(\"relationship\") == edge2_data[\"relationship\"]\n            ), f\"\u8fb9\u5173\u7cfb\u4e0d\u5339\u914d: \u671f\u671b {edge2_data['relationship']}, \u5b9e\u9645 {edge2_props.get('relationship')}\"\n\n            # \u9a8c\u8bc1\u8fb9\u63cf\u8ff0\u662f\u5426\u6b63\u786e\u4fdd\u5b58\n            assert (\n                edge2_props.get(\"description\") == edge2_data[\"description\"]\n            ), f\"\u8fb9\u63cf\u8ff0\u4e0d\u5339\u914d: \u671f\u671b {edge2_data['description']}, \u5b9e\u9645 {edge2_props.get('description')}\"\n\n            print(f\"\u8fb9 {node2_id} -> {node3_id} \u7279\u6b8a\u5b57\u7b26\u9a8c\u8bc1\u6210\u529f\")\n        else:\n            print(f\"\u8bfb\u53d6\u8fb9\u5c5e\u6027\u5931\u8d25: {node2_id} -> {node3_id}\")\n            assert False, f\"\u672a\u80fd\u8bfb\u53d6\u8fb9\u5c5e\u6027: {node2_id} -> {node3_id}\"\n\n        print(\"\\n\u7279\u6b8a\u5b57\u7b26\u6d4b\u8bd5\u5b8c\u6210\uff0c\u6570\u636e\u5df2\u4fdd\u7559\u5728\u6570\u636e\u5e93\u4e2d\")\n        return True\n\n    except Exception as e:\n        ASCIIColors.red(f\"\u6d4b\u8bd5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u9519\u8bef: {str(e)}\")\n        return False", "label": 0}
{"function": "    def roles(self):\n        \"\"\"Roles of the client processes\"\"\"\n        return self._roles", "label": 1}
{"function": "def generator(prompt:str, model:str, llm_auth_token:str,llm_base_url:str, using_custom_llm=False,is_failed=False):\n    if is_failed:\n        yield \"\u641c\u7d22\u5931\u8d25\uff0c\u6ca1\u6709\u8fd4\u56de\u7ed3\u679c\"\n    else:\n        total_token = \"\"\n        for token in  free_ask_internet.chat(prompt=prompt,model=model,llm_auth_token=llm_auth_token,llm_base_url=llm_base_url,using_custom_llm=using_custom_llm,stream=True):\n            total_token += token\n            yield token", "label": 0}
{"function": "    def feature_stage(self):\n        \"\"\"Returns the stage of the feature flag.\n\n        Returns:\n            FEATURE_STAGES|None. The stage of the feature flag, None if the\n            parameter isn't a feature flag.\n        \"\"\"\n        return self._feature_stage", "label": 1}
{"function": "    def test_record_extensions(self):\n        install_dir = self.mkdtemp()\n        project_dir, dist = self.create_dist(ext_modules=[\n            Extension('xx', ['xxmodule.c'])])\n        os.chdir(project_dir)\n        support.copy_xxmodule_c(project_dir)\n\n        buildextcmd = build_ext(dist)\n        support.fixup_build_ext(buildextcmd)\n        buildextcmd.ensure_finalized()\n\n        cmd = install(dist)\n        dist.command_obj['install'] = cmd\n        dist.command_obj['build_ext'] = buildextcmd\n        cmd.root = install_dir\n        cmd.record = os.path.join(project_dir, 'filelist')\n        cmd.ensure_finalized()\n        cmd.run()\n\n        f = open(cmd.record)\n        try:\n            content = f.read()\n        finally:\n            f.close()\n\n        found = [os.path.basename(line) for line in content.splitlines()]\n        expected = [_make_ext_name('xx'),\n                    'UNKNOWN-0.0.0-py%s.%s.egg-info' % sys.version_info[:2]]\n        self.assertEqual(found, expected)", "label": 1}
{"function": "    def test_malformed_single(self):\n        dg = Datagram()\n        dg.add_uint16(0) # Datagram length\n        dg.add_uint8(1) # Number of recipients\n        dg.add_channel(12341234) # Recipient\n        dg.add_channel(0) # Sender\n        dg.add_string('Ex nihilo, alea iacta est. Tohuvabohu!')\n        self.c1.s.send(dg.get_data())\n        # The MD should drop this packet completely.\n        self.expectNone(self.l1)\n        # The MD should drop the misbehaving participant.\n        self.assertRaises(EOFError, self.c1.recv_maybe())\n\n        # Cleanup\n        self.c1.close()\n        self.__class__.c1 = self.connectToServer()\n        self.l1.flush()", "label": 1}
{"function": "    def loop_waiting_for_flag(self, instance, timeout=5):\n        timeout = float(timeout) / 100\n        count = 100\n        while asyncore.socket_map and count > 0:\n            asyncore.loop(timeout=0.01, count=1, use_poll=self.use_poll)\n            if instance.flag:\n                return\n            count -= 1\n            time.sleep(timeout)\n        self.fail(\"flag not set\")", "label": 1}
{"function": "    def test_set(self):\n        \"\"\"Test that values can be set in the cache.\"\"\"\n        cache = TimedCache(datetime.timedelta(seconds=10))\n        key, value = \"test_key\", \"test_value\"\n\n        with patch(\"datetime.datetime\") as mock_datetime:\n            now = datetime.datetime(2023, 1, 1, tzinfo=datetime.timezone.utc)\n            mock_datetime.now.return_value = now\n\n            cache.set(key, value)\n\n            # Check that the value is stored with the correct expiration\n            assert key in cache.cache\n            stored_value, expiration = cache.cache[key]\n            assert stored_value == value\n            assert expiration == now + datetime.timedelta(seconds=10)", "label": 0}
{"function": "def setup_directories(video_path: Path) -> dict:\n    \"\"\"\n    Setup directories for storing processed files.\n\n    Args:\n        video_path (Path): Path to the video file.\n\n    Returns:\n        dict: A dictionary containing paths for various directories.\n    \"\"\"\n    base_dir = video_path.parent.parent\n    dirs = {\n        \"face_mask\": base_dir / \"face_mask\",\n        \"sep_pose_mask\": base_dir / \"sep_pose_mask\",\n        \"sep_face_mask\": base_dir / \"sep_face_mask\",\n        \"sep_lip_mask\": base_dir / \"sep_lip_mask\",\n        \"face_emb\": base_dir / \"face_emb\",\n        \"audio_emb\": base_dir / \"audio_emb\"\n    }\n\n    for path in dirs.values():\n        path.mkdir(parents=True, exist_ok=True)\n\n    return dirs", "label": 0}
{"function": "    def test_valid_json_array(self):\n        \"\"\"Test with valid JSON array\"\"\"\n        content = '[1, 2, 3, \"test\"]'\n        result = repair_json_output(content)\n        expected = json.dumps([1, 2, 3, \"test\"], ensure_ascii=False)\n        assert result == expected", "label": 0}
{"function": "    def __getitem__(self, index):\n\n        # if _DEBUG:\n        # index = 1\n\n        # img_id = self.ids[index]\n\n        im_path = self.annobase[index]['image']# os.path.join(self.root, img_id + '.jpg')\n        img = Image.open(im_path).convert(\"RGB\")\n        # im = cv2.imread(im_path)\n        anno = self.annobase[index]\n        target = RBoxList(torch.from_numpy(anno[\"boxes\"]), (anno['width'], anno['height']), mode=\"xywha\")\n        target.add_field(\"labels\", torch.from_numpy(anno[\"gt_classes\"]))\n        target.add_field(\"difficult\", torch.Tensor([0 for i in range(len(anno[\"gt_classes\"]))]))\n\n        masks = [np.array(mask).reshape(1, -1).tolist() for mask in anno[\"polys\"]]\n        # print('masks data:', masks)\n        masks = SegmentationMask(masks, img.size)\n        target.add_field(\"masks\", masks)\n\n        # target.add_field(\"masks\", torch.from_numpy(np.array(anno[\"polys\"]).reshape(-1)))\n\n        target = target.clip_to_image(remove_empty=True)\n        # print('target:', target, im_path)\n        if self.transforms is not None:\n            # off = int(self.num_samples * np.random.rand())\n            # mix_index = (off + index) % self.num_samples\n            # img_mix = Image.open(self.annobase[mix_index]['image']).convert(\"RGB\")\n            # img, target = self.mixup(img, img_mix, target)\n            img, target = self.transforms(img, target)\n        if _DEBUG:\n            if not target is None:\n                # print('target:', target, im_path)\n                self.show_boxes(img, target)\n\n        return img, target, index", "label": 1}
{"function": "    def format_record(record):\n        # \u83b7\u53d6\u65e5\u5fd7\u8bb0\u5f55\u4e2d\u7684\u6587\u4ef6\u5168\u8def\u5f84\n        file_path = record[\"file\"].path\n        # \u5c06\u7edd\u5bf9\u8def\u5f84\u8f6c\u6362\u4e3a\u76f8\u5bf9\u4e8e\u9879\u76ee\u6839\u76ee\u5f55\u7684\u8def\u5f84\n        relative_path = os.path.relpath(file_path, root_dir)\n        # \u66f4\u65b0\u8bb0\u5f55\u4e2d\u7684\u6587\u4ef6\u8def\u5f84\n        record[\"file\"].path = f\"./{relative_path}\"\n        # \u8fd4\u56de\u4fee\u6539\u540e\u7684\u683c\u5f0f\u5b57\u7b26\u4e32\n        # \u60a8\u53ef\u4ee5\u6839\u636e\u9700\u8981\u8c03\u6574\u8fd9\u91cc\u7684\u683c\u5f0f\n        record[\"message\"] = record[\"message\"].replace(root_dir, \".\")\n\n        _format = (\n            \"<green>{time:%Y-%m-%d %H:%M:%S}</> | \"\n            + \"<level>{level}</> | \"\n            + '\"{file.path}:{line}\":<blue> {function}</> '\n            + \"- <level>{message}</>\"\n            + \"\\n\"\n        )\n        return _format", "label": 0}
{"function": "        def noop_no_sync():\n            yield", "label": 0}
{"function": "    def print_text(text=None):\n        if text is not None:\n            print(text)", "label": 0}
{"function": "def generate_300vw_list(root, save_dir):\n  assert osp.isdir(root), '{} is not dir'.format(root)\n  if not osp.isdir(save_dir): os.makedirs(save_dir)\n  test_1_dirs = [114, 124, 125, 126, 150, 158, 401, 402, 505, 506, 507, 508, 509, 510, 511, 514, 515, 518, 519, 520, 521, 522, 524, 525, 537, 538, 540, 541, 546, 547, 548]\n  test_2_dirs = [203, 208, 211, 212, 213, 214, 218, 224, 403, 404, 405, 406, 407, 408, 409, 412, 550, 551, 553]\n  test_3_dirs = [410, 411, 516, 517, 526, 528, 529, 530, 531, 533, 557, 558, 559, 562]\n  train_dirs  = ['009', '059', '002', '033', '020', '035', '018', '119', '120', '025', '205', '047', '007', '013', '004', '143',\n                 '034', '028', '053', '225', '041', '010', '031', '046', '049', '011', '027', '003', '016', '160', '113', '001', '029', '043',\n                 '112', '138', '144', '204', '057', '015', '044', '048', '017', '115', '223', '037', '123', '019', '039', '022']\n\n  test_1_dirs, test_2_dirs, test_3_dirs = [ '{}'.format(x) for x in test_1_dirs], [ '{}'.format(x) for x in test_2_dirs], [ '{}'.format(x) for x in test_3_dirs]\n  #all_dirs = os.listdir(root)\n  #train_dirs = set(all_dirs) - set(test_1_dirs) - set(test_2_dirs) - set(test_3_dirs) - set(['ReadMe.txt', 'extra.zip'])\n  #train_dirs = list( train_dirs )\n  assert len(train_dirs) == 50, 'The length of train_dirs is not right : {}'.format( len(train_dirs) )\n  assert len(test_3_dirs) == 14, 'The length of test_3_dirs is not right : {}'.format( len(test_3_dirs) )\n\n  load_video_dir(root,  train_dirs, save_dir, '300VW.train.lst')\n  load_video_dir(root, test_1_dirs, save_dir, '300VW.test-1.lst')\n  load_video_dir(root, test_2_dirs, save_dir, '300VW.test-2.lst')\n  load_video_dir(root, test_3_dirs, save_dir, '300VW.test-3.lst')", "label": 1}
{"function": "    def _add_write_service(self, ioi, write_data, data_type):\n        \"\"\"\n        Add the write command stuff to the tagIOI\n        \"\"\"\n        RequestPathSize = int(len(ioi)/2)\n        RequestService = 0x4D\n        write_service = pack('<BB', RequestService, RequestPathSize)\n        write_service += ioi\n\n        if data_type == 160:\n            RequestNumberOfElements = self.StructIdentifier\n            TypeCodeLen = 0x02\n            write_service += pack('<BBHH', data_type, TypeCodeLen, self.StructIdentifier, len(write_data))\n        else:\n            TypeCodeLen = 0x00\n            write_service += pack('<BBH', data_type, TypeCodeLen, len(write_data))\n\n        for v in write_data:\n            try:\n                for i in range(len(v)):\n                    el = v[i]\n                    write_service += pack(self.CIPTypes[data_type][2], el)\n            except Exception:\n                write_service += pack(self.CIPTypes[data_type][2], v)\n\n        return write_service", "label": 1}
{"function": "    def get_musa_bare_metal_version(self, musa_dir):\n        raw_output = subprocess.run(\n            [musa_dir + \"/bin/mcc\", \"-v\"], check=True,\n            stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.decode(\"utf-8\")\n        output = raw_output.split()\n        release_idx = output.index(\"version\") + 1\n        bare_metal_version = parse(output[release_idx].split(\",\")[0])\n        musa_version = f\"{bare_metal_version.major}{bare_metal_version.minor}\"\n        return musa_version", "label": 0}
{"function": "        def execute(self):\n            url, method, body, json_body, headers = (\n                OAuth2Request(self.api).prepare_request(\n                    self.method, self.path, self.parameters,\n                    include_secret=self.include_secret))\n            if self.as_generator:\n                return self._paginator_with_url(url, method, body, headers)\n            else:\n                content, next = self._do_api_request(url, method, body,\n                                                     json_body, headers)\n            if self.paginates:\n                return content, next\n            else:\n                return content", "label": 1}
{"function": "    def activate_restore(self):\n        if not self.is_restore_active:\n            for seq in self.RESTORE_SEQUENCES:\n                self.text.event_add(self.RESTORE_VIRTUAL_EVENT_NAME, seq)\n            self.is_restore_active = True", "label": 1}
{"function": "    def test_multiple_completions(self):\n        \"\"\"Test handling multiple completions at once.\"\"\"\n        completions = [\n            [{\"content\": r\"\\boxed{\\frac{63}{400}}\"}],\n            [{\"content\": r\"\\boxed{\\frac{64}{400}}\"}],\n        ]\n        solutions = [r\"\\frac{63}{400}\", r\"\\frac{63}{400}\"]\n\n        rewards = accuracy_reward(completions, solutions)\n        self.assertEqual(len(rewards), 2)\n        self.assertEqual(rewards[0], 1.0)\n        self.assertEqual(rewards[1], 0.0)", "label": 0}
{"function": "def identity(n, dtype=None):\n    \"\"\"\n    Return the identity array.\n\n    The identity array is a square array with ones on\n    the main diagonal.\n\n    Parameters\n    ----------\n    n : int\n        Number of rows (and columns) in `n` x `n` output.\n    dtype : data-type, optional\n        Data-type of the output.  Defaults to ``float``.\n\n    Returns\n    -------\n    out : ndarray\n        `n` x `n` array with its main diagonal set to one,\n        and all other elements 0.\n\n    Examples\n    --------\n    >>> np.identity(3)\n    array([[ 1.,  0.,  0.],\n           [ 0.,  1.,  0.],\n           [ 0.,  0.,  1.]])\n\n    \"\"\"\n    from numpy import eye\n    return eye(n, dtype=dtype)", "label": 1}
{"function": "def random_true_with_probability(probability):\n    \"\"\"return True with the requested probability, False otherwise.\"\"\"\n    return random.random() < probability", "label": 0}
{"function": "    def __call__(self, tokens):\n        mergewords = self.mergewords\n        mergenums = self.mergenums\n\n        # This filter renumbers tokens as it expands them. New position\n        # counter.\n        newpos = None\n        for t in tokens:\n            text = t.text\n\n            # If this is the first token we've seen, use it to set the new\n            # position counter\n            if newpos is None:\n                if t.positions:\n                    newpos = t.pos\n                else:\n                    # Token doesn't have positions, just use 0\n                    newpos = 0\n\n            if ((text.isalpha() and (text.islower() or text.isupper()))\n                or text.isdigit()):\n                # Short-circuit the common cases of no delimiters, no case\n                # transitions, only digits, etc.\n                t.pos = newpos\n                yield t\n                newpos += 1\n            else:\n                # Split the token text on delimiters, word and/or number\n                # boundaries into a list of (text, pos, startchar, endchar)\n                # tuples\n                ranges = self._split(text)\n                parts = [(text[sc:ec], i + newpos, sc, ec)\n                         for i, (sc, ec) in enumerate(ranges)]\n\n                # Did the split yield more than one part?\n                if len(parts) > 1:\n                    # If the options are set, merge consecutive runs of all-\n                    # letters and/or all-numbers.\n                    if mergewords or mergenums:\n                        self._merge(parts)\n\n                # Yield tokens for the parts\n                chars = t.chars\n                if chars:\n                    base = t.startchar\n                for text, pos, startchar, endchar in parts:\n                    t.text = text\n                    t.pos = pos\n                    if t.chars:\n                        t.startchar = base + startchar\n                        t.endchar = base + endchar\n                    yield t\n\n                if parts:\n                    # Set the new position counter based on the last part\n                    newpos = parts[-1][1] + 1", "label": 1}
{"function": "def parse_results(\n    result_file,\n) -> tuple[defaultdict[str, defaultdict[str, dict[str, bool]]], defaultdict[str, set[str]], set[str], str]:\n    \"\"\"Parse a single test results file.\n\n    Returns:\n        Tuple containing:\n        - parsed_results: DefaultDict[provider, DefaultDict[model, Dict[test_name, pass_status]]]\n        - providers_in_file: DefaultDict[provider, Set[model]] found in this file.\n        - tests_in_file: Set[test_name] found in this file.\n        - run_timestamp: Timestamp when the test was run\n    \"\"\"\n    if not os.path.exists(result_file):\n        print(f\"Results file does not exist: {result_file}\")\n        # Return empty defaultdicts/set matching the type hint\n        return defaultdict(lambda: defaultdict(dict)), defaultdict(set), set(), \"\"\n\n    with open(result_file) as f:\n        results = json.load(f)\n\n    # Initialize results dictionary with specific types\n    parsed_results: defaultdict[str, defaultdict[str, dict[str, bool]]] = defaultdict(lambda: defaultdict(dict))\n    providers_in_file: defaultdict[str, set[str]] = defaultdict(set)\n    tests_in_file: set[str] = set()\n    # Extract provider from filename (e.g., \"openai.json\" -> \"openai\")\n    provider: str = result_file.stem\n\n    # Extract run timestamp from the JSON data\n    run_timestamp_unix = results.get(\"run_timestamp\")\n    run_timestamp_str = (\n        time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(run_timestamp_unix))\n        if run_timestamp_unix is not None\n        else \"Unknown\"\n    )\n\n    # Debug: Print summary of test results\n    print(f\"Test results summary for {provider}:\")\n    print(f\"Total tests: {results.get('summary', {}).get('total', 0)}\")\n    print(f\"Passed: {results.get('summary', {}).get('passed', 0)}\")\n    print(f\"Failed: {results.get('summary', {}).get('failed', 0)}\")\n    print(f\"Error: {results.get('summary', {}).get('error', 0)}\")\n    print(f\"Skipped: {results.get('summary', {}).get('skipped', 0)}\")\n\n    # Extract test results\n    if \"tests\" not in results or not results[\"tests\"]:\n        print(f\"No test results found in {result_file}\")\n        # Return empty defaultdicts/set matching the type hint\n        return defaultdict(lambda: defaultdict(dict)), defaultdict(set), set(), \"\"\n\n    # Process the tests\n    for test in results[\"tests\"]:\n        test_id = test.get(\"nodeid\", \"\")\n\n        if not (call_phase := test.get(\"call\")):\n            continue\n        call_outcome = call_phase.get(\"outcome\")\n        if call_outcome not in (\"passed\", \"failed\"):\n            continue\n\n        # --- Extract data from metadata ---\n        metadata = test.get(\"metadata\", {})\n        model = metadata.get(\"model\")\n        case_id = metadata.get(\"case_id\")  # String ID (if provided)\n        case_index = metadata.get(\"case_index\")  # Integer index (if no ID provided)\n\n        # Check if we have a model and at least one case identifier\n        if not model or (case_id is None and case_index is None):\n            print(\n                f\"Warning: Missing 'model' or case identifier ('case_id'/'case_index') metadata for test: {test_id}. Skipping.\"\n            )\n            continue\n\n        try:\n            test_name_base = test_id.split(\"::\")[1].split(\"[\")[0]\n        except (IndexError, ValueError) as e:\n            print(f\"Warning: Could not parse base test name for {test_id}. Error: {e}. Skipping.\")\n            continue\n\n        # Construct detailed test name using ID or index\n        if case_id is not None:\n            detailed_test_name = f\"{test_name_base} ({case_id})\"\n        elif case_index == 0:\n            # If case_id is missing and index is 0, assume single case, use base name only\n            detailed_test_name = test_name_base\n        elif case_index is not None:  # case_index > 0\n            # Use case_index for naming if case_id wasn't provided and index > 0\n            detailed_test_name = f\"{test_name_base} (case{case_index})\"\n        else:\n            # This case should be prevented by the earlier check, but handle defensively\n            print(f\"Error: No case identifier found for test {test_id} after initial check. Skipping.\")\n            continue\n\n        # Populate collections for this file\n        tests_in_file.add(detailed_test_name)\n        providers_in_file[provider].add(model)\n\n        if call_outcome == \"passed\":\n            parsed_results[provider][model][detailed_test_name] = True\n        elif call_outcome == \"failed\":\n            parsed_results[provider][model][detailed_test_name] = False\n\n    # Final Summary Warning (Optional)\n    if not parsed_results.get(provider):\n        print(f\"Warning: No valid test results parsed for provider {provider} from file {result_file}\")\n\n    return parsed_results, providers_in_file, tests_in_file, run_timestamp_str", "label": 0}
{"function": "    def get_prompt_for_current_round(self, content=None):\n        \"\"\"Get current round formatted question prompt during sft training\"\"\"\n        if self.sep_style == SeparatorStyle.PLAIN:\n            formatted_question = \"<image>\\n\"\n        elif self.sep_style == SeparatorStyle.DeepSeek:\n            formatted_question = (\n                f\"{self.roles[0]}: \" + content.strip() + self.sep + f\"{self.roles[1]}:\"\n            )\n        else:\n            raise ValueError(f\"Unsupported sep_style: {self.sep_style}\")\n        return formatted_question", "label": 0}
{"function": "    def digest(self):\n        return msdcc2.encrypt(self._data[:64], user=self._user).decode('hex')", "label": 1}
{"function": "  def test_error(self):\n    with run_configs.get().start(want_rgb=False) as controller:\n      with self.assertRaises(remote_controller.RequestError):\n        controller.create_game(sc_pb.RequestCreateGame())  # Missing map, etc.\n\n      with self.assertRaises(protocol.ProtocolError):\n        controller.join_game(sc_pb.RequestJoinGame())  # No game to join.", "label": 1}
{"function": "def test_add_metrics_missing_required_fields(tracer):\n    \"\"\"Test validation of required fields\"\"\"\n    tracer.trace = {}\n    metrics = [{\"name\": \"metric1\"}]  # Missing score\n    \n    with patch('ragaai_catalyst.tracers.agentic_tracing.tracers.base.logger') as mock_logger:\n        tracer.add_metrics(metrics)\n        mock_logger.error.assert_called_once_with(\n            \"Validation Error: Metric must contain 'name' and 'score' fields\"\n        )\n    assert len(tracer.trace_metrics) == 0", "label": 0}
{"function": "    def test_query_provider(self):\n        \"\"\"\n        wineventlog - Query by provider name (event source)\n        \"\"\"\n        self.write_event_log(\"selected\", source=self.otherAppName)\n        self.write_event_log(\"filtered\")\n        evts = self.read_events(config={\n            \"event_logs\": [\n                {\n                    \"name\": self.providerName,\n                    \"api\": self.api,\n                    \"provider\": [self.otherAppName]\n                }\n            ]\n        })\n        self.assertTrue(len(evts), 1)\n        self.assertEqual(evts[0][\"winlog.provider_name\"], self.otherAppName)", "label": 1}
{"function": "def get_rrmgr_cmd(src, dst, compression=None, tcp_buf_size=None,\n                  connections=None):\n    \"\"\"Returns rrmgr command for source and destination.\"\"\"\n    cmd = ['rrmgr', '-s', 'zfs']\n    if compression:\n        cmd.extend(['-c', six.text_type(compression)])\n    cmd.append('-q')\n    cmd.append('-e')\n    if tcp_buf_size:\n        cmd.extend(['-w', six.text_type(tcp_buf_size)])\n    if connections:\n        cmd.extend(['-n', six.text_type(connections)])\n    cmd.extend([src, dst])\n    return ' '.join(cmd)", "label": 1}
{"function": "    def test_1d_slicing3_npm(self):\n        self.test_1d_slicing3(flags=Noflags)", "label": 1}
{"function": "    def test_basic_set_get(self):\n        \"\"\"Test basic set and get operations\"\"\"\n        cache_instance = cache.TranslationCache(\"test_engine\")\n\n        # Test get with non-existent entry\n        result = cache_instance.get(\"hello\")\n        self.assertIsNone(result)\n\n        # Test set and get\n        cache_instance.set(\"hello\", \"\u4f60\u597d\")\n        result = cache_instance.get(\"hello\")\n        self.assertEqual(result, \"\u4f60\u597d\")", "label": 0}
{"function": "def parse_arguments():\n    \"\"\"\n    Parse command-line arguments such as model directory and device ID.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Spark TTS Gradio server.\")\n    parser.add_argument(\n        \"--model_dir\",\n        type=str,\n        default=\"pretrained_models/Spark-TTS-0.5B\",\n        help=\"Path to the model directory.\"\n    )\n    parser.add_argument(\n        \"--device\",\n        type=int,\n        default=0,\n        help=\"ID of the GPU device to use (e.g., 0 for cuda:0).\"\n    )\n    parser.add_argument(\n        \"--server_name\",\n        type=str,\n        default=\"0.0.0.0\",\n        help=\"Server host/IP for Gradio app.\"\n    )\n    parser.add_argument(\n        \"--server_port\",\n        type=int,\n        default=7860,\n        help=\"Server port for Gradio app.\"\n    )\n    return parser.parse_args()", "label": 0}
{"function": "    def test_unknown_eventlog_config(self):\n        \"\"\"\n        wineventlog - Unknown config parameter\n        \"\"\"\n        self.render_config_template(\n            event_logs=[\n                {\n                    \"name\": self.providerName,\n                    \"api\": self.api,\n                    \"forwarded\": False,\n                    \"invalid\": \"garbage\"}\n            ]\n        )\n        self.start_beat().check_wait(exit_code=1)\n        assert self.log_contains(\n            \"1 error: invalid event log key 'invalid' found.\")", "label": 1}
{"function": "    def __init__(self, W, base_ring = QQ, prefix='u'):\n        r\"\"\"\n        Initiate the affine nil-Coxeter algebra corresponding to the Weyl\n        group `W` over the base ring.\n\n        EXAMPLES::\n\n            sage: U = NilCoxeterAlgebra(WeylGroup(['A',3,1])); U\n            The Nil-Coxeter Algebra of Type A3~ over Rational Field\n            sage: TestSuite(U).run()\n\n            sage: U = NilCoxeterAlgebra(WeylGroup(['C',3]), ZZ); U\n            The Nil-Coxeter Algebra of Type C3 over Integer Ring\n            sage: TestSuite(U).run()\n        \"\"\"\n\n        self._W = W\n        self._n = W.n\n        self._base_ring = base_ring\n        self._cartan_type = W.cartan_type()\n        H = IwahoriHeckeAlgebra(W, 0, 0, base_ring=base_ring)\n        super(IwahoriHeckeAlgebra.T,self).__init__(H, prefix=prefix)", "label": 1}
{"function": "def test_autodetect__when_no_django(env):\n    assert not env.autodetect()", "label": 1}
{"function": "def get_env_value(key, provider):\n    env_mappings = {\n        \"openai\": {\"api_key\": \"OPENAI_API_KEY\", \"base_url\": \"OPENAI_ENDPOINT\"},\n        \"azure_openai\": {\"api_key\": \"AZURE_OPENAI_API_KEY\", \"base_url\": \"AZURE_OPENAI_ENDPOINT\"},\n        \"google\": {\"api_key\": \"GOOGLE_API_KEY\"},\n        \"deepseek\": {\"api_key\": \"DEEPSEEK_API_KEY\", \"base_url\": \"DEEPSEEK_ENDPOINT\"},\n        \"mistral\": {\"api_key\": \"MISTRAL_API_KEY\", \"base_url\": \"MISTRAL_ENDPOINT\"},\n        \"alibaba\": {\"api_key\": \"ALIBABA_API_KEY\", \"base_url\": \"ALIBABA_ENDPOINT\"},\n        \"moonshot\": {\"api_key\": \"MOONSHOT_API_KEY\", \"base_url\": \"MOONSHOT_ENDPOINT\"},\n        \"ibm\": {\"api_key\": \"IBM_API_KEY\", \"base_url\": \"IBM_ENDPOINT\"}\n    }\n\n    if provider in env_mappings and key in env_mappings[provider]:\n        return os.getenv(env_mappings[provider][key], \"\")\n    return \"\"", "label": 0}
{"function": "def set_seed(seed: int):\n    \"\"\"Sets the random seed for reproducibility.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed(seed)\n        torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False", "label": 0}
{"function": "    def mem(self):\n        return self.value.mem", "label": 1}
{"function": "    def __exit__(self, *exc_details):\n        received_exc = exc_details[0] is not None\n\n        # We manipulate the exception state so it behaves as though\n        # we were actually nesting multiple with statements\n        frame_exc = sys.exc_info()[1]\n        _fix_exception_context = _make_context_fixer(frame_exc)\n\n        # Callbacks are invoked in LIFO order to match the behaviour of\n        # nested context managers\n        suppressed_exc = False\n        pending_raise = False\n        while self._exit_callbacks:\n            cb = self._exit_callbacks.pop()\n            try:\n                if cb(*exc_details):\n                    suppressed_exc = True\n                    pending_raise = False\n                    exc_details = (None, None, None)\n            except:\n                new_exc_details = sys.exc_info()\n                # simulate the stack of exceptions by setting the context\n                _fix_exception_context(new_exc_details[1], exc_details[1])\n                pending_raise = True\n                exc_details = new_exc_details\n        if pending_raise:\n            _reraise_with_existing_context(exc_details)\n        return received_exc and suppressed_exc", "label": 1}
{"function": "    def declare(self):\n        self._ass.mem_addr.usage_read()\n        self._ass.mem_buf.usage_write()", "label": 1}
{"function": "    def __init__(self, client, config, serializer, deserializer):\n\n        self._client = client\n        self._serialize = serializer\n        self._deserialize = deserializer\n        self.api_version = \"2019-09-01\"\n\n        self.config = config", "label": 1}
{"function": "    def _add_first_states(self, feed_dict, rollouts):\n        \"\"\"\n        Add first state placeholders for the rollouts.\n        \"\"\"\n        if isinstance(self.init_state_vars, tuple):\n            for i, placeholder in enumerate(self.first_state_ph):\n                first_states = [r.start_state[i][0] for r in rollouts]\n                feed_dict[placeholder] = first_states\n        else:\n            first_states = [r.start_state[0] for r in rollouts]\n            feed_dict[self.first_state_ph] = first_states", "label": 1}
{"function": "    def stateful(self):\n        return True", "label": 1}
{"function": "def start_session(req: gr.Request):\n    user_dir = os.path.join(TMP_DIR, str(req.session_hash))\n    os.makedirs(user_dir, exist_ok=True)", "label": 0}
{"function": "def fold_batch_dim(data: 'DataProto', new_batch_size):\n    \"\"\"\n    Fold a batch dim from [bsz, xxx] into [new_bsz, bsz // new_bsz, xxx]\n    \"\"\"\n    batch_size = data.batch.batch_size[0]\n\n    assert batch_size % new_batch_size == 0\n\n    tensor: TensorDict = data.batch\n    non_tensor = data.non_tensor_batch\n\n    tensor = tensor.view(new_batch_size, -1)\n    tensor.auto_batch_size_(batch_dims=1)\n\n    for key, val in non_tensor.items():\n        non_tensor[key] = np.reshape(val, newshape=(new_batch_size, -1, *val.shape[1:]))\n\n    return DataProto(batch=tensor, non_tensor_batch=non_tensor, meta_info=data.meta_info)", "label": 0}
{"function": "    def __eq__(self, other):\n        return other and self.__class__ is other.__class__\\\n        and self.__dict__ == other.__dict__", "label": 1}
{"function": "def parse_opt():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', type=str, default=ROOT / 'yolo.pt', help='weights path')\n    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='inference size (pixels)')\n    parser.add_argument('--batch-size', type=int, default=1, help='batch size')\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='dataset.yaml path')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')\n    parser.add_argument('--test', action='store_true', help='test exports only')\n    parser.add_argument('--pt-only', action='store_true', help='test PyTorch only')\n    parser.add_argument('--hard-fail', nargs='?', const=True, default=False, help='Exception on error or < min metric')\n    opt = parser.parse_args()\n    opt.data = check_yaml(opt.data)  # check YAML\n    print_args(vars(opt))\n    return opt", "label": 0}
{"function": "    def __post_init__(self):\n        # perform necessary checking\n        self.check_consistency()", "label": 0}
{"function": "    def getAdhesionArea(self) -> Optional[Polygon]:\n        \"\"\"The polygon representing the 2D adhesion area.\n\n        If no adhesion is used, the regular convex hull is returned\n        \"\"\"\n        if self._node is None:\n            return None\n\n        hull = self._compute2DConvexHull()\n        if hull is None:\n            return None\n\n        return self._add2DAdhesionMargin(hull)", "label": 1}
{"function": "    def generate(self,\n                 input_prompt,\n                 img,\n                 max_area=720 * 1280,\n                 frame_num=81,\n                 shift=5.0,\n                 sample_solver='unipc',\n                 sampling_steps=40,\n                 guide_scale=5.0,\n                 n_prompt=\"\",\n                 seed=-1,\n                 offload_model=True):\n        r\"\"\"\n        Generates video frames from input image and text prompt using diffusion process.\n\n        Args:\n            input_prompt (`str`):\n                Text prompt for content generation.\n            img (PIL.Image.Image):\n                Input image tensor. Shape: [3, H, W]\n            max_area (`int`, *optional*, defaults to 720*1280):\n                Maximum pixel area for latent space calculation. Controls video resolution scaling\n            frame_num (`int`, *optional*, defaults to 81):\n                How many frames to sample from a video. The number should be 4n+1\n            shift (`float`, *optional*, defaults to 5.0):\n                Noise schedule shift parameter. Affects temporal dynamics\n                [NOTE]: If you want to generate a 480p video, it is recommended to set the shift value to 3.0.\n            sample_solver (`str`, *optional*, defaults to 'unipc'):\n                Solver used to sample the video.\n            sampling_steps (`int`, *optional*, defaults to 40):\n                Number of diffusion sampling steps. Higher values improve quality but slow generation\n            guide_scale (`float`, *optional*, defaults 5.0):\n                Classifier-free guidance scale. Controls prompt adherence vs. creativity\n            n_prompt (`str`, *optional*, defaults to \"\"):\n                Negative prompt for content exclusion. If not given, use `config.sample_neg_prompt`\n            seed (`int`, *optional*, defaults to -1):\n                Random seed for noise generation. If -1, use random seed\n            offload_model (`bool`, *optional*, defaults to True):\n                If True, offloads models to CPU during generation to save VRAM\n\n        Returns:\n            torch.Tensor:\n                Generated video frames tensor. Dimensions: (C, N H, W) where:\n                - C: Color channels (3 for RGB)\n                - N: Number of frames (81)\n                - H: Frame height (from max_area)\n                - W: Frame width from max_area)\n        \"\"\"\n        img = TF.to_tensor(img).sub_(0.5).div_(0.5).to(self.device)\n\n        F = frame_num\n        h, w = img.shape[1:]\n        aspect_ratio = h / w\n        lat_h = round(\n            np.sqrt(max_area * aspect_ratio) // self.vae_stride[1] //\n            self.patch_size[1] * self.patch_size[1])\n        lat_w = round(\n            np.sqrt(max_area / aspect_ratio) // self.vae_stride[2] //\n            self.patch_size[2] * self.patch_size[2])\n        h = lat_h * self.vae_stride[1]\n        w = lat_w * self.vae_stride[2]\n\n        max_seq_len = ((F - 1) // self.vae_stride[0] + 1) * lat_h * lat_w // (\n            self.patch_size[1] * self.patch_size[2])\n        max_seq_len = int(math.ceil(max_seq_len / self.sp_size)) * self.sp_size\n\n        seed = seed if seed >= 0 else random.randint(0, sys.maxsize)\n        seed_g = torch.Generator(device=self.device)\n        seed_g.manual_seed(seed)\n        noise = torch.randn(\n            16, (F - 1) // 4 + 1,\n            lat_h,\n            lat_w,\n            dtype=torch.float32,\n            generator=seed_g,\n            device=self.device)\n\n        msk = torch.ones(1, 81, lat_h, lat_w, device=self.device)\n        msk[:, 1:] = 0\n        msk = torch.concat([\n            torch.repeat_interleave(msk[:, 0:1], repeats=4, dim=1), msk[:, 1:]\n        ],\n                           dim=1)\n        msk = msk.view(1, msk.shape[1] // 4, 4, lat_h, lat_w)\n        msk = msk.transpose(1, 2)[0]\n\n        if n_prompt == \"\":\n            n_prompt = self.sample_neg_prompt\n\n        # preprocess\n        if not self.t5_cpu:\n            self.text_encoder.model.to(self.device)\n            context = self.text_encoder([input_prompt], self.device)\n            context_null = self.text_encoder([n_prompt], self.device)\n            if offload_model:\n                self.text_encoder.model.cpu()\n        else:\n            context = self.text_encoder([input_prompt], torch.device('cpu'))\n            context_null = self.text_encoder([n_prompt], torch.device('cpu'))\n            context = [t.to(self.device) for t in context]\n            context_null = [t.to(self.device) for t in context_null]\n\n        self.clip.model.to(self.device)\n        clip_context = self.clip.visual([img[:, None, :, :]])\n        if offload_model:\n            self.clip.model.cpu()\n\n        y = self.vae.encode([\n            torch.concat([\n                torch.nn.functional.interpolate(\n                    img[None].cpu(), size=(h, w), mode='bicubic').transpose(\n                        0, 1),\n                torch.zeros(3, F - 1, h, w)\n            ],\n                         dim=1).to(self.device)\n        ])[0]\n        y = torch.concat([msk, y])\n\n        @contextmanager\n        def noop_no_sync():\n            yield\n\n        no_sync = getattr(self.model, 'no_sync', noop_no_sync)\n\n        # evaluation mode\n        with amp.autocast(dtype=self.param_dtype), torch.no_grad(), no_sync():\n\n            if sample_solver == 'unipc':\n                sample_scheduler = FlowUniPCMultistepScheduler(\n                    num_train_timesteps=self.num_train_timesteps,\n                    shift=1,\n                    use_dynamic_shifting=False)\n                sample_scheduler.set_timesteps(\n                    sampling_steps, device=self.device, shift=shift)\n                timesteps = sample_scheduler.timesteps\n            elif sample_solver == 'dpm++':\n                sample_scheduler = FlowDPMSolverMultistepScheduler(\n                    num_train_timesteps=self.num_train_timesteps,\n                    shift=1,\n                    use_dynamic_shifting=False)\n                sampling_sigmas = get_sampling_sigmas(sampling_steps, shift)\n                timesteps, _ = retrieve_timesteps(\n                    sample_scheduler,\n                    device=self.device,\n                    sigmas=sampling_sigmas)\n            else:\n                raise NotImplementedError(\"Unsupported solver.\")\n\n            # sample videos\n            latent = noise\n\n            arg_c = {\n                'context': [context[0]],\n                'clip_fea': clip_context,\n                'seq_len': max_seq_len,\n                'y': [y],\n            }\n\n            arg_null = {\n                'context': context_null,\n                'clip_fea': clip_context,\n                'seq_len': max_seq_len,\n                'y': [y],\n            }\n\n            if offload_model:\n                torch.cuda.empty_cache()\n\n            self.model.to(self.device)\n            for _, t in enumerate(tqdm(timesteps)):\n                latent_model_input = [latent.to(self.device)]\n                timestep = [t]\n\n                timestep = torch.stack(timestep).to(self.device)\n\n                noise_pred_cond = self.model(\n                    latent_model_input, t=timestep, **arg_c)[0].to(\n                        torch.device('cpu') if offload_model else self.device)\n                if offload_model:\n                    torch.cuda.empty_cache()\n                noise_pred_uncond = self.model(\n                    latent_model_input, t=timestep, **arg_null)[0].to(\n                        torch.device('cpu') if offload_model else self.device)\n                if offload_model:\n                    torch.cuda.empty_cache()\n                noise_pred = noise_pred_uncond + guide_scale * (\n                    noise_pred_cond - noise_pred_uncond)\n\n                latent = latent.to(\n                    torch.device('cpu') if offload_model else self.device)\n\n                temp_x0 = sample_scheduler.step(\n                    noise_pred.unsqueeze(0),\n                    t,\n                    latent.unsqueeze(0),\n                    return_dict=False,\n                    generator=seed_g)[0]\n                latent = temp_x0.squeeze(0)\n\n                x0 = [latent.to(self.device)]\n                del latent_model_input, timestep\n\n            if offload_model:\n                self.model.cpu()\n                torch.cuda.empty_cache()\n\n            if self.rank == 0:\n                videos = self.vae.decode(x0)\n\n        del noise, latent\n        del sample_scheduler\n        if offload_model:\n            gc.collect()\n            torch.cuda.synchronize()\n        if dist.is_initialized():\n            dist.barrier()\n\n        return videos[0] if self.rank == 0 else None", "label": 0}
{"function": "    def test_providing_channel(self):\n        chan = Mock(name='channel')\n        cs = compat.ConsumerSet(self.connection, channel=chan)\n        assert cs._provided_channel\n        assert cs.backend is chan\n\n        cs.cancel = Mock(name='cancel')\n        cs.close()\n        chan.close.assert_not_called()", "label": 1}
{"function": "\tdef exit(self, save=True):\n\t\t\"\"\" Close the database and save all operations done to it if `save` is\n\t\tTrue. Write all contexts paths (NON fully-dotted) to the contexts file\n\t\tif at least one context was created or removed during operations. The\n\t\tcontexts file exists for terminal auto-completion.\"\"\"\n\t\tif save:\n\t\t\tself.connection.commit()\n\t\t\tif self.changed_contexts:\n\t\t\t\tc = self.connection.cursor()\n\t\t\t\tc.execute(\"\"\"\n\t\t\t\t\tSELECT DISTINCT path FROM Context\n\t\t\t\t\tORDER BY path\n\t\t\t\t\"\"\")\n\t\t\t\tdata_ctx = op.join(DATA_DIR, DATA_CTX_NAME)\n\t\t\t\twith open(data_ctx, 'w') as ctx_file:\n\t\t\t\t\tfor row in c:\n\t\t\t\t\t\tctx = userify_context(row[0])\n\t\t\t\t\t\tctx_file.write(ctx + '\\n')\n\t\tself.connection.close()", "label": 1}
{"function": "def init_model(args):\n    tokenizer = AutoTokenizer.from_pretrained('./model/')\n    if args.load == 0:\n        moe_path = '_moe' if args.use_moe else ''\n        modes = {0: 'pretrain', 1: 'full_sft', 2: 'rlhf', 3: 'reason', 4: 'grpo'}\n        ckp = f'./{args.out_dir}/{modes[args.model_mode]}_{args.hidden_size}{moe_path}.pth'\n\n        model = MiniMindForCausalLM(MiniMindConfig(\n            hidden_size=args.hidden_size,\n            num_hidden_layers=args.num_hidden_layers,\n            use_moe=args.use_moe\n        ))\n\n        model.load_state_dict(torch.load(ckp, map_location=args.device), strict=True)\n\n        if args.lora_name != 'None':\n            apply_lora(model)\n            load_lora(model, f'./{args.out_dir}/lora/{args.lora_name}_{args.hidden_size}.pth')\n    else:\n        transformers_model_path = './MiniMind2'\n        tokenizer = AutoTokenizer.from_pretrained(transformers_model_path)\n        model = AutoModelForCausalLM.from_pretrained(transformers_model_path, trust_remote_code=True)\n    print(f'MiniMind\u6a21\u578b\u53c2\u6570\u91cf: {sum(p.numel() for p in model.parameters() if p.requires_grad) / 1e6:.2f}M(illion)')\n    return model.eval().to(args.device), tokenizer", "label": 0}
{"function": "\t\tdef no_filter_action():\n\t\t\tpass", "label": 0}
{"function": "def prompt_user_action() -> str:\n    \"\"\"\n    Use inquirer to ask the user which action they want to perform.\n\n    :return: Selected action.\n    \"\"\"\n    try:\n        questions = [\n            inquirer.List(\n                'action',\n                message=\"Select the action you want to perform:\",\n                choices=[\n                    \"Generate Resume\",\n                    \"Generate Resume Tailored for Job Description\",\n                    \"Generate Tailored Cover Letter for Job Description\",\n                ],\n            ),\n        ]\n        answer = inquirer.prompt(questions)\n        if answer is None:\n            print(\"No answer provided. The user may have interrupted.\")\n            return \"\"\n        return answer.get('action', \"\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return \"\"", "label": 0}
{"function": "    def __init__(\n        self,\n        tracing_enabled: bool = False,\n        initial_output: list[TResponseOutputItem] | Exception | None = None,\n    ):\n        if initial_output is None:\n            initial_output = []\n        self.turn_outputs: list[list[TResponseOutputItem] | Exception] = (\n            [initial_output] if initial_output else []\n        )\n        self.tracing_enabled = tracing_enabled\n        self.last_turn_args: dict[str, Any] = {}\n        self.hardcoded_usage: Usage | None = None", "label": 0}
{"function": "def test_search_with_metadata(setup_test_memory):\n    \"\"\"Test search with metadata\"\"\"\n    video_file, index_file, chunks = setup_test_memory\n    retriever = MemvidRetriever(video_file, index_file)\n    \n    results = retriever.search_with_metadata(\"blockchain\", top_k=2)\n    assert len(results) <= 2\n    \n    if results:\n        result = results[0]\n        assert \"text\" in result\n        assert \"score\" in result\n        assert \"chunk_id\" in result\n        assert \"frame\" in result\n        assert result[\"score\"] > 0", "label": 0}
{"function": "    async def visit_page(self, channel_names: list[str] = None):\n        tasks_config = [\n            (\"hotel_fofa\", get_channels_by_fofa, \"hotel_fofa_result\"),\n            (\"multicast\", get_channels_by_multicast, \"multicast_result\"),\n            (\"hotel_foodie\", get_channels_by_hotel, \"hotel_foodie_result\"),\n            (\"subscribe\", get_channels_by_subscribe_urls, \"subscribe_result\"),\n            (\n                \"online_search\",\n                get_channels_by_online_search,\n                \"online_search_result\",\n            ),\n            (\"epg\", get_epg, \"epg_result\"),\n        ]\n\n        for setting, task_func, result_attr in tasks_config:\n            if (\n                    setting == \"hotel_foodie\" or setting == \"hotel_fofa\"\n            ) and config.open_hotel == False:\n                continue\n            if config.open_method[setting]:\n                if setting == \"subscribe\":\n                    subscribe_urls = get_urls_from_file(constants.subscribe_path)\n                    whitelist_urls = get_urls_from_file(constants.whitelist_path)\n                    if not os.getenv(\"GITHUB_ACTIONS\") and config.cdn_url:\n                        subscribe_urls = [join_url(config.cdn_url, url) if \"raw.githubusercontent.com\" in url else url\n                                          for url in subscribe_urls]\n                    task = asyncio.create_task(\n                        task_func(subscribe_urls,\n                                  names=channel_names,\n                                  whitelist=whitelist_urls,\n                                  callback=self.update_progress\n                                  )\n                    )\n                elif setting == \"hotel_foodie\" or setting == \"hotel_fofa\":\n                    task = asyncio.create_task(task_func(callback=self.update_progress))\n                else:\n                    task = asyncio.create_task(\n                        task_func(channel_names, callback=self.update_progress)\n                    )\n                self.tasks.append(task)\n                setattr(self, result_attr, await task)", "label": 0}
{"function": "    def test_include_xml(self):\n        \"\"\"\n        wineventlog - Include raw XML event\n        \"\"\"\n        msg = \"Include raw XML event\"\n        self.write_event_log(msg)\n        evts = self.read_events(config={\n            \"event_logs\": [\n                {\n                    \"name\": self.providerName,\n                    \"api\": self.api,\n                    \"include_xml\": True,\n                }\n            ]\n        })\n        self.assertTrue(len(evts), 1)\n        self.assert_common_fields(evts[0], msg=msg)\n        self.assertTrue(\"event.original\" in evts[0])\n        original = evts[0][\"event.original\"]\n        self.assertTrue(original.endswith('</Event>'),\n                        'xml value should end with </Event>: \"{}\"'.format(original))", "label": 1}
{"function": "def encode_jpeg_handler(converter: TensorFlowConverter, tf_op: \"tf.Operation\"):\n    raise NotImplementedError(f\"[TensorFlowConverter] {tf_op.type} is not supported yet.\")", "label": 1}
{"function": "    def __init__(self, open, high, low, close):\n        pass", "label": 1}
{"function": "    def _fetch_thumbnail(self):\n        url = get_thumbnail_url(self.data)\n        if url is not None:\n            self._msg = self._api.download_thumb(\n                url, self.__message_done_cb)", "label": 1}
{"function": "async def test_get_file_size(computer):\n    \"\"\"Test get_file_size functionality.\"\"\"\n    tmp_path = \"test_file_size.txt\"\n    test_content = \"A\" * 1000  # 1000 bytes\n    \n    await computer.interface.write_text(tmp_path, test_content)\n    \n    file_size = await computer.interface.get_file_size(tmp_path)\n    assert file_size == 1000, f\"File size should be 1000 bytes, got {file_size}\"\n    \n    await computer.interface.delete_file(tmp_path)", "label": 0}
{"function": "        def _expanduser(path):\n            return self.tmpdir", "label": 1}
{"function": "    def read(self):\n        self.get_style_context().add_class('read')\n        self._g('unread').props.visible = False", "label": 1}
{"function": "        def default_callback(self, *args, **kwargs):\n            pass", "label": 0}
{"function": "    def __init__(self):\n        self.root_path = config.root_path\n        self.server_reference = config.mcp_config.server_reference\n        self.agent = MCPAgent()", "label": 0}
{"function": "def convert_root_path():\n    frame = inspect.currentframe().f_back\n    caller_file = frame.f_code.co_filename\n    caller_file = os.path.abspath(caller_file)\n    result = os.path.join(os.path.dirname(caller_file), 'huggingface_space_mirror')\n    return result + '/'", "label": 0}
{"function": "def setup_test_memory():\n    \"\"\"Create test video and index\"\"\"\n    encoder = MemvidEncoder()\n    chunks = [\n        \"Quantum computing uses qubits for parallel processing\",\n        \"Machine learning models require large datasets\",\n        \"Neural networks mimic brain structure\",\n        \"Cloud computing provides scalable resources\",\n        \"Blockchain ensures data immutability\"\n    ]\n    encoder.add_chunks(chunks)\n    \n    with tempfile.TemporaryDirectory() as temp_dir:\n        video_file = os.path.join(temp_dir, \"test.mp4\")\n        index_file = os.path.join(temp_dir, \"test_index.json\")\n        \n        encoder.build_video(video_file, index_file, show_progress=False)\n        \n        yield video_file, index_file, chunks", "label": 0}
{"function": "def failed(message=\"Please, reload the task and try again.\", name=None):\n    \"\"\" Reports failure \"\"\"\n    if not name:\n        name = sys._getframe().f_back.f_code.co_name\n    print(\"#educational_plugin \" + name + \" FAILED + \" + message)", "label": 1}
{"function": "def build(setup_kwargs):\n    \"\"\"\n    This function is called by Poetry during the build process.\n    `setup_kwargs` is a dictionary that will be passed to `setuptools.setup()`.\n    \"\"\"\n    print('--- Running custom Poetry build script (build_vscode.py) ---')\n\n    # Build the VS Code extension and place the .vsix file\n    build_vscode_extension()\n\n    # Poetry will handle including files based on pyproject.toml `include` patterns.\n    # Ensure openhands/integrations/vscode/*.vsix is included there.\n\n    print('--- Custom Poetry build script (build_vscode.py) finished ---')", "label": 0}
{"function": "async def get_search_refs(request: QueryRequest):\n\n    global search_results\n    search_results = []\n    search_item_list = []\n    if request.ask_type == \"search\":\n        search_links,search_results = free_ask_internet.search_web_ref(request.query)\n        for search_item in search_links:\n            snippet = search_item.get(\"snippet\")\n            url = search_item.get(\"url\")\n            icon_url = search_item.get(\"icon_url\")\n            site_name = search_item.get(\"site_name\")\n            title = search_item.get(\"title\")\n    \n\n            si = SearchItem(snippet=snippet,url=url,icon_url=icon_url,site_name=site_name,title=title)\n\n            search_item_list.append(si)\n\n    resp = SearchResp(code=0,msg=\"success\",data=search_item_list)\n   \n    return  resp", "label": 0}
{"function": "    def test_create_dhparams(self, tmpdir):\n        filename = str(tmpdir.join(\"dhparam.pem\"))\n        certs.CertStore.load_dhparam(filename)\n        assert os.path.exists(filename)", "label": 1}
{"function": "        def on_update(www_auth):\n            if not www_auth and 'www-authenticate' in self.headers:\n                del self.headers['www-authenticate']\n            elif www_auth:\n                self.headers['WWW-Authenticate'] = www_auth.to_header()", "label": 1}
{"function": "def get_browser_session():\n    project_name = request.args.get(\"project_name\")\n    agent_state = AgentState.get_latest_state(project_name)\n    if not agent_state:\n        return jsonify({\"session\": None})\n    else:\n        browser_session = agent_state[\"browser_session\"]\n        return jsonify({\"session\": browser_session})", "label": 0}
{"function": "    def _parseReply(self, tag_name, elements, data):\n        \"\"\"\n        Gets the replies from the PLC\n        In the case of BOOL arrays and bits of\n            a word, we do some reformating\n        \"\"\"\n        tag, base_tag, index = _parseTagName(tag_name, 0)\n        data_type = self.KnownTags[base_tag][0]\n        bit_count = self.CIPTypes[data_type][0] * 8\n\n        # if bit of word was requested\n        if BitofWord(tag_name):\n            split_tag = tag_name.split('.')\n            bit_pos = split_tag[len(split_tag)-1]\n            bit_pos = int(bit_pos)\n\n            word_count = _getWordCount(bit_pos, elements, bit_count)\n            words = self._getReplyValues(tag_name, word_count, data)\n            vals = self._wordsToBits(tag_name, words, count=elements)\n        elif data_type == 211:\n            word_count = _getWordCount(index, elements, bit_count)\n            words = self._getReplyValues(tag_name, word_count, data)\n            vals = self._wordsToBits(tag_name, words, count=elements)\n        else:\n            vals = self._getReplyValues(tag_name, elements, data)\n\n        return vals", "label": 1}
{"function": "  def testExtensionScope(self):\n    self.assertEqual(unittest_pb2.optional_int32_extension.extension_scope,\n                     None)\n    self.assertEqual(unittest_pb2.TestRequired.single.extension_scope,\n                     unittest_pb2.TestRequired.DESCRIPTOR)", "label": 1}
{"function": "    def test_delitem_with_1_valid_key(self):\n        d = {\n            'a': 1,\n        }\n        b = KeypathDict(d)\n        del b['a']\n        with self.assertRaises(KeyError):\n            del b['a']\n        self.assertEqual(b.get('a'), None)", "label": 1}
{"function": "def main() -> None:\n    asyncio.run(run())", "label": 0}
{"function": "    def fit(self, attribute_list, class_list, row_sampler, col_sampler, bin_structure):\n        # when we start to fit a tree, we first conduct row and column sampling\n        col_sampler.shuffle()\n        row_sampler.shuffle()\n        class_list.sampling(row_sampler.row_mask)\n\n        # then we create the root node, initialize histogram(Gradient sum and Hessian sum)\n        root_node = TreeNode(name=1, depth=1, feature_dim=attribute_list.feature_dim)\n        root_node.Grad_setter(class_list.grad.sum())\n        root_node.Hess_setter(class_list.hess.sum())\n        self.root = root_node\n\n        # every time a new node is created, we put it into self.name_to_node\n        self.name_to_node[root_node.name] = root_node\n\n        # put it into the alive_node, and fill the class_list, all data are assigned to root node initially\n        self.alive_nodes.append(root_node)\n        for i in range(class_list.dataset_size):\n            class_list.corresponding_tree_node[i] = root_node\n\n        # then build the tree util there is no alive tree_node to split\n        self.build(attribute_list, class_list, col_sampler, bin_structure)\n        self.clean_up()", "label": 1}
{"function": "def list_of_dict_to_dict_of_list(list_of_dict: list[dict]):\n    if len(list_of_dict) == 0:\n        return {}\n    keys = list_of_dict[0].keys()\n    output = {key: [] for key in keys}\n    for data in list_of_dict:\n        for key, item in data.items():\n            assert key in output\n            output[key].append(item)\n    return output", "label": 0}
{"function": "    def __message_done_cb(self, pixbuf):\n        self._msg = None\n        self._g('preview').props.pixbuf = pixbuf\n        self._g('preview-button').show()\n        self._g('preview-button').connect('clicked', self.__image_clicked_cb)", "label": 1}
{"function": "    def _initial_read(self, tag, base_tag, data_type):\n        \"\"\"\n        Store each unique tag read in a dict so that we can retreive the\n        data type or data length (for STRING) later\n        \"\"\"\n        # if a tag already exists, return True\n        if base_tag in self.KnownTags:\n            return tag, None, 0\n        if data_type:\n            self.KnownTags[base_tag] = (data_type, 0)\n            return tag, None, 0\n\n        ioi = self._buildTagIOI(base_tag, data_type)\n        request = self._add_partial_read_service(ioi, 1)\n\n        # send our tag read request\n        status, ret_data = self.conn.send(request)\n\n        # make sure it was successful\n        if status == 0 or status == 6:\n            data_type = unpack_from('<B', ret_data, 50)[0]\n            data_len = unpack_from('<H', ret_data, 2)[0]\n            self.KnownTags[base_tag] = (data_type, data_len)\n            return tag, None, 0\n        else:\n            return tag, None, status", "label": 1}
{"function": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('input', type=str, nargs='+',\n                        help='Source file or directory.')\n    parser.add_argument('output', type=str,\n                        help='Destination directory.')\n    parser.add_argument('-W', '--width', type=int, default=320,\n                        help='width of output image (default:320)')\n    parser.add_argument('-H', '--height', type=int, default=320,\n                        help='height of output image (default:320)')\n    parser.add_argument('-m', '--mode', default='trimming',\n                        choices=['trimming', 'padding'],\n                        help='shaping mode (trimming or padding)  (default:trimming)')\n    parser.add_argument('-S', '--shuffle', choices=['True', 'False'],\n                        help='shuffle mode if not specified, train:True, val:False.' +\n                        ' Otherwise specified value will be used for both.')\n    parser.add_argument('-N', '--file-cache-size', type=int, default=100,\n                        help='num of data in cache file (default:100)')\n    parser.add_argument('-C', '--cache-type', default='npy',\n                        choices=['h5', 'npy'],\n                        help='cache format (h5 or npy) (default:npy)')\n    parser.add_argument('--thinning', type=int, default=1,\n                        help='Thinning rate')\n\n    args = parser.parse_args()\n    ############################################################################\n    # Analyze tar\n    # If it consists only of members corresponding to regular expression\n    # 'n[0-9]{8}\\.tar', it is judged as train data archive.\n    # If it consists only of members corresponding to regular expression\n    # 'ILSVRC2012_val_[0-9]{8}\\.JPEG', it is judged as validation data archive.\n\n    archives = {'train': None, 'val': None}\n    for inputarg in args.input:\n        print('Checking input file [{}]'.format(inputarg))\n        archive = tarfile.open(inputarg)\n        is_train = False\n        is_val = False\n        names = []\n        for name in archive.getnames():\n            if re.match(r'n[0-9]{8}\\.tar', name):\n                if is_val:\n                    print('Train data {} includes in validation tar'.format(name))\n                    exit(-1)\n                is_train = True\n            elif re.match(r'ILSVRC2012_val_[0-9]{8}\\.JPEG', name):\n                if is_train:\n                    print('Validation data {} includes in train tar'.format(name))\n                    exit(-1)\n                is_val = True\n            else:\n                print('Invalid member {} includes in tar file'.format(name))\n                exit(-1)\n            names.append(name)\n        if is_train:\n            if archives['train'] is None:\n                archives['train'] = (archive, names)\n            else:\n                print('Please specify only 1 training tar archive.')\n                exit(-1)\n        if is_val:\n            if archives['val'] is None:\n                archives['val'] = (archive, names)\n            else:\n                print('Please specify only 1 validation tar archive.')\n                exit(-1)\n\n    # Read label of validation data, (Use ascending label of wordnet_id)\n    validation_ground_truth = []\n    g_file = VALIDATION_DATA_LABEL\n    with open(g_file, 'r') as f:\n        for l in f.readlines():\n            validation_ground_truth.append(int(l.rstrip()))\n\n    ############################################################################\n    # Prepare logging\n    tmpdir = tempfile.mkdtemp()\n    logfilename = os.path.join(tmpdir, 'nnabla.log')\n\n    # Temporarily chdir to tmpdir just before importing nnabla to reflect nnabla.conf.\n    cwd = os.getcwd()\n    os.chdir(tmpdir)\n    with open('nnabla.conf', 'w') as f:\n        f.write('[LOG]\\n')\n        f.write('log_file_name = {}\\n'.format(logfilename))\n        f.write('log_file_format = %(funcName)s : %(message)s\\n')\n        f.write('log_console_level = CRITICAL\\n')\n\n    from nnabla.config import nnabla_config\n    os.chdir(cwd)\n\n    ############################################################################\n    # Data iterator setting\n    nnabla_config.set('DATA_ITERATOR',\n                      'cache_file_format', '.' + args.cache_type)\n    nnabla_config.set('DATA_ITERATOR',\n                      'data_source_file_cache_size', str(args.file_cache_size))\n    nnabla_config.set('DATA_ITERATOR',\n                      'data_source_file_cache_num_of_threads', '1')\n\n    if not os.path.isdir(args.output):\n        os.makedirs(args.output)\n\n    ############################################################################\n    # Prepare status monitor\n    from nnabla.utils.progress import configure_progress\n    configure_progress(None, _progress)\n\n    ############################################################################\n    # Converter\n\n    try:\n        if archives['train'] is not None:\n            from nnabla.logger import logger\n            logger.info('StartCreatingCache')\n            archive, names = archives['train']\n            output = os.path.join(args.output, 'train')\n            if not os.path.isdir(output):\n                os.makedirs(output)\n            _create_train_cache(archive, output, names, args)\n        if archives['val'] is not None:\n            from nnabla.logger import logger\n            logger.info('StartCreatingCache')\n            archive, names = archives['val']\n            output = os.path.join(args.output, 'val')\n            if not os.path.isdir(output):\n                os.makedirs(output)\n            _create_validation_cache(\n                archive, output, names, validation_ground_truth, args)\n    except KeyboardInterrupt:\n        shutil.rmtree(tmpdir, ignore_errors=True)\n\n        # Even if CTRL-C is pressed, it does not stop if there is a running\n        # thread, so it sending a signal to itself.\n        os.kill(os.getpid(), 9)\n\n    ############################################################################\n    # Finish\n    _finish = True\n    shutil.rmtree(tmpdir, ignore_errors=True)", "label": 1}
{"function": "    def homogeneous_generator_noncommutative_variables(self, r):\n        r\"\"\"\n        Give the `r^{th}` homogeneous function inside the Nil-Coxeter algebra.\n        In finite type `A` this is the sum of all decreasing elements of length `r`.\n        In affine type `A` this is the sum of all cyclically decreasing elements of length `r`.\n        This is only defined in finite type `A`, `B` and affine types `A^{(1)}`, `B^{(1)}`, `C^{(1)}`, `D^{(1)}`.\n\n        INPUT:\n\n        - ``r`` -- a positive integer at most the rank of the Weyl group\n\n        EXAMPLES::\n\n            sage: U = NilCoxeterAlgebra(WeylGroup(['A',3,1]))\n            sage: U.homogeneous_generator_noncommutative_variables(2)\n            u[1,0] + u[2,0] + u[0,3] + u[3,2] + u[3,1] + u[2,1]\n\n            sage: U = NilCoxeterAlgebra(WeylGroup(['B',4]))\n            sage: U.homogeneous_generator_noncommutative_variables(2)\n            u[1,2] + u[2,1] + u[3,1] + u[4,1] + u[2,3] + u[3,2] + u[4,2] + u[3,4] + u[4,3]\n\n            sage: U = NilCoxeterAlgebra(WeylGroup(['C',3]))\n            sage: U.homogeneous_generator_noncommutative_variables(2)\n            Traceback (most recent call last):\n            ...\n            AssertionError: Analogue of symmetric functions in noncommutative variables is not defined in type ['C', 3]\n\n        TESTS::\n\n            sage: U = NilCoxeterAlgebra(WeylGroup(['B',3,1]))\n            sage: U.homogeneous_generator_noncommutative_variables(-1)\n            0\n            sage: U.homogeneous_generator_noncommutative_variables(0)\n            1\n\n        \"\"\"\n        assert (len(self._cartan_type) == 2 and self._cartan_type[0] in ['A','B']) or (len(self._cartan_type) == 3 and self._cartan_type[2] == 1), \"Analogue of symmetric functions in noncommutative variables is not defined in type %s\"%(self._cartan_type)\n        if r >= self._n:\n            return self.zero()\n        return self.sum_of_monomials(w for w in self._W.pieri_factors() if w.length() == r)", "label": 1}
{"function": "    def _get_label(wordnet_id):\n        for item in wid2ind:\n            if item[1] == wordnet_id:\n                return item[0]", "label": 1}
{"function": "async def main():\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(description=\"Run Manus agent with a prompt\")\n    parser.add_argument(\n        \"--prompt\", type=str, required=False, help=\"Input prompt for the agent\"\n    )\n    args = parser.parse_args()\n\n    # Create and initialize Manus agent\n    agent = await Manus.create()\n    try:\n        # Use command line prompt if provided, otherwise ask for input\n        prompt = args.prompt if args.prompt else input(\"Enter your prompt: \")\n        if not prompt.strip():\n            logger.warning(\"Empty prompt provided.\")\n            return\n\n        logger.warning(\"Processing your request...\")\n        await agent.run(prompt)\n        logger.info(\"Request processing completed.\")\n    except KeyboardInterrupt:\n        logger.warning(\"Operation interrupted.\")\n    finally:\n        # Ensure agent resources are cleaned up before exiting\n        await agent.cleanup()", "label": 0}
{"function": "    def test_wait(self, n='test_wait'):\n\n        class C(compat.Consumer):\n\n            def iterconsume(self, limit=None):\n                yield from range(limit)\n\n        c = C(self.connection,\n              queue=n, exchange=n, routing_key='rkey')\n        assert c.wait(10) == list(range(10))\n        c.close()", "label": 1}
{"function": "    def generate(\n        self,\n        prompt_tokens: List[List[int]],\n        max_gen_len: int,\n        temperature: float = 0.6,\n        top_p: float = 0.9,\n        logprobs: bool = False,\n        echo: bool = False,\n    ) -> Tuple[List[List[int]], Optional[List[List[float]]]]:\n        \"\"\"\n        Generate text sequences based on provided prompts using the language generation model.\n\n        Args:\n            prompt_tokens (List[List[int]]): List of tokenized prompts, where each prompt is represented as a list of integers.\n            max_gen_len (int): Maximum length of the generated text sequence.\n            temperature (float, optional): Temperature value for controlling randomness in sampling. Defaults to 0.6.\n            top_p (float, optional): Top-p probability threshold for nucleus sampling. Defaults to 0.9.\n            logprobs (bool, optional): Flag indicating whether to compute token log probabilities. Defaults to False.\n            echo (bool, optional): Flag indicating whether to include prompt tokens in the generated output. Defaults to False.\n\n        Returns:\n            Tuple[List[List[int]], Optional[List[List[float]]]]: A tuple containing generated token sequences and, if logprobs is True, corresponding token log probabilities.\n\n        Note:\n            This method uses the provided prompts as a basis for generating text. It employs nucleus sampling to produce text with controlled randomness.\n            If logprobs is True, token log probabilities are computed for each generated token.\n\n        \"\"\"\n        params = self.model.params\n        bsz = len(prompt_tokens)\n        assert bsz <= params.max_batch_size, (bsz, params.max_batch_size)\n\n        min_prompt_len = min(len(t) for t in prompt_tokens)\n        max_prompt_len = max(len(t) for t in prompt_tokens)\n        assert max_prompt_len <= params.max_seq_len\n        total_len = min(params.max_seq_len, max_gen_len + max_prompt_len)\n\n        pad_id = self.tokenizer.pad_id\n        tokens = torch.full((bsz, total_len), pad_id, dtype=torch.long, device=\"cuda\")\n        for k, t in enumerate(prompt_tokens):\n            tokens[k, : len(t)] = torch.tensor(t, dtype=torch.long, device=\"cuda\")\n        if logprobs:\n            token_logprobs = torch.zeros_like(tokens, dtype=torch.float)\n\n        prev_pos = 0\n        eos_reached = torch.tensor([False] * bsz, device=\"cuda\")\n        input_text_mask = tokens != pad_id\n        if min_prompt_len == total_len:\n            logits = self.model.forward(tokens, prev_pos)\n            token_logprobs = -F.cross_entropy(\n                input=logits.transpose(1, 2),\n                target=tokens,\n                reduction=\"none\",\n                ignore_index=pad_id,\n            )\n\n        stop_tokens = torch.tensor(list(self.tokenizer.stop_tokens))\n\n        for cur_pos in range(min_prompt_len, total_len):\n            logits = self.model.forward(tokens[:, prev_pos:cur_pos], prev_pos)\n            if temperature > 0:\n                probs = torch.softmax(logits[:, -1] / temperature, dim=-1)\n                next_token = sample_top_p(probs, top_p)\n            else:\n                next_token = torch.argmax(logits[:, -1], dim=-1)\n\n            next_token = next_token.reshape(-1)\n            # only replace token if prompt has already been generated\n            next_token = torch.where(\n                input_text_mask[:, cur_pos], tokens[:, cur_pos], next_token\n            )\n            tokens[:, cur_pos] = next_token\n            if logprobs:\n                token_logprobs[:, prev_pos + 1 : cur_pos + 1] = -F.cross_entropy(\n                    input=logits.transpose(1, 2),\n                    target=tokens[:, prev_pos + 1 : cur_pos + 1],\n                    reduction=\"none\",\n                    ignore_index=pad_id,\n                )\n            eos_reached |= (~input_text_mask[:, cur_pos]) & (\n                torch.isin(next_token, stop_tokens)\n            )\n            prev_pos = cur_pos\n            if all(eos_reached):\n                break\n\n        if logprobs:\n            token_logprobs = token_logprobs.tolist()\n        out_tokens, out_logprobs = [], []\n        for i, toks in enumerate(tokens.tolist()):\n            # cut to max gen len\n            start = 0 if echo else len(prompt_tokens[i])\n            toks = toks[start : len(prompt_tokens[i]) + max_gen_len]\n            probs = None\n            if logprobs:\n                probs = token_logprobs[i][start : len(prompt_tokens[i]) + max_gen_len]\n            # cut to after eos tok if any\n            for stop_token in self.tokenizer.stop_tokens:\n                try:\n                    eos_idx = toks.index(stop_token)\n                    toks = toks[:eos_idx]\n                    probs = probs[:eos_idx] if logprobs else None\n                except ValueError:\n                    pass\n            out_tokens.append(toks)\n            out_logprobs.append(probs)\n        return (out_tokens, out_logprobs if logprobs else None)", "label": 0}
{"function": "def check_node_version():\n    \"\"\"Check if Node.js version is sufficient for building the extension.\"\"\"\n    try:\n        result = subprocess.run(\n            ['node', '--version'], capture_output=True, text=True, check=True\n        )\n        version_str = result.stdout.strip()\n        # Extract major version number (e.g., \"v12.22.9\" -> 12)\n        major_version = int(version_str.lstrip('v').split('.')[0])\n        return major_version >= 18  # Align with frontend actual usage (18.20.1)\n    except (subprocess.CalledProcessError, FileNotFoundError, ValueError):\n        return False", "label": 0}
{"function": "def mock_openai_client():\n    m = MockOpenAIClient()\n    m.set_response(\n        create_mock_response({\"role\": \"assistant\", \"content\": DEFAULT_RESPONSE_CONTENT})\n    )\n    return m", "label": 0}
{"function": "    def testTobaccoPaperMissingParagraphs(self):\n        local_pdf_path = os.path.join(os.path.dirname(__file__), \"gnarly_pdfs\", \"tobacco_missed_tokens_pg1.pdf\")\n\n        anchor_text = get_anchor_text(local_pdf_path, 1, pdf_engine=\"pdfreport\")\n\n        print(anchor_text)\n        print(len(anchor_text))\n        self.assertLessEqual(len(anchor_text), 4000)", "label": 0}
{"function": "    def _percent_uncovered(key):\n        (total, covered, percent) = covdata[key].coverage()\n        if covered:\n            return -1.0*covered/total\n        else:\n            return total or 1e6", "label": 1}
{"function": "def send_request(ques):\n    # url = 'https://qanything-test.site.youdao.com/api/local_doc_qa/local_doc_chat'\n    url = 'http://localhost:8777/api/local_doc_qa/local_doc_chat'\n    headers = {\n        'content-type': 'application/json'\n    }\n    data = {\n        \"user_id\": \"liujx_265\",\n        \"kb_ids\": [\"KBf652e9e379c546f1894597dcabdc8e47\"],\n        \"question\": ques,\n        \"rerank\": False,\n        \"history\": []\n    }\n    try:\n        start_time = time.time()\n        response = requests.post(url=url, headers=headers, json=data, timeout=60)\n        end_time = time.time()\n        response_times.append(end_time - start_time)\n        res = response.json()\n        print(res['response'])\n        print(f\"\u54cd\u5e94\u72b6\u6001\u7801: {response.status_code}, \u54cd\u5e94\u65f6\u95f4: {end_time - start_time}\u79d2\")\n    except Exception as e:\n        print(f\"\u8bf7\u6c42\u53d1\u9001\u5931\u8d25: {e}\")", "label": 0}
{"function": "    def __init__(self, base_params={}, base_url='http://localhost:9001',\n                       api_version='1.1', timeout=20):\n        self.api_version = api_version\n        self.base_params = base_params\n        self.base_url = base_url\n        self.timeout = timeout", "label": 1}
{"function": "def process_pdf(file) -> List:\n    \"\"\"Process PDF file and split into chunks with metadata.\"\"\"\n    try:\n        with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp_file:\n            tmp_file.write(file.getvalue())\n            loader = PyPDFLoader(tmp_file.name)\n            documents = loader.load()\n            \n            # Add source metadata\n            for doc in documents:\n                doc.metadata.update({\n                    \"source_type\": \"pdf\",\n                    \"file_name\": file.name,\n                    \"timestamp\": datetime.now().isoformat()\n                })\n            \n            text_splitter = RecursiveCharacterTextSplitter(\n                chunk_size=1000,\n                chunk_overlap=200\n            )\n            return text_splitter.split_documents(documents)\n    except Exception as e:\n        st.error(f\"\ud83d\udcc4 PDF processing error: {str(e)}\")\n        return []", "label": 0}
{"function": "    def __getstate__(self):\n        \"\"\"Object.__getstate__.\n\n        Returns:\n            dict: the state to be pickled for the instance.\n\n        \"\"\"\n        data = self.__dict__.copy()\n        del data['_replay_buffers']\n        del data['_context_replay_buffers']\n        return data", "label": 1}
{"function": "def audio_highpass_filter(audio, sample_rate, highpass_cutoff_freq):\n    \"\"\"apply highpass fileter to audio\n\n    Args:\n        audio (np.ndarray):\n        sample_rate (ind):\n        highpass_cutoff_freq (int):\n    \"\"\"\n\n    audio = torchaudio.functional.highpass_biquad(\n        torch.from_numpy(audio), sample_rate, cutoff_freq=highpass_cutoff_freq\n    )\n    return audio.numpy()", "label": 0}
{"function": "def decode(x, canvas): # b * (10 + 3)\n    x = x.view(-1, 10 + 3)\n    stroke = 1 - Decoder(x[:, :10])\n    stroke = stroke.view(-1, width, width, 1)\n    color_stroke = stroke * x[:, -3:].view(-1, 1, 1, 3)\n    stroke = stroke.permute(0, 3, 1, 2)\n    color_stroke = color_stroke.permute(0, 3, 1, 2)\n    stroke = stroke.view(-1, 5, 1, width, width)\n    color_stroke = color_stroke.view(-1, 5, 3, width, width)\n    res = []\n    for i in range(5):\n        canvas = canvas * (1 - stroke[:, i]) + color_stroke[:, i]\n        res.append(canvas)\n    return canvas, res", "label": 1}
{"function": "    def cmd_windows(self):\n        \"\"\"Return info for each client window\"\"\"\n        return [\n            i.info() for i in self.windows_map.values()\n            if not isinstance(i, window.Internal)\n        ]", "label": 1}
{"function": "def add_account(provider: str, account: dict) -> None:\n    \"\"\"\n    Adds an account to the cache.\n\n    Args:\n        account (dict): The account to add\n\n    Returns:\n        None\n    \"\"\"\n    if provider == \"twitter\":\n        # Get the current accounts\n        accounts = get_accounts(\"twitter\")\n\n        # Add the new account\n        accounts.append(account)\n\n        # Write the new accounts to the cache\n        with open(get_twitter_cache_path(), 'w') as file:\n            json.dump({\n                \"accounts\": accounts\n            }, file, indent=4)\n    elif provider == \"youtube\":\n        # Get the current accounts\n        accounts = get_accounts(\"youtube\")\n\n        # Add the new account\n        accounts.append(account)\n\n        # Write the new accounts to the cache\n        with open(get_youtube_cache_path(), 'w') as file:\n            json.dump({\n                \"accounts\": accounts\n            }, file, indent=4)", "label": 0}
{"function": "    def save(self, fpath: Path):\n        arg_dict = dict(\n            t3=self.t3.__dict__,\n            gen=self.gen\n        )\n        torch.save(arg_dict, fpath)", "label": 0}
{"function": "    def process_bind_param(self, value, dialect):\n        return utils.to_json_str(value)", "label": 1}
{"function": "    def read_image_dims(self, image_data):\n        \"\"\"Read the image dimensions.\n\n        Args:\n            image_data: string of image data.\n        Returns:\n            image_height and image_width.\n        \"\"\"\n        image = self.decode_image(image_data)\n        return image.shape[:2]", "label": 1}
{"function": "    def __repr__(self):\n        return f\"ReplacementInfo(first_replaced_line={self.first_replaced_line}, n_search_lines={self.n_search_lines}, n_replace_lines={self.n_replace_lines}, n_replacements={self.n_replacements})\"", "label": 0}
{"function": "    def testAnchorBase(self):\n        local_pdf_path = os.path.join(os.path.dirname(__file__), \"gnarly_pdfs\", \"pdftotext_two_column_issue.pdf\")\n\n        report = _pdf_report(local_pdf_path, 2)\n\n        print(report)\n\n        print(get_anchor_text(local_pdf_path, 2, pdf_engine=\"pdfreport\"))", "label": 0}
{"function": "        def run_inference(image, video, model_id, image_size, conf_threshold, input_type):\n            if input_type == \"Image\":\n                return yolov10_inference(image, None, model_id, image_size, conf_threshold)\n            else:\n                return yolov10_inference(None, video, model_id, image_size, conf_threshold)", "label": 0}
{"function": "def test_add_metrics_list_input(tracer):\n    \"\"\"Test adding multiple metrics using list input\"\"\"\n    tracer.trace = {}\n    metrics = [\n        {\"name\": \"metric1\", \"score\": 0.95},\n        {\"name\": \"metric2\", \"score\": 0.85}\n    ]\n    tracer.add_metrics(metrics)\n    \n    assert len(tracer.trace_metrics) == 2\n    assert tracer.trace_metrics[0][\"name\"] == \"metric1\"\n    assert tracer.trace_metrics[1][\"name\"] == \"metric2\"", "label": 0}
{"function": "def non_max_suppression_v2_handler(converter: TensorFlowConverter, tf_op: \"tf.Operation\"):\n    raise NotImplementedError(f\"[TensorFlowConverter] {tf_op.type} is not supported yet.\")", "label": 1}
{"function": "    def nudge(self):\n        self.kill_process()\n        self.paused = False\n        self.task = self.run_task(self.get_agent().monologue)\n        return self.task", "label": 0}
{"function": "\tdef __init__(self):\n\t\tRpcRequest.__init__(self, 'Domain', '2018-01-29', 'ListEmailVerification','domain')\n\t\tself.set_method('POST')\n\t\tif hasattr(self, \"endpoint_map\"):\n\t\t\tsetattr(self, \"endpoint_map\", endpoint_data.getEndpointMap())\n\t\tif hasattr(self, \"endpoint_regional\"):\n\t\t\tsetattr(self, \"endpoint_regional\", endpoint_data.getEndpointRegional())", "label": 1}
{"function": "  def testEnums(self):\n    # We test only module-level enums here.\n    # TODO(robinson): Examine descriptors directly to check\n    # enum descriptor output.\n    self.assertEqual(4, unittest_pb2.FOREIGN_FOO)\n    self.assertEqual(5, unittest_pb2.FOREIGN_BAR)\n    self.assertEqual(6, unittest_pb2.FOREIGN_BAZ)\n\n    proto = unittest_pb2.TestAllTypes()\n    self.assertEqual(1, proto.FOO)\n    self.assertEqual(1, unittest_pb2.TestAllTypes.FOO)\n    self.assertEqual(2, proto.BAR)\n    self.assertEqual(2, unittest_pb2.TestAllTypes.BAR)\n    self.assertEqual(3, proto.BAZ)\n    self.assertEqual(3, unittest_pb2.TestAllTypes.BAZ)", "label": 1}
{"function": "def get_covrage():\n    \"\"\"get covrage\"\"\"\n    # \u53d1\u9001\u8bf7\u6c42\u83b7\u53d6\u7f51\u9875\u5185\u5bb9\n    html_content = open(\"htmlcov/index.html\", \"r\", encoding=\"utf-8\").read()\n    soup = BeautifulSoup(html_content, 'html.parser')\n\n    # \u67e5\u627e\u5305\u542b\"pc_cov\"\u7684span\u6807\u7b7e\n    pc_cov_span = soup.find('span', class_='pc_cov')\n\n    # \u63d0\u53d6\u767e\u5206\u6bd4\u503c\n    percentage_value = pc_cov_span.text.strip()\n    percentage_float = float(percentage_value.rstrip('%'))\n    print (\"percentage_float:\", percentage_float)\n    assert percentage_float >= 0.2", "label": 0}
{"function": "def pytest_collection_finish():\n    print(f\"\\nTesting with {DEVICE=}\")", "label": 0}
{"function": "    def _tokenize_segment(self, segment: Segment) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Returns:\n            (seq_len, 33), (seq_len, 33)\n        \"\"\"\n        text_tokens, text_masks = self._tokenize_text_segment(segment.text, segment.speaker)\n        audio_tokens, audio_masks = self._tokenize_audio(segment.audio)\n\n        return torch.cat([text_tokens, audio_tokens], dim=0), torch.cat([text_masks, audio_masks], dim=0)", "label": 0}
{"function": "def main(hf_ckpt_path, save_path, n_experts, mp):\n    \"\"\"\n    Converts and saves model checkpoint files into a specified format.\n\n    Args:\n        hf_ckpt_path (str): Path to the directory containing the input checkpoint files.\n        save_path (str): Path to the directory where the converted checkpoint files will be saved.\n        n_experts (int): Total number of experts in the model.\n        mp (int): Model parallelism factor.\n        \n    Returns:\n        None\n    \"\"\"\n    torch.set_num_threads(8)\n    n_local_experts = n_experts // mp\n    state_dicts = [{} for _ in range(mp)]\n\n    for file_path in tqdm(glob(os.path.join(hf_ckpt_path, \"*.safetensors\"))):\n        with safe_open(file_path, framework=\"pt\", device=\"cpu\") as f:\n            for name in f.keys():\n                if \"model.layers.61\" in name:\n                    continue\n                param: torch.Tensor = f.get_tensor(name)\n                if name.startswith(\"model.\"):\n                    name = name[len(\"model.\"):]\n                name = name.replace(\"self_attn\", \"attn\")\n                name = name.replace(\"mlp\", \"ffn\")\n                name = name.replace(\"weight_scale_inv\", \"scale\")\n                name = name.replace(\"e_score_correction_bias\", \"bias\")\n                key = name.split(\".\")[-2]\n                assert key in mapping, f\"Key {key} not found in mapping\"\n                new_key, dim = mapping[key]\n                name = name.replace(key, new_key)\n                for i in range(mp):\n                    new_param = param\n                    if \"experts\" in name and \"shared_experts\" not in name:\n                        idx = int(name.split(\".\")[-3])\n                        if idx < i * n_local_experts or idx >= (i + 1) * n_local_experts:\n                            continue\n                    elif dim is not None:\n                        assert param.size(dim) % mp == 0, f\"Dimension {dim} must be divisible by {mp}\"\n                        shard_size = param.size(dim) // mp\n                        new_param = param.narrow(dim, i * shard_size, shard_size).contiguous()\n                    state_dicts[i][name] = new_param\n\n    os.makedirs(save_path, exist_ok=True)\n\n    for i in trange(mp):\n        save_file(state_dicts[i], os.path.join(save_path, f\"model{i}-mp{mp}.safetensors\"))\n\n    for file_path in glob(os.path.join(hf_ckpt_path, \"*token*\")):\n        new_file_path = os.path.join(save_path, os.path.basename(file_path))\n        shutil.copyfile(file_path, new_file_path)", "label": 0}
{"function": "def retain_logging_level():\n    \"\"\"Fixture to preserve the logging level between tests.\"\"\"\n    logger = get_logger(\"oumi\")\n    # Store the current log level\n    log_level = logger.level\n    yield\n    # Rehydrate the log level\n    logger.setLevel(log_level)", "label": 0}
{"function": "    def test_atomic_min_float(self):\n        self.check_atomic_min(dtype=np.float32, lo=-65535, hi=65535)", "label": 1}
{"function": "    def __init__(self, name, toolpath=None, **kw):\n        if toolpath is None:\n            toolpath = []\n\n        # Rename if there's a TOOL_ALIAS for this tool\n        self.name = TOOL_ALIASES.get(name, name)\n        self.toolpath = toolpath + DefaultToolpath\n        # remember these so we can merge them into the call\n        self.init_kw = kw\n\n        module = self._tool_module()\n        self.generate = module.generate\n        self.exists = module.exists\n        if hasattr(module, 'options'):\n            self.options = module.options", "label": 1}
{"function": "def union_numpy_dict(tensor_dict1: dict[np.ndarray], tensor_dict2: dict[np.ndarray]) -> dict[np.ndarray]:\n    for key, val in tensor_dict2.items():\n        if key in tensor_dict1:\n            assert isinstance(tensor_dict2[key], np.ndarray)\n            assert isinstance(tensor_dict1[key], np.ndarray)\n            assert np.all(tensor_dict2[key] == tensor_dict1[key]), \\\n                f'{key} in tensor_dict1 and tensor_dict2 are not the same object'\n        tensor_dict1[key] = val\n\n    return tensor_dict1", "label": 0}
{"function": "    def reduce(self, acc, val):\n        # Either USE_MEM or empty string\n        return val or acc", "label": 1}
{"function": "  def test_calculate_samples_count_per_handler_show_compile(self):\n    counters = ipr.calculate_samples_count_per_handler([\n      [\"foo\", \"BytecodeHandler:bar\"],\n      [\"foo\", \"BytecodeHandler:bar\"],\n      [\"beep\", \"BytecodeHandler:bar\"],\n      [\"hello\", \"v8::internal::Compiler\", \"[compiler]\"],\n    ])\n    self.assertItemsEqual(counters, [\n      (\"bar\", 3),\n      (\"[compiler]\", 1)\n    ])", "label": 1}
{"function": "    def unregister(self, fileobj: _FileObject) -> SelectorKey: ...", "label": 1}
{"function": "def act_quant_kernel(x_ptr, y_ptr, s_ptr, BLOCK_SIZE: tl.constexpr):\n    \"\"\"\n    Quantizes the input tensor `x_ptr` and stores the result in `y_ptr` and the scaling factor in `s_ptr`.\n\n    Args:\n        x_ptr (triton.Pointer): Pointer to the input tensor.\n        y_ptr (triton.Pointer): Pointer to the output tensor where quantized values will be stored.\n        s_ptr (triton.Pointer): Pointer to the output tensor where scaling factors will be stored.\n        BLOCK_SIZE (tl.constexpr): The size of the block to be processed by each program instance.\n\n    Returns:\n        None\n    \"\"\"\n    pid = tl.program_id(axis=0)\n    offs = pid * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    x = tl.load(x_ptr + offs).to(tl.float32)\n    s = tl.max(tl.abs(x)) / 448.\n    y = x / s\n    y = y.to(y_ptr.dtype.element_ty)\n    tl.store(y_ptr + offs, y)\n    tl.store(s_ptr + pid, s)", "label": 0}
{"function": "    def defer(self, *args, **kwargs): ...", "label": 1}
{"function": "def create_demo(stdout):\n    \"\"\"\n    Create a database with demo data for developers to work in a realistic environment.\n    The code is engineered to create a huge number of objects fast.\n    \"\"\"\n\n    queue = BulkQueue(stdout)\n\n    with Timeit(stdout, \"Creating users\"):\n        name_size = int(math.sqrt(defaults.NB_OBJECTS[\"users\"]))\n        first_names = [fake.first_name() for _ in range(name_size)]\n        last_names = [fake.last_name() for _ in range(name_size)]\n        for i in range(defaults.NB_OBJECTS[\"users\"]):\n            first_name = random.choice(first_names)\n            queue.push(\n                models.User(\n                    admin_email=f\"user{i:d}@example.com\",\n                    email=f\"user{i:d}@example.com\",\n                    password=\"!\",\n                    is_superuser=False,\n                    is_active=True,\n                    is_staff=False,\n                    short_name=first_name,\n                    full_name=f\"{first_name:s} {random.choice(last_names):s}\",\n                    language=random.choice(settings.LANGUAGES)[0],\n                )\n            )\n        queue.flush()\n\n    users_ids = list(models.User.objects.values_list(\"id\", flat=True))\n\n    with Timeit(stdout, \"Creating documents\"):\n        for i in range(defaults.NB_OBJECTS[\"docs\"]):\n            # pylint: disable=protected-access\n            key = models.Document._int2str(i)  # noqa: SLF001\n            padding = models.Document.alphabet[0] * (models.Document.steplen - len(key))\n            queue.push(\n                models.Document(\n                    depth=1,\n                    path=f\"{padding}{key}\",\n                    creator_id=random.choice(users_ids),\n                    title=fake.sentence(nb_words=4),\n                    link_reach=models.LinkReachChoices.AUTHENTICATED\n                    if random_true_with_probability(0.5)\n                    else random.choice(models.LinkReachChoices.values),\n                )\n            )\n\n        queue.flush()\n\n    with Timeit(stdout, \"Creating docs accesses\"):\n        docs_ids = list(models.Document.objects.values_list(\"id\", flat=True))\n        for doc_id in docs_ids:\n            for user_id in random.sample(\n                users_ids,\n                random.randint(1, defaults.NB_OBJECTS[\"max_users_per_document\"]),\n            ):\n                role = random.choice(models.RoleChoices.choices)\n                queue.push(\n                    models.DocumentAccess(\n                        document_id=doc_id, user_id=user_id, role=role[0]\n                    )\n                )\n        queue.flush()\n\n    with Timeit(stdout, \"Creating development users\"):\n        for dev_user in defaults.DEV_USERS:\n            queue.push(\n                models.User(\n                    admin_email=dev_user[\"email\"],\n                    email=dev_user[\"email\"],\n                    sub=dev_user[\"email\"],\n                    password=\"!\",\n                    is_superuser=False,\n                    is_active=True,\n                    is_staff=False,\n                    language=dev_user[\"language\"]\n                    or random.choice(settings.LANGUAGES)[0],\n                )\n            )\n\n        queue.flush()\n\n    with Timeit(stdout, \"Creating docs accesses on development users\"):\n        for dev_user in defaults.DEV_USERS:\n            docs_ids = list(models.Document.objects.values_list(\"id\", flat=True))\n            user_id = models.User.objects.get(email=dev_user[\"email\"]).id\n\n            for doc_id in docs_ids:\n                role = random.choice(models.RoleChoices.choices)\n                queue.push(\n                    models.DocumentAccess(\n                        document_id=doc_id, user_id=user_id, role=role[0]\n                    )\n                )\n\n        queue.flush()\n\n    with Timeit(stdout, \"Creating Template\"):\n        with open(\n            file=\"demo/data/template/code.txt\", mode=\"r\", encoding=\"utf-8\"\n        ) as text_file:\n            code_data = text_file.read()\n\n        with open(\n            file=\"demo/data/template/css.txt\", mode=\"r\", encoding=\"utf-8\"\n        ) as text_file:\n            css_data = text_file.read()\n\n        queue.push(\n            models.Template(\n                id=\"baca9e2a-59fb-42ef-b5c6-6f6b05637111\",\n                title=\"Demo Template\",\n                description=\"This is the demo template\",\n                code=code_data,\n                css=css_data,\n                is_public=True,\n            )\n        )\n        queue.flush()", "label": 0}
{"function": "def test_commands_create_demo():\n    \"\"\"The create_demo management command should create objects as expected.\"\"\"\n    call_command(\"create_demo\")\n\n    assert models.Template.objects.count() == 1\n    assert models.User.objects.count() >= 10\n    assert models.Document.objects.count() >= 10\n    assert models.DocumentAccess.objects.count() > 10\n\n    # assert dev users have doc accesses\n    user = models.User.objects.get(email=\"impress@impress.world\")\n    assert models.DocumentAccess.objects.filter(user=user).exists()\n    user = models.User.objects.get(email=\"user@webkit.test\")\n    assert models.DocumentAccess.objects.filter(user=user).exists()\n    user = models.User.objects.get(email=\"user@firefox.test\")\n    assert models.DocumentAccess.objects.filter(user=user).exists()\n    user = models.User.objects.get(email=\"user@chromium.test\")\n    assert models.DocumentAccess.objects.filter(user=user).exists()", "label": 0}
{"function": "def get_products() -> List[dict]:\n    \"\"\"\n    Gets the products from the cache.\n\n    Returns:\n        products (List[dict]): The products\n    \"\"\"\n    if not os.path.exists(get_afm_cache_path()):\n        # Create the cache file\n        with open(get_afm_cache_path(), 'w') as file:\n            json.dump({\n                \"products\": []\n            }, file, indent=4)\n\n    with open(get_afm_cache_path(), 'r') as file:\n        parsed = json.load(file)\n\n        # Get the products\n        return parsed[\"products\"]", "label": 0}
{"function": "    def create(cls, **kwargs) -> Union[bool, Any]:\n        \"\"\"Create a new record and save it the database.\"\"\"\n        instance = cls(**kwargs)\n        return instance.save()", "label": 1}
{"function": "def construct_meta_info(frames_dir_path: Path) -> dict:\n    \"\"\"\n    Construct meta information for a given frames directory.\n\n    Args:\n        frames_dir_path (Path): The path to the frames directory.\n\n    Returns:\n        dict: A dictionary containing the meta information for the frames directory, or None if the required files do not exist.\n    \"\"\"\n    mask_path = str(frames_dir_path).replace(\"images\", \"face_mask\") + \".png\"\n    face_emb_path = str(frames_dir_path).replace(\"images\", \"face_emb\") + \".pt\"\n\n    if not os.path.exists(mask_path):\n        print(f\"Mask path not found: {mask_path}\")\n        return None\n\n    if torch.load(face_emb_path) is None:\n        print(f\"Face emb is None: {face_emb_path}\")\n        return None\n\n    return {\n        \"image_path\": str(frames_dir_path),\n        \"mask_path\": mask_path,\n        \"face_emb\": face_emb_path,\n    }", "label": 0}
{"function": "    def test_initializePoses(self):\n        g2oFile = gtsam.findExampleDataFile(\"pose3example-grid\")\n        is3D = True\n        inputGraph, expectedValues = gtsam.readG2o(g2oFile, is3D)\n        priorModel = gtsam.noiseModel.Unit.Create(6)\n        inputGraph.add(gtsam.PriorFactorPose3(0, Pose3(), priorModel))\n\n        initial = gtsam.InitializePose3.initialize(inputGraph)\n        # TODO(frank): very loose !!\n        self.gtsamAssertEquals(initial, expectedValues, 0.1)", "label": 1}
{"function": "  def _cdf(self, x):\n    return math_ops.igamma(self.alpha, self.beta * x)", "label": 1}
{"function": "    def repr_str(self, x, level):\n        s = builtins.repr(x[:self.maxstring])\n        if len(s) > self.maxstring:\n            i = max(0, (self.maxstring-3)//2)\n            j = max(0, self.maxstring-3-i)\n            s = builtins.repr(x[:i] + x[len(x)-j:])\n            s = s[:i] + '...' + s[len(s)-j:]\n        return s", "label": 1}
{"function": "def union_numpy_dict(tensor_dict1: dict[str, np.ndarray], tensor_dict2: dict[str, np.ndarray]) -> dict[str, np.ndarray]:\n    for key, val in tensor_dict2.items():\n        if key in tensor_dict1:\n            assert isinstance(tensor_dict2[key], np.ndarray)\n            assert isinstance(tensor_dict1[key], np.ndarray)\n            # to properly deal with nan and object type\n            assert pd.DataFrame(tensor_dict2[key]).equals(pd.DataFrame(tensor_dict1[key])), (\n                f\"{key} in tensor_dict1 and tensor_dict2 are not the same object\"\n            )\n        tensor_dict1[key] = val\n\n    return tensor_dict1", "label": 0}
{"function": "    def __init__(self, open, high, low, close):\n        pass", "label": 1}
{"function": "  def test_replay_a_replay(self):\n    run_config = run_configs.get()\n    with run_config.start(want_rgb=False) as controller:\n      map_inst = maps.get(\"Flat64\")\n      map_data = map_inst.data(run_config)\n      interface = sc_pb.InterfaceOptions(raw=True)\n\n      # Play a quick game to generate a replay.\n      create = sc_pb.RequestCreateGame(\n          local_map=sc_pb.LocalMap(\n              map_path=map_inst.path, map_data=map_data))\n      create.player_setup.add(type=sc_pb.Participant)\n      create.player_setup.add(type=sc_pb.Computer, race=sc_common.Terran,\n                              difficulty=sc_pb.VeryEasy)\n      join = sc_pb.RequestJoinGame(race=sc_common.Terran, options=interface)\n\n      controller.create_game(create)\n      controller.join_game(join)\n      controller.step(100)\n      obs = controller.observe()\n      replay_data = controller.save_replay()\n\n      # Run through the replay the first time, verifying that it finishes, but\n      # wasn't recording a replay.\n      start_replay = sc_pb.RequestStartReplay(\n          replay_data=replay_data,\n          map_data=map_data,\n          options=interface,\n          observed_player_id=1)\n\n      controller.start_replay(start_replay)\n      controller.step(1000)\n      obs2 = controller.observe()\n      self.assertEqual(obs.observation.game_loop, obs2.observation.game_loop)\n      with self.assertRaises(protocol.ProtocolError):\n        controller.save_replay()\n\n      # Run through the replay a second time, verifying that it finishes, and\n      # *was* recording a replay.\n      start_replay.record_replay = True\n      controller.start_replay(start_replay)\n      controller.step(1000)\n      obs2 = controller.observe()\n      self.assertEqual(obs.observation.game_loop, obs2.observation.game_loop)\n      replay_data2 = controller.save_replay()\n\n      # Make sure the replay isn't too small. Variance is fine but empty is not.\n      self.assertGreater(len(replay_data2), len(replay_data) * 0.8)\n\n      # Run through the replay a third time, verifying that it finishes, but\n      # still wasn't recording a replay.\n      start_replay.record_replay = False\n      controller.start_replay(start_replay)\n      controller.step(1000)\n      obs3 = controller.observe()\n      self.assertEqual(obs.observation.game_loop, obs3.observation.game_loop)\n      with self.assertRaises(protocol.ProtocolError):\n        controller.save_replay()", "label": 1}
{"function": "def test_encoder_initialization():\n    \"\"\"Test encoder initialization\"\"\"\n    encoder = MemvidEncoder()\n    assert encoder.chunks == []\n    assert encoder.index_manager is not None", "label": 0}
{"function": "    def __init__(self, session, action_dist, obs_vectorizer):\n        \"\"\"\n        Construct a recurrent model.\n        \"\"\"\n        super().__init__(session, action_dist, obs_vectorizer)\n\n        self.seq_lens_ph = tf.placeholder(tf.int32, shape=(None,))\n        self.is_init_state_ph = tf.placeholder(tf.bool, shape=(None,))\n        self.mask_ph = tf.placeholder(tf.bool, (None, None))\n\n        # Set this to a variable or a tuple of variables\n        # for your model's initial state.\n        self.init_state_vars = None\n\n        # Set this to a placeholder for a batch of\n        # observation sequences.\n        self.obs_ph = None\n\n        # Set this to a placeholder or a tuple of\n        # placeholders for the first state in each\n        # sequence.\n        #\n        # If a value in _is_init_state is True, then the\n        # corresponding entry here is ignored.\n        self.first_state_ph = None\n\n        # Set these to the model outputs.\n        self.actor_out = None\n        self.critic_out = None\n        self.states_out = None", "label": 1}
{"function": "def setup_sidebar() -> None:\n    \"\"\"Configure sidebar with API settings and voice options.\"\"\"\n    with st.sidebar:\n        st.title(\"\ud83d\udd11 Configuration\")\n        st.markdown(\"---\")\n        \n        st.session_state.qdrant_url = st.text_input(\n            \"Qdrant URL\",\n            value=st.session_state.qdrant_url,\n            type=\"password\"\n        )\n        st.session_state.qdrant_api_key = st.text_input(\n            \"Qdrant API Key\",\n            value=st.session_state.qdrant_api_key,\n            type=\"password\"\n        )\n        st.session_state.openai_api_key = st.text_input(\n            \"OpenAI API Key\",\n            value=st.session_state.openai_api_key,\n            type=\"password\"\n        )\n        \n        st.markdown(\"---\")\n        st.markdown(\"### \ud83c\udfa4 Voice Settings\")\n        voices = [\"alloy\", \"ash\", \"ballad\", \"coral\", \"echo\", \"fable\", \"onyx\", \"nova\", \"sage\", \"shimmer\", \"verse\"]\n        st.session_state.selected_voice = st.selectbox(\n            \"Select Voice\",\n            options=voices,\n            index=voices.index(st.session_state.selected_voice),\n            help=\"Choose the voice for the audio response\"\n        )", "label": 0}
{"function": "def test_image():\n    image = Image.new(\"RGB\", (1024, 1024), \"white\")\n    draw = ImageDraw.Draw(image)\n    draw.text((10, 10), \"Hello World\", fill=\"black\", font_size=72)\n    draw.text(\n        (10, 200),\n        \"This is a sentence of text.\\nNow it is a paragraph.\\nA three-line one.\",\n        fill=\"black\",\n        font_size=24,\n    )\n    return image", "label": 0}
{"function": "def gpu_wrapped_execute_video_retargeting(*args, **kwargs):\n    return gradio_pipeline.execute_video_retargeting(*args, **kwargs)", "label": 0}
{"function": "\tdef testWindow(self):\n\t\tself._addDefItems()\n\t\tticket = self.__failManager.toBan()\n\t\tself.assertNotEqual(ticket.getIP(), \"100.100.10.10\")\n\t\tticket = self.__failManager.toBan()\n\t\tself.assertNotEqual(ticket.getIP(), \"100.100.10.10\")\n\t\tself.assertRaises(FailManagerEmpty, self.__failManager.toBan)", "label": 1}
{"function": "def image_to_h5():\n\tdirs = os.listdir(\"resized_img\")\n\tY = [] #label\n\tX = [] #data\n\tprint(len(dirs))\n\tfor filename in dirs:\n\t\tlabel = int(filename.split('_')[0])\n\t\tY.append(label)\n\t\tim = Image.open(\"resized_img//{}\".format(filename)).convert('RGB')\n\t\tmat = np.asarray(im) #image \u8f6c\u77e9\u9635\n\t\tX.append(mat)\n\n\tfile = h5py.File(\"dataset//data.h5\",\"w\")\n\tfile.create_dataset('X', data=np.array(X))\n\tfile.create_dataset('Y', data=np.array(Y))\n\tfile.close()", "label": 1}
{"function": "    def parse(cls, value, kwds):\n        if not value:\n            kwds['defects'].append(errors.HeaderMissingRequiredValue())\n            kwds['datetime'] = None\n            kwds['decoded'] = ''\n            kwds['parse_tree'] = parser.TokenList()\n            return\n        if isinstance(value, str):\n            value = utils.parsedate_to_datetime(value)\n        kwds['datetime'] = value\n        kwds['decoded'] = utils.format_datetime(kwds['datetime'])\n        kwds['parse_tree'] = cls.value_parser(kwds['decoded'])", "label": 1}
{"function": "    def test_cache_overwrite(self):\n        \"\"\"Test that cache entries can be overwritten\"\"\"\n        cache_instance = cache.TranslationCache(\"test_engine\")\n\n        # Set initial translation\n        cache_instance.set(\"hello\", \"\u4f60\u597d\")\n\n        # Overwrite with new translation\n        cache_instance.set(\"hello\", \"\u60a8\u597d\")\n\n        # Verify the new translation is returned\n        result = cache_instance.get(\"hello\")\n        self.assertEqual(result, \"\u60a8\u597d\")", "label": 0}
{"function": "    def parse(self, response):\n        if response.url == self.start_urls[0]:\n            match = re.search(\"var csv_url = '(.*)'\",\n                              response.body_as_unicode())\n            assert match.group(1)\n\n            yield scrapy.Request(f\"https://www.arco.com{match.group(1)}\")\n        else:\n            for station in csv.DictReader(response.body_as_unicode().splitlines()):\n                yield GeojsonPointItem(\n                    lat=station['Lat'],\n                    lon=station['Lng'],\n                    name=station['StoreName'],\n                    addr_full=station['Address'],\n                    city=station['City'],\n                    state=station['State'],\n                    postcode=station['Zip'],\n                    country='US' if len(station['State']) == 2 else 'MX',\n                    phone=station['Phone'],\n                    ref=station['StoreNumber'],\n                    extras={\n                        'amenity:fuel': True,\n                        'payment:credit_cards': station['CreditCards'] == '1',\n                        'shop': 'convenience' if station['ampm'] == '1' else None\n                    }\n                )", "label": 1}
{"function": "async def test_graph_batch_operations(storage):\n    \"\"\"\n    \u6d4b\u8bd5\u56fe\u6570\u636e\u5e93\u7684\u6279\u91cf\u64cd\u4f5c:\n    1. \u4f7f\u7528 get_nodes_batch \u6279\u91cf\u83b7\u53d6\u591a\u4e2a\u8282\u70b9\u7684\u5c5e\u6027\n    2. \u4f7f\u7528 node_degrees_batch \u6279\u91cf\u83b7\u53d6\u591a\u4e2a\u8282\u70b9\u7684\u5ea6\u6570\n    3. \u4f7f\u7528 edge_degrees_batch \u6279\u91cf\u83b7\u53d6\u591a\u4e2a\u8fb9\u7684\u5ea6\u6570\n    4. \u4f7f\u7528 get_edges_batch \u6279\u91cf\u83b7\u53d6\u591a\u4e2a\u8fb9\u7684\u5c5e\u6027\n    5. \u4f7f\u7528 get_nodes_edges_batch \u6279\u91cf\u83b7\u53d6\u591a\u4e2a\u8282\u70b9\u7684\u6240\u6709\u8fb9\n    \"\"\"\n    try:\n        chunk1_id = \"1\"\n        chunk2_id = \"2\"\n        chunk3_id = \"3\"\n        # 1. \u63d2\u5165\u6d4b\u8bd5\u6570\u636e\n        # \u63d2\u5165\u8282\u70b91: \u4eba\u5de5\u667a\u80fd\n        node1_id = \"\u4eba\u5de5\u667a\u80fd\"\n        node1_data = {\n            \"entity_id\": node1_id,\n            \"description\": \"\u4eba\u5de5\u667a\u80fd\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u4e00\u4e2a\u5206\u652f\uff0c\u5b83\u4f01\u56fe\u4e86\u89e3\u667a\u80fd\u7684\u5b9e\u8d28\uff0c\u5e76\u751f\u4ea7\u51fa\u4e00\u79cd\u65b0\u7684\u80fd\u4ee5\u4eba\u7c7b\u667a\u80fd\u76f8\u4f3c\u7684\u65b9\u5f0f\u505a\u51fa\u53cd\u5e94\u7684\u667a\u80fd\u673a\u5668\u3002\",\n            \"keywords\": \"AI,\u673a\u5668\u5b66\u4e60,\u6df1\u5ea6\u5b66\u4e60\",\n            \"entity_type\": \"\u6280\u672f\u9886\u57df\",\n            \"source_id\": GRAPH_FIELD_SEP.join([chunk1_id, chunk2_id]),\n        }\n        print(f\"\u63d2\u5165\u8282\u70b91: {node1_id}\")\n        await storage.upsert_node(node1_id, node1_data)\n\n        # \u63d2\u5165\u8282\u70b92: \u673a\u5668\u5b66\u4e60\n        node2_id = \"\u673a\u5668\u5b66\u4e60\"\n        node2_data = {\n            \"entity_id\": node2_id,\n            \"description\": \"\u673a\u5668\u5b66\u4e60\u662f\u4eba\u5de5\u667a\u80fd\u7684\u4e00\u4e2a\u5206\u652f\uff0c\u5b83\u4f7f\u7528\u7edf\u8ba1\u5b66\u65b9\u6cd5\u8ba9\u8ba1\u7b97\u673a\u7cfb\u7edf\u5728\u4e0d\u88ab\u660e\u786e\u7f16\u7a0b\u7684\u60c5\u51b5\u4e0b\u4e5f\u80fd\u591f\u5b66\u4e60\u3002\",\n            \"keywords\": \"\u76d1\u7763\u5b66\u4e60,\u65e0\u76d1\u7763\u5b66\u4e60,\u5f3a\u5316\u5b66\u4e60\",\n            \"entity_type\": \"\u6280\u672f\u9886\u57df\",\n            \"source_id\": GRAPH_FIELD_SEP.join([chunk2_id, chunk3_id]),\n        }\n        print(f\"\u63d2\u5165\u8282\u70b92: {node2_id}\")\n        await storage.upsert_node(node2_id, node2_data)\n\n        # \u63d2\u5165\u8282\u70b93: \u6df1\u5ea6\u5b66\u4e60\n        node3_id = \"\u6df1\u5ea6\u5b66\u4e60\"\n        node3_data = {\n            \"entity_id\": node3_id,\n            \"description\": \"\u6df1\u5ea6\u5b66\u4e60\u662f\u673a\u5668\u5b66\u4e60\u7684\u4e00\u4e2a\u5206\u652f\uff0c\u5b83\u4f7f\u7528\u591a\u5c42\u795e\u7ecf\u7f51\u7edc\u6765\u6a21\u62df\u4eba\u8111\u7684\u5b66\u4e60\u8fc7\u7a0b\u3002\",\n            \"keywords\": \"\u795e\u7ecf\u7f51\u7edc,CNN,RNN\",\n            \"entity_type\": \"\u6280\u672f\u9886\u57df\",\n            \"source_id\": GRAPH_FIELD_SEP.join([chunk3_id]),\n        }\n        print(f\"\u63d2\u5165\u8282\u70b93: {node3_id}\")\n        await storage.upsert_node(node3_id, node3_data)\n\n        # \u63d2\u5165\u8282\u70b94: \u81ea\u7136\u8bed\u8a00\u5904\u7406\n        node4_id = \"\u81ea\u7136\u8bed\u8a00\u5904\u7406\"\n        node4_data = {\n            \"entity_id\": node4_id,\n            \"description\": \"\u81ea\u7136\u8bed\u8a00\u5904\u7406\u662f\u4eba\u5de5\u667a\u80fd\u7684\u4e00\u4e2a\u5206\u652f\uff0c\u4e13\u6ce8\u4e8e\u4f7f\u8ba1\u7b97\u673a\u7406\u89e3\u548c\u5904\u7406\u4eba\u7c7b\u8bed\u8a00\u3002\",\n            \"keywords\": \"NLP,\u6587\u672c\u5206\u6790,\u8bed\u8a00\u6a21\u578b\",\n            \"entity_type\": \"\u6280\u672f\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8282\u70b94: {node4_id}\")\n        await storage.upsert_node(node4_id, node4_data)\n\n        # \u63d2\u5165\u8282\u70b95: \u8ba1\u7b97\u673a\u89c6\u89c9\n        node5_id = \"\u8ba1\u7b97\u673a\u89c6\u89c9\"\n        node5_data = {\n            \"entity_id\": node5_id,\n            \"description\": \"\u8ba1\u7b97\u673a\u89c6\u89c9\u662f\u4eba\u5de5\u667a\u80fd\u7684\u4e00\u4e2a\u5206\u652f\uff0c\u4e13\u6ce8\u4e8e\u4f7f\u8ba1\u7b97\u673a\u80fd\u591f\u4ece\u56fe\u50cf\u6216\u89c6\u9891\u4e2d\u83b7\u53d6\u4fe1\u606f\u3002\",\n            \"keywords\": \"CV,\u56fe\u50cf\u8bc6\u522b,\u76ee\u6807\u68c0\u6d4b\",\n            \"entity_type\": \"\u6280\u672f\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8282\u70b95: {node5_id}\")\n        await storage.upsert_node(node5_id, node5_data)\n\n        # \u63d2\u5165\u8fb91: \u4eba\u5de5\u667a\u80fd -> \u673a\u5668\u5b66\u4e60\n        edge1_data = {\n            \"relationship\": \"\u5305\u542b\",\n            \"weight\": 1.0,\n            \"description\": \"\u4eba\u5de5\u667a\u80fd\u9886\u57df\u5305\u542b\u673a\u5668\u5b66\u4e60\u8fd9\u4e2a\u5b50\u9886\u57df\",\n            \"source_id\": GRAPH_FIELD_SEP.join([chunk1_id, chunk2_id]),\n        }\n        print(f\"\u63d2\u5165\u8fb91: {node1_id} -> {node2_id}\")\n        await storage.upsert_edge(node1_id, node2_id, edge1_data)\n\n        # \u63d2\u5165\u8fb92: \u673a\u5668\u5b66\u4e60 -> \u6df1\u5ea6\u5b66\u4e60\n        edge2_data = {\n            \"relationship\": \"\u5305\u542b\",\n            \"weight\": 1.0,\n            \"description\": \"\u673a\u5668\u5b66\u4e60\u9886\u57df\u5305\u542b\u6df1\u5ea6\u5b66\u4e60\u8fd9\u4e2a\u5b50\u9886\u57df\",\n            \"source_id\": GRAPH_FIELD_SEP.join([chunk2_id, chunk3_id]),\n        }\n        print(f\"\u63d2\u5165\u8fb92: {node2_id} -> {node3_id}\")\n        await storage.upsert_edge(node2_id, node3_id, edge2_data)\n\n        # \u63d2\u5165\u8fb93: \u4eba\u5de5\u667a\u80fd -> \u81ea\u7136\u8bed\u8a00\u5904\u7406\n        edge3_data = {\n            \"relationship\": \"\u5305\u542b\",\n            \"weight\": 1.0,\n            \"description\": \"\u4eba\u5de5\u667a\u80fd\u9886\u57df\u5305\u542b\u81ea\u7136\u8bed\u8a00\u5904\u7406\u8fd9\u4e2a\u5b50\u9886\u57df\",\n            \"source_id\": GRAPH_FIELD_SEP.join([chunk3_id]),\n        }\n        print(f\"\u63d2\u5165\u8fb93: {node1_id} -> {node4_id}\")\n        await storage.upsert_edge(node1_id, node4_id, edge3_data)\n\n        # \u63d2\u5165\u8fb94: \u4eba\u5de5\u667a\u80fd -> \u8ba1\u7b97\u673a\u89c6\u89c9\n        edge4_data = {\n            \"relationship\": \"\u5305\u542b\",\n            \"weight\": 1.0,\n            \"description\": \"\u4eba\u5de5\u667a\u80fd\u9886\u57df\u5305\u542b\u8ba1\u7b97\u673a\u89c6\u89c9\u8fd9\u4e2a\u5b50\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8fb94: {node1_id} -> {node5_id}\")\n        await storage.upsert_edge(node1_id, node5_id, edge4_data)\n\n        # \u63d2\u5165\u8fb95: \u6df1\u5ea6\u5b66\u4e60 -> \u81ea\u7136\u8bed\u8a00\u5904\u7406\n        edge5_data = {\n            \"relationship\": \"\u5e94\u7528\u4e8e\",\n            \"weight\": 0.8,\n            \"description\": \"\u6df1\u5ea6\u5b66\u4e60\u6280\u672f\u5e94\u7528\u4e8e\u81ea\u7136\u8bed\u8a00\u5904\u7406\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8fb95: {node3_id} -> {node4_id}\")\n        await storage.upsert_edge(node3_id, node4_id, edge5_data)\n\n        # \u63d2\u5165\u8fb96: \u6df1\u5ea6\u5b66\u4e60 -> \u8ba1\u7b97\u673a\u89c6\u89c9\n        edge6_data = {\n            \"relationship\": \"\u5e94\u7528\u4e8e\",\n            \"weight\": 0.8,\n            \"description\": \"\u6df1\u5ea6\u5b66\u4e60\u6280\u672f\u5e94\u7528\u4e8e\u8ba1\u7b97\u673a\u89c6\u89c9\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8fb96: {node3_id} -> {node5_id}\")\n        await storage.upsert_edge(node3_id, node5_id, edge6_data)\n\n        # 2. \u6d4b\u8bd5 get_nodes_batch - \u6279\u91cf\u83b7\u53d6\u591a\u4e2a\u8282\u70b9\u7684\u5c5e\u6027\n        print(\"== \u6d4b\u8bd5 get_nodes_batch\")\n        node_ids = [node1_id, node2_id, node3_id]\n        nodes_dict = await storage.get_nodes_batch(node_ids)\n        print(f\"\u6279\u91cf\u83b7\u53d6\u8282\u70b9\u5c5e\u6027\u7ed3\u679c: {nodes_dict.keys()}\")\n        assert len(nodes_dict) == 3, f\"\u5e94\u8fd4\u56de3\u4e2a\u8282\u70b9\uff0c\u5b9e\u9645\u8fd4\u56de {len(nodes_dict)} \u4e2a\"\n        assert node1_id in nodes_dict, f\"{node1_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert node2_id in nodes_dict, f\"{node2_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert node3_id in nodes_dict, f\"{node3_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert (\n            nodes_dict[node1_id][\"description\"] == node1_data[\"description\"]\n        ), f\"{node1_id} \u63cf\u8ff0\u4e0d\u5339\u914d\"\n        assert (\n            nodes_dict[node2_id][\"description\"] == node2_data[\"description\"]\n        ), f\"{node2_id} \u63cf\u8ff0\u4e0d\u5339\u914d\"\n        assert (\n            nodes_dict[node3_id][\"description\"] == node3_data[\"description\"]\n        ), f\"{node3_id} \u63cf\u8ff0\u4e0d\u5339\u914d\"\n\n        # 3. \u6d4b\u8bd5 node_degrees_batch - \u6279\u91cf\u83b7\u53d6\u591a\u4e2a\u8282\u70b9\u7684\u5ea6\u6570\n        print(\"== \u6d4b\u8bd5 node_degrees_batch\")\n        node_degrees = await storage.node_degrees_batch(node_ids)\n        print(f\"\u6279\u91cf\u83b7\u53d6\u8282\u70b9\u5ea6\u6570\u7ed3\u679c: {node_degrees}\")\n        assert (\n            len(node_degrees) == 3\n        ), f\"\u5e94\u8fd4\u56de3\u4e2a\u8282\u70b9\u7684\u5ea6\u6570\uff0c\u5b9e\u9645\u8fd4\u56de {len(node_degrees)} \u4e2a\"\n        assert node1_id in node_degrees, f\"{node1_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert node2_id in node_degrees, f\"{node2_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert node3_id in node_degrees, f\"{node3_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert (\n            node_degrees[node1_id] == 3\n        ), f\"{node1_id} \u5ea6\u6570\u5e94\u4e3a3\uff0c\u5b9e\u9645\u4e3a {node_degrees[node1_id]}\"\n        assert (\n            node_degrees[node2_id] == 2\n        ), f\"{node2_id} \u5ea6\u6570\u5e94\u4e3a2\uff0c\u5b9e\u9645\u4e3a {node_degrees[node2_id]}\"\n        assert (\n            node_degrees[node3_id] == 3\n        ), f\"{node3_id} \u5ea6\u6570\u5e94\u4e3a3\uff0c\u5b9e\u9645\u4e3a {node_degrees[node3_id]}\"\n\n        # 4. \u6d4b\u8bd5 edge_degrees_batch - \u6279\u91cf\u83b7\u53d6\u591a\u4e2a\u8fb9\u7684\u5ea6\u6570\n        print(\"== \u6d4b\u8bd5 edge_degrees_batch\")\n        edges = [(node1_id, node2_id), (node2_id, node3_id), (node3_id, node4_id)]\n        edge_degrees = await storage.edge_degrees_batch(edges)\n        print(f\"\u6279\u91cf\u83b7\u53d6\u8fb9\u5ea6\u6570\u7ed3\u679c: {edge_degrees}\")\n        assert (\n            len(edge_degrees) == 3\n        ), f\"\u5e94\u8fd4\u56de3\u6761\u8fb9\u7684\u5ea6\u6570\uff0c\u5b9e\u9645\u8fd4\u56de {len(edge_degrees)} \u6761\"\n        assert (\n            node1_id,\n            node2_id,\n        ) in edge_degrees, f\"\u8fb9 {node1_id} -> {node2_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert (\n            node2_id,\n            node3_id,\n        ) in edge_degrees, f\"\u8fb9 {node2_id} -> {node3_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert (\n            node3_id,\n            node4_id,\n        ) in edge_degrees, f\"\u8fb9 {node3_id} -> {node4_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        # \u9a8c\u8bc1\u8fb9\u7684\u5ea6\u6570\u662f\u5426\u6b63\u786e\uff08\u6e90\u8282\u70b9\u5ea6\u6570 + \u76ee\u6807\u8282\u70b9\u5ea6\u6570\uff09\n        assert (\n            edge_degrees[(node1_id, node2_id)] == 5\n        ), f\"\u8fb9 {node1_id} -> {node2_id} \u5ea6\u6570\u5e94\u4e3a5\uff0c\u5b9e\u9645\u4e3a {edge_degrees[(node1_id, node2_id)]}\"\n        assert (\n            edge_degrees[(node2_id, node3_id)] == 5\n        ), f\"\u8fb9 {node2_id} -> {node3_id} \u5ea6\u6570\u5e94\u4e3a5\uff0c\u5b9e\u9645\u4e3a {edge_degrees[(node2_id, node3_id)]}\"\n        assert (\n            edge_degrees[(node3_id, node4_id)] == 5\n        ), f\"\u8fb9 {node3_id} -> {node4_id} \u5ea6\u6570\u5e94\u4e3a5\uff0c\u5b9e\u9645\u4e3a {edge_degrees[(node3_id, node4_id)]}\"\n\n        # 5. \u6d4b\u8bd5 get_edges_batch - \u6279\u91cf\u83b7\u53d6\u591a\u4e2a\u8fb9\u7684\u5c5e\u6027\n        print(\"== \u6d4b\u8bd5 get_edges_batch\")\n        # \u5c06\u5143\u7ec4\u5217\u8868\u8f6c\u6362\u4e3aNeo4j\u98ce\u683c\u7684\u5b57\u5178\u5217\u8868\n        edge_dicts = [{\"src\": src, \"tgt\": tgt} for src, tgt in edges]\n        edges_dict = await storage.get_edges_batch(edge_dicts)\n        print(f\"\u6279\u91cf\u83b7\u53d6\u8fb9\u5c5e\u6027\u7ed3\u679c: {edges_dict.keys()}\")\n        assert len(edges_dict) == 3, f\"\u5e94\u8fd4\u56de3\u6761\u8fb9\u7684\u5c5e\u6027\uff0c\u5b9e\u9645\u8fd4\u56de {len(edges_dict)} \u6761\"\n        assert (\n            node1_id,\n            node2_id,\n        ) in edges_dict, f\"\u8fb9 {node1_id} -> {node2_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert (\n            node2_id,\n            node3_id,\n        ) in edges_dict, f\"\u8fb9 {node2_id} -> {node3_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert (\n            node3_id,\n            node4_id,\n        ) in edges_dict, f\"\u8fb9 {node3_id} -> {node4_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert (\n            edges_dict[(node1_id, node2_id)][\"relationship\"]\n            == edge1_data[\"relationship\"]\n        ), f\"\u8fb9 {node1_id} -> {node2_id} \u5173\u7cfb\u4e0d\u5339\u914d\"\n        assert (\n            edges_dict[(node2_id, node3_id)][\"relationship\"]\n            == edge2_data[\"relationship\"]\n        ), f\"\u8fb9 {node2_id} -> {node3_id} \u5173\u7cfb\u4e0d\u5339\u914d\"\n        assert (\n            edges_dict[(node3_id, node4_id)][\"relationship\"]\n            == edge5_data[\"relationship\"]\n        ), f\"\u8fb9 {node3_id} -> {node4_id} \u5173\u7cfb\u4e0d\u5339\u914d\"\n\n        # 5.1 \u6d4b\u8bd5\u53cd\u5411\u8fb9\u7684\u6279\u91cf\u83b7\u53d6 - \u9a8c\u8bc1\u65e0\u5411\u56fe\u7279\u6027\n        print(\"== \u6d4b\u8bd5\u53cd\u5411\u8fb9\u7684\u6279\u91cf\u83b7\u53d6\")\n        # \u521b\u5efa\u53cd\u5411\u8fb9\u7684\u5b57\u5178\u5217\u8868\n        reverse_edge_dicts = [{\"src\": tgt, \"tgt\": src} for src, tgt in edges]\n        reverse_edges_dict = await storage.get_edges_batch(reverse_edge_dicts)\n        print(f\"\u6279\u91cf\u83b7\u53d6\u53cd\u5411\u8fb9\u5c5e\u6027\u7ed3\u679c: {reverse_edges_dict.keys()}\")\n        assert (\n            len(reverse_edges_dict) == 3\n        ), f\"\u5e94\u8fd4\u56de3\u6761\u53cd\u5411\u8fb9\u7684\u5c5e\u6027\uff0c\u5b9e\u9645\u8fd4\u56de {len(reverse_edges_dict)} \u6761\"\n\n        # \u9a8c\u8bc1\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u7684\u5c5e\u6027\u662f\u5426\u4e00\u81f4\n        for (src, tgt), props in edges_dict.items():\n            assert (\n                tgt,\n                src,\n            ) in reverse_edges_dict, f\"\u53cd\u5411\u8fb9 {tgt} -> {src} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n            assert (\n                props == reverse_edges_dict[(tgt, src)]\n            ), f\"\u8fb9 {src} -> {tgt} \u548c\u53cd\u5411\u8fb9 {tgt} -> {src} \u7684\u5c5e\u6027\u4e0d\u4e00\u81f4\"\n\n        print(\"\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u6210\u529f\uff1a\u6279\u91cf\u83b7\u53d6\u7684\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u5c5e\u6027\u4e00\u81f4\")\n\n        # 6. \u6d4b\u8bd5 get_nodes_edges_batch - \u6279\u91cf\u83b7\u53d6\u591a\u4e2a\u8282\u70b9\u7684\u6240\u6709\u8fb9\n        print(\"== \u6d4b\u8bd5 get_nodes_edges_batch\")\n        nodes_edges = await storage.get_nodes_edges_batch([node1_id, node3_id])\n        print(f\"\u6279\u91cf\u83b7\u53d6\u8282\u70b9\u8fb9\u7ed3\u679c: {nodes_edges.keys()}\")\n        assert (\n            len(nodes_edges) == 2\n        ), f\"\u5e94\u8fd4\u56de2\u4e2a\u8282\u70b9\u7684\u8fb9\uff0c\u5b9e\u9645\u8fd4\u56de {len(nodes_edges)} \u4e2a\"\n        assert node1_id in nodes_edges, f\"{node1_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert node3_id in nodes_edges, f\"{node3_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert (\n            len(nodes_edges[node1_id]) == 3\n        ), f\"{node1_id} \u5e94\u67093\u6761\u8fb9\uff0c\u5b9e\u9645\u6709 {len(nodes_edges[node1_id])} \u6761\"\n        assert (\n            len(nodes_edges[node3_id]) == 3\n        ), f\"{node3_id} \u5e94\u67093\u6761\u8fb9\uff0c\u5b9e\u9645\u6709 {len(nodes_edges[node3_id])} \u6761\"\n\n        # 6.1 \u9a8c\u8bc1\u6279\u91cf\u83b7\u53d6\u8282\u70b9\u8fb9\u7684\u65e0\u5411\u56fe\u7279\u6027\n        print(\"== \u9a8c\u8bc1\u6279\u91cf\u83b7\u53d6\u8282\u70b9\u8fb9\u7684\u65e0\u5411\u56fe\u7279\u6027\")\n\n        # \u68c0\u67e5\u8282\u70b91\u7684\u8fb9\u662f\u5426\u5305\u542b\u6240\u6709\u76f8\u5173\u7684\u8fb9\uff08\u65e0\u8bba\u65b9\u5411\uff09\n        node1_outgoing_edges = [\n            (src, tgt) for src, tgt in nodes_edges[node1_id] if src == node1_id\n        ]\n        node1_incoming_edges = [\n            (src, tgt) for src, tgt in nodes_edges[node1_id] if tgt == node1_id\n        ]\n        print(f\"\u8282\u70b9 {node1_id} \u7684\u51fa\u8fb9: {node1_outgoing_edges}\")\n        print(f\"\u8282\u70b9 {node1_id} \u7684\u5165\u8fb9: {node1_incoming_edges}\")\n\n        # \u68c0\u67e5\u662f\u5426\u5305\u542b\u5230\u673a\u5668\u5b66\u4e60\u3001\u81ea\u7136\u8bed\u8a00\u5904\u7406\u548c\u8ba1\u7b97\u673a\u89c6\u89c9\u7684\u8fb9\n        has_edge_to_node2 = any(tgt == node2_id for _, tgt in node1_outgoing_edges)\n        has_edge_to_node4 = any(tgt == node4_id for _, tgt in node1_outgoing_edges)\n        has_edge_to_node5 = any(tgt == node5_id for _, tgt in node1_outgoing_edges)\n\n        assert has_edge_to_node2, f\"\u8282\u70b9 {node1_id} \u7684\u8fb9\u5217\u8868\u4e2d\u5e94\u5305\u542b\u5230 {node2_id} \u7684\u8fb9\"\n        assert has_edge_to_node4, f\"\u8282\u70b9 {node1_id} \u7684\u8fb9\u5217\u8868\u4e2d\u5e94\u5305\u542b\u5230 {node4_id} \u7684\u8fb9\"\n        assert has_edge_to_node5, f\"\u8282\u70b9 {node1_id} \u7684\u8fb9\u5217\u8868\u4e2d\u5e94\u5305\u542b\u5230 {node5_id} \u7684\u8fb9\"\n\n        # \u68c0\u67e5\u8282\u70b93\u7684\u8fb9\u662f\u5426\u5305\u542b\u6240\u6709\u76f8\u5173\u7684\u8fb9\uff08\u65e0\u8bba\u65b9\u5411\uff09\n        node3_outgoing_edges = [\n            (src, tgt) for src, tgt in nodes_edges[node3_id] if src == node3_id\n        ]\n        node3_incoming_edges = [\n            (src, tgt) for src, tgt in nodes_edges[node3_id] if tgt == node3_id\n        ]\n        print(f\"\u8282\u70b9 {node3_id} \u7684\u51fa\u8fb9: {node3_outgoing_edges}\")\n        print(f\"\u8282\u70b9 {node3_id} \u7684\u5165\u8fb9: {node3_incoming_edges}\")\n\n        # \u68c0\u67e5\u662f\u5426\u5305\u542b\u4e0e\u673a\u5668\u5b66\u4e60\u3001\u81ea\u7136\u8bed\u8a00\u5904\u7406\u548c\u8ba1\u7b97\u673a\u89c6\u89c9\u7684\u8fde\u63a5\uff08\u5ffd\u7565\u65b9\u5411\uff09\n        has_connection_with_node2 = any(\n            (src == node2_id and tgt == node3_id)\n            or (src == node3_id and tgt == node2_id)\n            for src, tgt in nodes_edges[node3_id]\n        )\n        has_connection_with_node4 = any(\n            (src == node3_id and tgt == node4_id)\n            or (src == node4_id and tgt == node3_id)\n            for src, tgt in nodes_edges[node3_id]\n        )\n        has_connection_with_node5 = any(\n            (src == node3_id and tgt == node5_id)\n            or (src == node5_id and tgt == node3_id)\n            for src, tgt in nodes_edges[node3_id]\n        )\n\n        assert (\n            has_connection_with_node2\n        ), f\"\u8282\u70b9 {node3_id} \u7684\u8fb9\u5217\u8868\u4e2d\u5e94\u5305\u542b\u4e0e {node2_id} \u7684\u8fde\u63a5\"\n        assert (\n            has_connection_with_node4\n        ), f\"\u8282\u70b9 {node3_id} \u7684\u8fb9\u5217\u8868\u4e2d\u5e94\u5305\u542b\u4e0e {node4_id} \u7684\u8fde\u63a5\"\n        assert (\n            has_connection_with_node5\n        ), f\"\u8282\u70b9 {node3_id} \u7684\u8fb9\u5217\u8868\u4e2d\u5e94\u5305\u542b\u4e0e {node5_id} \u7684\u8fde\u63a5\"\n\n        print(\"\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u6210\u529f\uff1a\u6279\u91cf\u83b7\u53d6\u7684\u8282\u70b9\u8fb9\u5305\u542b\u6240\u6709\u76f8\u5173\u7684\u8fb9\uff08\u65e0\u8bba\u65b9\u5411\uff09\")\n\n        # 7. \u6d4b\u8bd5 get_nodes_by_chunk_ids - \u6279\u91cf\u6839\u636e chunk_ids \u83b7\u53d6\u591a\u4e2a\u8282\u70b9\n        print(\"== \u6d4b\u8bd5 get_nodes_by_chunk_ids\")\n\n        print(\"== \u6d4b\u8bd5\u5355\u4e2a chunk_id\uff0c\u5339\u914d\u591a\u4e2a\u8282\u70b9\")\n        nodes = await storage.get_nodes_by_chunk_ids([chunk2_id])\n        assert len(nodes) == 2, f\"{chunk1_id} \u5e94\u67092\u4e2a\u8282\u70b9\uff0c\u5b9e\u9645\u6709 {len(nodes)} \u4e2a\"\n\n        has_node1 = any(node[\"entity_id\"] == node1_id for node in nodes)\n        has_node2 = any(node[\"entity_id\"] == node2_id for node in nodes)\n\n        assert has_node1, f\"\u8282\u70b9 {node1_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert has_node2, f\"\u8282\u70b9 {node2_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n\n        print(\"== \u6d4b\u8bd5\u591a\u4e2a chunk_id\uff0c\u90e8\u5206\u5339\u914d\u591a\u4e2a\u8282\u70b9\")\n        nodes = await storage.get_nodes_by_chunk_ids([chunk2_id, chunk3_id])\n        assert (\n            len(nodes) == 3\n        ), f\"{chunk2_id}, {chunk3_id} \u5e94\u67093\u4e2a\u8282\u70b9\uff0c\u5b9e\u9645\u6709 {len(nodes)} \u4e2a\"\n\n        has_node1 = any(node[\"entity_id\"] == node1_id for node in nodes)\n        has_node2 = any(node[\"entity_id\"] == node2_id for node in nodes)\n        has_node3 = any(node[\"entity_id\"] == node3_id for node in nodes)\n\n        assert has_node1, f\"\u8282\u70b9 {node1_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert has_node2, f\"\u8282\u70b9 {node2_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n        assert has_node3, f\"\u8282\u70b9 {node3_id} \u5e94\u5728\u8fd4\u56de\u7ed3\u679c\u4e2d\"\n\n        # 8. \u6d4b\u8bd5 get_edges_by_chunk_ids - \u6279\u91cf\u6839\u636e chunk_ids \u83b7\u53d6\u591a\u6761\u8fb9\n        print(\"== \u6d4b\u8bd5 get_edges_by_chunk_ids\")\n\n        print(\"== \u6d4b\u8bd5\u5355\u4e2a chunk_id\uff0c\u5339\u914d\u591a\u6761\u8fb9\")\n        edges = await storage.get_edges_by_chunk_ids([chunk2_id])\n        assert len(edges) == 2, f\"{chunk2_id} \u5e94\u67092\u6761\u8fb9\uff0c\u5b9e\u9645\u6709 {len(edges)} \u6761\"\n\n        has_edge_node1_node2 = any(\n            edge[\"source\"] == node1_id and edge[\"target\"] == node2_id for edge in edges\n        )\n        has_edge_node2_node3 = any(\n            edge[\"source\"] == node2_id and edge[\"target\"] == node3_id for edge in edges\n        )\n\n        assert has_edge_node1_node2, f\"{chunk2_id} \u5e94\u5305\u542b {node1_id} \u5230 {node2_id} \u7684\u8fb9\"\n        assert has_edge_node2_node3, f\"{chunk2_id} \u5e94\u5305\u542b {node2_id} \u5230 {node3_id} \u7684\u8fb9\"\n\n        print(\"== \u6d4b\u8bd5\u591a\u4e2a chunk_id\uff0c\u90e8\u5206\u5339\u914d\u591a\u6761\u8fb9\")\n        edges = await storage.get_edges_by_chunk_ids([chunk2_id, chunk3_id])\n        assert (\n            len(edges) == 3\n        ), f\"{chunk2_id}, {chunk3_id} \u5e94\u67093\u6761\u8fb9\uff0c\u5b9e\u9645\u6709 {len(edges)} \u6761\"\n\n        has_edge_node1_node2 = any(\n            edge[\"source\"] == node1_id and edge[\"target\"] == node2_id for edge in edges\n        )\n        has_edge_node2_node3 = any(\n            edge[\"source\"] == node2_id and edge[\"target\"] == node3_id for edge in edges\n        )\n        has_edge_node1_node4 = any(\n            edge[\"source\"] == node1_id and edge[\"target\"] == node4_id for edge in edges\n        )\n\n        assert (\n            has_edge_node1_node2\n        ), f\"{chunk2_id}, {chunk3_id} \u5e94\u5305\u542b {node1_id} \u5230 {node2_id} \u7684\u8fb9\"\n        assert (\n            has_edge_node2_node3\n        ), f\"{chunk2_id}, {chunk3_id} \u5e94\u5305\u542b {node2_id} \u5230 {node3_id} \u7684\u8fb9\"\n        assert (\n            has_edge_node1_node4\n        ), f\"{chunk2_id}, {chunk3_id} \u5e94\u5305\u542b {node1_id} \u5230 {node4_id} \u7684\u8fb9\"\n\n        print(\"\\n\u6279\u91cf\u64cd\u4f5c\u6d4b\u8bd5\u5b8c\u6210\")\n        return True\n\n    except Exception as e:\n        ASCIIColors.red(f\"\u6d4b\u8bd5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u9519\u8bef: {str(e)}\")\n        return False", "label": 0}
{"function": "def initialize_system():\n    stealth_mode = config.getboolean('BROWSER', 'stealth_mode')\n    personality_folder = \"jarvis\" if config.getboolean('MAIN', 'jarvis_personality') else \"base\"\n    languages = config[\"MAIN\"][\"languages\"].split(' ')\n    \n    # Force headless mode in Docker containers\n    headless = config.getboolean('BROWSER', 'headless_browser')\n    if is_running_in_docker() and not headless:\n        # Print prominent warning to console (visible in docker-compose output)\n        print(\"\\n\" + \"*\" * 70)\n        print(\"*** WARNING: Detected Docker environment - forcing headless_browser=True ***\")\n        print(\"*** INFO: To see the browser, run 'python cli.py' on your host machine ***\")\n        print(\"*\" * 70 + \"\\n\")\n        \n        # Flush to ensure it's displayed immediately\n        sys.stdout.flush()\n        \n        # Also log to file\n        logger.warning(\"Detected Docker environment - forcing headless_browser=True\")\n        logger.info(\"To see the browser, run 'python cli.py' on your host machine instead\")\n        \n        headless = True\n    \n    provider = Provider(\n        provider_name=config[\"MAIN\"][\"provider_name\"],\n        model=config[\"MAIN\"][\"provider_model\"],\n        server_address=config[\"MAIN\"][\"provider_server_address\"],\n        is_local=config.getboolean('MAIN', 'is_local')\n    )\n    logger.info(f\"Provider initialized: {provider.provider_name} ({provider.model})\")\n\n    browser = Browser(\n        create_driver(headless=headless, stealth_mode=stealth_mode, lang=languages[0]),\n        anticaptcha_manual_install=stealth_mode\n    )\n    logger.info(\"Browser initialized\")\n\n    agents = [\n        CasualAgent(\n            name=config[\"MAIN\"][\"agent_name\"],\n            prompt_path=f\"prompts/{personality_folder}/casual_agent.txt\",\n            provider=provider, verbose=False\n        ),\n        CoderAgent(\n            name=\"coder\",\n            prompt_path=f\"prompts/{personality_folder}/coder_agent.txt\",\n            provider=provider, verbose=False\n        ),\n        FileAgent(\n            name=\"File Agent\",\n            prompt_path=f\"prompts/{personality_folder}/file_agent.txt\",\n            provider=provider, verbose=False\n        ),\n        BrowserAgent(\n            name=\"Browser\",\n            prompt_path=f\"prompts/{personality_folder}/browser_agent.txt\",\n            provider=provider, verbose=False, browser=browser\n        ),\n        PlannerAgent(\n            name=\"Planner\",\n            prompt_path=f\"prompts/{personality_folder}/planner_agent.txt\",\n            provider=provider, verbose=False, browser=browser\n        )\n    ]\n    logger.info(\"Agents initialized\")\n\n    interaction = Interaction(\n        agents,\n        tts_enabled=config.getboolean('MAIN', 'speak'),\n        stt_enabled=config.getboolean('MAIN', 'listen'),\n        recover_last_session=config.getboolean('MAIN', 'recover_last_session'),\n        langs=languages\n    )\n    logger.info(\"Interaction initialized\")\n    return interaction", "label": 0}
{"function": "def table_rec_predictor() -> TableRecPredictor:\n    table_rec_predictor = TableRecPredictor()\n    yield table_rec_predictor\n    del table_rec_predictor", "label": 0}
{"function": "    def set_current_run_dtype(self, variables):\n        if variables[0].dtype != self.current_run_dtype and self.current_run_dtype is not None:\n            for index, var in enumerate(variables):\n                variables[index] = var.to(self.current_run_dtype)\n        return tuple(variables)", "label": 0}
{"function": "    def get_endpoint(self, path=None, workspace=None, id=None):\n        \"\"\"\n        Retrieves an already created Endpoint. Only one of `path` or `id` can be provided.\n\n        Parameters\n        ----------\n        path : str, optional\n            Path of the Endpoint.\n        workspace : str, optional\n            Name of the workspace of the Endpoint.\n        id : str, optional\n            ID of the Endpoint. This parameter cannot be provided alongside `path`.\n\n        Returns\n        -------\n        :class:`~verta.endpoint._endpoint.Endpoint`\n\n        \"\"\"\n        if path is not None and id is not None:\n            raise ValueError(\"cannot specify both `path` and `id`\")\n        if path is None and id is None:\n            raise ValueError(\"must specify either `path` or `id`\")\n\n        workspace = self._set_from_config_if_none(workspace, \"workspace\")\n        if workspace is None:\n            workspace = self._get_personal_workspace()\n\n        if id is not None:\n            endpoint = Endpoint._get_by_id(self._conn, self._conf, workspace, id)\n        else:\n            endpoint = Endpoint._get_by_path(self._conn, self._conf, workspace, path)\n\n        if endpoint is None:\n            raise ValueError(\"Endpoint not found\")\n        return endpoint", "label": 1}
{"function": "    def get_or_create_registered_model(self, name=None, desc=None, labels=None, workspace=None, public_within_org=None, id=None):\n        \"\"\"\n        Attaches a registered_model to this Client.\n\n        If an accessible registered_model with name `name` does not already exist, it will be created\n        and initialized with specified metadata parameters. If such a registered_model does already exist,\n        it will be retrieved; specifying metadata parameters in this case will raise an exception.\n\n        Parameters\n        ----------\n        name : str, optional\n            Name of the registered_model. If no name is provided, one will be generated.\n        desc : str, optional\n            Description of the registered_model.\n        labels: list of str, optional\n            Labels of the registered_model.\n        workspace : str, optional\n            Workspace under which the registered_model with name `name` exists. If not provided, the current\n            user's personal workspace will be used.\n        public_within_org : bool, default False\n            If creating a registered_model in an organization's workspace, whether to make this registered_model\n            accessible to all members of that organization.\n        id : str, optional\n            ID of the registered_model. This parameter cannot be provided alongside `name`, and other\n            parameters will be ignored.\n\n        Returns\n        -------\n        :class:`~verta._registry.model.RegisteredModel`\n\n        Raises\n        ------\n        ValueError\n            If a registered_model with `name` already exists, but metadata parameters are passed in.\n\n        \"\"\"\n        if name is not None and id is not None:\n            raise ValueError(\"cannot specify both `name` and `id`\")\n\n        name = self._set_from_config_if_none(name, \"registered_model\")\n        workspace = self._set_from_config_if_none(workspace, \"workspace\")\n\n        if workspace is None:\n            workspace = self._get_personal_workspace()\n\n        self._ctx = _Context(self._conn, self._conf)\n        self._ctx.workspace_name = workspace\n\n        if id is not None:\n            registered_model = RegisteredModel._get_by_id(self._conn, self._conf, id)\n        else:\n            registered_model = RegisteredModel._get_or_create_by_name(self._conn, name,\n                                                                                lambda name: RegisteredModel._get_by_name(self._conn, self._conf, name, self._ctx.workspace_name),\n                                                                                lambda name: RegisteredModel._create(self._conn, self._conf, self._ctx, name=name, desc=desc, tags=labels, public_within_org=public_within_org))\n\n        return registered_model", "label": 1}
{"function": "    def image(self):\n        \"\"\" Returns a reference to the modified image. \"\"\"\n        return self.newImage", "label": 1}
{"function": "    def localdir(self):\n        return os.getcwd()", "label": 1}
{"function": "def _ext_name_to_id(name):\n    \"\"\"\n    Convert a string with a name of extension to numerical ID.\n\n    Handles both numerical IDs and names.\n\n    :raises AttributeError: when the specified identifier is not defined\n        in ExtensionType\n    \"\"\"\n    try:\n        return int(name)\n    except ValueError:\n        return getattr(ExtensionType, name)", "label": 1}
{"function": "def run_command(command, shell=False, log_step=None):\n    \"\"\"Run a system command and ensure it succeeds.\"\"\"\n    if log_step:\n        log_file = os.path.join(args.log_dir, log_step + \".log\")\n        with open(log_file, \"w\") as f:\n            try:\n                subprocess.run(command, shell=shell, check=True, stdout=f, stderr=f)\n            except subprocess.CalledProcessError as e:\n                logging.error(f\"Error occurred while running command: {e}, check details in {log_file}\")\n                sys.exit(1)\n    else:\n        try:\n            subprocess.run(command, shell=shell, check=True)\n        except subprocess.CalledProcessError as e:\n            logging.error(f\"Error occurred while running command: {e}\")\n        sys.exit(1)", "label": 0}
{"function": "    def cmd_shutdown(self):\n        \"\"\"Quit Qtile\"\"\"\n        self.stop()", "label": 1}
{"function": "    def test_string_rjust(self):\n        self.check_func(lambda x: x.str.rjust(0))\n        self.check_func(lambda x: x.str.rjust(10))\n        self.check_func(lambda x: x.str.rjust(30, \"x\"))", "label": 1}
{"function": "    def test_atomic_min_int64(self):\n        self.check_atomic_min(dtype=np.int64, lo=-65535, hi=65535)", "label": 1}
{"function": "def main():\n    local_model_file = config(\"LOCAL_MODEL\", default=\"\")\n\n    if not local_model_file:\n        print(\"LOCAL_MODEL not set in the `.env` file.\")\n        return\n\n    local_model_file = Path(local_model_file)\n    if not local_model_file.exists():\n        print(f\"Local model not found: {local_model_file}\")\n        return\n\n    print(f\"Local model found: {local_model_file}\")\n    will_start_server = input(\"Do you want to use this local model ? (y/n): \")\n\n    if will_start_server.lower().strip() not in [\"y\", \"yes\"]:\n        return\n\n    print(\"Starting the local server...\")\n    if local_model_file.suffix == \".gguf\":\n        serve_llamacpp_python(local_model_file)\n    else:\n        raise ValueError(f\"Unsupported model file type: {local_model_file.suffix}\")", "label": 0}
{"function": "    def batches(self, rollouts, batch_size=None):\n        sizes = [r.num_steps for r in rollouts]\n        for rollout_indices in mini_batches(sizes, batch_size):\n            batch = [rollouts[i] for i in rollout_indices]\n            max_len = max([r.num_steps for r in batch])\n            obs_seqs = []\n            is_inits = []\n            masks = []\n            rollout_idxs = []\n            timestep_idxs = []\n            for rollout_idx, rollout in zip(rollout_indices, batch):\n                obs_seq = list(self.obs_vectorizer.to_vecs(rollout.step_observations))\n                empty_obs = np.zeros(np.array(obs_seq[0]).shape)\n                obs_seqs.append(_pad(obs_seq, max_len, value=empty_obs))\n                is_inits.append(not rollout.trunc_start)\n                masks.append(_pad([True] * rollout.num_steps, max_len))\n                rollout_idxs.extend([rollout_idx] * rollout.num_steps)\n                timestep_idxs.extend(range(rollout.num_steps))\n            feed_dict = {\n                self.obs_ph: obs_seqs,\n                self.is_init_state_ph: is_inits,\n                self.mask_ph: masks,\n                self.seq_lens_ph: [r.num_steps for r in batch]\n            }\n            self._add_first_states(feed_dict, batch)\n            yield {\n                'rollout_idxs': rollout_idxs,\n                'timestep_idxs': timestep_idxs,\n                'feed_dict': feed_dict\n            }", "label": 1}
{"function": "    def __eq__(self, other):\n        if not isinstance(other, Flake8Error):\n            return NotImplemented\n        return (\n            self.filename == other.filename\n            and self.line_number == other.line_number\n            and self.col_number == other.col_number\n            and self.problem == other.problem\n        )", "label": 0}
{"function": "async def logout(request: Request):\n    request.session.pop(\"user\", None)\n    return RedirectResponse(url=\"/\")", "label": 0}
{"function": "def array_equiv(a1, a2):\n    \"\"\"\n    Returns True if input arrays are shape consistent and all elements equal.\n\n    Shape consistent means they are either the same shape, or one input array\n    can be broadcasted to create the same shape as the other one.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    out : bool\n        True if equivalent, False otherwise.\n\n    Examples\n    --------\n    >>> np.array_equiv([1, 2], [1, 2])\n    True\n    >>> np.array_equiv([1, 2], [1, 3])\n    False\n\n    Showing the shape equivalence:\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])\n    True\n    >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\n    False\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])\n    False\n\n    \"\"\"\n    try:\n        a1, a2 = asarray(a1), asarray(a2)\n    except Exception:\n        return False\n    try:\n        multiarray.broadcast(a1, a2)\n    except Exception:\n        return False\n\n    return bool(asarray(a1 == a2).all())", "label": 1}
{"function": "def handle_client(conn, processor):\n    try:\n        with conn:\n            conn.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n            while True:\n                data = conn.recv(1024)\n                if not data:\n                    processor.first_package = True\n                    break\n                data_str = data.decode(\"utf-8\").strip()\n                logger.info(f\"Received text: {data_str}\")\n\n                try:\n                    processor.generate_stream(data_str, conn)\n                except Exception as inner_e:\n                    logger.error(f\"Error during processing: {inner_e}\")\n                    traceback.print_exc()\n                    break\n    except Exception as e:\n        logger.error(f\"Error handling client: {e}\")\n        traceback.print_exc()", "label": 0}
{"function": "    def from_topology_description(cls, topology_description):\n        known_servers = topology_description.known_servers\n        primary = None\n        for sd in known_servers:\n            if sd.server_type == SERVER_TYPE.RSPrimary:\n                primary = sd\n                break\n\n        return Selection(topology_description,\n                         topology_description.known_servers,\n                         topology_description.common_wire_version,\n                         primary)", "label": 1}
{"function": "  def __init__(self):\n    super().__init__(name=\"mock_plugin\")\n    self.enable_user_message_callback = False\n    self.enable_event_callback = False", "label": 0}
{"function": "    def select(self, timeout: Optional[float] = ...) -> List[Tuple[SelectorKey, _EventMask]]: ...", "label": 1}
{"function": "def partial_fields(target_class, kwargs):\n    return target_class(**{k: v for k, v in kwargs.items() if hasattr(target_class, k)})", "label": 0}
{"function": "    def test_from_array_float(surv_arrays):\n        event, time = surv_arrays\n\n        expected = numpy.empty(dtype=[('event', bool), ('time', float)], shape=100)\n        expected['event'] = event.astype(bool)\n        expected['time'] = time\n\n        y = Surv.from_arrays(event.astype(float), time)\n        assert_array_equal(y, expected)", "label": 1}
{"function": "def test_search(setup_test_memory):\n    \"\"\"Test semantic search\"\"\"\n    video_file, index_file, chunks = setup_test_memory\n    retriever = MemvidRetriever(video_file, index_file)\n    \n    # Search for quantum\n    results = retriever.search(\"quantum physics\", top_k=3)\n    assert len(results) <= 3\n    assert any(\"quantum\" in result.lower() for result in results)\n    \n    # Search for AI\n    results = retriever.search(\"artificial intelligence\", top_k=3)\n    assert len(results) <= 3\n    assert any(\"neural\" in result.lower() or \"machine\" in result.lower() for result in results)", "label": 0}
{"function": "def end_process():\n    stream.input_queue.push('end')", "label": 0}
{"function": "    def system_listMethods(self):\n        \"\"\"system.listMethods() => ['add', 'subtract', 'multiple']\n\n        Returns a list of the methods supported by the server.\"\"\"\n\n        methods = set(self.funcs.keys())\n        if self.instance is not None:\n            # Instance can implement _listMethod to return a list of\n            # methods\n            if hasattr(self.instance, '_listMethods'):\n                methods |= set(self.instance._listMethods())\n            # if the instance has a _dispatch method then we\n            # don't have enough information to provide a list\n            # of methods\n            elif not hasattr(self.instance, '_dispatch'):\n                methods |= set(list_public_methods(self.instance))\n        return sorted(methods)", "label": 1}
{"function": "\tdef get_greatest_id(self):\n\t\t\"\"\" Returns the greatest existing task ID, or None if there are no\n\t\ttask.\"\"\"\n\t\tc = self.connection.cursor()\n\t\tc.execute(\"\"\"\n\t\t\tSELECT MAX(id)\n\t\t\tFROM Task\n\t\t\"\"\")\n\t\trow = c.fetchone()\n\t\tif row is None:\n\t\t\treturn None\n\t\telse:\n\t\t\treturn row[0]", "label": 1}
{"function": "async def _cleanup_test_nodes(graphiti: Graphiti, group_id: str):\n    \"\"\"Helper function to clean up test nodes.\"\"\"\n    try:\n        # Get all nodes for this group\n        search_results = await graphiti.search_(query='*', group_ids=[group_id])\n\n        # Delete all found nodes\n        for node in search_results.nodes:\n            await node.delete(graphiti.driver)\n\n    except Exception as e:\n        # Log but don't fail the test if cleanup fails\n        print(f'Warning: Failed to clean up test nodes for group {group_id}: {e}')", "label": 0}
{"function": "        def doMulti(slot, index, size):\n            slot[index].notifyDirty(self.setDirty)\n            slot[index].notifyValueChanged(self.setDirty)", "label": 1}
{"function": "    def address(self):\n        return self.socket.getsockname()", "label": 1}
{"function": "def change_instruction(mode_checkbox_group):\n    return instruct_dict[mode_checkbox_group]", "label": 0}
{"function": "    def __getattr__(self, name):\n        return partial(self, name)", "label": 1}
{"function": "    def test_get_navigation_signal_dtype(self):\n        s = self.signal\n        assert s._get_navigation_signal().data.dtype.name == s.data.dtype.name", "label": 1}
{"function": "def reset_sliders(*args, **kwargs):\n    return 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.5, True, True", "label": 0}
{"function": "    def __setitem__(self, key, value):\n        \"\"\"Detect list set events and emit change events.\"\"\"\n        list.__setitem__(self, key, value)\n        self.changed()", "label": 1}
{"function": "def multi_image_data():\n    files = [\n        THIS_DIR / \"fixtures/images/vision_test_1.jpg\",\n        THIS_DIR / \"fixtures/images/vision_test_2.jpg\",\n        THIS_DIR / \"fixtures/images/vision_test_3.jpg\",\n    ]\n    encoded_files = []\n    for file in files:\n        with open(file, \"rb\") as image_file:\n            base64_data = base64.b64encode(image_file.read()).decode(\"utf-8\")\n            encoded_files.append(f\"data:image/jpeg;base64,{base64_data}\")\n    return encoded_files", "label": 0}
{"function": "def add_product(product: dict) -> None:\n    \"\"\"\n    Adds a product to the cache.\n\n    Args:\n        product (dict): The product to add\n\n    Returns:\n        None\n    \"\"\"\n    # Get the current products\n    products = get_products()\n\n    # Add the new product\n    products.append(product)\n\n    # Write the new products to the cache\n    with open(get_afm_cache_path(), 'w') as file:\n        json.dump({\n            \"products\": products\n        }, file, indent=4)", "label": 0}
{"function": "    def create_index(self, name, tablename, columns, schema=None, **kw):\n        \"\"\"Issue a \"create index\" instruction using the current\n        migration context.\n\n        e.g.::\n\n            from alembic import op\n            op.create_index('ik_test', 't1', ['foo', 'bar'])\n\n        :param name: name of the index.\n        :param tablename: name of the owning table.\n        :param columns: a list of string column names in the\n         table.\n        :param schema: Optional schema name to operate within.\n\n         .. versionadded:: 0.4.0\n\n        \"\"\"\n\n        self.impl.create_index(\n            self._index(name, tablename, columns, schema=schema, **kw)\n        )", "label": 1}
{"function": "    def change_state(self, state, change_text = False):\n        if not isinstance(state, basestring):\n            raise TypeError('change_state takes a string got a %s' % type(state))\n        self.status_state = state\n\n        if change_text:\n            self.ChangeValue(self.status_state, state.title())\n        else:\n            self.Default = state.title()\n\n        edit_toggle = getattr(profile.status, 'edit_toggle', True)\n        if getattr(profile.status, 'edit_toggle', True):\n            # update the icon\n            self.SetButtonIcon(StatusMessage.icon_for(self.status_state))\n\n            self.cancel_timer()\n            self.timer.StartOneShot(self.set_delay)\n\n            # select all text in the textfield\n            disp = self.display\n            disp.TypeField()\n            wx.CallAfter(disp.txtfld.SetSelection, -1, -1)\n        else:\n            self.setandshow(profile.status.copy(status = self.status_state, editable = None, edit_toggle = None))", "label": 1}
{"function": "def init_distributed_mode():\n    if not ddp: return\n    global ddp_local_rank, DEVICE\n\n    dist.init_process_group(backend=\"nccl\")\n    ddp_rank = int(os.environ[\"RANK\"])\n    ddp_local_rank = int(os.environ[\"LOCAL_RANK\"])\n    ddp_world_size = int(os.environ[\"WORLD_SIZE\"])\n    DEVICE = f\"cuda:{ddp_local_rank}\"\n    torch.cuda.set_device(DEVICE)", "label": 0}
{"function": "async def create_chat_completion(request: ChatCompletionRequest):\n    global model, tokenizer\n    print(request)\n    if request.messages[-1].role != \"user\":\n        raise HTTPException(status_code=400, detail=\"Invalid request\")\n    query = request.messages[-1].content\n\n\n    generate = predict(query, \"\", request.model)\n    return EventSourceResponse(generate, media_type=\"text/event-stream\")", "label": 0}
{"function": "    def test_repo_setfilters(self, shell):\n        \"\"\"\n        Test do_repo_setfilters with wrong filters syntax\n\n        :param shell:\n        :return:\n        \"\"\"\n        shell.help_repo_setfilters = MagicMock()\n        shell.client.channel.software.setRepoFilters = MagicMock()\n        mprint = MagicMock()\n        logger = MagicMock()\n\n        with patch(\"spacecmd.repo.print\", mprint) as prn, \\\n                patch(\"spacecmd.repo.logging\", logger) as lgr:\n            out = spacecmd.repo.do_repo_setfilters(shell, \"repo +emacs -vim\")\n\n        assert out is 0\n        assert not mprint.called\n        assert not shell.help_repo_setfilters.called\n        assert not logger.error.called\n        assert shell.client.channel.software.setRepoFilters.call_count == 1\n        assert shell.client.channel.software.setRepoFilters.called\n\n        assert_args_expect(shell.client.channel.software.setRepoFilters.call_args_list,\n                           [((shell.session, 'repo',\n                              [{'filter': 'emacs', 'flag': '+'},\n                               {'filter': 'vim', 'flag': '-'}]), {})])", "label": 1}
{"function": "def yolov10_inference(image, video, model_id, image_size, conf_threshold):\n    model = YOLOv10.from_pretrained(f'jameslahm/{model_id}')\n    if image:\n        results = model.predict(source=image, imgsz=image_size, conf=conf_threshold)\n        annotated_image = results[0].plot()\n        return annotated_image[:, :, ::-1], None\n    else:\n        video_path = tempfile.mktemp(suffix=\".webm\")\n        with open(video_path, \"wb\") as f:\n            with open(video, \"rb\") as g:\n                f.write(g.read())\n\n        cap = cv2.VideoCapture(video_path)\n        fps = cap.get(cv2.CAP_PROP_FPS)\n        frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n        frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n\n        output_video_path = tempfile.mktemp(suffix=\".webm\")\n        out = cv2.VideoWriter(output_video_path, cv2.VideoWriter_fourcc(*'vp80'), fps, (frame_width, frame_height))\n\n        while cap.isOpened():\n            ret, frame = cap.read()\n            if not ret:\n                break\n\n            results = model.predict(source=frame, imgsz=image_size, conf=conf_threshold)\n            annotated_frame = results[0].plot()\n            out.write(annotated_frame)\n\n        cap.release()\n        out.release()\n\n        return None, output_video_path", "label": 0}
{"function": "def prepare_model():\n    _, arch = system_info()\n    hf_url = args.hf_repo\n    model_dir = args.model_dir\n    quant_type = args.quant_type\n    quant_embd = args.quant_embd\n    if hf_url is not None:\n        # download the model\n        model_dir = os.path.join(model_dir, SUPPORTED_HF_MODELS[hf_url][\"model_name\"])\n        Path(model_dir).mkdir(parents=True, exist_ok=True)\n        logging.info(f\"Downloading model {hf_url} from HuggingFace to {model_dir}...\")\n        run_command([\"huggingface-cli\", \"download\", hf_url, \"--local-dir\", model_dir], log_step=\"download_model\")\n    elif not os.path.exists(model_dir):\n        logging.error(f\"Model directory {model_dir} does not exist.\")\n        sys.exit(1)\n    else:\n        logging.info(f\"Loading model from directory {model_dir}.\")\n    gguf_path = os.path.join(model_dir, \"ggml-model-\" + quant_type + \".gguf\")\n    if not os.path.exists(gguf_path) or os.path.getsize(gguf_path) == 0:\n        logging.info(f\"Converting HF model to GGUF format...\")\n        if quant_type.startswith(\"tl\"):\n            run_command([sys.executable, \"utils/convert-hf-to-gguf-bitnet.py\", model_dir, \"--outtype\", quant_type, \"--quant-embd\"], log_step=\"convert_to_tl\")\n        else: # i2s\n            # convert to f32\n            run_command([sys.executable, \"utils/convert-hf-to-gguf-bitnet.py\", model_dir, \"--outtype\", \"f32\"], log_step=\"convert_to_f32_gguf\")\n            f32_model = os.path.join(model_dir, \"ggml-model-f32.gguf\")\n            i2s_model = os.path.join(model_dir, \"ggml-model-i2_s.gguf\")\n            # quantize to i2s\n            if platform.system() != \"Windows\":\n                if quant_embd:\n                    run_command([\"./build/bin/llama-quantize\", \"--token-embedding-type\", \"f16\", f32_model, i2s_model, \"I2_S\", \"1\", \"1\"], log_step=\"quantize_to_i2s\")\n                else:\n                    run_command([\"./build/bin/llama-quantize\", f32_model, i2s_model, \"I2_S\", \"1\"], log_step=\"quantize_to_i2s\")\n            else:\n                if quant_embd:\n                    run_command([\"./build/bin/Release/llama-quantize\", \"--token-embedding-type\", \"f16\", f32_model, i2s_model, \"I2_S\", \"1\", \"1\"], log_step=\"quantize_to_i2s\")\n                else:\n                    run_command([\"./build/bin/Release/llama-quantize\", f32_model, i2s_model, \"I2_S\", \"1\"], log_step=\"quantize_to_i2s\")\n\n        logging.info(f\"GGUF model saved at {gguf_path}\")\n    else:\n        logging.info(f\"GGUF model already exists at {gguf_path}\")", "label": 0}
{"function": "    def __init__(self, file_descr, landscape=False):\n        # Tamanhos em px\n        self.width = 750\n        self.widthCanhoto = 0\n        self.fontSizeTitle = 9\n        self.heightLine = 27\n        self.fontSizeValue = 12\n        self.title = 'Boleto banc\u00e1rio'\n        self.fileDescr = file_descr\n\n        if landscape:\n            raise NotImplementedError('Em desenvolvimento...')\n        else:\n            tpl = string.Template(self._load_template('head.html'))\n            self.html = tpl.substitute(title=self.title, width=self.width,\n                                       font_size_value=self.fontSizeValue,\n                                       height_line=self.heightLine,\n                                       font_size_title=self.fontSizeTitle)", "label": 1}
{"function": "    def on_status_button_left_click(self, e = None):\n        if self.searching:\n            return self.TextField.SetFocus()\n        self.skipenter = True\n        self.button_timer.Start(BUTTON_HOLD_TIME, True)\n        if e: e.Skip(True)", "label": 1}
{"function": "def main():\n    with gr.Blocks() as demo:\n        gr.Markdown(\"### \u4ee3\u7801\u5e93 [CosyVoice](https://github.com/FunAudioLLM/CosyVoice) \\\n                    \u9884\u8bad\u7ec3\u6a21\u578b [CosyVoice-300M](https://www.modelscope.cn/models/iic/CosyVoice-300M) \\\n                    [CosyVoice-300M-Instruct](https://www.modelscope.cn/models/iic/CosyVoice-300M-Instruct) \\\n                    [CosyVoice-300M-SFT](https://www.modelscope.cn/models/iic/CosyVoice-300M-SFT)\")\n        gr.Markdown(\"#### \u8bf7\u8f93\u5165\u9700\u8981\u5408\u6210\u7684\u6587\u672c\uff0c\u9009\u62e9\u63a8\u7406\u6a21\u5f0f\uff0c\u5e76\u6309\u7167\u63d0\u793a\u6b65\u9aa4\u8fdb\u884c\u64cd\u4f5c\")\n\n        tts_text = gr.Textbox(label=\"\u8f93\u5165\u5408\u6210\u6587\u672c\", lines=1, value=\"\u6211\u662f\u901a\u4e49\u5b9e\u9a8c\u5ba4\u8bed\u97f3\u56e2\u961f\u5168\u65b0\u63a8\u51fa\u7684\u751f\u6210\u5f0f\u8bed\u97f3\u5927\u6a21\u578b\uff0c\u63d0\u4f9b\u8212\u9002\u81ea\u7136\u7684\u8bed\u97f3\u5408\u6210\u80fd\u529b\u3002\")\n        with gr.Row():\n            mode_checkbox_group = gr.Radio(choices=inference_mode_list, label='\u9009\u62e9\u63a8\u7406\u6a21\u5f0f', value=inference_mode_list[0])\n            instruction_text = gr.Text(label=\"\u64cd\u4f5c\u6b65\u9aa4\", value=instruct_dict[inference_mode_list[0]], scale=0.5)\n            sft_dropdown = gr.Dropdown(choices=sft_spk, label='\u9009\u62e9\u9884\u8bad\u7ec3\u97f3\u8272', value=sft_spk[0], scale=0.25)\n            stream = gr.Radio(choices=stream_mode_list, label='\u662f\u5426\u6d41\u5f0f\u63a8\u7406', value=stream_mode_list[0][1])\n            speed = gr.Number(value=1, label=\"\u901f\u5ea6\u8c03\u8282(\u4ec5\u652f\u6301\u975e\u6d41\u5f0f\u63a8\u7406)\", minimum=0.5, maximum=2.0, step=0.1)\n            with gr.Column(scale=0.25):\n                seed_button = gr.Button(value=\"\\U0001F3B2\")\n                seed = gr.Number(value=0, label=\"\u968f\u673a\u63a8\u7406\u79cd\u5b50\")\n\n        with gr.Row():\n            prompt_wav_upload = gr.Audio(sources='upload', type='filepath', label='\u9009\u62e9prompt\u97f3\u9891\u6587\u4ef6\uff0c\u6ce8\u610f\u91c7\u6837\u7387\u4e0d\u4f4e\u4e8e16khz')\n            prompt_wav_record = gr.Audio(sources='microphone', type='filepath', label='\u5f55\u5236prompt\u97f3\u9891\u6587\u4ef6')\n        prompt_text = gr.Textbox(label=\"\u8f93\u5165prompt\u6587\u672c\", lines=1, placeholder=\"\u8bf7\u8f93\u5165prompt\u6587\u672c\uff0c\u9700\u4e0eprompt\u97f3\u9891\u5185\u5bb9\u4e00\u81f4\uff0c\u6682\u65f6\u4e0d\u652f\u6301\u81ea\u52a8\u8bc6\u522b...\", value='')\n        instruct_text = gr.Textbox(label=\"\u8f93\u5165instruct\u6587\u672c\", lines=1, placeholder=\"\u8bf7\u8f93\u5165instruct\u6587\u672c.\", value='')\n\n        generate_button = gr.Button(\"\u751f\u6210\u97f3\u9891\")\n\n        audio_output = gr.Audio(label=\"\u5408\u6210\u97f3\u9891\", autoplay=True, streaming=True)\n\n        seed_button.click(generate_seed, inputs=[], outputs=seed)\n        generate_button.click(generate_audio,\n                              inputs=[tts_text, mode_checkbox_group, sft_dropdown, prompt_text, prompt_wav_upload, prompt_wav_record, instruct_text,\n                                      seed, stream, speed],\n                              outputs=[audio_output])\n        mode_checkbox_group.change(fn=change_instruction, inputs=[mode_checkbox_group], outputs=[instruction_text])\n    demo.queue(max_size=4, default_concurrency_limit=2)\n    demo.launch(server_name='0.0.0.0', server_port=args.port)", "label": 0}
{"function": "def test_css_selector(tester: Crawl4AiTester):\n    print(\"\\n=== Testing CSS Selector ===\")\n    request = {\n        \"urls\": [\"https://www.nbcnews.com/business\"],\n        \"priority\": 7,\n        \"css_selector\": \".wide-tease-item__description\",\n        \"crawler_params\": {\"headless\": True},\n        \"extra\": {\"word_count_threshold\": 10},\n    }\n\n    result = tester.submit_and_wait(request)\n    print(f\"CSS selector result length: {len(result['result']['markdown'])}\")\n    assert result[\"result\"][\"success\"]", "label": 0}
{"function": "  def _IpPrefix2AddressMask(self, addr):\n    def _Length2Mask(length):\n      return 0xFFFFFFFF & ~((1 << (32 - length)) - 1)\n\n    addr, masklen = addr.split('/')\n    return self._Ip2Long(addr), _Length2Mask(int(masklen))", "label": 1}
{"function": "        def _paginator_with_url(self, url, method=\"GET\", body=None, headers=None):\n            pass", "label": 1}
{"function": "    def __gt__(self, other: Any) -> bool: ...", "label": 1}
{"function": "  def testUpdateCloudStorageDependenciesReadOnlyConfig(\n      self, uploader_cs_mock):\n    self.fs.CreateFile(self.file_path,\n                       contents='\\n'.join(self.expected_file_lines))\n    config = dependency_manager.BaseConfig(self.file_path)\n    with self.assertRaises(dependency_manager.ReadWriteError):\n      config.AddCloudStorageDependencyUpdateJob(\n          'dep', 'plat', 'path')\n    with self.assertRaises(dependency_manager.ReadWriteError):\n      config.AddCloudStorageDependencyUpdateJob(\n          'dep', 'plat', 'path', version='1.2.3')\n    with self.assertRaises(dependency_manager.ReadWriteError):\n      config.AddCloudStorageDependencyUpdateJob(\n          'dep', 'plat', 'path', execute_job=False)\n    with self.assertRaises(dependency_manager.ReadWriteError):\n      config.AddCloudStorageDependencyUpdateJob(\n          'dep', 'plat', 'path', version='1.2.3', execute_job=False)", "label": 1}
{"function": "def loop_cart(l):\n    for ix in reversed(range(l+1)):\n        for iy in reversed(range(l-ix+1)):\n            iz = l - ix - iy\n            yield ix, iy, iz", "label": 1}
{"function": "async def test_browser_use_agent():\n    from browser_use.browser.browser import Browser, BrowserConfig\n    from browser_use.browser.context import (\n        BrowserContextConfig\n    )\n    from browser_use.agent.service import Agent\n\n    from src.browser.custom_browser import CustomBrowser\n    from src.controller.custom_controller import CustomController\n    from src.utils import llm_provider\n    from src.agent.browser_use.browser_use_agent import BrowserUseAgent\n\n    llm = llm_provider.get_llm_model(\n        provider=\"openai\",\n        model_name=\"gpt-4o\",\n        temperature=0.8,\n    )\n\n    # llm = llm_provider.get_llm_model(\n    #     provider=\"google\",\n    #     model_name=\"gemini-2.0-flash\",\n    #     temperature=0.6,\n    #     api_key=os.getenv(\"GOOGLE_API_KEY\", \"\")\n    # )\n\n    # llm = utils.get_llm_model(\n    #     provider=\"deepseek\",\n    #     model_name=\"deepseek-reasoner\",\n    #     temperature=0.8\n    # )\n\n    # llm = utils.get_llm_model(\n    #     provider=\"deepseek\",\n    #     model_name=\"deepseek-chat\",\n    #     temperature=0.8\n    # )\n\n    # llm = utils.get_llm_model(\n    #     provider=\"ollama\", model_name=\"qwen2.5:7b\", temperature=0.5\n    # )\n\n    # llm = utils.get_llm_model(\n    #     provider=\"ollama\", model_name=\"deepseek-r1:14b\", temperature=0.5\n    # )\n\n    window_w, window_h = 1280, 1100\n\n    # llm = llm_provider.get_llm_model(\n    #     provider=\"azure_openai\",\n    #     model_name=\"gpt-4o\",\n    #     temperature=0.5,\n    #     base_url=os.getenv(\"AZURE_OPENAI_ENDPOINT\", \"\"),\n    #     api_key=os.getenv(\"AZURE_OPENAI_API_KEY\", \"\"),\n    # )\n\n    mcp_server_config = {\n        \"mcpServers\": {\n            # \"markitdown\": {\n            #     \"command\": \"docker\",\n            #     \"args\": [\n            #         \"run\",\n            #         \"--rm\",\n            #         \"-i\",\n            #         \"markitdown-mcp:latest\"\n            #     ]\n            # },\n            \"desktop-commander\": {\n                \"command\": \"npx\",\n                \"args\": [\n                    \"-y\",\n                    \"@wonderwhy-er/desktop-commander\"\n                ]\n            },\n        }\n    }\n    controller = CustomController()\n    await controller.setup_mcp_client(mcp_server_config)\n    use_own_browser = True\n    use_vision = True  # Set to False when using DeepSeek\n\n    max_actions_per_step = 10\n    browser = None\n    browser_context = None\n\n    try:\n        extra_browser_args = []\n        if use_own_browser:\n            browser_binary_path = os.getenv(\"BROWSER_PATH\", None)\n            if browser_binary_path == \"\":\n                browser_binary_path = None\n            browser_user_data = os.getenv(\"BROWSER_USER_DATA\", None)\n            if browser_user_data:\n                extra_browser_args += [f\"--user-data-dir={browser_user_data}\"]\n        else:\n            browser_binary_path = None\n        browser = CustomBrowser(\n            config=BrowserConfig(\n                headless=False,\n                browser_binary_path=browser_binary_path,\n                extra_browser_args=extra_browser_args,\n                new_context_config=BrowserContextConfig(\n                    window_width=window_w,\n                    window_height=window_h,\n                )\n            )\n        )\n        browser_context = await browser.new_context(\n            config=BrowserContextConfig(\n                trace_path=None,\n                save_recording_path=None,\n                save_downloads_path=\"./tmp/downloads\",\n                window_height=window_h,\n                window_width=window_w,\n            )\n        )\n        agent = BrowserUseAgent(\n            # task=\"download pdf from https://arxiv.org/pdf/2311.16498 and rename this pdf to 'mcp-test.pdf'\",\n            task=\"give me nvidia stock price\",\n            llm=llm,\n            browser=browser,\n            browser_context=browser_context,\n            controller=controller,\n            use_vision=use_vision,\n            max_actions_per_step=max_actions_per_step,\n            generate_gif=True\n        )\n        history: AgentHistoryList = await agent.run(max_steps=100)\n\n        print(\"Final Result:\")\n        pprint(history.final_result(), indent=4)\n\n        print(\"\\nErrors:\")\n        pprint(history.errors(), indent=4)\n\n    except Exception:\n        import traceback\n        traceback.print_exc()\n    finally:\n        if browser_context:\n            await browser_context.close()\n        if browser:\n            await browser.close()\n        if controller:\n            await controller.close_mcp_client()", "label": 0}
{"function": "    def validate(self):\n        \"\"\"Validates the PlatformParameter domain object.\"\"\"\n        if re.match(self.PARAMETER_NAME_REGEXP, self._name) is None:\n            raise utils.ValidationError(\n                'Invalid parameter name \\'%s\\', expected to match regexp '\n                '%s.' % (self._name, self.PARAMETER_NAME_REGEXP))\n\n        if self._data_type not in self.DATA_TYPE_PREDICATES_DICT:\n            raise utils.ValidationError(\n                'Unsupported data type \\'%s\\'.' % self._data_type)\n\n        predicate = self.DATA_TYPE_PREDICATES_DICT[self.data_type]\n        if not predicate(self._default_value):\n            raise utils.ValidationError(\n                'Expected %s, received \\'%s\\' in default value.' % (\n                    self._data_type, self._default_value))\n        for rule in self._rules:\n            if not predicate(rule.value_when_matched):\n                raise utils.ValidationError(\n                    'Expected %s, received \\'%s\\' in value_when_matched.' % (\n                        self._data_type, rule.value_when_matched))\n            if not rule.has_server_mode_filter():\n                raise utils.ValidationError(\n                    'All rules must have a server_mode filter.')\n            rule.validate()\n\n        if self._is_feature:\n            self._validate_feature_flag()", "label": 1}
{"function": "def test_invalid_flag() -> None:\n    result = subprocess.run(\n        [\"python\", \"-m\", \"markitdown\", \"--foobar\"], capture_output=True, text=True\n    )\n\n    assert result.returncode != 0, f\"CLI exited with error: {result.stderr}\"\n    assert (\n        \"unrecognized arguments\" in result.stderr\n    ), \"Expected 'unrecognized arguments' to appear in STDERR\"\n    assert \"SYNTAX\" in result.stderr, \"Expected 'SYNTAX' to appear in STDERR\"", "label": 0}
{"function": "async def get_response(query:str) -> str | None | Any:\n    \"\"\"\n    Received a response based on local secondme model.\n\n    Args:\n        query (str): Questions raised by users regarding the secondme model\n\n    \"\"\"\n\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"text/event-stream\"\n    }\n    messages.append({\"role\": \"user\", \"content\": query})\n\n    data={\n        \"messages\": messages,\n        \"stream\": True\n    }\n\n    conn = http.client.HTTPConnection(url)\n\n    # Send the POST request\n    conn.request(\"POST\", path, body=json.dumps(data), headers=headers)\n\n    # Get the response\n    response = conn.getresponse()\n    full_content=\"\"\n\n    for line in response:\n        if line:\n            decoded_line = line.decode('utf-8').strip()\n            if decoded_line == 'data: [DONE]':\n                break\n            if decoded_line.startswith('data: '):\n                try:\n                    json_str = decoded_line[6:]\n                    chunk = json.loads(json_str)\n                    content = chunk['choices'][0]['delta'].get('content', '')\n                    if content:\n                        full_content+=content\n                except json.JSONDecodeError:\n                    pass\n\n    conn.close()\n    if full_content:\n        messages.append({\"role\": \"system\", \"content\": full_content})\n        return full_content\n    else:\n        return None", "label": 0}
{"function": "    def repr_dict(self, x, level):\n        n = len(x)\n        if n == 0: return '{}'\n        if level <= 0: return '{...}'\n        newlevel = level - 1\n        repr1 = self.repr1\n        pieces = []\n        for key in islice(_possibly_sorted(x), self.maxdict):\n            keyrepr = repr1(key, newlevel)\n            valrepr = repr1(x[key], newlevel)\n            pieces.append('%s: %s' % (keyrepr, valrepr))\n        if n > self.maxdict: pieces.append('...')\n        s = ', '.join(pieces)\n        return '{%s}' % (s,)", "label": 1}
{"function": "    def test_preserves_port(self):\n        \"\"\"Non-default ports should be preserved.\"\"\"\n        assert resource_url_from_server_url(\"https://example.com:8443/path\") == \"https://example.com:8443/path\"\n        assert resource_url_from_server_url(\"http://example.com:8080/\") == \"http://example.com:8080/\"", "label": 0}
{"function": "def main() -> None:\n    \"\"\"Main application function.\"\"\"\n    st.set_page_config(\n        page_title=\"Voice RAG Agent\",\n        page_icon=\"\ud83c\udf99\ufe0f\",\n        layout=\"wide\"\n    )\n    \n    init_session_state()\n    setup_sidebar()\n    \n    st.title(\"\ud83c\udf99\ufe0f Voice RAG Agent\")\n    st.info(\"Get voice-powered answers to your documentation questions by configuring your API keys and uploading PDF documents. Then, simply ask questions to receive both text and voice responses!\")\n    \n    # File upload section\n    uploaded_file = st.file_uploader(\"Upload PDF\", type=[\"pdf\"])\n    \n    if uploaded_file:\n        file_name = uploaded_file.name\n        if file_name not in st.session_state.processed_documents:\n            with st.spinner('Processing PDF...'):\n                try:\n                    # Setup Qdrant if not already done\n                    if not st.session_state.client:\n                        client, embedding_model = setup_qdrant()\n                        st.session_state.client = client\n                        st.session_state.embedding_model = embedding_model\n                    \n                    # Process and store document\n                    documents = process_pdf(uploaded_file)\n                    if documents:\n                        store_embeddings(\n                            st.session_state.client,\n                            st.session_state.embedding_model,\n                            documents,\n                            COLLECTION_NAME\n                        )\n                        st.session_state.processed_documents.append(file_name)\n                        st.success(f\"\u2705 Added PDF: {file_name}\")\n                        st.session_state.setup_complete = True\n                except Exception as e:\n                    st.error(f\"Error processing document: {str(e)}\")\n    \n    # Display processed documents\n    if st.session_state.processed_documents:\n        st.sidebar.header(\"\ud83d\udcda Processed Documents\")\n        for doc in st.session_state.processed_documents:\n            st.sidebar.text(f\"\ud83d\udcc4 {doc}\")\n    \n    # Query interface\n    query = st.text_input(\n        \"What would you like to know about the documentation?\",\n        placeholder=\"e.g., How do I authenticate API requests?\",\n        disabled=not st.session_state.setup_complete\n    )\n    \n    if query and st.session_state.setup_complete:\n        with st.status(\"Processing your query...\", expanded=True) as status:\n            try:\n                result = asyncio.run(process_query(\n                    query,\n                    st.session_state.client,\n                    st.session_state.embedding_model,\n                    COLLECTION_NAME,\n                    st.session_state.openai_api_key,\n                    st.session_state.selected_voice\n                ))\n                \n                if result[\"status\"] == \"success\":\n                    status.update(label=\"\u2705 Query processed!\", state=\"complete\")\n                    \n                    st.markdown(\"### Response:\")\n                    st.write(result[\"text_response\"])\n                    \n                    if \"audio_path\" in result:\n                        st.markdown(f\"### \ud83d\udd0a Audio Response (Voice: {st.session_state.selected_voice})\")\n                        st.audio(result[\"audio_path\"], format=\"audio/mp3\", start_time=0)\n                        \n                        with open(result[\"audio_path\"], \"rb\") as audio_file:\n                            audio_bytes = audio_file.read()\n                            st.download_button(\n                                label=\"\ud83d\udce5 Download Audio Response\",\n                                data=audio_bytes,\n                                file_name=f\"voice_response_{st.session_state.selected_voice}.mp3\",\n                                mime=\"audio/mp3\"\n                            )\n                    \n                    st.markdown(\"### Sources:\")\n                    for source in result[\"sources\"]:\n                        st.markdown(f\"- {source}\")\n                else:\n                    status.update(label=\"\u274c Error processing query\", state=\"error\")\n                    st.error(f\"Error: {result.get('error', 'Unknown error occurred')}\")\n            \n            except Exception as e:\n                status.update(label=\"\u274c Error processing query\", state=\"error\")\n                st.error(f\"Error processing query: {str(e)}\")\n    \n    elif not st.session_state.setup_complete:\n        st.info(\"\ud83d\udc48 Please configure the system and upload documents first!\")", "label": 0}
{"function": "    def test_setitem_with_keys_list(self):\n        d = {\n            'a': {\n                'b': {\n                    'c': 1,\n                    'd': 2,\n                },\n            },\n        }\n        b = KeypathDict(d)\n        b['a', 'b.c'] = 2\n        self.assertEqual(b['a.b.c'], 2)\n        b['a', 'b', 'c'] = 3\n        self.assertEqual(b['a.b.c'], 3)\n        b['a', 'b', 'd'] = 4\n        self.assertEqual(b['a.b.d'], 4)\n        b['a', 'b', 'e'] = 5\n        self.assertEqual(b['a.b.e'], 5)", "label": 1}
{"function": "    def __init__(self, hCtx):\n        self.hCtx = hCtx", "label": 1}
{"function": "def fetch_readme() -> str:\n    \"\"\"\n    This function reads the README.md file in the current directory.\n\n    Returns:\n        The lines in the README file.\n    \"\"\"\n    with open(\"README.md\", encoding=\"utf-8\") as f:\n        return f.read()", "label": 0}
{"function": "def main(unused_argv):\n  tf.logging.set_verbosity(tf.logging.INFO)\n  # Get dataset-dependent information.\n  dataset = segmentation_dataset.get_dataset(\n      FLAGS.dataset, FLAGS.vis_split, dataset_dir=FLAGS.dataset_dir)\n  train_id_to_eval_id = None\n  if dataset.name == segmentation_dataset.get_cityscapes_dataset_name():\n    tf.logging.info('Cityscapes requires converting train_id to eval_id.')\n    train_id_to_eval_id = _CITYSCAPES_TRAIN_ID_TO_EVAL_ID\n\n  # Prepare for visualization.\n  tf.gfile.MakeDirs(FLAGS.vis_logdir)\n  save_dir = os.path.join(FLAGS.vis_logdir, _SEMANTIC_PREDICTION_SAVE_FOLDER)\n  tf.gfile.MakeDirs(save_dir)\n  raw_save_dir = os.path.join(\n      FLAGS.vis_logdir, _RAW_SEMANTIC_PREDICTION_SAVE_FOLDER)\n  tf.gfile.MakeDirs(raw_save_dir)\n\n  tf.logging.info('Visualizing on %s set', FLAGS.vis_split)\n\n  g = tf.Graph()\n  with g.as_default():\n    samples = input_generator.get(dataset,\n                                  FLAGS.vis_crop_size,\n                                  FLAGS.vis_batch_size,\n                                  min_resize_value=FLAGS.min_resize_value,\n                                  max_resize_value=FLAGS.max_resize_value,\n                                  resize_factor=FLAGS.resize_factor,\n                                  dataset_split=FLAGS.vis_split,\n                                  is_training=False,\n                                  model_variant=FLAGS.model_variant)\n\n    model_options = common.ModelOptions(\n        outputs_to_num_classes={common.OUTPUT_TYPE: dataset.num_classes},\n        crop_size=FLAGS.vis_crop_size,\n        atrous_rates=FLAGS.atrous_rates,\n        output_stride=FLAGS.output_stride)\n\n    if tuple(FLAGS.eval_scales) == (1.0,):\n      tf.logging.info('Performing single-scale test.')\n      predictions = model.predict_labels(\n          samples[common.IMAGE],\n          model_options=model_options,\n          image_pyramid=FLAGS.image_pyramid)\n    else:\n      tf.logging.info('Performing multi-scale test.')\n      predictions = model.predict_labels_multi_scale(\n          samples[common.IMAGE],\n          model_options=model_options,\n          eval_scales=FLAGS.eval_scales,\n          add_flipped_images=FLAGS.add_flipped_images)\n    predictions = predictions[common.OUTPUT_TYPE]\n\n    if FLAGS.min_resize_value and FLAGS.max_resize_value:\n      # Only support batch_size = 1, since we assume the dimensions of original\n      # image after tf.squeeze is [height, width, 3].\n      assert FLAGS.vis_batch_size == 1\n\n      # Reverse the resizing and padding operations performed in preprocessing.\n      # First, we slice the valid regions (i.e., remove padded region) and then\n      # we reisze the predictions back.\n      original_image = tf.squeeze(samples[common.ORIGINAL_IMAGE])\n      original_image_shape = tf.shape(original_image)\n      predictions = tf.slice(\n          predictions,\n          [0, 0, 0],\n          [1, original_image_shape[0], original_image_shape[1]])\n      resized_shape = tf.to_int32([tf.squeeze(samples[common.HEIGHT]),\n                                   tf.squeeze(samples[common.WIDTH])])\n      predictions = tf.squeeze(\n          tf.image.resize_images(tf.expand_dims(predictions, 3),\n                                 resized_shape,\n                                 method=tf.image.ResizeMethod.NEAREST_NEIGHBOR,\n                                 align_corners=True), 3)\n\n    tf.train.get_or_create_global_step()\n    saver = tf.train.Saver(slim.get_variables_to_restore())\n    sv = tf.train.Supervisor(graph=g,\n                             logdir=FLAGS.vis_logdir,\n                             init_op=tf.global_variables_initializer(),\n                             summary_op=None,\n                             summary_writer=None,\n                             global_step=None,\n                             saver=saver)\n    num_batches = int(math.ceil(\n        dataset.num_samples / float(FLAGS.vis_batch_size)))\n    last_checkpoint = None\n\n    # Loop to visualize the results when new checkpoint is created.\n    num_iters = 0\n    while (FLAGS.max_number_of_iterations <= 0 or\n           num_iters < FLAGS.max_number_of_iterations):\n      num_iters += 1\n      last_checkpoint = slim.evaluation.wait_for_new_checkpoint(\n          FLAGS.checkpoint_dir, last_checkpoint)\n      start = time.time()\n      tf.logging.info(\n          'Starting visualization at ' + time.strftime('%Y-%m-%d-%H:%M:%S',\n                                                       time.gmtime()))\n      tf.logging.info('Visualizing with model %s', last_checkpoint)\n\n      with sv.managed_session(FLAGS.master,\n                              start_standard_services=False) as sess:\n        sv.start_queue_runners(sess)\n        sv.saver.restore(sess, last_checkpoint)\n\n        image_id_offset = 0\n        for batch in range(num_batches):\n          tf.logging.info('Visualizing batch %d / %d', batch + 1, num_batches)\n          _process_batch(sess=sess,\n                         original_images=samples[common.ORIGINAL_IMAGE],\n                         semantic_predictions=predictions,\n                         image_names=samples[common.IMAGE_NAME],\n                         image_heights=samples[common.HEIGHT],\n                         image_widths=samples[common.WIDTH],\n                         image_id_offset=image_id_offset,\n                         save_dir=save_dir,\n                         raw_save_dir=raw_save_dir,\n                         train_id_to_eval_id=train_id_to_eval_id)\n          image_id_offset += FLAGS.vis_batch_size\n\n      tf.logging.info(\n          'Finished visualization at ' + time.strftime('%Y-%m-%d-%H:%M:%S',\n                                                       time.gmtime()))\n      time_to_next_eval = start + FLAGS.eval_interval_secs - time.time()\n      if time_to_next_eval > 0:\n        time.sleep(time_to_next_eval)", "label": 1}
{"function": "def array_equal(a1, a2):\n    \"\"\"\n    True if two arrays have the same shape and elements, False otherwise.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equal.\n\n    See Also\n    --------\n    allclose: Returns True if two arrays are element-wise equal within a\n              tolerance.\n    array_equiv: Returns True if input arrays are shape consistent and all\n                 elements equal.\n\n    Examples\n    --------\n    >>> np.array_equal([1, 2], [1, 2])\n    True\n    >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\n    True\n    >>> np.array_equal([1, 2], [1, 2, 3])\n    False\n    >>> np.array_equal([1, 2], [1, 4])\n    False\n\n    \"\"\"\n    try:\n        a1, a2 = asarray(a1), asarray(a2)\n    except Exception:\n        return False\n    if a1.shape != a2.shape:\n        return False\n    return bool(asarray(a1 == a2).all())", "label": 1}
{"function": "    def __add__(self, value):\n        \"\"\"Detect list add events and emit change events.\"\"\"\n        list.__add__(self, value)\n        self.changed()", "label": 1}
{"function": "def test_clear():\n    \"\"\"Test clearing encoder\"\"\"\n    encoder = MemvidEncoder()\n    encoder.add_chunks([\"test1\", \"test2\"])\n    \n    encoder.clear()\n    assert encoder.chunks == []\n    assert encoder.get_stats()[\"total_chunks\"] == 0", "label": 0}
{"function": "    def test_home_installation_scheme(self):\n        # This ensure two things:\n        # - that --home generates the desired set of directory names\n        # - test --home is supported on all platforms\n        builddir = self.mkdtemp()\n        destination = os.path.join(builddir, \"installation\")\n\n        dist = Distribution({\"name\": \"foopkg\"})\n        # script_name need not exist, it just need to be initialized\n        dist.script_name = os.path.join(builddir, \"setup.py\")\n        dist.command_obj[\"build\"] = support.DummyCommand(\n            build_base=builddir,\n            build_lib=os.path.join(builddir, \"lib\"),\n            )\n\n        cmd = install(dist)\n        cmd.home = destination\n        cmd.ensure_finalized()\n\n        self.assertEqual(cmd.install_base, destination)\n        self.assertEqual(cmd.install_platbase, destination)\n\n        def check_path(got, expected):\n            got = os.path.normpath(got)\n            expected = os.path.normpath(expected)\n            self.assertEqual(got, expected)\n\n        libdir = os.path.join(destination, \"lib\", \"python\")\n        check_path(cmd.install_lib, libdir)\n        check_path(cmd.install_platlib, libdir)\n        check_path(cmd.install_purelib, libdir)\n        check_path(cmd.install_headers,\n                   os.path.join(destination, \"include\", \"python\", \"foopkg\"))\n        check_path(cmd.install_scripts, os.path.join(destination, \"bin\"))\n        check_path(cmd.install_data, destination)", "label": 1}
{"function": "    def __init__(self, api: RedditAPI, data):\n        Gtk.ListBoxRow.__init__(self)\n        self.get_style_context().add_class('link-row')\n        self.add_events(Gdk.EventMask.KEY_PRESS_MASK)\n        self._api = api\n        self.data = data['data']\n\n        is_comment_reply = self.data.get('subreddit') is not None\n\n        self._builder = Gtk.Builder.new_from_resource(\n            '/today/sam/reddit-is-gtk/row-comment.ui')\n        self._g = self._builder.get_object\n        self.add(self._g('box'))\n\n        read = not self.data.get('new', True)\n        if read:\n            self.read()\n\n        # Keep a reference so the GC doesn't collect them\n        self._abb = AuthorButtonBehaviour(self._g('author'), self.data)\n        self._tbb = TimeButtonBehaviour(self._g('time'), self.data)\n        if is_comment_reply:\n            self._srbb = SubButtonBehaviour(self._g('subreddit'), self.data)\n        else:\n            self._g('subreddit').props.sensitive = False\n            self._g('subreddit').props.label = 'PM'\n\n        self._g('nsfw').props.visible = self.data.get('over_18')\n        self._g('saved').props.visible = self.data.get('saved')\n\n        self._g('title').props.label = (self.data.get('link_title') or\n                                        self.data['subject'])\n        content = newmarkdown.make_markdown_widget(self.data['body'])\n        self._g('grid').attach(content, 0, 2, 3, 1)\n\n        if is_comment_reply:\n            self._g('type-private-message').props.visible = False\n        else:\n            self._g('type-comment-reply').props.visible = False", "label": 1}
{"function": "    def __init__(self, real):\n        pass", "label": 1}
{"function": "    def __init__(self, parent=None):\n        super().__init__(parent=parent)\n        self.setObjectName(\"batchProcessInterface\")\n        self.setWindowTitle(self.tr(\"\u6279\u91cf\u5904\u7406\"))\n        self.setAcceptDrops(True)\n        self.batch_thread = BatchProcessThread()\n\n        self.init_ui()\n        self.setup_connections()", "label": 0}
{"function": "    def test_add_tool_with_signature_inference(self):\n        \"\"\"Test adding a tool and inferring parameters from the function signature.\"\"\"\n        self.tool_manager._add_tool(get_current_temperature)\n        # Expected output from tool_manager.tools() when called with OpenAI format\n        expected_tool_spec = [\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"get_current_temperature\",\n                    \"description\": \"Gets the current temperature for a specific location and unit.\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"location\": {\n                                \"type\": \"string\",\n                                \"description\": \"\",  # No description provided in function signature\n                            },\n                            \"unit\": {\n                                \"type\": \"string\",\n                                \"description\": \"\",\n                                \"default\": \"Celsius\",\n                            },\n                        },\n                        \"required\": [\"location\"],\n                    },\n                },\n            }\n        ]\n        tools = self.tool_manager.tools()\n        print(tools)\n        self.assertIn(\n            \"get_current_temperature\", [tool[\"function\"][\"name\"] for tool in tools]\n        )\n        assert (\n            tools == expected_tool_spec\n        ), f\"Expected {expected_tool_spec}, but got {tools}\"", "label": 0}
{"function": "    def test_1d_slicing7(self, flags=enable_pyobj_flags):\n        pyfunc = slicing_1d_usecase7\n        self.check_1d_slicing_with_arg(pyfunc, flags)", "label": 1}
{"function": "async def dummy_scraper(url):\n    \"\"\"A dummy scraping function that returns dummy HTML content for the URL.\"\"\"\n    return f\"<html>dummy content for {url}</html>\"", "label": 0}
{"function": "\tdef get_subcontexts(self, path='', get_empty=True):\n\t\t\"\"\" Return a list of Row-contexts that are direct children of the\n\t\tcontext pointed to by `path`. The list doesn't contain contexts that\n\t\thave a \"hidden\" visibility. If `get_empty` is False, then contexts\n\t\tthat have 0 total tasks are excluded from the list. In the list,\n\t\tcontexts are sorted by:\n\t\t * priority, descending\n\t\t * total number of tasks (including tasks in descendance), ascending\n\t\t\"\"\"\n\t\tif get_empty:\n\t\t\tadd_condition = ''\n\t\telse:\n\t\t\tadd_condition = 'AND total_tasks > 0'\n\t\tc = self.connection.cursor()\n\t\tc.execute(\"\"\"\n\t\t\tSELECT c.*, COUNT(own.id) as own_tasks, (\n\t\t\t\tSELECT COUNT(t.id)\n\t\t\t\tFROM Context c1\n\t\t\t\tLEFT JOIN Task t\n\t\t\t\t  ON t.context = c1.id\n\t\t\t\t AND t.start <= (datetime('now'))\n\t\t\t\t AND t.done IS NULL\n\t\t\t\tWHERE c1.path LIKE c.path||'%' \n\t\t\t) as total_tasks\n\t\t\tFROM Context c\n\t\t\tLEFT JOIN Task own\n\t\t\t  ON own.context = c.id\n\t\t\t AND own.start <= (datetime('now'))\n\t\t\t AND own.done IS NULL\n\t\t\tWHERE path LIKE ?\n\t\t\t  AND path NOT LIKE ?\n\t\t\t  AND visibility = 'normal'\n\t\t\t  {}\n\t\t\tGROUP BY c.id\n\t\t\tORDER BY\n\t\t\t  priority DESC,\n\t\t\t  total_tasks DESC\n\t\t\"\"\".format(add_condition), (\n\t\t\t'{}.%'.format(path),\n\t\t\t'{}.%.%'.format(path),\n\t\t\t)\n\t\t)\n\t\treturn c.fetchall()", "label": 1}
{"function": "def import_model(in_path: Path, out_path: Path, silent: bool = False) -> None:\n    with safe_open(in_path, framework=\"pt\", device=\"cpu\") as f:\n        tensors = {key: f.get_tensor(key) for key in f.keys()}\n    model = {\n        \"text_emb.weight\": tensors[\"model.embed_tokens.weight\"],\n        \"text_linear.weight\": tensors[\"lm_head.weight\"],\n        \"out_norm.weight\": tensors[\"model.norm.weight\"],\n    }\n    n_layers = -1\n    for key in tensors.keys():\n        if key.startswith(\"model.layers.\"):\n            layer_idx = int(key.split(\".\")[2])\n            n_layers = max(layer_idx, n_layers)\n    n_layers += 1\n    if not silent:\n        print(f\"found {n_layers} layers\")\n    for layer_idx in range(n_layers):\n        dst_prefix = f\"transformer.layers.{layer_idx}.\"\n        src_prefix = f\"model.layers.{layer_idx}.\"\n        _model = {\n            \"norm1.weight\": \"input_layernorm.weight\",\n            \"norm2.weight\": \"post_attention_layernorm.weight\",\n            \"self_attn.out_proj.weight\": \"self_attn.o_proj.weight\",\n            \"gating.linear_out.weight\": \"mlp.down_proj.weight\",\n        }\n        for dst, src in _model.items():\n            model[dst_prefix + dst] = tensors[src_prefix + src]\n        gate_proj = tensors[src_prefix + \"mlp.gate_proj.weight\"]\n        up_proj = tensors[src_prefix + \"mlp.up_proj.weight\"]\n        linear_in = torch.cat([gate_proj, up_proj], dim=0)\n        model[dst_prefix + \"gating.linear_in.weight\"] = linear_in\n        q = tensors[src_prefix + \"self_attn.q_proj.weight\"]\n        k = tensors[src_prefix + \"self_attn.k_proj.weight\"]\n        v = tensors[src_prefix + \"self_attn.v_proj.weight\"]\n        in_proj = torch.cat([q, k, v], dim=0)\n        model[dst_prefix + \"self_attn.in_proj.weight\"] = in_proj\n\n    save_file(model, out_path)", "label": 0}
{"function": "    def alertFiles(self):\n        return list(self.alertPath.glob(\"*[0-9].*\"))", "label": 1}
{"function": "def automatically_move_pipeline_components(pipe):\n    for attr_name in dir(pipe):\n        attr_value = getattr(pipe, attr_name, None)\n        if isinstance(attr_value, torch.nn.Module):\n            automatically_move_to_gpu_when_forward(attr_value)\n    return", "label": 0}
{"function": "def test_tool_call(mock_openai_client: MockOpenAIClient):\n    expected_location = \"San Francisco\"\n\n    # set up mock to record function calls\n    get_weather_mock = Mock()\n\n    def get_weather(location):\n        get_weather_mock(location=location)\n        return \"It's sunny today.\"\n\n    agent = Agent(name=\"Test Agent\", functions=[get_weather])\n    messages = [\n        {\"role\": \"user\", \"content\": \"What's the weather like in San Francisco?\"}\n    ]\n\n    # set mock to return a response that triggers function call\n    mock_openai_client.set_sequential_responses(\n        [\n            create_mock_response(\n                message={\"role\": \"assistant\", \"content\": \"\"},\n                function_calls=[\n                    {\"name\": \"get_weather\", \"args\": {\"location\": expected_location}}\n                ],\n            ),\n            create_mock_response(\n                {\"role\": \"assistant\", \"content\": DEFAULT_RESPONSE_CONTENT}\n            ),\n        ]\n    )\n\n    # set up client and run\n    client = Swarm(client=mock_openai_client)\n    response = client.run(agent=agent, messages=messages)\n\n    get_weather_mock.assert_called_once_with(location=expected_location)\n    assert response.messages[-1][\"role\"] == \"assistant\"\n    assert response.messages[-1][\"content\"] == DEFAULT_RESPONSE_CONTENT", "label": 0}
{"function": "def fold_batch_dim(data: \"DataProto\", new_batch_size):\n    \"\"\"\n    Fold a batch dim from [bsz, xxx] into [new_bsz, bsz // new_bsz, xxx]\n    \"\"\"\n    batch_size = data.batch.batch_size[0]\n\n    assert batch_size % new_batch_size == 0\n\n    tensor: TensorDict = data.batch\n    non_tensor = data.non_tensor_batch\n\n    tensor = tensor.view(new_batch_size, -1)\n    tensor.auto_batch_size_(batch_dims=1)\n\n    for key, val in non_tensor.items():\n        non_tensor[key] = np.reshape(val, newshape=(new_batch_size, -1, *val.shape[1:]))\n\n    return type(data)(batch=tensor, non_tensor_batch=non_tensor, meta_info=data.meta_info)", "label": 0}
{"function": "  def testIsExtension(self):\n    self.assertTrue(unittest_pb2.optional_int32_extension.is_extension)\n    self.assertTrue(unittest_pb2.TestRequired.single.is_extension)\n\n    message_descriptor = unittest_pb2.TestRequired.DESCRIPTOR\n    non_extension_descriptor = message_descriptor.fields_by_name['a']\n    self.assertTrue(not non_extension_descriptor.is_extension)", "label": 1}
{"function": "    def execute(self, context):\n        MUV_OT_MoveUV.__running = True\n        self.__operating = False\n        self.__first_time = True\n\n        context.window_manager.modal_handler_add(self)\n        self.__topology_dict, self.__ini_uvs = _find_uv(context)\n\n        if context.area:\n            context.area.tag_redraw()\n\n        return {'RUNNING_MODAL'}", "label": 1}
{"function": "def main(opt):\n    # check_requirements(exclude=('tensorboard', 'thop'))\n    run(**vars(opt))", "label": 0}
{"function": "    def test_from_array_event_value_wrong_1(surv_arrays):\n        event, time = surv_arrays\n        event += 1\n\n        with pytest.raises(ValueError,\n                           match=\"non-boolean event indicator must contain 0 and 1 only\"):\n            Surv.from_arrays(event, time)", "label": 1}
{"function": "    def application(cls, f):\n        \"\"\"Decorate a function as responder that accepts the request as first\n        argument.  This works like the :func:`responder` decorator but the\n        function is passed the request object as first argument and the\n        request object will be closed automatically::\n\n            @Request.application\n            def my_wsgi_app(request):\n                return Response('Hello World!')\n\n        :param f: the WSGI callable to decorate\n        :return: a new WSGI callable\n        \"\"\"\n        #: return a callable that wraps the -2nd argument with the request\n        #: and calls the function with all the arguments up to that one and\n        #: the request.  The return value is then called with the latest\n        #: two arguments.  This makes it possible to use this decorator for\n        #: both methods and standalone WSGI functions.\n        def application(*args):\n            request = cls(args[-2])\n            with request:\n                return f(*args[:-2] + (request,))(*args[-2:])\n        return update_wrapper(application, f)", "label": 1}
{"function": "def get_testdata_dir() -> Path:\n    return (Path(__file__).parent / \"testdata\").resolve()", "label": 0}
{"function": "def capture_gpu_object(capture=True):\n    if capture:\n        return GPUObject()\n    else:\n        return contextlib.nullcontext()", "label": 0}
{"function": "def generate(model, text, audio_prompt_path, exaggeration, temperature, seed_num, cfgw, min_p, top_p, repetition_penalty):\n    if model is None:\n        model = ChatterboxTTS.from_pretrained(DEVICE)\n\n    if seed_num != 0:\n        set_seed(int(seed_num))\n\n    wav = model.generate(\n        text,\n        audio_prompt_path=audio_prompt_path,\n        exaggeration=exaggeration,\n        temperature=temperature,\n        cfg_weight=cfgw,\n        min_p=min_p,\n        top_p=top_p,\n        repetition_penalty=repetition_penalty,\n    )\n    return (model.sr, wav.squeeze(0).numpy())", "label": 0}
{"function": "def test_parse_picture():\n    line = (\n        \"image::images/example1.png[Example Image, width=200, height=150, align=center]\"\n    )\n    res = AsciiDocBackend._parse_picture(line)\n    assert res\n    assert res.get(\"width\", 0) == \"200\"\n    assert res.get(\"height\", 0) == \"150\"\n    assert res.get(\"uri\", \"\") == \"images/example1.png\"\n\n    line = \"image::renamed-bookmark.png[Renamed bookmark]\"\n    res = AsciiDocBackend._parse_picture(line)\n    assert res\n    assert \"width\" not in res\n    assert \"height\" not in res\n    assert res.get(\"uri\", \"\") == \"renamed-bookmark.png\"", "label": 0}
{"function": "def test_llm(config, query, image_path=None, system_message=None):\n    from src.utils import utils, llm_provider\n\n    # Special handling for Ollama-based models\n    if config.provider == \"ollama\":\n        if \"deepseek-r1\" in config.model_name:\n            from src.utils.llm_provider import DeepSeekR1ChatOllama\n            llm = DeepSeekR1ChatOllama(model=config.model_name)\n        else:\n            llm = ChatOllama(model=config.model_name)\n\n        ai_msg = llm.invoke(query)\n        print(ai_msg.content)\n        if \"deepseek-r1\" in config.model_name:\n            pdb.set_trace()\n        return\n\n    # For other providers, use the standard configuration\n    llm = llm_provider.get_llm_model(\n        provider=config.provider,\n        model_name=config.model_name,\n        temperature=config.temperature,\n        base_url=config.base_url or get_env_value(\"base_url\", config.provider),\n        api_key=config.api_key or get_env_value(\"api_key\", config.provider)\n    )\n\n    # Prepare messages for non-Ollama models\n    messages = []\n    if system_message:\n        messages.append(SystemMessage(content=create_message_content(system_message)))\n    messages.append(HumanMessage(content=create_message_content(query, image_path)))\n    ai_msg = llm.invoke(messages)\n\n    # Handle different response types\n    if hasattr(ai_msg, \"reasoning_content\"):\n        print(ai_msg.reasoning_content)\n    print(ai_msg.content)", "label": 0}
{"function": "def allclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):\n    \"\"\"\n    Returns True if two arrays are element-wise equal within a tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    If either array contains one or more NaNs, False is returned.\n    Infs are treated as equal if they are in the same place and of the same\n    sign in both arrays.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN's as equal.  If True, NaN's in `a` will be\n        considered equal to NaN's in `b` in the output array.\n\n        .. versionadded:: 1.10.0\n\n    Returns\n    -------\n    allclose : bool\n        Returns True if the two arrays are equal within the given\n        tolerance; False otherwise.\n\n    See Also\n    --------\n    isclose, all, any, equal\n\n    Notes\n    -----\n    If the following equation is element-wise True, then allclose returns\n    True.\n\n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    The above equation is not symmetric in `a` and `b`, so that\n    ``allclose(a, b)`` might be different from ``allclose(b, a)`` in\n    some rare cases.\n\n    The comparison of `a` and `b` uses standard broadcasting, which\n    means that `a` and `b` need not have the same shape in order for\n    ``allclose(a, b)`` to evaluate to True.  The same is true for\n    `equal` but not `array_equal`.\n\n    Examples\n    --------\n    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\n    False\n    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\n    True\n    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\n    True\n\n    \"\"\"\n    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))\n    return bool(res)", "label": 1}
{"function": "def parse_args():\n    parser = argparse.ArgumentParser(description=\"Run a task with a given configuration file.\")\n    parser.add_argument('--config', type=str, required=True, help='Path to the configuration file.')\n    return parser.parse_args()", "label": 0}
{"function": "    def test_umask_secret(self, tmpdir):\n        filename = str(tmpdir.join(\"secret\"))\n        with certs.CertStore.umask_secret(), open(filename, \"wb\"):\n            pass\n        # TODO: How do we actually attempt to read that file as another user?\n        assert os.stat(filename).st_mode & 0o77 == 0", "label": 1}
{"function": "def test_audio_path():\n    return Path(\"./tests/data/audio/sample_10s.mp3\")", "label": 0}
{"function": "def llama3_2_1B() -> torchtune.modules.transformer.TransformerDecoder:\n    return llama3_2.llama3_2(\n        vocab_size=128_256,\n        num_layers=16,\n        num_heads=32,\n        num_kv_heads=8,\n        embed_dim=2048,\n        max_seq_len=2048,\n        intermediate_dim=8192,\n        attn_dropout=0.0,\n        norm_eps=1e-5,\n        rope_base=500_000,\n        scale_factor=32,\n    )", "label": 0}
{"function": "    def parse_ticker(self, ticker, market=None):\n        timestamp = ticker['timestamp']\n        symbol = None\n        if not market:\n            if 'symbol' in ticker:\n                marketId = ticker['symbol']\n                if marketId in self.markets_by_id:\n                    market = self.markets_by_id[marketId]\n        if market:\n            symbol = market['symbol']\n        last = self.safe_float(ticker, 'last')\n        return {\n            'symbol': symbol,\n            'timestamp': timestamp,\n            'datetime': self.iso8601(timestamp),\n            'high': self.safe_float(ticker, 'high'),\n            'low': self.safe_float(ticker, 'low'),\n            'bid': self.safe_float(ticker, 'buy'),\n            'bidVolume': None,\n            'ask': self.safe_float(ticker, 'sell'),\n            'askVolume': None,\n            'vwap': None,\n            'open': None,\n            'close': last,\n            'last': last,\n            'previousClose': None,\n            'change': None,\n            'percentage': None,\n            'average': None,\n            'baseVolume': self.safe_float(ticker, 'vol'),\n            'quoteVolume': None,\n            'info': ticker,\n        }", "label": 1}
{"function": "    def __init__(self, in_ch=3, mid_ch=12, out_ch=3):\n        super(RSU4, self).__init__()\n\n        self.rebnconvin = REBNCONV(in_ch, out_ch, dirate=1)\n\n        self.rebnconv1 = REBNCONV(out_ch, mid_ch, dirate=1)\n        self.pool1 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv2 = REBNCONV(mid_ch, mid_ch, dirate=1)\n        self.pool2 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n        self.rebnconv3 = REBNCONV(mid_ch, mid_ch, dirate=1)\n\n        self.rebnconv4 = REBNCONV(mid_ch, mid_ch, dirate=2)\n\n        self.rebnconv3d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv2d = REBNCONV(mid_ch * 2, mid_ch, dirate=1)\n        self.rebnconv1d = REBNCONV(mid_ch * 2, out_ch, dirate=1)", "label": 0}
{"function": "            def flatten_all(list_):\n                \"\"\" Flattens arbitrary depth lists of lists (e.g. [[1,2],[3,[1]]] -> [1,2,3,1]). \"\"\"\n                for el in list_:\n                    if isinstance(el, (list, tuple)) and len(el) > 0:\n                        yield from flatten_all(el)\n                    else:\n                        yield el", "label": 1}
{"function": "    def declare(self):\n        self._ass.mem_addr.usage_read()\n        self._ass.mem_buf.usage_read()", "label": 1}
{"function": "    def test_accuracy_reward_wrong_answer_no_latex(self):\n        \"\"\"Test accuracy_reward with an incorrect answer and gold solution with no latex.\"\"\"\n        completion = [[{\"content\": r\"\\boxed{3}\"}]]\n        solution = [\"6\"]\n        rewards = accuracy_reward(completion, solution)\n        self.assertEqual(rewards[0], 0.0)", "label": 0}
{"function": "def _get_cuda_home():\n    if TORCH_VERSION == 'parrots':\n        from parrots.utils.build_extension import CUDA_HOME\n    else:\n        if is_rocm_pytorch():\n            from torch.utils.cpp_extension import ROCM_HOME\n            CUDA_HOME = ROCM_HOME\n        else:\n            from torch.utils.cpp_extension import CUDA_HOME\n    return CUDA_HOME", "label": 0}
{"function": "def gpu_wrapped_execute_video(*args, **kwargs):\n    return gradio_pipeline.execute_video(*args, **kwargs)", "label": 0}
{"function": "def serve_llamacpp_python(local_model_file: Path, **kwargs):\n    def guess_chat_format(local_model_file):\n        model_name = local_model_file.stem\n\n        # handle known cases that the server backends handle incorrectly\n        # this is highly heuristic, should be expand later\n        # server backends usually has logic for this but they could still be wrong\n        if \"qwen\" in model_name:\n            return \"qwen\"\n\n        return None\n\n    # default port\n    if \"port\" not in kwargs:\n        kwargs[\"port\"] = 31415\n\n    chat_format = guess_chat_format(local_model_file)\n    if chat_format:\n        kwargs = {**kwargs, \"chat_format\": chat_format}\n\n    # these scripts create a separate conda env and run the server\n    if system_name == \"Windows\":\n        script_file = this_dir / \"server_llamacpp_windows.bat\"\n    elif system_name == \"Linux\":\n        script_file = this_dir / \"server_llamacpp_linux.sh\"\n    elif system_name == \"Darwin\":\n        script_file = this_dir / \"server_llamacpp_macos.sh\"\n    else:\n        raise ValueError(f\"Unsupported system: {system_name}\")\n\n    args = \" \".join(f\"--{k} {v}\" for k, v in kwargs.items())\n\n    cmd = f\"{script_file} --model {local_model_file} {args}\"\n    subprocess.Popen(cmd, shell=True)", "label": 0}
{"function": "def _hash_name_to_id(h_alg):\n    \"\"\"Try to convert hash algorithm name to HashAlgorithm TLS ID.\n\n    accepts also a string with a single number in it\n    \"\"\"\n    try:\n        return int(h_alg)\n    except ValueError:\n        return getattr(HashAlgorithm, h_alg)", "label": 1}
{"function": "    def set_system_message(self, system_message: str):\n        \"\"\"Set the system message.\"\"\"\n        self.system_message = system_message", "label": 0}
{"function": "def member_with_tags_server_selector(tag_sets, selection):\n    \"\"\"All near-enough members matching the tag sets.\"\"\"\n    return apply_tag_sets(tag_sets, readable_server_selector(selection))", "label": 1}
{"function": "def process_all_videos(input_video_list: List[Path], output_dir: Path, step: int) -> None:\n    \"\"\"\n    Process all videos in the input list.\n\n    Args:\n        input_video_list (List[Path]): List of video paths to process.\n        output_dir (Path): Directory to save the output.\n        gpu_status (bool): Whether to use GPU for processing.\n    \"\"\"\n    face_analysis_model_path = \"pretrained_models/face_analysis\"\n    landmark_model_path = \"pretrained_models/face_analysis/models/face_landmarker_v2_with_blendshapes.task\"\n    audio_separator_model_file = \"pretrained_models/audio_separator/Kim_Vocal_2.onnx\"\n    wav2vec_model_path = 'pretrained_models/wav2vec/wav2vec2-base-960h'\n\n    audio_processor = AudioProcessor(\n        16000,\n        25,\n        wav2vec_model_path,\n        False,\n        os.path.dirname(audio_separator_model_file),\n        os.path.basename(audio_separator_model_file),\n        os.path.join(output_dir, \"vocals\"),\n    ) if step==2 else None\n\n    image_processor = ImageProcessorForDataProcessing(\n        face_analysis_model_path, landmark_model_path, step)\n\n    for video_path in tqdm(input_video_list, desc=\"Processing videos\"):\n        process_single_video(video_path, output_dir,\n                             image_processor, audio_processor, step)", "label": 0}
{"function": "def fast_check_ffmpeg():\n    try:\n        subprocess.run([\"ffmpeg\", \"-version\"], capture_output=True, check=True)\n        return True\n    except:\n        return False", "label": 0}
{"function": "async def test_openrouter_error_propagation(monkeypatch):\n    class DummyAPIError(Exception):\n        pass\n\n    settings = Settings(\n        ENABLE_OPENROUTER=True,\n        OPENROUTER_API_KEY=\"key\",\n        OPENROUTER_MODEL=\"test-model\",\n        LLM_KEY=\"OPENROUTER\",\n    )\n    SettingsManager.set_settings(settings)\n    importlib.reload(config_registry)\n\n    monkeypatch.setattr(app, \"ARTIFACT_MANAGER\", DummyArtifactManager())\n\n    async def _raise(*args, **kwargs):\n        raise DummyAPIError()\n\n    fake_litellm = types.SimpleNamespace(\n        acompletion=_raise,\n        exceptions=types.SimpleNamespace(APIError=DummyAPIError),\n    )\n    monkeypatch.setattr(api_handler_factory, \"litellm\", fake_litellm)\n\n    handler = api_handler_factory.LLMAPIHandlerFactory.get_llm_api_handler(\"OPENROUTER\")\n    with pytest.raises(api_handler_factory.LLMProviderErrorRetryableTask):\n        await handler(\"hi\", \"test\")", "label": 0}
{"function": "    def get_parent(self):\n        \"\"\"\n        Returns the parent node of the current node.\n\n        Returns:\n            KnowledgeNode: The parent node of the current node.\n        \"\"\"\n        return self.parent", "label": 0}
{"function": "    def valCollectionMetaData(self, obj):\n        \"\"\"Function to add CollectionMetaData\n\n        :param obj: element to add CollectionMetaData\n        \"\"\"\n        values = []\n        for i in self.parModis:\n            values.append(i.retCollectionMetaData())\n        self._cicle_values(obj, self._checkvaldict(values))", "label": 1}
{"function": "def test_mammals():\n  \"\"\"Test module mammals.py by downloading\n   mammals.csv and testing shape of\n   extracted data has 62 rows and 2 columns\n  \"\"\"\n  test_path = tempfile.mkdtemp()\n  x_train, metadata = mammals(test_path)\n  try:\n    assert x_train.shape == (62, 2)\n  except:\n    shutil.rmtree(test_path)\n    raise()", "label": 1}
{"function": "def get_processes():\n  tasklist = subprocess.Popen(\"tasklist.exe /fo csv\", stdout=subprocess.PIPE, universal_newlines=True)\n  tasklist = tasklist.stdout.read()\n  tasklist = tasklist.split(\"\\n\")\n  tasklist = list(map(lambda x: x.split(\",\")[0][1:-1].lower(), tasklist))\n  tasklist = list(filter(lambda x: x[-4:] == \".exe\", tasklist))\n  return tasklist", "label": 1}
{"function": "  async def _run_async_impl(self, invocation_context):\n    yield Event(\n        invocation_id=invocation_context.invocation_id,\n        author=self.name,\n        content=types.Content(\n            role=\"model\", parts=[types.Part(text=\"Test response\")]\n        ),\n    )", "label": 0}
{"function": "async def client_with_handler() -> AsyncIterator[ClientWithHandler]:\n    client: httpx.AsyncClient | None = None\n\n    def create_client(handler: Callable[[httpx.Request], httpx.Response]) -> httpx.AsyncClient:\n        nonlocal client\n        assert client is None, 'client_with_handler can only be called once'\n        client = httpx.AsyncClient(mounts={'all://': httpx.MockTransport(handler)})\n        return client\n\n    try:\n        yield create_client\n    finally:\n        if client:  # pragma: no branch\n            await client.aclose()", "label": 0}
{"function": "def login_post():\n    return {}", "label": 1}
{"function": "    def write(self, buf):\n        temp_linebuf = self.linebuf + buf\n        self.linebuf = ''\n        for line in temp_linebuf.splitlines(True):\n            # From the io.TextIOWrapper docs:\n            #   On output, if newline is None, any '\\n' characters written\n            #   are translated to the system default line separator.\n            # By default sys.stdout.write() expects '\\n' newlines and then\n            # translates them so this is still cross platform.\n            if line[-1] == '\\n':\n                self.logger.log(self.log_level, line.rstrip())\n            else:\n                self.linebuf += line", "label": 0}
{"function": "    def forward(self, z):\n        shift_z = z - np.max(z, axis=1, keepdims=True)\n        exp_z = np.exp(shift_z)\n        a = exp_z / np.sum(exp_z, axis=1, keepdims=True)\n        return a", "label": 1}
{"function": "    def __init__(self, *args, **kwargs):\n        super(FormForm, self).__init__(*args, **kwargs)\n\n        if not self.user.profile.is_superuser:\n            if 'status_detail' in self.fields:\n                self.fields.pop('status_detail')", "label": 1}
{"function": "    def chat(self, input):\n        try:\n            image = Image.open(io.BytesIO(base64.b64decode(input['image']))).convert('RGB')\n        except Exception as e:\n            return \"Image decode error\"\n\n        msgs = json.loads(input['question'])\n        input_ids = wrap_question_for_omni_lmm(\n            msgs, self.image_token_len, self.tokenizer)['input_ids']\n        input_ids = torch.as_tensor(input_ids)\n        #print('input_ids', input_ids)\n        image = self.image_transform(image)\n\n        out = self.decode(image, input_ids)\n\n        return out", "label": 0}
{"function": "\tdef testCheckIPGenerator(self):\n\t\tfor i, ip in self._ip_range(65536 if not unittest.F2B.fast else 1000):\n\t\t\tif i == 254:\n\t\t\t\tself.assertEqual(str(ip), '127.0.0.255')\n\t\t\telif i == 255:\n\t\t\t\tself.assertEqual(str(ip), '127.0.1.0')\n\t\t\telif i == 1000:\n\t\t\t\tself.assertEqual(str(ip), '127.0.3.233')\n\t\t\telif i == 65534:\n\t\t\t\tself.assertEqual(str(ip), '127.0.255.255')\n\t\t\telif i == 65535:\n\t\t\t\tself.assertEqual(str(ip), '127.1.0.0')", "label": 1}
{"function": "async def test_desktop(monkeypatch):\n    \"\"\"Test the desktop server\"\"\"\n    from pathlib import Path\n\n    from pydantic import AnyUrl\n\n    from examples.fastmcp.desktop import mcp\n\n    # Mock desktop directory listing\n    mock_files = [Path(\"/fake/path/file1.txt\"), Path(\"/fake/path/file2.txt\")]\n    monkeypatch.setattr(Path, \"iterdir\", lambda self: mock_files)\n    monkeypatch.setattr(Path, \"home\", lambda: Path(\"/fake/home\"))\n\n    async with client_session(mcp._mcp_server) as client:\n        # Test the sum function\n        result = await client.call_tool(\"sum\", {\"a\": 1, \"b\": 2})\n        assert len(result.content) == 1\n        content = result.content[0]\n        assert isinstance(content, TextContent)\n        assert content.text == \"3\"\n\n        # Test the desktop resource\n        result = await client.read_resource(AnyUrl(\"dir://desktop\"))\n        assert len(result.contents) == 1\n        content = result.contents[0]\n        assert isinstance(content, TextResourceContents)\n        assert isinstance(content.text, str)\n        if sys.platform == \"win32\":\n            file_1 = \"/fake/path/file1.txt\".replace(\"/\", \"\\\\\\\\\")  # might be a bug\n            file_2 = \"/fake/path/file2.txt\".replace(\"/\", \"\\\\\\\\\")  # might be a bug\n            assert file_1 in content.text\n            assert file_2 in content.text\n            # might be a bug, but the test is passing\n        else:\n            assert \"/fake/path/file1.txt\" in content.text\n            assert \"/fake/path/file2.txt\" in content.text", "label": 0}
{"function": "    def __iter__(self):\n        for _ in range(self._retry_count):\n            try:\n                db.session.rollback()\n                return super().__iter__()\n            except OperationalError:\n                app.logger.warning(\"Retrying to reach database...\")\n                time.sleep(self._retry_sleep_interval_sec)\n\n        app.logger.critical(\"Database couldn't be reached.\")\n        raise DatabaseNotReachable", "label": 1}
{"function": "def gen_prompt(question,content_list, lang=\"zh-CN\", context_length_limit=11000,debug=False):\n    \n    limit_len = (context_length_limit - 2000)\n    if len(question) > limit_len:\n        question = question[0:limit_len]\n    \n    ref_content = [ item.get(\"content\") for item in content_list]\n    \n    answer_language = ' Simplified Chinese '\n    if lang == \"zh-CN\":\n        answer_language = ' Simplified Chinese '\n    if lang == \"zh-TW\":\n        answer_language = ' Traditional Chinese '\n    if lang == \"en-US\":\n        answer_language = ' English '\n\n\n    if len(ref_content) > 0:\n        \n        if False:\n            prompts = '''\n            \u60a8\u662f\u4e00\u4f4d\u7531 nash_su \u5f00\u53d1\u7684\u5927\u578b\u8bed\u8a00\u4eba\u5de5\u667a\u80fd\u52a9\u624b\u3002\u60a8\u5c06\u88ab\u63d0\u4f9b\u4e00\u4e2a\u7528\u6237\u95ee\u9898\uff0c\u5e76\u9700\u8981\u64b0\u5199\u4e00\u4e2a\u6e05\u6670\u3001\u7b80\u6d01\u4e14\u51c6\u786e\u7684\u7b54\u6848\u3002\u63d0\u4f9b\u4e86\u4e00\u7ec4\u4e0e\u95ee\u9898\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\uff0c\u6bcf\u4e2a\u90fd\u4ee5[[citation:x]]\u8fd9\u6837\u7684\u7f16\u53f7\u5f00\u5934\uff0cx\u4ee3\u8868\u4e00\u4e2a\u6570\u5b57\u3002\u8bf7\u5728\u9002\u5f53\u7684\u60c5\u51b5\u4e0b\u5728\u53e5\u5b50\u672b\u5c3e\u5f15\u7528\u4e0a\u4e0b\u6587\u3002\u7b54\u6848\u5fc5\u987b\u6b63\u786e\u3001\u7cbe\u786e\uff0c\u5e76\u4ee5\u4e13\u5bb6\u7684\u4e2d\u7acb\u548c\u804c\u4e1a\u8bed\u6c14\u64b0\u5199\u3002\u8bf7\u5c06\u7b54\u6848\u9650\u5236\u57282000\u4e2a\u6807\u8bb0\u5185\u3002\u4e0d\u8981\u63d0\u4f9b\u4e0e\u95ee\u9898\u65e0\u5173\u7684\u4fe1\u606f\uff0c\u4e5f\u4e0d\u8981\u91cd\u590d\u3002\u5982\u679c\u7ed9\u51fa\u7684\u4e0a\u4e0b\u6587\u4fe1\u606f\u4e0d\u8db3\uff0c\u8bf7\u5728\u76f8\u5173\u4e3b\u9898\u540e\u5199\u4e0a\u201c\u4fe1\u606f\u7f3a\u5931\uff1a\u201d\u3002\u8bf7\u6309\u7167\u5f15\u7528\u7f16\u53f7[citation:x]\u7684\u683c\u5f0f\u5728\u7b54\u6848\u4e2d\u5bf9\u5e94\u90e8\u5206\u5f15\u7528\u4e0a\u4e0b\u6587\u3002\u5982\u679c\u4e00\u53e5\u8bdd\u6e90\u81ea\u591a\u4e2a\u4e0a\u4e0b\u6587\uff0c\u8bf7\u5217\u51fa\u6240\u6709\u76f8\u5173\u7684\u5f15\u7528\u7f16\u53f7\uff0c\u4f8b\u5982[citation:3][citation:5]\uff0c\u4e0d\u8981\u5c06\u5f15\u7528\u96c6\u4e2d\u5728\u6700\u540e\u8fd4\u56de\uff0c\u800c\u662f\u5728\u7b54\u6848\u5bf9\u5e94\u90e8\u5206\u5217\u51fa\u3002\u9664\u975e\u662f\u4ee3\u7801\u3001\u7279\u5b9a\u7684\u540d\u79f0\u6216\u5f15\u7528\u7f16\u53f7\uff0c\u7b54\u6848\u7684\u8bed\u8a00\u5e94\u4e0e\u95ee\u9898\u76f8\u540c\u3002\u4ee5\u4e0b\u662f\u4e0a\u4e0b\u6587\u7684\u5185\u5bb9\u96c6\uff1a\n            '''  + \"\\n\\n\" + \"```\" \n            ref_index = 1\n\n            for ref_text in ref_content:\n                \n                prompts = prompts + \"\\n\\n\" + \" [citation:{}]  \".format(str(ref_index)) +  ref_text\n                ref_index += 1\n\n            if len(prompts) >= limit_len:\n                prompts = prompts[0:limit_len]        \n            prompts = prompts + '''\n    ```\n    \u8bb0\u4f4f\uff0c\u4e0d\u8981\u4e00\u5b57\u4e0d\u5dee\u7684\u91cd\u590d\u4e0a\u4e0b\u6587\u5185\u5bb9. \u56de\u7b54\u5fc5\u987b\u4f7f\u7528\u7b80\u4f53\u4e2d\u6587\uff0c\u5982\u679c\u56de\u7b54\u5f88\u957f\uff0c\u8bf7\u5c3d\u91cf\u7ed3\u6784\u5316\u3001\u5206\u6bb5\u843d\u603b\u7ed3\u3002\u8bf7\u6309\u7167\u5f15\u7528\u7f16\u53f7[citation:x]\u7684\u683c\u5f0f\u5728\u7b54\u6848\u4e2d\u5bf9\u5e94\u90e8\u5206\u5f15\u7528\u4e0a\u4e0b\u6587\u3002\u5982\u679c\u4e00\u53e5\u8bdd\u6e90\u81ea\u591a\u4e2a\u4e0a\u4e0b\u6587\uff0c\u8bf7\u5217\u51fa\u6240\u6709\u76f8\u5173\u7684\u5f15\u7528\u7f16\u53f7\uff0c\u4f8b\u5982[citation:3][citation:5]\uff0c\u4e0d\u8981\u5c06\u5f15\u7528\u96c6\u4e2d\u5728\u6700\u540e\u8fd4\u56de\uff0c\u800c\u662f\u5728\u7b54\u6848\u5bf9\u5e94\u90e8\u5206\u5217\u51fa\u3002\u4e0b\u9762\u662f\u7528\u6237\u95ee\u9898\uff1a\n    ''' + question  \n        else:\n            prompts = '''\n            You are a large language AI assistant develop by nash_su. You are given a user question, and please write clean, concise and accurate answer to the question. You will be given a set of related contexts to the question, each starting with a reference number like [[citation:x]], where x is a number. Please use the context and cite the context at the end of each sentence if applicable.\n            Your answer must be correct, accurate and written by an expert using an unbiased and professional tone. Please limit to 1024 tokens. Do not give any information that is not related to the question, and do not repeat. Say \"information is missing on\" followed by the related topic, if the given context do not provide sufficient information.\n\n            Please cite the contexts with the reference numbers, in the format [citation:x]. If a sentence comes from multiple contexts, please list all applicable citations, like [citation:3][citation:5]. Other than code and specific names and citations, your answer must be written in the same language as the question.\n            Here are the set of contexts:\n            '''  + \"\\n\\n\" + \"```\" \n            ref_index = 1\n\n            for ref_text in ref_content:\n                \n                prompts = prompts + \"\\n\\n\" + \" [citation:{}]  \".format(str(ref_index)) +  ref_text\n                ref_index += 1\n\n            if len(prompts) >= limit_len:\n                prompts = prompts[0:limit_len]        \n            prompts = prompts + '''\n            ```\n            Above is the reference contexts. Remember, don't repeat the context word for word. Answer in ''' + answer_language + '''. If the response is lengthy, structure it in paragraphs and summarize where possible. Cite the context using the format [citation:x] where x is the reference number. If a sentence originates from multiple contexts, list all relevant citation numbers, like [citation:3][citation:5]. Don't cluster the citations at the end but include them in the answer where they correspond.\n            Remember, don't blindly repeat the contexts verbatim. And here is the user question:\n            ''' + question  \n \n     \n    else:\n        prompts = question\n\n    if debug:\n        print(prompts)\n        print(\"\u603b\u957f\u5ea6\uff1a\"+ str(len(prompts)))\n    return prompts", "label": 0}
{"function": "    def test_atomic_max_double_shared(self):\n        vals = np.random.randint(0, 32, size=32).astype(np.float64)\n        res = np.zeros(1, np.float64)\n        cuda_func = cuda.jit('void(float64[:], float64[:])')(atomic_max_double_shared)\n        cuda_func[1, 32](res, vals)\n\n        gold = np.max(vals)\n        np.testing.assert_equal(res, gold)", "label": 1}
{"function": "    def name(self):\n        \"\"\"Return the name of the climate device.\"\"\"\n        return self._name", "label": 1}
{"function": "def tr(key):\n    loc = locales.get(st.session_state[\"ui_language\"], {})\n    return loc.get(\"Translation\", {}).get(key, key)", "label": 0}
{"function": "  def _define_vars(self, params):\n    pass", "label": 1}
{"function": "async def health_check():\n    logger.info(\"Health check endpoint called\")\n    return {\"status\": \"healthy\", \"version\": \"0.1.0\"}", "label": 0}
{"function": "def init_session_state():\n    defaults = {\n        \"initialized\": False,\n        \"qdrant_url\": \"\",\n        \"qdrant_api_key\": \"\",\n        \"firecrawl_api_key\": \"\",\n        \"openai_api_key\": \"\",\n        \"doc_url\": \"\",\n        \"setup_complete\": False,\n        \"client\": None,\n        \"embedding_model\": None,\n        \"processor_agent\": None,\n        \"tts_agent\": None,\n        \"selected_voice\": \"coral\"\n    }\n    \n    for key, value in defaults.items():\n        if key not in st.session_state:\n            st.session_state[key] = value", "label": 0}
{"function": "    def setUp(self):\n        super().setUp()\n\n        self.thread = test.post_thread(self.category, poster=self.user)\n        self.api_link = self.thread.get_api_url()\n\n        self.other_user = create_test_user(\"OtherUser\", \"otheruser@example.com\")", "label": 1}
{"function": "    def end_at(self, key=None, **kwargs):\n        \"\"\"End document at this point\"\"\"\n        if key:\n            self._end_at = self._firestore_doc(key)\n        else:\n            self._end_at = self._fields_by_column_name(**kwargs)\n        return self", "label": 1}
{"function": "def get_model_name():\n    if args.hf_repo:\n        return SUPPORTED_HF_MODELS[args.hf_repo][\"model_name\"]\n    return os.path.basename(os.path.normpath(args.model_dir))", "label": 0}
{"function": "    def voice_clone(text, prompt_text, prompt_wav_upload, prompt_wav_record):\n        \"\"\"\n        Gradio callback to clone voice using text and optional prompt speech.\n        - text: The input text to be synthesised.\n        - prompt_text: Additional textual info for the prompt (optional).\n        - prompt_wav_upload/prompt_wav_record: Audio files used as reference.\n        \"\"\"\n        prompt_speech = prompt_wav_upload if prompt_wav_upload else prompt_wav_record\n        prompt_text_clean = None if len(prompt_text) < 2 else prompt_text\n\n        audio_output_path = run_tts(\n            text,\n            model,\n            prompt_text=prompt_text_clean,\n            prompt_speech=prompt_speech\n        )\n        return audio_output_path", "label": 0}
{"function": "def train_sft():\n    \"\"\"Fine-tune the model using prepared datasets.\"\"\"\n    from weclone.train.train_sft import main as train_sft_main\n\n    train_sft_main()", "label": 0}
{"function": "def _add_gpu_requires():\n  global install_requires\n  # Add Nvidia-GPU\n  try:\n    out = subprocess.run(['nvidia-smi', '--query-gpu=name', '--format=csv,noheader'], shell=True, text=True, capture_output=True, check=False)\n    if out.returncode == 0:\n      install_requires.extend(extras_require[\"nvidia-gpu\"])\n  except subprocess.CalledProcessError:\n    pass\n\n  # Add AMD-GPU\n  # This will mostly work only on Linux, amd/rocm-smi is not yet supported on Windows\n  try:\n    out = subprocess.run(['amd-smi', 'list', '--csv'], shell=True, text=True, capture_output=True, check=False)\n    if out.returncode == 0:\n      install_requires.extend(extras_require[\"amd-gpu\"])\n  except:\n    out = subprocess.run(['rocm-smi', 'list', '--csv'], shell=True, text=True, capture_output=True, check=False)\n    if out.returncode == 0:\n      install_requires.extend(extras_require[\"amd-gpu\"])\n  finally:\n    pass", "label": 0}
{"function": "    def consumer(self, partition_id):\n        c = Consumer(self._location, self._enable_ssl, self._cert_path, self._topic, self._general_group, partition_id)\n        assert len(c._consumer.partitions_for_topic(self._topic)) == self._partitions, \\\n            \"Number of kafka topic partitions doesn't match value in config for spider feed\"\n        return c", "label": 1}
{"function": "def missing_annotation_tool(location, unit=\"Celsius\"):\n    \"\"\"Tool function without type annotations.\"\"\"\n    return {\"location\": location, \"unit\": unit, \"temperature\": \"72\"}", "label": 0}
{"function": "def single_turn_conversation():\n    return Conversation(\n        messages=[\n            Message(role=Role.USER, content=\"Hello\"),\n            Message(role=Role.ASSISTANT, content=\"Hi there!\"),\n        ]\n    )", "label": 0}
{"function": "def browser_snapshot():\n    snapshot_path = request.args.get(\"snapshot_path\")\n    return send_file(snapshot_path, as_attachment=True)", "label": 0}
{"function": "    def handle_connect(self):\n        pass", "label": 1}
{"function": "    def test_params_distinction(self):\n        \"\"\"Test that cache distinguishes between different engine parameters\"\"\"\n        params1 = {\"param\": \"value1\"}\n        params2 = {\"param\": \"value2\"}\n        cache1 = cache.TranslationCache(\"test_engine\", params1)\n        cache2 = cache.TranslationCache(\"test_engine\", params2)\n\n        # Set same text with different parameters\n        cache1.set(\"hello\", \"\u4f60\u597d 1\")\n        cache2.set(\"hello\", \"\u4f60\u597d 2\")\n\n        # Verify each parameter set gets its own translation\n        self.assertEqual(cache1.get(\"hello\"), \"\u4f60\u597d 1\")\n        self.assertEqual(cache2.get(\"hello\"), \"\u4f60\u597d 2\")", "label": 0}
{"function": "    def test_keypath_separator_getter_setter(self):\n        d = KeypathDict({}, keypath_separator=None)\n        self.assertEqual(d.keypath_separator, None)\n        d['a.b.c'] = 1\n        with self.assertRaises(ValueError):\n            d.keypath_separator = '.'\n        d.keypath_separator = '/'\n        self.assertEqual(d.keypath_separator, '/')\n        d['x/y/z'] = 2\n        r = {\n            'a.b.c': 1,\n            'x': {\n                'y': {\n                    'z': 2,\n                },\n            },\n        }\n        self.assertEqual(d, r)", "label": 1}
{"function": "def test_list_max(list_input: list, target_num) -> None:\n    \"\"\"\n    list_input: \u8f93\u5165\u5217\u8868\u5143\u7d20\uff0c\u5143\u7d20\u5747\u4e3a\u6570\u5b57\u7c7b\u578b\n    \"\"\"\n    assert target_num == mymax(list_input)", "label": 0}
{"function": "def delete_file(path):\n    \"\"\"delete file.\"\"\"\n    if not os.path.exists(path):\n        if os.path.isfile(path):\n            try:\n                os.remove(path)\n                print(f\"File '{path}' deleted.\")\n            except TypeError as e:\n                print(f\"Error deleting file '{path}': {e}\")\n    elif os.path.isdir(path):\n        try:\n            shutil.rmtree(path)\n            print(f\"Directory '{path}' and its contents deleted.\")\n        except TypeError as e:\n            print(f\"Error deleting directory '{path}': {e}\")", "label": 0}
{"function": "    def test_format_reward_incorrect(self):\n        \"\"\"Test format_reward with incorrect format.\"\"\"\n        incorrect_formats = [\n            \"<think>Only thinking</think>\",\n            \"<answer>Only answer</answer>\",\n            \"No tags at all\",\n            \"<think>Missing closing</think><answer>Missing closing\",\n            \"<think>Wrong order</answer><answer>Wrong order</think>\",\n        ]\n\n        for fmt in incorrect_formats:\n            completion = [[{\"content\": fmt}]]\n            rewards = format_reward(completion)\n            self.assertEqual(rewards[0], 0.0)", "label": 0}
{"function": "def automatically_move_to_gpu_when_forward(m: torch.nn.Module, target_model: torch.nn.Module = None):\n    if target_model is None:\n        target_model = m\n\n    def patch_method(method_name):\n        if not hasattr(m, method_name):\n            return\n\n        if not hasattr(m, 'forge_space_hooked_names'):\n            m.forge_space_hooked_names = []\n\n        if method_name in m.forge_space_hooked_names:\n            print(f'Already hooked {type(m).__name__}.{method_name}')\n            return\n\n        print(f'Automatic hook: {type(m).__name__}.{method_name}')\n\n        original_method = getattr(m, method_name)\n\n        def patched_method(*args, **kwargs):\n            load_module(target_model)\n            return original_method(*args, **kwargs)\n\n        setattr(m, method_name, patched_method)\n\n        m.forge_space_hooked_names.append(method_name)\n        return\n\n    for method_name in ['forward', 'encode', 'decode']:\n        patch_method(method_name)\n\n    return", "label": 0}
{"function": "    def test_1d_slicing4_npm(self):\n        self.test_1d_slicing4(flags=Noflags)", "label": 1}
{"function": "    def _call(api, *args, **kwargs):\n        method = WeixinAPIMethod(api, *args, **kwargs)\n        return method.execute()", "label": 1}
{"function": "  def _TestConnectivity(self):\n    with open(os.devnull, 'wb') as devnull:\n      return subprocess.call(['ping', '-q', '-c1', '-W1', self._device_ip],\n                             stdout=devnull) == 0", "label": 1}
{"function": "    def call(self, user_question, temperature=0.3, prompt_version=\"kimi\", **kwargs):\n\n        completion = self.client.chat.completions.create(\n            model=self.model,\n            messages=prompt_dict[prompt_version]\n            + [\n                {\"role\": \"user\", \"content\": user_question},\n            ],\n            temperature=temperature,\n            **kwargs\n        )\n        return completion.choices[0].message.content", "label": 0}
{"function": "    def fold(self, **_3to2kwargs):\n        policy = _3to2kwargs['policy']; del _3to2kwargs['policy']\n        \"\"\"Fold header according to policy.\n\n        The parsed representation of the header is folded according to\n        RFC5322 rules, as modified by the policy.  If the parse tree\n        contains surrogateescaped bytes, the bytes are CTE encoded using\n        the charset 'unknown-8bit\".\n\n        Any non-ASCII characters in the parse tree are CTE encoded using\n        charset utf-8. XXX: make this a policy setting.\n\n        The returned value is an ASCII-only string possibly containing linesep\n        characters, and ending with a linesep character.  The string includes\n        the header name and the ': ' separator.\n\n        \"\"\"\n        # At some point we need to only put fws here if it was in the source.\n        header = parser.Header([\n            parser.HeaderLabel([\n                parser.ValueTerminal(self.name, 'header-name'),\n                parser.ValueTerminal(':', 'header-sep')]),\n            parser.CFWSList([parser.WhiteSpaceTerminal(' ', 'fws')]),\n                             self._parse_tree])\n        return header.fold(policy=policy)", "label": 1}
{"function": "    def patch(self, api_link, ops):\n        return self.client.patch(\n            api_link, json.dumps(ops), content_type=\"application/json\"\n        )", "label": 1}
{"function": "    def get_or_create_endpoint(self, path=None, description=None, workspace=None, id=None):\n        \"\"\"\n        Attaches an endpoint to this Client.\n\n        If an accessible endpoint with name `path` does not already exist, it will be created\n        and initialized with specified metadata parameters. If such an endpoint does already exist,\n        it will be retrieved; specifying metadata parameters in this case will raise an exception.\n\n        Parameters\n        ----------\n        path : str, optional\n            Path for the endpoint.\n        description : str, optional\n            Description of the endpoint.\n        workspace : str, optional\n            Workspace under which the endpoint with name `name` exists. If not provided, the current\n            user's personal workspace will be used.\n        id : str, optional\n            ID of the endpoint. This parameter cannot be provided alongside `name`, and other\n            parameters will be ignored.\n\n        Returns\n        -------\n        :class:`~verta.endpoint._endpoint.Endpoint`\n\n        Raises\n        ------\n        ValueError\n            If an endpoint with `path` already exists, but metadata parameters are passed in.\n\n        \"\"\"\n        if path is not None and id is not None:\n            raise ValueError(\"cannot specify both `path` and `id`\")\n        if path is None and id is None:\n            raise ValueError(\"must specify either `path` or `id`\")\n\n        workspace = self._set_from_config_if_none(workspace, \"workspace\")\n        if workspace is None:\n            workspace = self._get_personal_workspace()\n        if id is not None:\n            return Endpoint._get_by_id(self._conn, self._conf, workspace, id)\n        else:\n            return Endpoint._get_or_create_by_name(self._conn, path,\n                                            lambda name: Endpoint._get_by_path(self._conn, self._conf, workspace, path),\n                                            lambda name: Endpoint._create( self._conn, self._conf, workspace, path, description))", "label": 1}
{"function": "def _get_content_from_fragment(block, user_id, course, request_factory, mock_get_current_request):\n    \"\"\"\n    Returns the content from the rendered fragment of a block\n    Arguments:\n        block: some sort of xblock descriptor, must implement .scope_ids.usage_id\n        user_id (int): id of user\n        course_id (CourseLocator): id of course\n    \"\"\"\n    fake_request = request_factory.get('')\n    mock_get_current_request.return_value = fake_request\n\n    # Load a block we know will pass access control checks\n    block = load_single_xblock(\n        request=fake_request,\n        user_id=user_id,\n        course_id=six.text_type(course.id),\n        usage_key_string=six.text_type(block.scope_ids.usage_id),\n        course=course,\n        will_recheck_access=True,\n    )\n    # Attempt to render the block, this should return different fragments if the content is gated or not.\n    frag = block.render('student_view')\n    return frag.content", "label": 1}
{"function": "def is_agent_active():\n    data = request.json\n    project_name = data.get(\"project_name\")\n    is_active = AgentState.is_agent_active(project_name)\n    return jsonify({\"is_active\": is_active})", "label": 0}
{"function": "def c2s_bra(l, gcart):\n    if l == 0:\n        return gcart * 0.282094791773878143\n    elif l == 1:\n        return gcart * 0.488602511902919921\n    else:\n        m = gcart.shape[1]\n        gsph = numpy.empty((l*2+1,m))\n        fc2s = gto.moleintor.libcgto.CINTc2s_ket_sph\n        fc2s(gsph.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(m),\n             gcart.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(l))\n        return gsph", "label": 1}
{"function": "def save_yaml_file(yaml_file: str, data: dict) -> None:\n    with open(yaml_file, 'w', encoding='utf-8') as file:\n        yaml.safe_dump(\n            data=data, stream=file, allow_unicode=True)", "label": 0}
{"function": "    def test_normal_success_requests(self, mock_get, mock_sleep):\n        \"\"\"Test that successful requests return immediately without retry.\"\"\"\n        # Setup mock response: 200 success\n        mock_200_response = Mock()\n        mock_200_response.status_code = 200\n        mock_200_response.text = \"Success\"\n        \n        mock_get.return_value = mock_200_response\n        \n        # Call the function\n        headers = {\"X-API-KEY\": \"test-key\"}\n        url = \"https://api.financialdatasets.ai/test\"\n        \n        result = _make_api_request(url, headers)\n        \n        # Verify behavior\n        assert result.status_code == 200\n        assert result.text == \"Success\"\n        \n        # Verify requests.get was called only once\n        assert mock_get.call_count == 1\n        \n        # Verify sleep was never called\n        mock_sleep.assert_not_called()", "label": 0}
{"function": "  def get_state_transition(self):\n    return [[1., 1.],  # Add slope to level\n            [0., 1.]]  # Maintain slope", "label": 1}
{"function": "    def __init__(\n        self,\n        config,\n        checkpoint_dir,\n        device_id=0,\n        rank=0,\n        t5_fsdp=False,\n        dit_fsdp=False,\n        use_usp=False,\n        t5_cpu=False,\n        init_on_cpu=True,\n    ):\n        r\"\"\"\n        Initializes the image-to-video generation model components.\n\n        Args:\n            config (EasyDict):\n                Object containing model parameters initialized from config.py\n            checkpoint_dir (`str`):\n                Path to directory containing model checkpoints\n            device_id (`int`,  *optional*, defaults to 0):\n                Id of target GPU device\n            rank (`int`,  *optional*, defaults to 0):\n                Process rank for distributed training\n            t5_fsdp (`bool`, *optional*, defaults to False):\n                Enable FSDP sharding for T5 model\n            dit_fsdp (`bool`, *optional*, defaults to False):\n                Enable FSDP sharding for DiT model\n            use_usp (`bool`, *optional*, defaults to False):\n                Enable distribution strategy of USP.\n            t5_cpu (`bool`, *optional*, defaults to False):\n                Whether to place T5 model on CPU. Only works without t5_fsdp.\n            init_on_cpu (`bool`, *optional*, defaults to True):\n                Enable initializing Transformer Model on CPU. Only works without FSDP or USP.\n        \"\"\"\n        self.device = torch.device(f\"cuda:{device_id}\")\n        self.config = config\n        self.rank = rank\n        self.use_usp = use_usp\n        self.t5_cpu = t5_cpu\n\n        self.num_train_timesteps = config.num_train_timesteps\n        self.param_dtype = config.param_dtype\n\n        shard_fn = partial(shard_model, device_id=device_id)\n        self.text_encoder = T5EncoderModel(\n            text_len=config.text_len,\n            dtype=config.t5_dtype,\n            device=torch.device('cpu'),\n            checkpoint_path=os.path.join(checkpoint_dir, config.t5_checkpoint),\n            tokenizer_path=os.path.join(checkpoint_dir, config.t5_tokenizer),\n            shard_fn=shard_fn if t5_fsdp else None,\n        )\n\n        self.vae_stride = config.vae_stride\n        self.patch_size = config.patch_size\n        self.vae = WanVAE(\n            vae_pth=os.path.join(checkpoint_dir, config.vae_checkpoint),\n            device=self.device)\n\n        self.clip = CLIPModel(\n            dtype=config.clip_dtype,\n            device=self.device,\n            checkpoint_path=os.path.join(checkpoint_dir,\n                                         config.clip_checkpoint),\n            tokenizer_path=os.path.join(checkpoint_dir, config.clip_tokenizer))\n\n        logging.info(f\"Creating WanModel from {checkpoint_dir}\")\n        self.model = WanModel.from_pretrained(checkpoint_dir)\n        self.model.eval().requires_grad_(False)\n\n        if t5_fsdp or dit_fsdp or use_usp:\n            init_on_cpu = False\n\n        if use_usp:\n            from xfuser.core.distributed import get_sequence_parallel_world_size\n\n            from .distributed.xdit_context_parallel import (\n                usp_attn_forward,\n                usp_dit_forward,\n            )\n            for block in self.model.blocks:\n                block.self_attn.forward = types.MethodType(\n                    usp_attn_forward, block.self_attn)\n            self.model.forward = types.MethodType(usp_dit_forward, self.model)\n            self.sp_size = get_sequence_parallel_world_size()\n        else:\n            self.sp_size = 1\n\n        if dist.is_initialized():\n            dist.barrier()\n        if dit_fsdp:\n            self.model = shard_fn(self.model)\n        else:\n            if not init_on_cpu:\n                self.model.to(self.device)\n\n        self.sample_neg_prompt = config.sample_neg_prompt", "label": 0}
{"function": "    def test_string_wrap(self):\n        self.check_func(lambda x: x.str.wrap(5))\n        self.check_func(lambda x: x.str.wrap(5, expand_tabs=False))\n        self.check_func(lambda x: x.str.wrap(5, replace_whitespace=False))\n        self.check_func(lambda x: x.str.wrap(5, drop_whitespace=False))\n        self.check_func(lambda x: x.str.wrap(5, break_long_words=False))\n        self.check_func(lambda x: x.str.wrap(5, break_on_hyphens=False))", "label": 1}
{"function": "def get_csv_path(name: str):\n    # Return the matching CSV file path\n    return Path(f\"./tests/data/csv/{name}.csv\")", "label": 0}
{"function": "def _whats_your_name():\n    return 'ping'", "label": 1}
{"function": "def _support_ipv6():\n    return True", "label": 1}
{"function": "    def format(self, record: logging.LogRecord):\n        logstr = \"[\" + datetime.now(self.tz).strftime(\"%z %Y%m%d %H:%M:%S\") + \"] [\"\n        if self.color:\n            logstr += log_level_color_code.get(record.levelno, colorCodeInfo)\n        logstr += log_level_msg_str.get(record.levelno, record.levelname)\n        if self.color:\n            logstr += colorReset\n        if sys.version_info >= (3, 9):\n            fn = record.filename.removesuffix(\".py\")\n        elif record.filename.endswith(\".py\"):\n            fn = record.filename[:-3]\n        logstr += f\"] {str(record.name)} | {fn} | {str(record.msg)%record.args}\"\n        return logstr", "label": 0}
{"function": "    def test_multi(self):\n        self.l1.flush()\n        self.c1.flush()\n        self.c2.flush()\n\n        # Subscribe to a pair of channels on c1.\n        for channel in [1111, 2222]:\n            dg = Datagram.create_add_channel(channel)\n            self.c1.send(dg)\n\n        # Subscribe to another pair of channels on c2.\n        for channel in [2222, 3333]:\n            dg = Datagram.create_add_channel(channel)\n            self.c2.send(dg)\n\n        self.l1.flush() # Don't care about the subscribe messages.\n\n        # Sanity check: A datagram on channel 2222 should be delivered to both.\n        dg = Datagram.create([2222], 0, 1234)\n        dg.add_uint32(0xDEADBEEF)\n        self.l1.send(dg)\n        self.expect(self.c1, dg)\n        self.expect(self.c2, dg)\n\n        # A datagram to channels 1111 and 3333 should be delievered to both.\n        dg = Datagram.create([1111, 3333], 0, 1234)\n        dg.add_uint32(0xDEADBEEF)\n        self.l1.send(dg)\n        self.expect(self.c1, dg)\n        self.expect(self.c2, dg)\n\n        # A datagram should only be delivered once if multiple channels match.\n        dg = Datagram.create([1111, 2222], 0, 1234)\n        dg.add_uint32(0xDEADBEEF)\n        self.l1.send(dg)\n        self.expect(self.c1, dg)\n        self.expectNone(self.c1)\n        self.expect(self.c2, dg)\n\n        # Let's try something really absurd:\n        dg = Datagram.create([1111, 2222, 3333, 1111, 1111,\n                              2222, 3333, 3333, 2222], 0, 1234)\n        dg.add_uint32(0xDEADBEEF)\n        self.l1.send(dg)\n        self.expect(self.c1, dg)\n        self.expectNone(self.c1)\n        self.expect(self.c2, dg)\n        self.expectNone(self.c2)\n\n        # And, of course, sending this monstrosity on c1 should result in it\n        # showing up on c2 and l1 once only; no echo back on c1.\n        self.c1.send(dg)\n        self.expect(self.l1, dg)\n        self.expectNone(self.l1)\n        self.expect(self.c2, dg)\n        self.expectNone(self.c2)\n        self.expectNone(self.c1)\n\n        # Unsubscribe the channels...\n        for channel in [1111, 2222, 3333]:\n            dg = Datagram.create_remove_channel(channel)\n            self.c1.send(dg)\n            self.c2.send(dg)", "label": 1}
{"function": "    def _set_property(name, doc=None):\n        def fget(self):\n            def on_update(header_set):\n                if not header_set and name in self.headers:\n                    del self.headers[name]\n                elif header_set:\n                    self.headers[name] = header_set.to_header()\n            return parse_set_header(self.headers.get(name), on_update)\n        def fset(self, value):\n            if not value:\n                del self.headers[name]\n            elif isinstance(value, string_types):\n                self.headers[name] = value\n            else:\n                self.headers[name] = dump_header(value)\n        return property(fget, fset, doc=doc)", "label": 1}
{"function": "    def sys(self):\n        return self.value.sys", "label": 1}
{"function": "def test_version() -> None:\n    result = subprocess.run(\n        [\"python\", \"-m\", \"markitdown\", \"--version\"], capture_output=True, text=True\n    )\n\n    assert result.returncode == 0, f\"CLI exited with error: {result.stderr}\"\n    assert __version__ in result.stdout, f\"Version not found in output: {result.stdout}\"", "label": 0}
{"function": "def unfold_batch_dim(data: 'DataProto', batch_dims=2):\n    \"\"\"\n    Unfold the first n dims as new batch dim\n    \"\"\"\n    tensor: TensorDict = data.batch\n    non_tensor = data.non_tensor_batch\n    tensor.auto_batch_size_(batch_dims=batch_dims)\n    tensor = tensor.view(-1)\n\n    batch_size = tensor.batch_size[0]\n\n    non_tensor_new = {}\n\n    for key, val in non_tensor.items():\n        non_tensor_new[key] = np.reshape(val, newshape=(batch_size, *val.shape[batch_dims:]))\n\n    return DataProto(batch=tensor, non_tensor_batch=non_tensor_new, meta_info=data.meta_info)", "label": 0}
{"function": "    def kv_store(self, kv_store):\n        self._kv_store = kv_store", "label": 1}
{"function": "    def test_repo_clearfilters_interactive(self, shell):\n        \"\"\"\n        Test do_repo_clearfilters interactive.\n\n        :param shell:\n        :return:\n        \"\"\"\n        shell.help_repo_clearfilters = MagicMock()\n        shell.client.channel.software.clearRepoFilters = MagicMock()\n        shell.user_confirm = MagicMock(return_value=True)\n        mprint = MagicMock()\n        logger = MagicMock()\n\n        with patch(\"spacecmd.repo.print\", mprint) as prn, \\\n                patch(\"spacecmd.repo.logging\", logger) as lgr:\n            out = spacecmd.repo.do_repo_clearfilters(shell, \"repo\")\n\n        assert out is 0\n        assert not mprint.called\n        assert not shell.help_repo_clearfilters.called\n        assert not logger.error.called\n        assert shell.client.channel.software.clearRepoFilters.called", "label": 1}
{"function": "    def setup(self):\n        self.connection = Connection(transport=Transport)", "label": 1}
{"function": "    def test_add_tool_with_enum(self):\n        \"\"\"Test adding a tool with an enum parameter.\"\"\"\n        self.tool_manager._add_tool(get_current_temperature_v2, TemperatureParamsV2)\n\n        expected_tool_spec = [\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"get_current_temperature_v2\",\n                    \"description\": \"Gets the current temperature for a specific location and unit (with enum support).\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"location\": {\n                                \"type\": \"string\",\n                                \"description\": \"\",\n                            },\n                            \"unit\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"Celsius\", \"Fahrenheit\"],\n                                \"description\": \"\",\n                                \"default\": \"Celsius\",\n                            },\n                        },\n                        \"required\": [\"location\"],\n                    },\n                },\n            }\n        ]\n\n        tools = self.tool_manager.tools()\n        assert (\n            tools == expected_tool_spec\n        ), f\"Expected {expected_tool_spec}, but got {tools}\"", "label": 0}
{"function": "    def write(self, values):\n        for record in self:\n            vat_values = {\n                'vat': values.get('vat', record.vat),\n                'l10n_latam_identification_type_id': values.get(\n                    'l10n_latam_identification_type_id', record.l10n_latam_identification_type_id.id),\n                'country_id': values.get('country_id', record.country_id.id)\n            }\n            values['vat'] = self._format_vat_cl(vat_values)\n        return super().write(values)", "label": 1}
{"function": "def decode_jpeg_handler(converter: TensorFlowConverter, tf_op: \"tf.Operation\"):\n    raise NotImplementedError(f\"[TensorFlowConverter] {tf_op.type} is not supported yet.\")", "label": 1}
{"function": "    def target_humidity(self):\n        \"\"\"Return the humidity we try to reach.\"\"\"\n        return self._target_humidity", "label": 1}
{"function": "def test_save_load(special_tokens):\n    # take a bit more complex piece of text and train the tokenizer, chosen at random\n    text = llama_text\n    # create a Tokenizer and do 64 merges\n    tokenizer = RegexTokenizer()\n    tokenizer.train(text, 256 + 64)\n    tokenizer.register_special_tokens(special_tokens)\n    # verify that decode(encode(x)) == x\n    assert tokenizer.decode(tokenizer.encode(text, \"all\")) == text\n    # verify that save/load work as expected\n    ids = tokenizer.encode(text, \"all\")\n    # save the tokenizer (TODO use a proper temporary directory)\n    tokenizer.save(\"test_tokenizer_tmp\")\n    # re-load the tokenizer\n    tokenizer = RegexTokenizer()\n    tokenizer.load(\"test_tokenizer_tmp.model\")\n    # verify that decode(encode(x)) == x\n    assert tokenizer.decode(ids) == text\n    assert tokenizer.decode(tokenizer.encode(text, \"all\")) == text\n    assert tokenizer.encode(text, \"all\") == ids\n    # delete the temporary files\n    for file in [\"test_tokenizer_tmp.model\", \"test_tokenizer_tmp.vocab\"]:\n        os.remove(file)", "label": 0}
{"function": "def main():\n    # ======================================================\n    # 1. configs & runtime variables\n    # ======================================================\n    torch.set_grad_enabled(False)\n\n    # == parse configs ==\n    cfg = parse_configs()\n    cfg = parse_alias(cfg)\n\n    # == device and dtype ==\n    device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n    dtype = to_torch_dtype(cfg.get(\"dtype\", \"bf16\"))\n    seed = cfg.get(\"seed\", 1024)\n    if seed is not None:\n        set_seed(seed)\n\n    # == init distributed env ==\n    init_inference_environment()\n    logger = create_logger()\n    logger.info(\"Inference configuration:\\n %s\", pformat(cfg.to_dict()))\n    is_saving_process = get_is_saving_process(cfg)\n    booster = get_booster(cfg)\n    booster_ae = get_booster(cfg, ae=True)\n\n    # ======================================================\n    # 2. build dataset and dataloader\n    # ======================================================\n    logger.info(\"Building dataset...\")\n\n    # save directory\n    save_dir = cfg.save_dir\n    os.makedirs(save_dir, exist_ok=True)\n\n    # == build dataset ==\n    if cfg.get(\"prompt\"):\n        cfg.dataset.data_path = create_tmp_csv(save_dir, cfg.prompt, cfg.get(\"ref\", None), create=is_main_process())\n    dist.barrier()\n    dataset = build_module(cfg.dataset, DATASETS)\n\n    # range selection\n    start_index = cfg.get(\"start_index\", 0)\n    end_index = cfg.get(\"end_index\", None)\n    if end_index is None:\n        end_index = start_index + cfg.get(\"num_samples\", len(dataset.data) + 1)\n    dataset.data = dataset.data[start_index:end_index]\n    logger.info(\"Dataset contains %s samples.\", len(dataset))\n\n    # == build dataloader ==\n    dataloader_args = dict(\n        dataset=dataset,\n        batch_size=cfg.get(\"batch_size\", 1),\n        num_workers=cfg.get(\"num_workers\", 4),\n        seed=cfg.get(\"seed\", 1024),\n        shuffle=False,\n        drop_last=False,\n        pin_memory=True,\n        process_group=get_data_parallel_group(),\n        prefetch_factor=cfg.get(\"prefetch_factor\", None),\n    )\n    dataloader, _ = prepare_dataloader(**dataloader_args)\n\n    # == prepare default params ==\n    sampling_option = SamplingOption(**cfg.sampling_option)\n    sampling_option = sanitize_sampling_option(sampling_option)\n\n    cond_type = cfg.get(\"cond_type\", \"t2v\")\n    prompt_refine = cfg.get(\"prompt_refine\", False)\n    fps_save = cfg.get(\"fps_save\", 16)\n    num_sample = cfg.get(\"num_sample\", 1)\n\n    type_name = \"image\" if cfg.sampling_option.num_frames == 1 else \"video\"\n    sub_dir = f\"{type_name}_{cfg.sampling_option.resolution}\"\n    os.makedirs(os.path.join(save_dir, sub_dir), exist_ok=True)\n    use_t2i2v = cfg.get(\"use_t2i2v\", False)\n    img_sub_dir = os.path.join(sub_dir, \"generated_condition\")\n    if use_t2i2v:\n        os.makedirs(os.path.join(save_dir, sub_dir, \"generated_condition\"), exist_ok=True)\n\n    # ======================================================\n    # 3. build model\n    # ======================================================\n    logger.info(\"Building models...\")\n\n    # == build flux model ==\n    model, model_ae, model_t5, model_clip, optional_models = prepare_models(\n        cfg, device, dtype, offload_model=cfg.get(\"offload_model\", False)\n    )\n    log_cuda_max_memory(\"build model\")\n\n    if booster:\n        model, _, _, _, _ = booster.boost(model=model)\n        model = model.unwrap()\n    if booster_ae:\n        model_ae, _, _, _, _ = booster_ae.boost(model=model_ae)\n        model_ae = model_ae.unwrap()\n\n    api_fn = prepare_api(model, model_ae, model_t5, model_clip, optional_models)\n\n    # prepare image flux model if t2i2v\n    if use_t2i2v:\n        api_fn_img = prepare_api(\n            optional_models[\"img_flux\"], optional_models[\"img_flux_ae\"], model_t5, model_clip, optional_models\n        )\n\n    # ======================================================\n    # 4. inference\n    # ======================================================\n    for epoch in range(num_sample):  # generate multiple samples with different seeds\n        dataloader_iter = iter(dataloader)\n        with tqdm(\n            enumerate(dataloader_iter, start=0),\n            desc=\"Inference progress\",\n            disable=not is_main_process(),\n            initial=0,\n            total=len(dataloader),\n        ) as pbar:\n            for _, batch in pbar:\n                original_text = batch.pop(\"text\")\n                if use_t2i2v:\n                    batch[\"text\"] = original_text if not prompt_refine else refine_prompts(original_text, type=\"t2i\")\n                    sampling_option_t2i = modify_option_to_t2i(\n                        sampling_option,\n                        distilled=True,\n                        img_resolution=cfg.get(\"img_resolution\", \"768px\"),\n                    )\n                    if cfg.get(\"offload_model\", False):\n                        model_move_start = time.time()\n                        model = model.to(\"cpu\", dtype)\n                        model_ae = model_ae.to(\"cpu\", dtype)\n                        optional_models[\"img_flux\"].to(device, dtype)\n                        optional_models[\"img_flux_ae\"].to(device, dtype)\n                        logger.info(\n                            \"offload video diffusion model to cpu, load image flux model to gpu: %s s\",\n                            time.time() - model_move_start,\n                        )\n\n                    logger.info(\"Generating image condition by flux...\")\n                    x_cond = api_fn_img(\n                        sampling_option_t2i,\n                        \"t2v\",\n                        seed=sampling_option.seed + epoch if sampling_option.seed else None,\n                        channel=cfg[\"img_flux\"][\"in_channels\"],\n                        **batch,\n                    ).cpu()\n\n                    # save image to disk\n                    batch[\"name\"] = process_and_save(\n                        x_cond,\n                        batch,\n                        cfg,\n                        img_sub_dir,\n                        sampling_option_t2i,\n                        epoch,\n                        start_index,\n                        saving=is_saving_process,\n                    )\n                    dist.barrier()\n\n                    if cfg.get(\"offload_model\", False):\n                        model_move_start = time.time()\n                        model = model.to(device, dtype)\n                        model_ae = model_ae.to(device, dtype)\n                        optional_models[\"img_flux\"].to(\"cpu\", dtype)\n                        optional_models[\"img_flux_ae\"].to(\"cpu\", dtype)\n                        logger.info(\n                            \"load video diffusion model to gpu, offload image flux model to cpu: %s s\",\n                            time.time() - model_move_start,\n                        )\n\n                    ref_dir = os.path.join(save_dir, os.path.join(sub_dir, \"generated_condition\"))\n                    batch[\"ref\"] = [os.path.join(ref_dir, f\"{x}.png\") for x in batch[\"name\"]]\n                    cond_type = \"i2v_head\"\n\n                batch[\"text\"] = original_text\n                if prompt_refine:\n                    batch[\"text\"] = refine_prompts(\n                        original_text, type=\"t2v\" if cond_type == \"t2v\" else \"t2i\", image_paths=batch.get(\"ref\", None)\n                    )\n                batch[\"text\"] = add_fps_info_to_text(batch.pop(\"text\"), fps=fps_save)\n                if \"motion_score\" in cfg:\n                    batch[\"text\"] = add_motion_score_to_text(batch.pop(\"text\"), cfg.get(\"motion_score\", 5))\n\n                logger.info(\"Generating video...\")\n                x = api_fn(\n                    sampling_option,\n                    cond_type,\n                    seed=sampling_option.seed + epoch if sampling_option.seed else None,\n                    patch_size=cfg.get(\"patch_size\", 2),\n                    save_prefix=cfg.get(\"save_prefix\", \"\"),\n                    channel=cfg[\"model\"][\"in_channels\"],\n                    **batch,\n                ).cpu()\n\n                if is_saving_process:\n                    process_and_save(x, batch, cfg, sub_dir, sampling_option, epoch, start_index)\n                dist.barrier()\n\n    logger.info(\"Inference finished.\")\n    log_cuda_max_memory(\"inference\")", "label": 0}
{"function": "def handle_uploads(input_video, input_images):\n    \"\"\"\n    Create a new 'target_dir' + 'images' subfolder, and place user-uploaded\n    images or extracted frames from video into it. Return (target_dir, image_paths).\n    \"\"\"\n    start_time = time.time()\n    gc.collect()\n    torch.cuda.empty_cache()\n\n    # Create a unique folder name\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S_%f\")\n    target_dir = f\"input_images_{timestamp}\"\n    target_dir_images = os.path.join(target_dir, \"images\")\n\n    # Clean up if somehow that folder already exists\n    if os.path.exists(target_dir):\n        shutil.rmtree(target_dir)\n    os.makedirs(target_dir)\n    os.makedirs(target_dir_images)\n\n    image_paths = []\n\n    # --- Handle images ---\n    if input_images is not None:\n        for file_data in input_images:\n            if isinstance(file_data, dict) and \"name\" in file_data:\n                file_path = file_data[\"name\"]\n            else:\n                file_path = file_data\n            dst_path = os.path.join(target_dir_images, os.path.basename(file_path))\n            shutil.copy(file_path, dst_path)\n            image_paths.append(dst_path)\n\n    # --- Handle video ---\n    if input_video is not None:\n        if isinstance(input_video, dict) and \"name\" in input_video:\n            video_path = input_video[\"name\"]\n        else:\n            video_path = input_video\n\n        vs = cv2.VideoCapture(video_path)\n        fps = vs.get(cv2.CAP_PROP_FPS)\n        frame_interval = int(fps * 1)  # 1 frame/sec\n\n        count = 0\n        video_frame_num = 0\n        while True:\n            gotit, frame = vs.read()\n            if not gotit:\n                break\n            count += 1\n            if count % frame_interval == 0:\n                image_path = os.path.join(target_dir_images, f\"{video_frame_num:06}.png\")\n                cv2.imwrite(image_path, frame)\n                image_paths.append(image_path)\n                video_frame_num += 1\n\n    # Sort final images for gallery\n    image_paths = sorted(image_paths)\n\n    end_time = time.time()\n    print(f\"Files copied to {target_dir_images}; took {end_time - start_time:.3f} seconds\")\n    return target_dir, image_paths", "label": 0}
{"function": "  def _variance(self):\n    return self.alpha / math_ops.square(self.beta)", "label": 1}
{"function": "def test_output_to_file_with_data_uris(shared_tmp_dir, test_vector) -> None:\n    \"\"\"Test CLI functionality when keep_data_uris is enabled\"\"\"\n\n    output_file = os.path.join(shared_tmp_dir, test_vector.filename + \".output\")\n    result = subprocess.run(\n        [\n            \"python\",\n            \"-m\",\n            \"markitdown\",\n            \"--keep-data-uris\",\n            \"-o\",\n            output_file,\n            os.path.join(TEST_FILES_DIR, test_vector.filename),\n        ],\n        capture_output=True,\n        text=True,\n    )\n\n    assert result.returncode == 0, f\"CLI exited with error: {result.stderr}\"\n    assert os.path.exists(output_file), f\"Output file not created: {output_file}\"\n\n    with open(output_file, \"r\") as f:\n        output_data = f.read()\n        for test_string in test_vector.must_include:\n            assert test_string in output_data\n        for test_string in test_vector.must_not_include:\n            assert test_string not in output_data\n\n    os.remove(output_file)\n    assert not os.path.exists(output_file), f\"Output file not deleted: {output_file}\"", "label": 0}
{"function": "    def _onSettingValueChanged(self, key: str, property_name: str) -> None:\n        if property_name != \"value\":  # Not the value that was changed.\n            return\n\n        if key in self._affected_settings:\n            self._onChanged()\n        if key in self._influencing_settings:\n            self._init2DConvexHullCache()  # Invalidate the cache.\n            self._onChanged()", "label": 1}
{"function": "def get_answer_placeholders():\n    \"\"\"\n        Returns all answer placeholders text\n    \"\"\"\n    prefix = \"#educational_plugin_window = \"\n    path = sys.argv[-1]\n    import os\n\n    file_name_without_extension = os.path.splitext(path)[0]\n    windows_path = file_name_without_extension + \"_windows\"\n    windows = []\n    f = open(windows_path, \"r\")\n    window_text = \"\"\n    first = True\n    for line in f.readlines():\n        if line.startswith(prefix):\n            if not first:\n                windows.append(window_text.strip())\n            else:\n                first = False\n            window_text = line[len(prefix):]\n        else:\n            window_text += line\n\n    if window_text:\n        windows.append(window_text.strip())\n\n    f.close()\n    return windows", "label": 1}
{"function": "    def test_atomic_max_double_normalizedindex(self):\n        vals = np.random.randint(0, 65535, size=(32, 32)).astype(np.float64)\n        res = np.zeros(1, np.float64)\n        cuda_func = cuda.jit('void(float64[:], float64[:,:])')(\n            atomic_max_double_normalizedindex)\n        cuda_func[32, 32](res, vals)\n\n        gold = np.max(vals)\n        np.testing.assert_equal(res, gold)", "label": 1}
{"function": "def get_image() -> torch.Tensor | None:\n    image = st.file_uploader(\"Input\", type=[\"jpg\", \"JPEG\", \"png\"])\n    if image is None:\n        return None\n    image = Image.open(image).convert(\"RGB\")\n\n    transform = transforms.Compose(\n        [\n            transforms.ToTensor(),\n            transforms.Lambda(lambda x: 2.0 * x - 1.0),\n        ]\n    )\n    img: torch.Tensor = transform(image)\n    return img[None, ...]", "label": 0}
{"function": "    def __init__(self, parent, initialColor, name, mask, labelSize):\n        \"\"\" Initializes the paint color, the mask color (cyan, magenta, or\n        yellow), connects the color selector and invert checkbox to functions,\n        and creates a two-by-two grid layout.\n        \"\"\"\n        super(ScreenWidget, self).__init__(parent)\n\n        self.originalImage = QImage()\n        self.newImage = QImage()\n\n        self.paintColor = initialColor\n        self.maskColor = mask\n        self.inverted = False\n\n        self.imageLabel = QLabel()\n        self.imageLabel.setFrameShadow(QFrame.Sunken)\n        self.imageLabel.setFrameShape(QFrame.StyledPanel)\n        self.imageLabel.setMinimumSize(labelSize)\n\n        self.nameLabel = QLabel(name)\n        self.colorButton = QPushButton(\"Modify...\")\n        self.colorButton.setBackgroundRole(QPalette.Button)\n        self.colorButton.setMinimumSize(32, 32)\n\n        palette = QPalette(self.colorButton.palette())\n        palette.setColor(QPalette.Button, initialColor)\n        self.colorButton.setPalette(palette)\n\n        self.invertButton = QPushButton(\"Invert\")\n        self.invertButton.setEnabled(False)\n\n        self.colorButton.clicked.connect(self.setColor)\n        self.invertButton.clicked.connect(self.invertImage)\n\n        gridLayout = QGridLayout()\n        gridLayout.addWidget(self.imageLabel, 0, 0, 1, 2)\n        gridLayout.addWidget(self.nameLabel, 1, 0)\n        gridLayout.addWidget(self.colorButton, 1, 1)\n        gridLayout.addWidget(self.invertButton, 2, 1, 1, 1)\n        self.setLayout(gridLayout)", "label": 1}
{"function": "    def test_user_site(self):\n        # site.USER_SITE was introduced in 2.6\n        if sys.version < '2.6':\n            return\n\n        # preparing the environment for the test\n        self.old_user_base = site.USER_BASE\n        self.old_user_site = site.USER_SITE\n        self.tmpdir = self.mkdtemp()\n        self.user_base = os.path.join(self.tmpdir, 'B')\n        self.user_site = os.path.join(self.tmpdir, 'S')\n        site.USER_BASE = self.user_base\n        site.USER_SITE = self.user_site\n        install_module.USER_BASE = self.user_base\n        install_module.USER_SITE = self.user_site\n\n        def _expanduser(path):\n            return self.tmpdir\n        self.old_expand = os.path.expanduser\n        os.path.expanduser = _expanduser\n\n        def cleanup():\n            site.USER_BASE = self.old_user_base\n            site.USER_SITE = self.old_user_site\n            install_module.USER_BASE = self.old_user_base\n            install_module.USER_SITE = self.old_user_site\n            os.path.expanduser = self.old_expand\n\n        self.addCleanup(cleanup)\n\n        for key in ('nt_user', 'unix_user', 'os2_home'):\n            self.assertIn(key, INSTALL_SCHEMES)\n\n        dist = Distribution({'name': 'xx'})\n        cmd = install(dist)\n\n        # making sure the user option is there\n        options = [name for name, short, lable in\n                   cmd.user_options]\n        self.assertIn('user', options)\n\n        # setting a value\n        cmd.user = 1\n\n        # user base and site shouldn't be created yet\n        self.assertFalse(os.path.exists(self.user_base))\n        self.assertFalse(os.path.exists(self.user_site))\n\n        # let's run finalize\n        cmd.ensure_finalized()\n\n        # now they should\n        self.assertTrue(os.path.exists(self.user_base))\n        self.assertTrue(os.path.exists(self.user_site))\n\n        self.assertIn('userbase', cmd.config_vars)\n        self.assertIn('usersite', cmd.config_vars)", "label": 1}
{"function": "def init_session_state() -> None:\n    \"\"\"Initialize Streamlit session state with default values.\"\"\"\n    defaults = {\n        \"initialized\": False,\n        \"qdrant_url\": \"\",\n        \"qdrant_api_key\": \"\",\n        \"openai_api_key\": \"\",\n        \"setup_complete\": False,\n        \"client\": None,\n        \"embedding_model\": None,\n        \"processor_agent\": None,\n        \"tts_agent\": None,\n        \"selected_voice\": \"coral\",\n        \"processed_documents\": []\n    }\n    \n    for key, value in defaults.items():\n        if key not in st.session_state:\n            st.session_state[key] = value", "label": 0}
{"function": "            def fetch_data():\n                step, batch = next(pbar_iter)\n                pinned_video = batch[\"video\"]\n                batch[\"video\"] = pinned_video.to(device, dtype, non_blocking=True)\n                return batch, step, pinned_video", "label": 0}
{"function": "    def test_best_model2_alignment_handles_empty_trg_sentence(self):\n        # arrange\n        sentence_pair = AlignedSent([], TestIBMModel.__TEST_SRC_SENTENCE)\n        ibm_model = IBMModel([])\n\n        # act\n        a_info = ibm_model.best_model2_alignment(sentence_pair)\n\n        # assert\n        self.assertEqual(a_info.alignment[1:], ())\n        self.assertEqual(a_info.cepts, [[], [], [], [], []])", "label": 1}
{"function": "def migrate_database():\n    \"\"\"Add instance_password column to tables with instance_id\"\"\"\n    db_path = get_db_path()\n    \n    logger.info(f\"Using database at: {db_path}\")\n    \n    # Check if database file exists\n    if not os.path.exists(db_path):\n        logger.error(f\"Database file not found at {db_path}\")\n        return False\n    \n    # Default password to use\n    default_password = \"mindverse666\"\n    \n    try:\n        # Connect to the database\n        conn = sqlite3.connect(db_path)\n        cursor = conn.cursor()\n        \n        # List all tables\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n        tables = cursor.fetchall()\n        logger.info(f\"Tables in database: {[table[0] for table in tables]}\")\n        \n        # Check for any table that might have instance_id but not instance_password\n        for table_name in [table[0] for table in tables]:\n            # Get columns for this table\n            cursor.execute(f\"PRAGMA table_info({table_name})\")\n            table_columns = cursor.fetchall()\n            table_column_names = [column[1] for column in table_columns]\n            \n            # If table has instance_id but not instance_password\n            if \"instance_id\" in table_column_names and \"instance_password\" not in table_column_names:\n                logger.info(f\"Table {table_name} has instance_id but not instance_password\")\n                logger.info(f\"Adding instance_password column to {table_name} table\")\n                cursor.execute(f\"ALTER TABLE {table_name} ADD COLUMN instance_password VARCHAR(255) DEFAULT '{default_password}'\")\n                logger.info(f\"Added instance_password column to {table_name} table with default value '{default_password}'\")\n                \n                # Update existing rows to set the default password where instance_id is not null\n                cursor.execute(f\"UPDATE {table_name} SET instance_password = '{default_password}' WHERE instance_id IS NOT NULL AND instance_password IS NULL\")\n                updated_rows = cursor.rowcount\n                logger.info(f\"Updated {updated_rows} rows in {table_name} with default password\")\n        \n        # Commit the changes\n        conn.commit()\n        logger.info(\"Migration completed successfully\")\n        \n        # Close the connection\n        conn.close()\n        return True\n        \n    except sqlite3.Error as e:\n        logger.error(f\"SQLite error: {e}\")\n        return False\n    except Exception as e:\n        logger.error(f\"Error during migration: {e}\")\n        return False", "label": 0}
{"function": "def img2base64(file_name):\n    with open(file_name, 'rb') as f:\n        encoded_string = base64.b64encode(f.read())\n        return encoded_string", "label": 0}
{"function": "def _IdGrad(_, grad):\n  return grad", "label": 1}
{"function": "    def __init__(self, ass):\n        super().__init__(ass.mem_get)\n        self._ass = ass", "label": 1}
{"function": "def _validate_args(args):\n    # Basic check\n    assert args.ckpt_dir is not None, \"Please specify the checkpoint directory.\"\n    assert args.task in WAN_CONFIGS, f\"Unsupport task: {args.task}\"\n    assert args.task in EXAMPLE_PROMPT, f\"Unsupport task: {args.task}\"\n\n    # The default sampling steps are 40 for image-to-video tasks and 50 for text-to-video tasks.\n    if args.sample_steps is None:\n        args.sample_steps = 50\n        if \"i2v\" in args.task:\n            args.sample_steps = 40\n\n    if args.sample_shift is None:\n        args.sample_shift = 5.0\n        if \"i2v\" in args.task and args.size in [\"832*480\", \"480*832\"]:\n            args.sample_shift = 3.0\n        elif \"flf2v\" in args.task or \"vace\" in args.task:\n            args.sample_shift = 16\n\n    # The default number of frames are 1 for text-to-image tasks and 81 for other tasks.\n    if args.frame_num is None:\n        args.frame_num = 1 if \"t2i\" in args.task else 81\n\n    # T2I frame_num check\n    if \"t2i\" in args.task:\n        assert args.frame_num == 1, f\"Unsupport frame_num {args.frame_num} for task {args.task}\"\n\n    args.base_seed = args.base_seed if args.base_seed >= 0 else random.randint(\n        0, sys.maxsize)\n    # Size check\n    assert args.size in SUPPORTED_SIZES[\n        args.\n        task], f\"Unsupport size {args.size} for task {args.task}, supported sizes are: {', '.join(SUPPORTED_SIZES[args.task])}\"", "label": 0}
{"function": "    def scale_outputs(self, scale):\n        \"\"\"\n        Scale the network outputs by the given amount.\n\n        This may be called right after initializing the\n        model to help deal with different reward scales.\n        \"\"\"\n        self.critic_out *= scale\n        self.actor_out *= scale", "label": 1}
{"function": "def _resize_image(im, width, height, padding):\n    # resize\n    h = im.shape[0]\n    w = im.shape[1]\n    if w != width or h != height:\n        # resize image\n        if not padding:\n            # trimming mode\n            if float(h) / w > float(height) / width:\n                target_h = int(float(w) / width * height)\n                im = im[(h - target_h) // 2:h -\n                        (h - target_h) // 2, ::]\n            else:\n                target_w = int(float(h) / height * width)\n                im = im[::, (w - target_w) // 2:w -\n                        (w - target_w) // 2]\n        else:\n            # padding mode\n            if float(h) / w < float(height) / width:\n                target_h = int(float(height) / width * w)\n                pad = (((target_h - h) // 2, target_h -\n                        (target_h - h) // 2 - h), (0, 0))\n            else:\n                target_w = int(float(width) / height * h)\n                pad = ((0, 0), ((target_w - w) // 2,\n                                target_w - (target_w - w) // 2 - w))\n            pad = pad + ((0, 0),)\n            im = np.pad(im, pad, 'constant')\n        im = imresize(im, (width, height))\n\n    x = np.array(im, dtype=np.uint8).transpose((2, 0, 1))\n    return x", "label": 1}
{"function": "    def apply(self, top, value):\n        return value", "label": 1}
{"function": "def generate(audio, target_voice_path):\n    wav = model.generate(\n        audio, target_voice_path=target_voice_path,\n    )\n    return model.sr, wav.squeeze(0).numpy()", "label": 0}
{"function": "        def model_changed(self):\n            print(\"   New value:\", self.model.get_value())", "label": 1}
{"function": "def log_reader_thread(log_file):\n    \"\"\"Background thread that continuously reads the log file and adds new lines to the queue\"\"\"\n    try:\n        with open(log_file, \"r\", encoding=\"utf-8\") as f:\n            # Move to the end of file\n            f.seek(0, 2)\n\n            while not STOP_LOG_THREAD.is_set():\n                line = f.readline()\n                if line:\n                    LOG_QUEUE.put(line)  # Add to conversation record queue\n                else:\n                    # No new lines, wait for a short time\n                    time.sleep(0.1)\n    except Exception as e:\n        logging.error(f\"Log reader thread error: {str(e)}\")", "label": 0}
{"function": "    def test_host_power_action(self):\n        self._test_compute_api('host_power_action', 'call', action='action',\n                host='host')", "label": 1}
{"function": "async def test_ascrape_with_js_support(mock_playwright):\n    \"\"\"Test the ascrape_with_js_support method with different browser configurations.\"\"\"\n    mock_pw, mock_browser, mock_context, mock_page = mock_playwright\n\n    url = \"http://example.com\"\n    loader = ChromiumLoader([url], backend=\"playwright\", requires_js_support=True)\n\n    # Test with Chromium\n    result = await loader.ascrape_with_js_support(url, browser_name=\"chromium\")\n    assert mock_pw.chromium.launch.call_count == 1\n    assert mock_page.goto.call_count == 1\n    assert mock_page.content.call_count == 1\n\n    # Test with Firefox\n    result = await loader.ascrape_with_js_support(url, browser_name=\"firefox\")\n    assert mock_pw.firefox.launch.call_count == 1\n    assert mock_page.goto.call_count == 2\n    assert mock_page.content.call_count == 2\n\n    # Test with invalid browser name\n    with pytest.raises(ValueError):\n        await loader.ascrape_with_js_support(url, browser_name=\"invalid\")", "label": 0}
{"function": "    def hasGroupAsParent(node: \"SceneNode\") -> bool:\n        parent = node.getParent()\n        if parent is None:\n            return False\n        return bool(parent.callDecoration(\"isGroup\"))", "label": 1}
{"function": "    def mouse_event_for_distance(self, event, x, y, flags, param):\n        \"\"\"\n        This function is designed to move region with mouse events in a real-time video stream.\n\n        Args:\n            event (int): The type of mouse event (e.g., cv2.EVENT_MOUSEMOVE, cv2.EVENT_LBUTTONDOWN, etc.).\n            x (int): The x-coordinate of the mouse pointer.\n            y (int): The y-coordinate of the mouse pointer.\n            flags (int): Any flags associated with the event (e.g., cv2.EVENT_FLAG_CTRLKEY,\n                cv2.EVENT_FLAG_SHIFTKEY, etc.).\n            param (dict): Additional parameters you may want to pass to the function.\n        \"\"\"\n        global selected_boxes\n        global left_mouse_count\n        if event == cv2.EVENT_LBUTTONDOWN:\n            self.left_mouse_count += 1\n            if self.left_mouse_count <= 2:\n                for box, track_id in zip(self.boxes, self.trk_ids):\n                    if box[0] < x < box[2] and box[1] < y < box[3] and track_id not in self.selected_boxes:\n                        self.selected_boxes[track_id] = []\n                        self.selected_boxes[track_id] = box\n\n        if event == cv2.EVENT_RBUTTONDOWN:\n            self.selected_boxes = {}\n            self.left_mouse_count = 0", "label": 0}
{"function": "def get_seed(randomize_seed: bool, seed: int) -> int:\n    \"\"\"\n    Get the random seed.\n    \"\"\"\n    return np.random.randint(0, MAX_SEED) if randomize_seed else seed", "label": 0}
{"function": "    def __init__(self, open, high, low, close):\n        pass", "label": 1}
{"function": "    def should_match(signature, name):\n      self.assertEqual(ipr.strip_function_parameters(signature), name)", "label": 1}
{"function": "def main():\n    with open(os.path.join(os.path.dirname(__file__), \"matrix.txt\")) as matfile:\n        matrix = parse(matfile)\n    targets = [(len(matrix) - 1, len(matrix[0]) - 1)]\n    sources = [(0, 0)]\n    print(sum(matrix[y][x] for (x, y) in astar(matrix, targets, sources)))", "label": 1}
{"function": "    def __str__(self):\n        return \"(%s) %s-%s\" % (self.status_code, self.error_type,\n                               self.error_message)", "label": 1}
{"function": "def unpad_dataproto(data: \"DataProto\", pad_size):\n    \"\"\"Unpad the data proto with pad_size. i.e. `data[:-pad_size]`\"\"\"\n    if pad_size != 0:\n        data = data[:-pad_size]\n    return data", "label": 0}
{"function": "  def inference_graph(self, data):\n    with ops.device(self.device_assigner):\n      # Compute activations for the neural network.\n      nn_activations = layers.fully_connected(data, self.params.layer_size)\n\n      for _ in range(1, self.params.num_layers):\n        # pylint: disable=W0106\n        nn_activations = layers.fully_connected(nn_activations,\n                                                self.params.layer_size)\n      return nn_activations", "label": 1}
{"function": "    def __init__(self, first_replaced_line: int, n_search_lines: int, n_replace_lines: int, n_replacements: int):\n        self.first_replaced_line = first_replaced_line\n        self.n_search_lines = n_search_lines\n        self.n_replace_lines = n_replace_lines\n        self.n_replacements = n_replacements", "label": 0}
{"function": "    def test_post_live_migration_at_destination(self):\n        self.flags(long_rpc_timeout=1234)\n        self._test_compute_api('post_live_migration_at_destination', 'call',\n                instance=self.fake_instance_obj,\n                block_migration='block_migration', host='host', version='5.0',\n                timeout=1234, call_monitor_timeout=60)", "label": 1}
{"function": "def pytest_generate_tests(metafunc):\n    \"\"\"Dynamically parametrize tests based on the selected provider and config.\"\"\"\n    if \"model\" in metafunc.fixturenames:\n        model = metafunc.config.getoption(\"model\")\n        if model:\n            metafunc.parametrize(\"model\", [model])\n            return\n\n        provider = metafunc.config.getoption(\"provider\")\n        if not provider:\n            print(\"Warning: --provider not specified. Skipping model parametrization.\")\n            metafunc.parametrize(\"model\", [])\n            return\n\n        try:\n            config_data = _load_all_verification_configs()\n        except (OSError, FileNotFoundError) as e:\n            print(f\"ERROR loading verification configs: {e}\")\n            config_data = {\"providers\": {}}\n\n        provider_config = config_data.get(\"providers\", {}).get(provider)\n        if provider_config:\n            models = provider_config.get(\"models\", [])\n            if models:\n                metafunc.parametrize(\"model\", models)\n            else:\n                print(f\"Warning: No models found for provider '{provider}' in config.\")\n                metafunc.parametrize(\"model\", [])  # Parametrize empty if no models found\n        else:\n            print(f\"Warning: Provider '{provider}' not found in config. No models parametrized.\")\n            metafunc.parametrize(\"model\", [])  # Parametrize empty if provider not found", "label": 0}
{"function": "    def serialize(self):\n        \"\"\"Returns the object serialized as a JSON string.\n\n        Returns:\n            str. JSON-encoded string encoding all of the information composing\n            the object.\n        \"\"\"\n        platform_parameter_dict = self.to_dict()\n\n        return json.dumps(platform_parameter_dict)", "label": 1}
{"function": "    def parse(cls, value, kwds):\n        kwds['parse_tree'] = cls.value_parser(value)\n        kwds['decoded'] = str(kwds['parse_tree'])", "label": 1}
{"function": "def handle_shutdown(signum, frame):\n    \"\"\"Handle graceful shutdown on SIGTERM/SIGINT\"\"\"\n    logger.info(\"Received shutdown signal. Starting graceful shutdown...\")\n    sys.exit(0)", "label": 0}
{"function": "def expand_engine_lists(engine_lists):\n  def map_engine(engine):\n    return inference_engine_classes.get(engine, engine)  # Return original name if not found\n\n  return [[map_engine(engine) for engine in sublist]\n          for sublist in engine_lists]", "label": 0}
{"function": "    def __init__(self, in_features, out_features, bias=True):\n        super(GraphConvolution, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = Parameter(torch.FloatTensor(in_features, out_features))\n        init.xavier_uniform_(self.weight)\n        if bias:\n            self.bias = Parameter(torch.FloatTensor(out_features))\n            init.constant_(self.bias, 0)\n        else:\n            self.register_parameter('bias', None)\n\n        self.reset_parameters()", "label": 1}
{"function": "    def test_neighboring_sets_neighbor_alignment_info(self):\n        # arrange\n        a_info = AlignmentInfo(\n            (0, 3, 2),\n            (None, 'des', '\u0153ufs', 'verts'),\n            ('UNUSED', 'green', 'eggs'),\n            [[], [], [2], [1]],\n        )\n        ibm_model = IBMModel([])\n\n        # act\n        neighbors = ibm_model.neighboring(a_info)\n\n        # assert: select a few particular alignments\n        for neighbor in neighbors:\n            if neighbor.alignment == (0, 2, 2):\n                moved_alignment = neighbor\n            elif neighbor.alignment == (0, 3, 2):\n                swapped_alignment = neighbor\n\n        self.assertEqual(moved_alignment.cepts, [[], [], [1, 2], []])\n        self.assertEqual(swapped_alignment.cepts, [[], [], [2], [1]])", "label": 1}
{"function": "def ask(\n    question,\n    debug=False,\n    max_plan_iterations=1,\n    max_step_num=3,\n    enable_background_investigation=True,\n):\n    \"\"\"Run the agent workflow with the given question.\n\n    Args:\n        question: The user's query or request\n        debug: If True, enables debug level logging\n        max_plan_iterations: Maximum number of plan iterations\n        max_step_num: Maximum number of steps in a plan\n        enable_background_investigation: If True, performs web search before planning to enhance context\n    \"\"\"\n    asyncio.run(\n        run_agent_workflow_async(\n            user_input=question,\n            debug=debug,\n            max_plan_iterations=max_plan_iterations,\n            max_step_num=max_step_num,\n            enable_background_investigation=enable_background_investigation,\n        )\n    )", "label": 0}
{"function": "def get_accounts(provider: str) -> List[dict]:\n    \"\"\"\n    Gets the accounts from the cache.\n\n    Args:\n        provider (str): The provider to get the accounts for\n\n    Returns:\n        account (List[dict]): The accounts\n    \"\"\"\n    cache_path = \"\"\n\n    if provider == \"twitter\":\n        cache_path = get_twitter_cache_path()\n    elif provider == \"youtube\":\n        cache_path = get_youtube_cache_path()\n\n    if not os.path.exists(cache_path):\n        # Create the cache file\n        with open(cache_path, 'w') as file:\n            json.dump({\n                \"accounts\": []\n            }, file, indent=4)\n\n    with open(cache_path, 'r') as file:\n        parsed = json.load(file)\n\n        if parsed is None:\n            return []\n        \n        if 'accounts' not in parsed:\n            return []\n\n        # Get accounts dictionary\n        return parsed['accounts']", "label": 0}
{"function": "def clean_sv_cn_model():\r\n    global sv_cn_model\r\n    if sv_cn_model:\r\n        sv_cn_model.embedding_model = sv_cn_model.embedding_model.cpu()\r\n        sv_cn_model = None\r\n        try:\r\n            torch.cuda.empty_cache()\r\n        except:\r\n            pass\r", "label": 0}
{"function": "    def __eq__(self, other: Any) -> bool: ...", "label": 1}
{"function": "    def cffi_type(self, space):\n        state = space.fromcache(State)\n        return state.c_llong", "label": 1}
{"function": "    def clean_tax_rate(self):\n        return self.cleaned_data.get('tax_rate') or 0", "label": 1}
{"function": "    def chat(self, input):\n        try:\n            image = Image.open(io.BytesIO(base64.b64decode(input['image']))).convert('RGB')\n        except Exception as e:\n            return \"Image decode error\"\n\n        msgs = json.loads(input['question'])\n        \n        answer, context, _ = self.model.chat(\n            image=image,\n            msgs=msgs,\n            context=None,\n            tokenizer=self.tokenizer,\n            sampling=True,\n            temperature=0.7\n    \t)\n        return answer", "label": 0}
{"function": "    def public_key(self):\n        return msg_utils.encode_hex(self.ecc.raw_pubkey)", "label": 1}
{"function": "def login_get():\n    return {}", "label": 1}
{"function": "    def test_atomic_max_double_oneindex(self):\n        vals = np.random.randint(0, 128, size=32).astype(np.float64)\n        res = np.zeros(1, np.float64)\n        cuda_func = cuda.jit('void(float64[:], float64[:])')(\n            atomic_max_double_oneindex)\n        cuda_func[1, 32](res, vals)\n\n        gold = np.max(vals)\n        np.testing.assert_equal(res, gold)", "label": 1}
{"function": "    def defects(self):\n        return tuple(self._defects)", "label": 1}
{"function": "    def read(self, n):\n        '''Read raw bytes.'''\n        b = self.serialport.read(n)\n        self.logger.verbose('Facedancer received %s bytes; %s bytes remaining' % (len(b), self.serialport.inWaiting()))\n        self.logger.verbose('Facedancer Rx: %s' % hexlify(b))\n        return b", "label": 1}
{"function": "        def _build_parameters(self, args, kwargs):\n            for index, value in enumerate(args):\n                if value is None:\n                    continue\n                try:\n                    self.parameters[self.accepts_parameters[index]] = encode_string(value)\n                except IndexError:\n                    raise WeixinClientError(\"Too many arguments supplied\")\n\n            for key, value in six.iteritems(kwargs):\n                if value is None:\n                    continue\n                if key in self.parameters:\n                    raise WeixinClientError(\"Parameter %s already supplied\" % key)\n                if key not in set(['json_body']):\n                    value = encode_string(value)\n                self.parameters[key] = value", "label": 1}
{"function": "  def testUpdateCloudStorageDependenciesWrite(\n      self, base_config_cs_mock, uploader_cs_mock):\n    expected_dependencies = self.dependencies\n    self.fs.CreateFile(self.file_path,\n                       contents='\\n'.join(self.expected_file_lines))\n    config = dependency_manager.BaseConfig(self.file_path, writable=True)\n    self.assertFalse(config._IsDirty())\n    self.assertEqual(expected_dependencies, config._config_data)\n\n    base_config_cs_mock.CalculateHash.return_value = self.new_dep_hash\n    uploader_cs_mock.Exists.return_value = False\n    expected_dependencies = self.new_dependencies\n    config.AddCloudStorageDependencyUpdateJob(\n        'dep1', 'plat2', self.new_dep_path, execute_job=True)\n    self.assertFalse(config._IsDirty())\n    self.assertFalse(config._pending_uploads)\n    self.assertEqual(expected_dependencies, config._config_data)\n    # check that file contents has been updated\n    file_module = fake_filesystem.FakeFileOpen(self.fs)\n    expected_file_lines = list(self.new_expected_file_lines)\n    for line in file_module(self.file_path):\n      self.assertEqual(expected_file_lines.pop(0), line.strip())\n    self.fs.CloseOpenFile(file_module(self.file_path))\n\n    expected_dependencies = self.final_dependencies\n    base_config_cs_mock.CalculateHash.return_value = self.final_dep_hash\n    config.AddCloudStorageDependencyUpdateJob(\n        'dep2', 'plat1', self.final_dep_path, execute_job=True)\n    self.assertFalse(config._IsDirty())\n    self.assertFalse(config._pending_uploads)\n    self.assertEqual(expected_dependencies, config._config_data)\n    # check that file contents has been updated\n    expected_file_lines = list(self.final_expected_file_lines)\n    file_module = fake_filesystem.FakeFileOpen(self.fs)\n    for line in file_module(self.file_path):\n      self.assertEqual(expected_file_lines.pop(0), line.strip())\n    self.fs.CloseOpenFile(file_module(self.file_path))", "label": 1}
{"function": "def parse_args():\n    parser = argparse.ArgumentParser(description=\"Run a task with a given configuration file.\")\n    parser.add_argument('--config', type=str, required=True, help='Path to the configuration file.')\n    return parser.parse_args()", "label": 0}
{"function": "    def __init__(self, open, high, low, close):\n        pass", "label": 1}
{"function": "    def quit(self):\n        \"\"\"\u5173\u95ed\u6d4f\u89c8\u5668\"\"\"\n        if self.browser:\n            try:\n                self.browser.quit()\n            except:\n                pass", "label": 0}
{"function": "def unpack_state(state: dict) -> Tuple[Gaussian, edict, str]:\n    gs = Gaussian(\n        aabb=state['gaussian']['aabb'],\n        sh_degree=state['gaussian']['sh_degree'],\n        mininum_kernel_size=state['gaussian']['mininum_kernel_size'],\n        scaling_bias=state['gaussian']['scaling_bias'],\n        opacity_bias=state['gaussian']['opacity_bias'],\n        scaling_activation=state['gaussian']['scaling_activation'],\n    )\n    gs._xyz = torch.tensor(state['gaussian']['_xyz'], device='cuda')\n    gs._features_dc = torch.tensor(state['gaussian']['_features_dc'], device='cuda')\n    gs._scaling = torch.tensor(state['gaussian']['_scaling'], device='cuda')\n    gs._rotation = torch.tensor(state['gaussian']['_rotation'], device='cuda')\n    gs._opacity = torch.tensor(state['gaussian']['_opacity'], device='cuda')\n    \n    mesh = edict(\n        vertices=torch.tensor(state['mesh']['vertices'], device='cuda'),\n        faces=torch.tensor(state['mesh']['faces'], device='cuda'),\n    )\n    \n    return gs, mesh", "label": 0}
{"function": "    def get_array(self):\n        # Return the heap in form of array\n        return self.array[1:]", "label": 1}
{"function": "def test_openai_model():\n    config = LLMConfig(provider=\"openai\", model_name=\"gpt-4o\")\n    test_llm(config, \"Describe this image\", \"assets/examples/test.png\")", "label": 0}
{"function": "    def offset(self, num_to_skip):\n        \"\"\"Offset for query\"\"\"\n        self._offset = num_to_skip\n        return self", "label": 1}
{"function": "def get_new_path(suffix=\"\") -> str:\n    directory = tempfile.mkdtemp()\n    return os.path.join(directory, str(uuid.uuid4()) + suffix)", "label": 0}
{"function": "def initialize_model(model_dir=\"pretrained_models/Spark-TTS-0.5B\", device=0):\n    \"\"\"Load the model once at the beginning.\"\"\"\n    logging.info(f\"Loading model from: {model_dir}\")\n\n    # Determine appropriate device based on platform and availability\n    if platform.system() == \"Darwin\":\n        # macOS with MPS support (Apple Silicon)\n        device = torch.device(f\"mps:{device}\")\n        logging.info(f\"Using MPS device: {device}\")\n    elif torch.cuda.is_available():\n        # System with CUDA support\n        device = torch.device(f\"cuda:{device}\")\n        logging.info(f\"Using CUDA device: {device}\")\n    else:\n        # Fall back to CPU\n        device = torch.device(\"cpu\")\n        logging.info(\"GPU acceleration not available, using CPU\")\n\n    model = SparkTTS(model_dir, device)\n    return model", "label": 0}
{"function": "def main(fp8_path, bf16_path):\n    \"\"\"\n    Converts FP8 weights to BF16 and saves the converted weights.\n\n    This function reads FP8 weights from the specified directory, converts them to BF16,\n    and saves the converted weights to another specified directory. It also updates the\n    model index file to reflect the changes.\n\n    Args:\n    fp8_path (str): The path to the directory containing the FP8 weights and model index file.\n    bf16_path (str): The path to the directory where the converted BF16 weights will be saved.\n\n    Raises:\n    KeyError: If a required scale_inv tensor is missing for a weight.\n\n    Notes:\n    - The function assumes that the FP8 weights are stored in safetensor files.\n    - The function caches loaded safetensor files to optimize memory usage.\n    - The function updates the model index file to remove references to scale_inv tensors.\n    \"\"\"\n    torch.set_default_dtype(torch.bfloat16)\n    os.makedirs(bf16_path, exist_ok=True)\n    model_index_file = os.path.join(fp8_path, \"model.safetensors.index.json\")\n    with open(model_index_file, \"r\") as f:\n        model_index = json.load(f)\n    weight_map = model_index[\"weight_map\"]\n    \n    # Cache for loaded safetensor files\n    loaded_files = {}\n    fp8_weight_names = []\n\n    # Helper function to get tensor from the correct file\n    def get_tensor(tensor_name):\n        \"\"\"\n        Retrieves a tensor from the cached safetensor files or loads it from disk if not cached.\n\n        Args:\n            tensor_name (str): The name of the tensor to retrieve.\n\n        Returns:\n            torch.Tensor: The retrieved tensor.\n\n        Raises:\n            KeyError: If the tensor does not exist in the safetensor file.\n        \"\"\"\n        file_name = weight_map[tensor_name]\n        if file_name not in loaded_files:\n            file_path = os.path.join(fp8_path, file_name)\n            loaded_files[file_name] = load_file(file_path, device=\"cuda\")\n        return loaded_files[file_name][tensor_name]\n\n    safetensor_files = list(glob(os.path.join(fp8_path, \"*.safetensors\")))\n    safetensor_files.sort()\n    for safetensor_file in tqdm(safetensor_files):\n        file_name = os.path.basename(safetensor_file)\n        current_state_dict = load_file(safetensor_file, device=\"cuda\")\n        loaded_files[file_name] = current_state_dict\n        \n        new_state_dict = {}\n        for weight_name, weight in current_state_dict.items():\n            if weight_name.endswith(\"_scale_inv\"):\n                continue\n            elif weight.element_size() == 1:  # FP8 weight\n                scale_inv_name = f\"{weight_name}_scale_inv\"\n                try:\n                    # Get scale_inv from the correct file\n                    scale_inv = get_tensor(scale_inv_name)\n                    fp8_weight_names.append(weight_name)\n                    new_state_dict[weight_name] = weight_dequant(weight, scale_inv)\n                except KeyError:\n                    print(f\"Warning: Missing scale_inv tensor for {weight_name}, skipping conversion\")\n                    new_state_dict[weight_name] = weight\n            else:\n                new_state_dict[weight_name] = weight\n                \n        new_safetensor_file = os.path.join(bf16_path, file_name)\n        save_file(new_state_dict, new_safetensor_file)\n        \n        # Memory management: keep only the 2 most recently used files\n        if len(loaded_files) > 2:\n            oldest_file = next(iter(loaded_files))\n            del loaded_files[oldest_file]\n            torch.cuda.empty_cache()\n    \n    # Update model index\n    new_model_index_file = os.path.join(bf16_path, \"model.safetensors.index.json\")\n    for weight_name in fp8_weight_names:\n        scale_inv_name = f\"{weight_name}_scale_inv\"\n        if scale_inv_name in weight_map:\n            weight_map.pop(scale_inv_name)\n    with open(new_model_index_file, \"w\") as f:\n        json.dump({\"metadata\": {}, \"weight_map\": weight_map}, f, indent=2)", "label": 0}
{"function": "    def clean_html(self, html):\n        \"\"\"Apply ``Cleaner`` to HTML string or document and return a cleaned string or document.\"\"\"\n        result_type = type(html)\n        if isinstance(html, six.string_types):\n            doc = html_fromstring(html)\n        else:\n            doc = copy.deepcopy(html)\n        self(doc)\n        if issubclass(result_type, six.binary_type):\n            return tostring(doc, encoding='utf-8')\n        elif issubclass(result_type, six.text_type):\n            return tostring(doc, encoding='unicode')\n        else:\n            return doc", "label": 1}
{"function": "    def from_values(cls, *args, **kwargs):\n        \"\"\"Create a new request object based on the values provided.  If\n        environ is given missing values are filled from there.  This method is\n        useful for small scripts when you need to simulate a request from an URL.\n        Do not use this method for unittesting, there is a full featured client\n        object (:class:`Client`) that allows to create multipart requests,\n        support for cookies etc.\n\n        This accepts the same options as the\n        :class:`~werkzeug.test.EnvironBuilder`.\n\n        .. versionchanged:: 0.5\n           This method now accepts the same arguments as\n           :class:`~werkzeug.test.EnvironBuilder`.  Because of this the\n           `environ` parameter is now called `environ_overrides`.\n\n        :return: request object\n        \"\"\"\n        from werkzeug.test import EnvironBuilder\n        charset = kwargs.pop('charset', cls.charset)\n        kwargs['charset'] = charset\n        builder = EnvironBuilder(*args, **kwargs)\n        try:\n            return builder.get_request(cls)\n        finally:\n            builder.close()", "label": 1}
{"function": "    def neighbors(position):\n        (x, y) = position\n        candidates = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n        return [(x, y) for (x, y) in candidates if x >= 0 and x < len(matrix)\n                                               and y >= 0 and y < len(matrix[0])]", "label": 1}
{"function": "    def forward(self, input, adj):\n        support = torch.mm(input, self.weight)\n        output = torch.spmm(adj, support)\n        if self.bias is not None:\n            return output + self.bias\n        else:\n            return output", "label": 1}
{"function": "def fast_pickle(obj: Any, path: str) -> None:\n    with copy_from_shm(path) as tmp_path:\n        with open(tmp_path, \"wb\") as f:\n            pickle.dump(obj, f)", "label": 0}
{"function": "def test_request_with_cookies():\n    \"\"\"Test a request with cookies.\"\"\"\n    request = RequestModel(\n        name=\"Request with cookies\",\n        method=\"GET\",\n        url=\"https://example.com/api\",\n        cookies=[\n            Cookie(name=\"session\", value=\"abc123\"),\n            Cookie(name=\"preference\", value=\"dark-mode\"),\n            Cookie(name=\"disabled\", value=\"value\", enabled=False),\n        ],\n    )\n\n    expected = \"curl \\\\\\n  --cookie 'session=abc123' \\\\\\n  --cookie 'preference=dark-mode' \\\\\\n  'https://example.com/api'\"\n    assert request.to_curl() == expected", "label": 0}
{"function": "  def testHasDefaultValues(self):\n    desc = unittest_pb2.TestAllTypes.DESCRIPTOR\n\n    expected_has_default_by_name = {\n        'optional_int32': False,\n        'repeated_int32': False,\n        'optional_nested_message': False,\n        'default_int32': True,\n    }\n\n    has_default_by_name = dict(\n        [(f.name, f.has_default_value)\n         for f in desc.fields\n         if f.name in expected_has_default_by_name])\n    self.assertEqual(expected_has_default_by_name, has_default_by_name)", "label": 1}
{"function": "def main(\n    ckpt_dir: str,\n    tokenizer_path: str,\n    temperature: float = 0.6,\n    top_p: float = 0.9,\n    max_seq_len: int = 512,\n    max_batch_size: int = 4,\n    max_gen_len: Optional[int] = None,\n):\n    \"\"\"\n    Examples to run with the models finetuned for chat. Prompts correspond of chat\n    turns between the user and assistant with the final one always being the user.\n\n    An optional system prompt at the beginning to control how the model should respond\n    is also supported.\n\n    The context window of llama3 models is 8192 tokens, so `max_seq_len` needs to be <= 8192.\n\n    `max_gen_len` is optional because finetuned models are able to stop generations naturally.\n    \"\"\"\n    generator = Llama.build(\n        ckpt_dir=ckpt_dir,\n        tokenizer_path=tokenizer_path,\n        max_seq_len=max_seq_len,\n        max_batch_size=max_batch_size,\n    )\n\n    dialogs: List[Dialog] = [\n        [{\"role\": \"user\", \"content\": \"what is the recipe of mayonnaise?\"}],\n        [\n            {\"role\": \"user\", \"content\": \"I am going to Paris, what should I see?\"},\n            {\n                \"role\": \"assistant\",\n                \"content\": \"\"\"\\\nParis, the capital of France, is known for its stunning architecture, art museums, historical landmarks, and romantic atmosphere. Here are some of the top attractions to see in Paris:\n\n1. The Eiffel Tower: The iconic Eiffel Tower is one of the most recognizable landmarks in the world and offers breathtaking views of the city.\n2. The Louvre Museum: The Louvre is one of the world's largest and most famous museums, housing an impressive collection of art and artifacts, including the Mona Lisa.\n3. Notre-Dame Cathedral: This beautiful cathedral is one of the most famous landmarks in Paris and is known for its Gothic architecture and stunning stained glass windows.\n\nThese are just a few of the many attractions that Paris has to offer. With so much to see and do, it's no wonder that Paris is one of the most popular tourist destinations in the world.\"\"\",\n            },\n            {\"role\": \"user\", \"content\": \"What is so great about #1?\"},\n        ],\n        [\n            {\"role\": \"system\", \"content\": \"Always answer with Haiku\"},\n            {\"role\": \"user\", \"content\": \"I am going to Paris, what should I see?\"},\n        ],\n        [\n            {\n                \"role\": \"system\",\n                \"content\": \"Always answer with emojis\",\n            },\n            {\"role\": \"user\", \"content\": \"How to go from Beijing to NY?\"},\n        ],\n    ]\n    results = generator.chat_completion(\n        dialogs,\n        max_gen_len=max_gen_len,\n        temperature=temperature,\n        top_p=top_p,\n    )\n\n    for dialog, result in zip(dialogs, results):\n        for msg in dialog:\n            print(f\"{msg['role'].capitalize()}: {msg['content']}\\n\")\n        print(\n            f\"> {result['generation']['role'].capitalize()}: {result['generation']['content']}\"\n        )\n        print(\"\\n==================================\\n\")", "label": 0}
{"function": "def test_add_metrics_dict_input(tracer):\n    \"\"\"Test adding metrics using dictionary input\"\"\"\n    tracer.trace = {}\n    metric_dict = {\n        \"name\": \"test_metric\",\n        \"score\": 0.95,\n        \"reasoning\": \"Good performance\"\n    }\n    tracer.add_metrics(metric_dict)\n    \n    assert len(tracer.trace_metrics) == 1\n    metric = tracer.trace_metrics[0]\n    assert metric[\"name\"] == \"test_metric\"\n    assert metric[\"score\"] == 0.95\n    assert metric[\"reason\"] == \"Good performance\"", "label": 0}
{"function": "    def create_state_fields(self, dtype, state_size):\n        \"\"\"\n        Set self.first_state_ph and self.init_state_vars\n        with the given TF datatype and the state size.\n\n        The state size may be an integer, a TensorShape,\n        or a tuple thereof.\n        \"\"\"\n        if isinstance(state_size, tuple):\n            self.first_state_ph = ()\n            self.init_state_vars = ()\n            for sub_shape in state_size:\n                placeholder = tf.placeholder(dtype, _add_outer_none(sub_shape))\n                variable = tf.Variable(tf.zeros(sub_shape))\n                self.first_state_ph += (placeholder,)\n                self.init_state_vars += (variable,)\n        else:\n            placeholder = tf.placeholder(dtype, _add_outer_none(state_size))\n            variable = tf.Variable(tf.zeros(state_size))\n            self.first_state_ph = placeholder\n            self.init_state_vars = variable", "label": 1}
{"function": "    def preserve(self):\n        return self.pop_all()", "label": 1}
{"function": "\tdef set_VerificationStatus(self,VerificationStatus):\n\t\tself.add_query_param('VerificationStatus',VerificationStatus)", "label": 1}
{"function": "    def cmd_sync(self):\n        \"\"\"Sync the X display. Should only be used for development\"\"\"\n        self.conn.flush()", "label": 1}
{"function": "    def update(self, commit: bool = True, **kwargs) -> Union[bool, Any]:\n        \"\"\"Update specific fields of a record.\"\"\"\n        for attr, value in kwargs.items():\n            setattr(self, attr, value)\n        return self.save() if commit else self", "label": 1}
{"function": "    def PARLER_LANGUAGES(self):\n        \"\"\"\n        Return languages for Parler computed from the LANGUAGES and LANGUAGE_CODE settings.\n        \"\"\"\n        return {\n            self.SITE_ID: tuple({\"code\": code} for code, _name in self.LANGUAGES),\n            \"default\": {\n                \"fallbacks\": [self.LANGUAGE_CODE],\n                \"hide_untranslated\": False,\n            },\n        }", "label": 0}
{"function": "    def tearDown(self):\n        # Clean up\n        cache.clean_test_db(self.test_db)", "label": 0}
{"function": "    def save(self, **kwargs):\n        pricing = super(PricingForm, self).save(**kwargs)\n        if self.cleaned_data.get('billing_dt_select'):\n            dt_select = self.cleaned_data.get('billing_dt_select').split(',')\n            pricing.num_days = dt_select[0]\n            pricing.due_sore = dt_select[1]\n        if self.cleaned_data.get('billing_cycle'):\n            cycle = self.cleaned_data.get('billing_cycle').split(',')\n            pricing.billing_frequency = cycle[0]\n            pricing.billing_period = cycle[1]\n        #pricing.save()\n        return pricing", "label": 1}
{"function": "    def writecmd(self, c):\n        '''Write a single command.'''\n        self.write(c.as_bytestring())\n        self.logger.verbose('Facedancer Tx command: %s' % c)", "label": 1}
{"function": "def translation_page():\n    st.title(\"\ud83c\udf0f \u5b57\u5e55\u7ffb\u8bd1\")\n    st.markdown(\"---\")\n\n    # \u521d\u59cb\u5316session state\n    if \"translated_content\" not in st.session_state:\n        st.session_state.translated_content = None\n    if \"current_subtitle_file\" not in st.session_state:\n        st.session_state.current_subtitle_file = None\n    if \"translation_done\" not in st.session_state:\n        st.session_state.translation_done = False\n\n    temp_dir = create_temp_dir()\n\n    # \u4f7f\u7528\u5bb9\u5668\u5e03\u5c40\n    with st.container():\n        subtitle_file = st.file_uploader(\n            label=\"\u4e0a\u4f20\u5b57\u5e55\u6587\u4ef6\",\n            type=[\"srt\", \"ass\", \"vtt\"],\n            key=\"trans_subtitle\",\n            label_visibility=\"visible\",\n            help=\"\u652f\u6301 SRT\u3001ASS\u3001VTT \u683c\u5f0f\u7684\u5b57\u5e55\u6587\u4ef6\",\n        )\n\n        target_language = st.selectbox(\n            \"\u9009\u62e9\u8981\u7ffb\u8bd1\u6210\u7684\u76ee\u6807\u8bed\u8a00\",\n            [\n                \"\u82f1\u8bed\",\n                \"\u7b80\u4f53\u4e2d\u6587\",\n                \"\u7e41\u4f53\u4e2d\u6587\",\n                \"\u65e5\u672c\u8a9e\",\n                \"\u97e9\u8bed\",\n                \"\u7ca4\u8bed\",\n                \"\u6cd5\u8bed\",\n                \"\u5fb7\u8bed\",\n                \"\u897f\u73ed\u7259\u8bed\",\n                \"\u4fc4\u8bed\",\n                \"\u8461\u8404\u7259\u8bed\",\n                \"\u571f\u8033\u5176\u8bed\",\n            ],\n            index=0,\n            help=\"\u9009\u62e9\u8981\u5c06\u5b57\u5e55\u7ffb\u8bd1\u6210\u7684\u76ee\u6807\u8bed\u8a00\",\n        )\n\n    # \u5982\u679c\u4e0a\u4f20\u4e86\u65b0\u6587\u4ef6\uff0c\u6e05\u7406\u65e7\u6587\u4ef6\u548c\u72b6\u6001\n    if (\n        subtitle_file is not None\n        and subtitle_file != st.session_state.current_subtitle_file\n    ):\n        if st.session_state.current_subtitle_file:\n            old_path = temp_dir / st.session_state.current_subtitle_file.name\n            if os.path.exists(old_path):\n                os.remove(old_path)\n        st.session_state.current_subtitle_file = subtitle_file\n        st.session_state.translation_done = False\n        st.session_state.translated_content = None\n        st.session_state.translated_asr_data = None\n\n    if subtitle_file is not None:\n        subtitle_path = temp_dir / subtitle_file.name\n        with open(subtitle_path, \"wb\") as f:\n            f.write(subtitle_file.getbuffer())\n\n        # \u663e\u793a\u539f\u59cb\u5b57\u5e55\u9884\u89c8\n        with st.expander(\"\u539f\u59cb\u5b57\u5e55\u9884\u89c8\"):\n            asr_data = ASRData.from_subtitle_file(str(subtitle_path))\n            st.session_state.asr_data = asr_data\n            subtitle_json = st.session_state.asr_data.to_json()\n            df = pd.DataFrame(\n                [\n                    {\n                        \"\u5f00\u59cb\u65f6\u95f4\": format_time(v[\"start_time\"]),\n                        \"\u7ed3\u675f\u65f6\u95f4\": format_time(v[\"end_time\"]),\n                        \"\u539f\u6587\": v[\"original_subtitle\"],\n                        \"\u8bd1\u6587\": v[\"translated_subtitle\"],\n                    }\n                    for k, v in subtitle_json.items()\n                ]\n            )\n\n            st.dataframe(df, use_container_width=True)\n\n        # \u5f00\u59cb\u7ffb\u8bd1\u6309\u94ae\n        if st.button(\"\u5f00\u59cb\u7ffb\u8bd1\", use_container_width=True):\n            with st.spinner(\"\u6b63\u5728\u7ffb\u8bd1\u4e2d...\"):\n                try:\n                    logger.info(f\"\u5f00\u59cb\u7ffb\u8bd1\u5b57\u5e55\u6587\u4ef6: {subtitle_file.name}\")\n                    # \u8bfb\u53d6\u5b57\u5e55\u6587\u4ef6\n                    asr_data = ASRData.from_subtitle_file(str(subtitle_path))\n\n                    logger.info(f\"\u76ee\u6807\u8bed\u8a00: {target_language}\")\n                    # \u521b\u5efa\u4f18\u5316\u5668\u5b9e\u4f8b\uff08\u7528\u4e8e\u7ffb\u8bd1\uff09\n                    translator = TranslatorFactory.create_translator(\n                        translator_type=TranslatorType.BING,\n                        target_language=target_language,\n                    )\n\n                    # \u51c6\u5907\u5b57\u5e55\u6570\u636e\n                    subtitle_json = {\n                        str(k): v[\"original_subtitle\"]\n                        for k, v in asr_data.to_json().items()\n                    }\n                    logger.info(f\"\u5f85\u7ffb\u8bd1\u5b57\u5e55\u6bb5\u843d\u6570: {len(subtitle_json)}\")\n\n                    # \u6267\u884c\u7ffb\u8bd1\n                    logger.info(\"\u5f00\u59cb\u591a\u7ebf\u7a0b\u7ffb\u8bd1\")\n                    asr_data = translator.translate_subtitle(asr_data)\n                    logger.info(\"\u7ffb\u8bd1\u5b8c\u6210\")\n\n                    # \u4fdd\u5b58\u7ffb\u8bd1\u540e\u7684\u5b57\u5e55\n                    st.session_state.translated_content = asr_data.to_srt()\n                    st.session_state.translated_asr_data = asr_data\n                    st.session_state.translation_done = True\n\n                    logger.info(\"\u5b57\u5e55\u7ffb\u8bd1\u5168\u6d41\u7a0b\u5b8c\u6210\")\n                    st.success(\"\u7ffb\u8bd1\u5b8c\u6210\uff01\")\n\n                except Exception as e:\n                    logger.exception(f\"\u7ffb\u8bd1\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u9519\u8bef: {str(e)}\")\n                    st.error(f\"\u7ffb\u8bd1\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u9519\u8bef: {str(e)}\")\n\n        # \u5982\u679c\u7ffb\u8bd1\u5b8c\u6210\uff0c\u663e\u793a\u7ed3\u679c\u548c\u4e0b\u8f7d\u6309\u94ae\n        if (\n            st.session_state.translation_done\n            and st.session_state.translated_asr_data is not None\n        ):\n            # \u663e\u793a\u7ffb\u8bd1\u540e\u7684\u9884\u89c8\n            st.subheader(\"\u7ffb\u8bd1\u7ed3\u679c\u9884\u89c8\")\n            subtitle_json = st.session_state.translated_asr_data.to_json()\n            df = pd.DataFrame(\n                [\n                    {\n                        \"\u5f00\u59cb\u65f6\u95f4\": format_time(v[\"start_time\"]),\n                        \"\u7ed3\u675f\u65f6\u95f4\": format_time(v[\"end_time\"]),\n                        \"\u539f\u6587\": v[\"original_subtitle\"],\n                        \"\u8bd1\u6587\": v[\"translated_subtitle\"],\n                    }\n                    for k, v in subtitle_json.items()\n                ]\n            )\n\n            st.dataframe(df, use_container_width=True)\n\n            # \u63d0\u4f9b\u4e0b\u8f7d\u6309\u94ae\n            st.download_button(\n                label=\"\u4e0b\u8f7d\u7ffb\u8bd1\u540e\u7684\u5b57\u5e55\",\n                data=st.session_state.translated_content,\n                file_name=f\"translated_{subtitle_file.name}\",\n                mime=\"text/plain\",\n                use_container_width=True,\n            )", "label": 0}
{"function": "    def drop_table(self, name, **kw):\n        \"\"\"Issue a \"drop table\" instruction using the current\n        migration context.\n\n\n        e.g.::\n\n            drop_table(\"accounts\")\n\n        :param name: Name of the table\n        :param schema: Optional schema name to operate within.\n\n         .. versionadded:: 0.4.0\n\n        :param \\**kw: Other keyword arguments are passed to the underlying\n         :class:`sqlalchemy.schema.Table` object created for the command.\n\n        \"\"\"\n        self.impl.drop_table(\n            self._table(name, **kw)\n        )", "label": 1}
{"function": "\tdef set_ResourceOwnerAccount(self,ResourceOwnerAccount):\n\t\tself.add_query_param('ResourceOwnerAccount',ResourceOwnerAccount)", "label": 1}
{"function": "    def is_rpc_path_valid(self):\n        if self.rpc_paths:\n            return self.path in self.rpc_paths\n        else:\n            # If .rpc_paths is empty, just assume all paths are legal\n            return True", "label": 1}
{"function": "    def is_feature(self):\n        \"\"\"Returns whether this parameter is also a feature flag.\n\n        Returns:\n            bool. True if the parameter is a feature flag.\n        \"\"\"\n        return self._is_feature", "label": 1}
{"function": "def run_yapf(target):\n  if os.path.isfile(target):\n    files = [target]\n  else:\n    files = [os.path.join(root, file) for root, _, files in os.walk(target) for file in files if file.endswith('.py')]\n\n  for file in files:\n    try:\n      command = [\"yapf\", \"-i\", file]\n      subprocess.run(command, check=True, capture_output=True, text=True)\n      print(f\"Formatted: {file}\")\n    except subprocess.CalledProcessError as e:\n      print(f\"Error formatting {file}: {e.stderr}\")", "label": 0}
{"function": "    def child_left(ind):\n        # Calculate first child position for given index\n        return ind*2", "label": 1}
{"function": "    def InParentNamespaceBufferHasIdentifier(cls, buf, offset, size_prefixed=False):\n        return flatbuffers.util.BufferHasIdentifier(buf, offset, b\"\\x4D\\x4F\\x4E\\x53\", size_prefixed=size_prefixed)", "label": 1}
{"function": "def test_validation_valid_excluded_types():\n    \"\"\"Test validation function with valid excluded types.\"\"\"\n    entity_types = {\n        'Person': Person,\n        'Organization': Organization,\n    }\n\n    # Valid exclusions\n    assert validate_excluded_entity_types(['Entity'], entity_types) is True\n    assert validate_excluded_entity_types(['Person'], entity_types) is True\n    assert validate_excluded_entity_types(['Entity', 'Person'], entity_types) is True\n    assert validate_excluded_entity_types(None, entity_types) is True\n    assert validate_excluded_entity_types([], entity_types) is True", "label": 0}
{"function": "def split_string(string: str, chunk_size: int) -> List[str]:\n    words = string.split()\n    result = []\n    current_chunk = \"\"\n    for word in words:\n        if (\n            len(current_chunk) + len(word) + 1 <= chunk_size\n        ):  # Check if adding the word exceeds the chunk size\n            current_chunk += f\" {word}\"\n        else:\n            if current_chunk:  # Append the current chunk if not empty\n                result.append(current_chunk.strip())\n            current_chunk = word\n    if current_chunk:  # Append the last chunk if not empty\n        result.append(current_chunk.strip())\n    return result", "label": 0}
{"function": "        def cleanup():\n            site.USER_BASE = self.old_user_base\n            site.USER_SITE = self.old_user_site\n            install_module.USER_BASE = self.old_user_base\n            install_module.USER_SITE = self.old_user_site\n            os.path.expanduser = self.old_expand", "label": 1}
{"function": "    def __init__(self, environ, populate_request=True, shallow=False):\n        self.environ = environ\n        if populate_request and not shallow:\n            self.environ['werkzeug.request'] = self\n        self.shallow = shallow", "label": 1}
{"function": "    def limit(self, count):\n        \"\"\"Apply limit for query\"\"\"\n        # save the Limit in cursor for next fetch\n        self.cursor_dict['limit'] = count\n\n        if count:\n            self.n_limit = count\n        return self", "label": 1}
{"function": "  def __init__(\n      self,\n      name: str,\n      parent_agent: Optional[BaseAgent] = None,\n  ):\n    super().__init__(name=name, sub_agents=[])\n    # BaseAgent doesn't have disallow_transfer_to_parent field\n    # This is intentional as we want to test non-LLM agents\n    if parent_agent:\n      self.parent_agent = parent_agent", "label": 0}
{"function": "def fast_check_ffmpeg():\n    try:\n        subprocess.run([\"ffmpeg\", \"-version\"], capture_output=True, check=True)\n        return True\n    except:\n        return False", "label": 0}
{"function": "async def test_file_exists(computer):\n    tmp_path = \"test_file_exists.txt\"\n    # Ensure file does not exist\n    if await computer.interface.file_exists(tmp_path):\n        await computer.interface.delete_file(tmp_path)\n    exists = await computer.interface.file_exists(tmp_path)\n    assert exists is False, f\"File {tmp_path} should not exist\"\n    # Create file and check again\n    await computer.interface.write_text(tmp_path, \"hello\")\n    exists = await computer.interface.file_exists(tmp_path)\n    assert exists is True, f\"File {tmp_path} should exist\"\n    await computer.interface.delete_file(tmp_path)", "label": 0}
{"function": "    def get_all_citation_index(self):\n        citation_pattern = re.compile(r\"\\[(\\d+)\\]\")\n        return list(map(int, citation_pattern.findall(self.utterance)))", "label": 0}
{"function": "def list_of_dict_to_dict_of_list(list_of_dict: list[dict]):\n    if len(list_of_dict) == 0:\n        return {}\n    keys = list_of_dict[0].keys()\n    output = {key: [] for key in keys}\n    for data in list_of_dict:\n        for key, item in data.items():\n            assert key in output\n            output[key].append(item)\n    return output", "label": 0}
{"function": "        def receive(payload, message):\n            callback_called[0] = True", "label": 1}
{"function": "    def getConvexHullHeadFull(self) -> Optional[Polygon]:\n        \"\"\"For one at the time this is the convex hull of the node with the full head size\n\n        In case of printing all at once this is None.\n        \"\"\"\n        if self._node is None:\n            return None\n\n        if self._isSingularOneAtATimeNode():\n            return self._compute2DConvexHeadFull()\n\n        return None", "label": 1}
{"function": "async def test_mcp_client():\n    from src.utils.mcp_client import setup_mcp_client_and_tools, create_tool_param_model\n\n    test_server_config = {\n        \"mcpServers\": {\n            # \"markitdown\": {\n            #     \"command\": \"docker\",\n            #     \"args\": [\n            #         \"run\",\n            #         \"--rm\",\n            #         \"-i\",\n            #         \"markitdown-mcp:latest\"\n            #     ]\n            # },\n            \"desktop-commander\": {\n                \"command\": \"npx\",\n                \"args\": [\n                    \"-y\",\n                    \"@wonderwhy-er/desktop-commander\"\n                ]\n            },\n            # \"filesystem\": {\n            #     \"command\": \"npx\",\n            #     \"args\": [\n            #         \"-y\",\n            #         \"@modelcontextprotocol/server-filesystem\",\n            #         \"/Users/xxx/ai_workspace\",\n            #     ]\n            # },\n        }\n    }\n\n    mcp_tools, mcp_client = await setup_mcp_client_and_tools(test_server_config)\n\n    for tool in mcp_tools:\n        tool_param_model = create_tool_param_model(tool)\n        print(tool.name)\n        print(tool.description)\n        print(tool_param_model.model_json_schema())\n    pdb.set_trace()", "label": 0}
{"function": "    def __exit__(self, *excinfo):\n        pass", "label": 1}
{"function": "    def __init__(self):\n        \"\"\" Constructor initializes a default value for the brightness, creates\n            the main menu entries, and constructs a central widget that contains\n            enough space for images to be displayed.\n        \"\"\"\n        super(Viewer, self).__init__()\n\n        self.scaledImage = QImage()\n        self.menuMap = {}\n        self.path = ''\n        self.brightness = 255\n\n        self.setWindowTitle(\"QImage Color Separations\")\n\n        self.createMenus()\n        self.setCentralWidget(self.createCentralWidget())", "label": 1}
{"function": "    def _irq(self, event, data):\n        # Track connections so we can send notifications.\n        if event == _IRQ_CENTRAL_CONNECT:\n            conn_handle, _, _, = data\n            self._connections.add(conn_handle)\n        elif event == _IRQ_CENTRAL_DISCONNECT:\n            conn_handle, _, _, = data\n            if conn_handle in self._connections:\n                self._connections.remove(conn_handle)\n            # Start advertising again to allow a new connection.\n            self._advertise()\n        elif event == _IRQ_GATTS_WRITE:\n            conn_handle, value_handle, = data\n            if conn_handle in self._connections and value_handle == self._rx_handle:\n                self._rx_buffer += self._ble.gatts_read(self._rx_handle)\n                if self._handler:\n                    self._handler()", "label": 1}
{"function": "def generate(\n    mmgpt: MultiModalityCausalLM,\n    vl_chat_processor: VLChatProcessor,\n    prompt: str,\n    short_prompt: str,\n    parallel_size: int = 16,\n    temperature: float = 1,\n    cfg_weight: float = 5,\n    image_token_num_per_image: int = 576,\n    img_size: int = 384,\n    patch_size: int = 16,\n):\n    input_ids = vl_chat_processor.tokenizer.encode(prompt)\n    input_ids = torch.LongTensor(input_ids)\n\n    tokens = torch.zeros((parallel_size * 2, len(input_ids)), dtype=torch.int).cuda()\n    for i in range(parallel_size * 2):\n        tokens[i, :] = input_ids\n        if i % 2 != 0:\n            tokens[i, 1:-1] = vl_chat_processor.pad_id\n\n    inputs_embeds = mmgpt.language_model.get_input_embeddings()(tokens)\n\n    generated_tokens = torch.zeros((parallel_size, image_token_num_per_image), dtype=torch.int).cuda()\n    outputs = None  # Initialize outputs for use in the loop\n\n    for i in range(image_token_num_per_image):\n        outputs = mmgpt.language_model.model(\n            inputs_embeds=inputs_embeds,\n            use_cache=True,\n            past_key_values=outputs.past_key_values if i != 0 else None\n        )\n        hidden_states = outputs.last_hidden_state\n\n        logits = mmgpt.gen_head(hidden_states[:, -1, :])\n        logit_cond = logits[0::2, :]\n        logit_uncond = logits[1::2, :]\n\n        logits = logit_uncond + cfg_weight * (logit_cond - logit_uncond)\n        probs = torch.softmax(logits / temperature, dim=-1)\n\n        next_token = torch.multinomial(probs, num_samples=1)\n        generated_tokens[:, i] = next_token.squeeze(dim=-1)\n\n        next_token = torch.cat([next_token.unsqueeze(dim=1), next_token.unsqueeze(dim=1)], dim=1).view(-1)\n        img_embeds = mmgpt.prepare_gen_img_embeds(next_token)\n        inputs_embeds = img_embeds.unsqueeze(dim=1)\n\n    dec = mmgpt.gen_vision_model.decode_code(\n        generated_tokens.to(dtype=torch.int),\n        shape=[parallel_size, 8, img_size // patch_size, img_size // patch_size]\n    )\n    dec = dec.to(torch.float32).cpu().numpy().transpose(0, 2, 3, 1)\n\n    dec = np.clip((dec + 1) / 2 * 255, 0, 255)\n\n    visual_img = np.zeros((parallel_size, img_size, img_size, 3), dtype=np.uint8)\n    visual_img[:, :, :] = dec\n\n    os.makedirs('generated_samples', exist_ok=True)\n\n    # Create a timestamp\n    timestamp = time.strftime(\"%Y%m%d-%H%M%S\")\n\n    # Sanitize the short_prompt to ensure it's safe for filenames\n    short_prompt = re.sub(r'\\W+', '_', short_prompt)[:50]\n\n    # Save images with timestamp and part of the user prompt in the filename\n    for i in range(parallel_size):\n        save_path = os.path.join('generated_samples', f\"img_{timestamp}_{short_prompt}_{i}.jpg\")\n        PIL.Image.fromarray(visual_img[i]).save(save_path)", "label": 0}
{"function": "    def show_status(self, status, force=False):\n        'Displays the specified status message.'\n\n        if not force and status is getattr(self, '_shown_status', None):\n            return\n\n        # make the text area not editable for statuses like \"Invisble\" and\n        # \"Offline\", which have the \"editable\" attribute set to False\n        self.Editable = status.editable\n\n        self.display.empty_text = getattr(status, 'hint', '')\n        self.ChangeValue(status.message)                    # change text\n        self.SetButtonIcon(StatusMessage.icon_for(status))  # change icon\n        self.status_state = status.status                   # store the state\n        self._shown_status = status", "label": 1}
{"function": "    def test_query_event_id(self):\n        \"\"\"\n        wineventlog - Query by event IDs\n        \"\"\"\n        msg = \"event_id test case\"\n        self.write_event_log(msg, eventID=10)  # Excluded\n        self.write_event_log(msg, eventID=50)\n        self.write_event_log(msg, eventID=100)\n        self.write_event_log(msg, eventID=150)  # Excluded\n        self.write_event_log(msg, eventID=175)\n        self.write_event_log(msg, eventID=200)\n        evts = self.read_events(config={\n            \"tags\": [\"event_id\"],\n            \"event_logs\": [\n                {\n                    \"name\": self.providerName,\n                    \"api\": self.api,\n                    \"event_id\": \"50, 100-200, -150\"\n                }\n            ]\n        }, expected_events=4)\n        self.assertTrue(len(evts), 4)\n        self.assertEqual(evts[0][\"winlog.event_id\"], 50)\n        self.assertEqual(evts[1][\"winlog.event_id\"], 100)\n        self.assertEqual(evts[2][\"winlog.event_id\"], 175)\n        self.assertEqual(evts[3][\"winlog.event_id\"], 200)", "label": 1}
{"function": "    def load_yaml(yaml_path: Path) -> dict:\n        \"\"\"Load and parse a YAML file.\"\"\"\n        try:\n            with open(yaml_path, \"r\") as stream:\n                return yaml.safe_load(stream)\n        except yaml.YAMLError as exc:\n            raise ConfigError(f\"Error reading YAML file {yaml_path}: {exc}\")\n        except FileNotFoundError:\n            raise ConfigError(f\"YAML file not found: {yaml_path}\")", "label": 0}
{"function": "def test_state_initialization():\n    \"\"\"Test that State class has correct default attribute definitions.\"\"\"\n    # Test that the class has the expected attribute definitions\n    assert State.locale == \"en-US\"\n    assert State.observations == []\n    assert State.plan_iterations == 0\n    assert State.current_plan is None\n    assert State.final_report == \"\"\n    assert State.auto_accepted_plan is False\n    assert State.enable_background_investigation is True\n    assert State.background_investigation_results is None\n\n    # Verify state initialization\n    state = State(messages=[])\n    assert \"messages\" in state\n\n    # Without explicitly passing attributes, they're not in the state\n    assert \"locale\" not in state\n    assert \"observations\" not in state", "label": 0}
{"function": "def _progress(state, progress=0.0):\n    global _pbar\n    global _prev_progress\n\n    if state is None:\n        if _pbar is not None:\n            _pbar.close()\n        _pbar = None\n        _prev_progress = None\n    else:\n        if _pbar is None:\n            _pbar = tqdm.tqdm(desc=state, total=100, unit='%')\n        else:\n            if _prev_progress is None:\n                _prev_progress = 0\n            update = int((progress - _prev_progress) * 100)\n            if update > 0:\n                _pbar.update(update)\n                _prev_progress = progress", "label": 1}
{"function": "    def plot_psf_vs_rad(self, energies=None, ax=None, **kwargs):\n        \"\"\"Plot PSF vs radius.\n\n        Parameters\n        ----------\n        energy : `~astropy.units.Quantity`\n            Energies where to plot the PSF.\n        **kwargs : dict\n            Keyword arguments pass to `~matplotlib.pyplot.plot`.\n        \"\"\"\n        import matplotlib.pyplot as plt\n\n        if energies is None:\n            energies = [100, 1000, 10000] * u.GeV\n\n        ax = plt.gca() if ax is None else ax\n\n        for energy in energies:\n            psf_value = np.squeeze(self.evaluate(energy=energy))\n            label = f\"{energy:.0f}\"\n            ax.plot(\n                self.rad.to_value(\"deg\"),\n                psf_value.to_value(\"sr-1\"),\n                label=label,\n                **kwargs,\n            )\n\n        ax.set_yscale(\"log\")\n        ax.set_xlabel(\"Offset (deg)\")\n        ax.set_ylabel(\"PSF (1 / sr)\")\n        plt.legend()\n        return ax", "label": 1}
{"function": "async def think_wrapper(interaction, query):\n    try:\n        interaction.last_query = query\n        logger.info(\"Agents request is being processed\")\n        success = await interaction.think()\n        if not success:\n            interaction.last_answer = \"Error: No answer from agent\"\n            interaction.last_reasoning = \"Error: No reasoning from agent\"\n            interaction.last_success = False\n        else:\n            interaction.last_success = True\n        pretty_print(interaction.last_answer)\n        interaction.speak_answer()\n        return success\n    except Exception as e:\n        logger.error(f\"Error in think_wrapper: {str(e)}\")\n        interaction.last_answer = f\"\"\n        interaction.last_reasoning = f\"Error: {str(e)}\"\n        interaction.last_success = False\n        raise e", "label": 0}
{"function": "def main():\n    parser = argparse.ArgumentParser(description=\"Experiment Runner\")\n    parser.add_argument(\n        \"--config\", type=str, required=True, help=\"Path to YAML config file\"\n    )\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Enable debug output\")\n    args = parser.parse_args()\n\n    setup_logging(args.debug)\n    logger = logging.getLogger(__name__)\n    results = []\n\n    try:\n        configs = load_config(args.config)\n        runner = ExperimentRunner()\n\n        for config in configs:\n            logger.info(f\"Running {config.name}\")\n            result = runner.run_task(config)\n            results.append(result)\n\n        if get_bool_env_var(\"SGLANG_IS_IN_CI\"):\n            write_in_github_step_summary(results)\n    except Exception as e:\n        logger.error(f\"Error: {e}\")\n        raise", "label": 0}
{"function": "    def handle_accepted(self, sock, addr):\n        self.handler(sock)", "label": 1}
{"function": "    def __init__(self, parent = None):\n        super().__init__(parent)\n        cura.CuraApplication.CuraApplication.getInstance().getPreferences().preferenceChanged.connect(self._onFavoritesChanged)\n        self._onChanged()", "label": 1}
{"function": "    def test_restore_instance(self):\n        self._test_compute_api('restore_instance', 'cast',\n                instance=self.fake_instance_obj, version='5.0')", "label": 1}
{"function": "    def guess_chat_format(local_model_file):\n        model_name = local_model_file.stem\n\n        # handle known cases that the server backends handle incorrectly\n        # this is highly heuristic, should be expand later\n        # server backends usually has logic for this but they could still be wrong\n        if \"qwen\" in model_name:\n            return \"qwen\"\n\n        return None", "label": 0}
{"function": "def build_revert_indices(B: int, T: int, C: int, delay_pattern: tp.List[int]) -> tp.Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Precompute indices for the revert operation using PyTorch.\n\n    Returns:\n        A tuple (t_idx_BxTxC, indices_BTCx3) where:\n            - t_idx_BxTxC is a tensor of shape [B, T, C] computed as time indices plus the delay.\n            - indices_BTCx3 is a tensor of shape [B*T*C, 3] used for gathering, computed from:\n                batch indices, clamped time indices, and channel indices.\n    \"\"\"\n    # Use default device unless specified otherwise; assumes inputs might define device later\n    device = None  # Or determine dynamically if needed, e.g., from a model parameter\n\n    delay_arr = torch.tensor(delay_pattern, dtype=torch.int32, device=device)\n\n    t_idx_BT1 = torch.broadcast_to(torch.arange(T, device=device).unsqueeze(0), [B, T])\n    t_idx_BT1 = t_idx_BT1.unsqueeze(-1)\n\n    t_idx_BxTxC = torch.minimum(\n        t_idx_BT1 + delay_arr.view(1, 1, C),\n        torch.tensor(T - 1, device=device),\n    )\n    b_idx_BxTxC = torch.broadcast_to(torch.arange(B, device=device).view(B, 1, 1), [B, T, C])\n    c_idx_BxTxC = torch.broadcast_to(torch.arange(C, device=device).view(1, 1, C), [B, T, C])\n\n    indices_BTCx3 = torch.stack(\n        [\n            b_idx_BxTxC.reshape(-1),\n            t_idx_BxTxC.reshape(-1),\n            c_idx_BxTxC.reshape(-1),\n        ],\n        axis=1,\n    ).long()  # Ensure indices are long type\n\n    return t_idx_BxTxC, indices_BTCx3", "label": 0}
{"function": "def _check_component_availability(component_type, available_components, make_component):\n    \"\"\"Generic helper to check if a hardware component is available\"\"\"\n    if component_type not in available_components:\n        raise ValueError(\n            f\"The {component_type} type is not valid. Expected one of these '{available_components}'\"\n        )\n\n    try:\n        component = make_component(component_type)\n        component.connect()\n        del component\n        return True\n\n    except Exception as e:\n        print(f\"\\nA {component_type} is not available.\")\n\n        if isinstance(e, ModuleNotFoundError):\n            print(f\"\\nInstall module '{e.name}'\")\n        elif isinstance(e, SerialException):\n            print(\"\\nNo physical device detected.\")\n        elif isinstance(e, ValueError) and \"camera_index\" in str(e):\n            print(\"\\nNo physical camera detected.\")\n        else:\n            traceback.print_exc()\n\n        return False", "label": 0}
{"function": "def convert_openai_checkpoint_to_pytorch(openai_checkpoint_folder_path, openai_config_file, pytorch_dump_folder_path):\n    # Construct model\n    if openai_config_file == \"\":\n        config = OpenAIGPTConfig()\n    else:\n        config = OpenAIGPTConfig.from_json_file(openai_config_file)\n    model = OpenAIGPTModel(config)\n\n    # Load weights from numpy\n    load_tf_weights_in_openai_gpt(model, config, openai_checkpoint_folder_path)\n\n    # Save pytorch-model\n    pytorch_weights_dump_path = pytorch_dump_folder_path + '/' + WEIGHTS_NAME\n    pytorch_config_dump_path = pytorch_dump_folder_path + '/' + CONFIG_NAME\n    print(\"Save PyTorch model to {}\".format(pytorch_weights_dump_path))\n    torch.save(model.state_dict(), pytorch_weights_dump_path)\n    print(\"Save configuration file to {}\".format(pytorch_config_dump_path))\n    with open(pytorch_config_dump_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(config.to_json_string())", "label": 1}
{"function": "def try_import() -> Iterator[Callable[[], bool]]:\n    import_success = False\n\n    def check_import() -> bool:\n        return import_success\n\n    try:\n        yield check_import\n    except ImportError:\n        pass\n    else:\n        import_success = True", "label": 0}
{"function": "def test_config_operators():\n    \"\"\" Test the `log_config`, `clear_config`, `add_config` and `get_config` together. It's\n    difficult to test them alone.\n    \"\"\"\n\n    @configurable\n    def configured(arg):\n        pass\n\n    assert len(get_config()) == 0\n    add_config({configured: HParams()})\n    log_config()  # Smoke test\n    assert len(get_config()) == 1\n    clear_config()\n    assert len(get_config()) == 0", "label": 1}
{"function": "def env() -> Iterator[TestEnv]:\n    test_env = TestEnv()\n\n    yield test_env\n\n    test_env.reset()", "label": 0}
{"function": "    def save(self, commit: bool = True) -> Union[bool, Any]:\n        \"\"\"Save the record.\"\"\"\n        db.session.add(self)\n        if commit:\n            db.session.commit()\n        return self", "label": 1}
{"function": "def test_add_text():\n    \"\"\"Test adding text with auto-chunking\"\"\"\n    encoder = MemvidEncoder()\n    text = \"This is a test. \" * 50  # 800 characters\n    \n    encoder.add_text(text, chunk_size=100, overlap=20)\n    assert len(encoder.chunks) > 1\n    assert all(chunk for chunk in encoder.chunks)  # No empty chunks", "label": 0}
{"function": "    def get_last_email_domain(self):\n        \"\"\"Get the domain from the last used email\"\"\"\n        try:\n            if not os.path.exists(self.accounts_file):\n                return None\n            \n            # Only read the last 1KB of data from the file\n            with open(self.accounts_file, 'rb') as f:\n                # Get file size\n                f.seek(0, os.SEEK_END)\n                file_size = f.tell()\n                \n                if file_size == 0:\n                    return None\n                \n                # Determine the number of bytes to read, maximum 1KB\n                read_size = min(1024, file_size)\n                \n                # Move to the appropriate position to start reading\n                f.seek(file_size - read_size)\n                \n                # Read the end data\n                data = f.read(read_size).decode('utf-8', errors='ignore')\n            \n            # Split by lines and search in reverse\n            lines = data.split('\\n')\n            for line in reversed(lines):\n                if line.strip().startswith('Email:'):\n                    email = line.split('Email:')[1].strip()\n                    # Extract domain part (after @)\n                    if '@' in email:\n                        return email.split('@')[1]\n                    return None\n            \n            # If no email is found in the last 1KB\n            return None\n            \n        except Exception as e:\n            error_msg = self.translator.get('account.get_last_email_domain_failed', error=str(e)) if self.translator else f'Failed to get the last used email domain: {str(e)}'\n            print(f\"{Fore.RED}{EMOJI['ERROR']} {error_msg}{Style.RESET_ALL}\")\n            return None", "label": 0}
{"function": "\tdef testBgService(self):\n\t\tbgSvc = self.__failManager._FailManager__bgSvc\n\t\tfailManager2nd = FailManager()\n\t\t# test singleton (same object):\n\t\tbgSvc2 = failManager2nd._FailManager__bgSvc\n\t\tself.assertTrue(id(bgSvc) == id(bgSvc2))\n\t\tbgSvc2 = None\n\t\t# test service :\n\t\tself.assertTrue(bgSvc.service(True, True))\n\t\tself.assertFalse(bgSvc.service())\n\t\t# bypass threshold and time:\n\t\tfor i in range(1, bgSvc._BgService__threshold):\n\t\t\tself.assertFalse(bgSvc.service())\n\t\t# bypass time check:\n\t\tbgSvc._BgService__serviceTime = -0x7fffffff\n\t\tself.assertTrue(bgSvc.service())\n\t\t# bypass threshold and time:\n\t\tbgSvc._BgService__serviceTime = -0x7fffffff\n\t\tfor i in range(1, bgSvc._BgService__threshold):\n\t\t\tself.assertFalse(bgSvc.service())\n\t\tself.assertTrue(bgSvc.service(False, True))\n\t\tself.assertFalse(bgSvc.service(False, True))", "label": 1}
{"function": "def non_max_suppression_handler(converter: TensorFlowConverter, tf_op: \"tf.Operation\"):\n    raise NotImplementedError(f\"[TensorFlowConverter] {tf_op.type} is not supported yet.\")", "label": 1}
{"function": "    def post(self, shared, prep_res, exec_res):\n        shared[\"files\"] = exec_res  # List of (path, content) tuples", "label": 0}
{"function": "def sec_to_hm(t):\n    \"\"\"Convert time in seconds to time in hours, minutes and seconds\n    e.g. 10239 -> (2, 50, 39)\n    \"\"\"\n    t = int(t)\n    s = t % 60\n    t //= 60\n    m = t % 60\n    t //= 60\n    return t, m, s", "label": 1}
{"function": "def SimpleAngle(length=1.0, angle=45.0):\n    newpoints = []\n\n    angle = radians(angle)\n    newpoints.append([length, 0.0, 0.0])\n    newpoints.append([0.0, 0.0, 0.0])\n    newpoints.append([length * cos(angle), length * sin(angle), 0.0])\n\n    return newpoints", "label": 1}
{"function": "    def __init__(self, logger, log_level=logging.INFO):\n        self.terminal = sys.stdout\n        self.logger = logger\n        self.log_level = log_level\n        self.linebuf = ''", "label": 0}
{"function": "def arbiter_server_selector(selection):\n    return selection.with_server_descriptions(\n        [s for s in selection.server_descriptions\n         if s.server_type == SERVER_TYPE.RSArbiter])", "label": 1}
{"function": "    def ENVIRONMENT(self):\n        \"\"\"Environment in which the application is launched.\"\"\"\n        return self.__class__.__name__.lower()", "label": 0}
{"function": "    def __init__(self, real, timeperiod=5, vfactor=0.7):\n        pass", "label": 1}
{"function": "  def _mode(self):\n    mode = (self.alpha - 1.) / self.beta\n    if self.allow_nan_stats:\n      nan = np.array(np.nan, dtype=self.dtype.as_numpy_dtype())\n      return math_ops.select(\n          self.alpha >= 1.,\n          mode,\n          array_ops.fill(self.batch_shape(), nan, name=\"nan\"))\n    else:\n      return control_flow_ops.with_dependencies([\n          check_ops.assert_less(\n              array_ops.ones((), self.dtype),\n              self.alpha,\n              message=\"mode not defined for components of alpha <= 1\"),\n          ], mode)", "label": 1}
{"function": "    def _execute_uv_install(self, package_name: str) -> bool:\n        \"\"\"\n        Execute the uvpackagemanager tool directly to install the missing package.\n        Returns True if installation seems successful (no errors in output), otherwise False.\n        \"\"\"\n        class ToolUseMock:\n            name = \"uvpackagemanager\"\n            input = {\n                \"command\": \"install\",\n                \"packages\": [package_name]\n            }\n\n        result = self._execute_tool(ToolUseMock())\n        if \"Error\" not in result and \"failed\" not in result.lower():\n            self.console.print(\"[green]The package was installed successfully.[/green]\")\n            return True\n        else:\n            self.console.print(f\"[red]Failed to install {package_name}. Output:[/red] {result}\")\n            return False", "label": 0}
{"function": "    def test_atomic_max_nan_location(self):\n        vals = np.random.randint(0, 128, size=(1,1)).astype(np.float64)\n        gold = vals.copy().reshape(1)\n        res = np.zeros(1, np.float64) + np.nan\n        cuda_func = cuda.jit('void(float64[:], float64[:,:])')(atomic_max)\n        cuda_func[1, 1](res, vals)\n\n        np.testing.assert_equal(res, gold)", "label": 1}
{"function": "    def test_from_array_event_value_wrong_5(surv_arrays):\n        event, time = surv_arrays\n        event = numpy.arange(event.shape[0])\n\n        with pytest.raises(ValueError,\n                           match=\"event indicator must be binary\"):\n            Surv.from_arrays(event, time)", "label": 1}
{"function": "    def test_best_model2_alignment_handles_empty_src_sentence(self):\n        # arrange\n        sentence_pair = AlignedSent(TestIBMModel.__TEST_TRG_SENTENCE, [])\n        ibm_model = IBMModel([])\n\n        # act\n        a_info = ibm_model.best_model2_alignment(sentence_pair)\n\n        # assert\n        self.assertEqual(a_info.alignment[1:], (0, 0, 0))\n        self.assertEqual(a_info.cepts, [[1, 2, 3]])", "label": 1}
{"function": "        def wrapper(self):\n            key = id(self), get_ident()\n            if key in repr_running:\n                return fillvalue\n            repr_running.add(key)\n            try:\n                result = user_function(self)\n            finally:\n                repr_running.discard(key)\n            return result", "label": 1}
{"function": "def setup_logging(debug: bool = False):\n    level = logging.DEBUG if debug else logging.INFO\n    logging.basicConfig(\n        level=level,\n        format=\"%(asctime)s - %(levelname)s - %(message)s\",\n        handlers=[logging.StreamHandler(), logging.FileHandler(\"experiment.log\")],\n    )", "label": 0}
{"function": "def temp_directory(tmp_path: Path) -> Path:\n    \"\"\"Create a temporary directory structure for testing repository scanning.\n\n    The structure includes:\n    test_repo/\n    \u251c\u2500\u2500 file1.txt\n    \u251c\u2500\u2500 file2.py\n    \u251c\u2500\u2500 src/\n    \u2502   \u251c\u2500\u2500 subfile1.txt\n    \u2502   \u251c\u2500\u2500 subfile2.py\n    \u2502   \u2514\u2500\u2500 subdir/\n    \u2502       \u251c\u2500\u2500 file_subdir.txt\n    \u2502       \u2514\u2500\u2500 file_subdir.py\n    \u251c\u2500\u2500 dir1/\n    \u2502   \u2514\u2500\u2500 file_dir1.txt\n    \u2514\u2500\u2500 dir2/\n        \u2514\u2500\u2500 file_dir2.txt\n\n    Parameters\n    ----------\n    tmp_path : Path\n        The temporary directory path provided by the ``tmp_path`` fixture.\n\n    Returns\n    -------\n    Path\n        The path to the created ``test_repo`` directory.\n\n    \"\"\"\n    test_dir = tmp_path / \"test_repo\"\n    test_dir.mkdir()\n\n    # Root files\n    (test_dir / \"file1.txt\").write_text(\"Hello World\")\n    (test_dir / \"file2.py\").write_text(\"print('Hello')\")\n\n    # src directory and its files\n    src_dir = test_dir / \"src\"\n    src_dir.mkdir()\n    (src_dir / \"subfile1.txt\").write_text(\"Hello from src\")\n    (src_dir / \"subfile2.py\").write_text(\"print('Hello from src')\")\n\n    # src/subdir and its files\n    subdir = src_dir / \"subdir\"\n    subdir.mkdir()\n    (subdir / \"file_subdir.txt\").write_text(\"Hello from subdir\")\n    (subdir / \"file_subdir.py\").write_text(\"print('Hello from subdir')\")\n\n    # dir1 and its file\n    dir1 = test_dir / \"dir1\"\n    dir1.mkdir()\n    (dir1 / \"file_dir1.txt\").write_text(\"Hello from dir1\")\n\n    # dir2 and its file\n    dir2 = test_dir / \"dir2\"\n    dir2.mkdir()\n    (dir2 / \"file_dir2.txt\").write_text(\"Hello from dir2\")\n\n    return test_dir", "label": 0}
{"function": "    def squash(self, tensor, dim=-1):\n        squared_norm = (tensor ** 2).sum(dim=dim, keepdim=True)\n        scale = squared_norm / (1 + squared_norm)\n        return scale * tensor / torch.sqrt(squared_norm)", "label": 1}
{"function": "    def test_from_store_with_passphrase(self, tdata, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"mitmproxy\", 2048, \"password\")\n        ca.add_cert_file(\"*\", tdata.path(\"mitmproxy/data/mitmproxy.pem\"), \"password\")\n\n        assert ca.get_cert(b\"foo\", [])", "label": 1}
{"function": "        def check_path(got, expected):\n            got = os.path.normpath(got)\n            expected = os.path.normpath(expected)\n            self.assertEqual(got, expected)", "label": 1}
{"function": "    def valInsTime(self, obj):\n        \"\"\"Function to add the minimum of InsertTime\n\n        :param obj: element to add InsertTime\n        \"\"\"\n        values = []\n        for i in self.parModis:\n            values.append(i.retInsertTime())\n        obj.text = self._minval(values)", "label": 1}
{"function": "    def test_get_expired(self):\n        \"\"\"Test retrieving a value that exists but has expired.\"\"\"\n        cache = TimedCache(datetime.timedelta(seconds=10))\n        key, value = \"test_key\", \"test_value\"\n\n        # Set a past expiration time\n        past = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(\n            seconds=1\n        )\n        cache.cache[key] = (value, past)\n\n        # Should return NOT_FOUND\n        assert cache.get(key) is TimedCache.NOT_FOUND", "label": 0}
{"function": "    def _create_new_devbox(self) -> DevboxView:\n        # Note: Runloop connect\n        start_command = get_action_execution_server_startup_command(\n            server_port=self._sandbox_port,\n            plugins=self.plugins,\n            app_config=self.config,\n        )\n\n        # Add some additional commands based on our image\n        # NB: start off as root, action_execution_server will ultimately choose user but expects all context\n        # (ie browser) to be installed as root\n        # Convert start_command list to a single command string with additional setup\n        start_command_str = (\n            'export MAMBA_ROOT_PREFIX=/openhands/micromamba && '\n            'cd /openhands/code && '\n            '/openhands/micromamba/bin/micromamba run -n openhands poetry config virtualenvs.path /openhands/poetry && '\n            + ' '.join(start_command)\n        )\n        entrypoint = f\"sudo bash -c '{start_command_str}'\"\n\n        devbox = self.runloop_api_client.devboxes.create(\n            entrypoint=entrypoint,\n            name=self.sid,\n            environment_variables={'DEBUG': 'true'} if self.config.debug else {},\n            prebuilt='openhands',\n            launch_parameters=LaunchParameters(\n                available_ports=[self._sandbox_port, self._vscode_port],\n                resource_size_request='LARGE',\n                launch_commands=[\n                    f'mkdir -p {self.config.workspace_mount_path_in_sandbox}'\n                ],\n            ),\n            metadata={'container-name': self.container_name},\n        )\n        return self._wait_for_devbox(devbox)", "label": 0}
{"function": "    def testLargePromptHint3(self):\n        local_pdf_path = os.path.join(os.path.dirname(__file__), \"gnarly_pdfs\", \"large_prompt_hint3.pdf\")\n\n        anchor_text = get_anchor_text(local_pdf_path, 2, pdf_engine=\"pdfreport\")\n\n        print(anchor_text)\n        print(len(anchor_text))\n        self.assertLessEqual(len(anchor_text), 4000)", "label": 0}
{"function": "def anyio_backend():\n    return 'asyncio'", "label": 0}
{"function": "def InParentNamespaceStart(builder): builder.StartObject(0)", "label": 1}
{"function": "    def available_partitions(self):\n        partitions = []\n        lags = self._offset_fetcher.get()\n        for partition, lag in six.iteritems(lags):\n            if lag < self._max_next_requests:\n                partitions.append(partition)\n        return partitions", "label": 1}
{"function": "    def set_preferred(self, master, preferred):\n        self.preferred_name[master] = preferred", "label": 1}
{"function": "    def test_debug_mode(self):\n        # this covers the code called when DEBUG is set\n        old_logs_len = len(self.logs)\n        install_module.DEBUG = True\n        try:\n            with captured_stdout():\n                self.test_record()\n        finally:\n            install_module.DEBUG = False\n        self.assertTrue(len(self.logs) > old_logs_len)", "label": 1}
{"function": "def unpack(text):\n    # we do this because `pytest -v .` prints the arguments to console, and we don't\n    # want to print the entire contents of the file, it creates a mess. So here we go.\n    if text.startswith(\"FILE:\"):\n        dirname = os.path.dirname(os.path.abspath(__file__))\n        taylorswift_file = os.path.join(dirname, text[5:])\n        contents = open(taylorswift_file, \"r\", encoding=\"utf-8\").read()\n        return contents\n    else:\n        return text", "label": 0}
{"function": "    def get_tensor(tensor_name):\n        \"\"\"\n        Retrieves a tensor from the cached safetensor files or loads it from disk if not cached.\n\n        Args:\n            tensor_name (str): The name of the tensor to retrieve.\n\n        Returns:\n            torch.Tensor: The retrieved tensor.\n\n        Raises:\n            KeyError: If the tensor does not exist in the safetensor file.\n        \"\"\"\n        file_name = weight_map[tensor_name]\n        if file_name not in loaded_files:\n            file_path = os.path.join(fp8_path, file_name)\n            loaded_files[file_name] = load_file(file_path, device=\"cuda\")\n        return loaded_files[file_name][tensor_name]", "label": 0}
{"function": "def run_owl(question: str, example_module: str) -> Tuple[str, str, str]:\n    \"\"\"Run the OWL system and return results\n\n    Args:\n        question: User question\n        example_module: Example module name to import (e.g., \"run_terminal_zh\" or \"run_deep\")\n\n    Returns:\n        Tuple[...]: Answer, token count, status\n    \"\"\"\n    global CURRENT_PROCESS\n\n    # Validate input\n    if not validate_input(question):\n        logging.warning(\"User submitted invalid input\")\n        return (\n            \"Please enter a valid question\",\n            \"0\",\n            \"\u274c Error: Invalid input question\",\n        )\n\n    try:\n        # Ensure environment variables are loaded\n        load_dotenv(find_dotenv(), override=True)\n        logging.info(\n            f\"Processing question: '{question}', using module: {example_module}\"\n        )\n\n        # Check if the module is in MODULE_DESCRIPTIONS\n        if example_module not in MODULE_DESCRIPTIONS:\n            logging.error(f\"User selected an unsupported module: {example_module}\")\n            return (\n                f\"Selected module '{example_module}' is not supported\",\n                \"0\",\n                \"\u274c Error: Unsupported module\",\n            )\n\n        # Dynamically import target module\n        module_path = f\"examples.{example_module}\"\n        try:\n            logging.info(f\"Importing module: {module_path}\")\n            module = importlib.import_module(module_path)\n        except ImportError as ie:\n            logging.error(f\"Unable to import module {module_path}: {str(ie)}\")\n            return (\n                f\"Unable to import module: {module_path}\",\n                \"0\",\n                f\"\u274c Error: Module {example_module} does not exist or cannot be loaded - {str(ie)}\",\n            )\n        except Exception as e:\n            logging.error(\n                f\"Error occurred while importing module {module_path}: {str(e)}\"\n            )\n            return (\n                f\"Error occurred while importing module: {module_path}\",\n                \"0\",\n                f\"\u274c Error: {str(e)}\",\n            )\n\n        # Check if it contains the construct_society function\n        if not hasattr(module, \"construct_society\"):\n            logging.error(\n                f\"construct_society function not found in module {module_path}\"\n            )\n            return (\n                f\"construct_society function not found in module {module_path}\",\n                \"0\",\n                \"\u274c Error: Module interface incompatible\",\n            )\n\n        # Build society simulation\n        try:\n            logging.info(\"Building society simulation...\")\n            society = module.construct_society(question)\n\n        except Exception as e:\n            logging.error(f\"Error occurred while building society simulation: {str(e)}\")\n            return (\n                f\"Error occurred while building society simulation: {str(e)}\",\n                \"0\",\n                f\"\u274c Error: Build failed - {str(e)}\",\n            )\n\n        # Run society simulation\n        try:\n            logging.info(\"Running society simulation...\")\n            answer, chat_history, token_info = run_society(society)\n            logging.info(\"Society simulation completed\")\n        except Exception as e:\n            logging.error(f\"Error occurred while running society simulation: {str(e)}\")\n            return (\n                f\"Error occurred while running society simulation: {str(e)}\",\n                \"0\",\n                f\"\u274c Error: Run failed - {str(e)}\",\n            )\n\n        # Safely get token count\n        if not isinstance(token_info, dict):\n            token_info = {}\n\n        completion_tokens = token_info.get(\"completion_token_count\", 0)\n        prompt_tokens = token_info.get(\"prompt_token_count\", 0)\n        total_tokens = completion_tokens + prompt_tokens\n\n        logging.info(\n            f\"Processing completed, token usage: completion={completion_tokens}, prompt={prompt_tokens}, total={total_tokens}\"\n        )\n\n        return (\n            answer,\n            f\"Completion tokens: {completion_tokens:,} | Prompt tokens: {prompt_tokens:,} | Total: {total_tokens:,}\",\n            \"\u2705 Successfully completed\",\n        )\n\n    except Exception as e:\n        logging.error(\n            f\"Uncaught error occurred while processing the question: {str(e)}\"\n        )\n        return (f\"Error occurred: {str(e)}\", \"0\", f\"\u274c Error: {str(e)}\")", "label": 0}
{"function": "    def test_repo_clearfilters_not_interactive(self, shell):\n        \"\"\"\n        Test do_repo_clearfilters not interactive.\n\n        :param shell:\n        :return:\n        \"\"\"\n        shell.help_repo_clearfilters = MagicMock()\n        shell.client.channel.software.clearRepoFilters = MagicMock()\n        shell.user_confirm = MagicMock(return_value=False)\n        mprint = MagicMock()\n        logger = MagicMock()\n\n        with patch(\"spacecmd.repo.print\", mprint) as prn, \\\n                patch(\"spacecmd.repo.logging\", logger) as lgr:\n            out = spacecmd.repo.do_repo_clearfilters(shell, \"repo --yes\")\n\n        assert out is 0\n        assert not mprint.called\n        assert not shell.help_repo_clearfilters.called\n        assert not logger.error.called\n        assert shell.client.channel.software.clearRepoFilters.called", "label": 1}
{"function": "            def callback(d):\n                preview = d['denoised']\n                preview = vae_decode_fake(preview)\n\n                preview = (preview * 255.0).detach().cpu().numpy().clip(0, 255).astype(np.uint8)\n                preview = einops.rearrange(preview, 'b c t h w -> (b h) (t w) c')\n\n                if stream.input_queue.top() == 'end':\n                    stream.output_queue.push(('end', None))\n                    raise KeyboardInterrupt('User ends the task.')\n\n                current_step = d['i'] + 1\n                percentage = int(100.0 * current_step / steps)\n                hint = f'Sampling {current_step}/{steps}'\n                desc = f'Total generated frames: {int(max(0, total_generated_latent_frames * 4 - 3))}, Video length: {max(0, (total_generated_latent_frames * 4 - 3) / 30) :.2f} seconds (FPS-30). The video is being extended now ...'\n                stream.output_queue.push(('progress', (preview, desc, make_progress_bar_html(percentage, hint))))\n                return", "label": 0}
{"function": "    def test_add_tool_with_pydantic_model(self):\n        \"\"\"Test adding a tool with an explicit Pydantic model.\"\"\"\n        self.tool_manager._add_tool(get_current_temperature, TemperatureParams)\n\n        expected_tool_spec = [\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"get_current_temperature\",\n                    \"description\": \"Gets the current temperature for a specific location and unit.\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"location\": {\n                                \"type\": \"string\",\n                                \"description\": \"\",\n                            },\n                            \"unit\": {\n                                \"type\": \"string\",\n                                \"description\": \"\",\n                                \"default\": \"Celsius\",\n                            },\n                        },\n                        \"required\": [\"location\"],\n                    },\n                },\n            }\n        ]\n\n        tools = self.tool_manager.tools()\n        self.assertIn(\n            \"get_current_temperature\", [tool[\"function\"][\"name\"] for tool in tools]\n        )\n        assert (\n            tools == expected_tool_spec\n        ), f\"Expected {expected_tool_spec}, but got {tools}\"", "label": 0}
{"function": "def worker(input_image, prompt, n_prompt, seed, total_second_length, latent_window_size, steps, cfg, gs, rs, gpu_memory_preservation, use_teacache, mp4_crf):\n    total_latent_sections = (total_second_length * 30) / (latent_window_size * 4)\n    total_latent_sections = int(max(round(total_latent_sections), 1))\n\n    job_id = generate_timestamp()\n\n    stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'Starting ...'))))\n\n    try:\n        # Clean GPU\n        if not high_vram:\n            unload_complete_models(\n                text_encoder, text_encoder_2, image_encoder, vae, transformer\n            )\n\n        # Text encoding\n\n        stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'Text encoding ...'))))\n\n        if not high_vram:\n            fake_diffusers_current_device(text_encoder, gpu)  # since we only encode one text - that is one model move and one encode, offload is same time consumption since it is also one load and one encode.\n            load_model_as_complete(text_encoder_2, target_device=gpu)\n\n        llama_vec, clip_l_pooler = encode_prompt_conds(prompt, text_encoder, text_encoder_2, tokenizer, tokenizer_2)\n\n        if cfg == 1:\n            llama_vec_n, clip_l_pooler_n = torch.zeros_like(llama_vec), torch.zeros_like(clip_l_pooler)\n        else:\n            llama_vec_n, clip_l_pooler_n = encode_prompt_conds(n_prompt, text_encoder, text_encoder_2, tokenizer, tokenizer_2)\n\n        llama_vec, llama_attention_mask = crop_or_pad_yield_mask(llama_vec, length=512)\n        llama_vec_n, llama_attention_mask_n = crop_or_pad_yield_mask(llama_vec_n, length=512)\n\n        # Processing input image\n\n        stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'Image processing ...'))))\n\n        H, W, C = input_image.shape\n        height, width = find_nearest_bucket(H, W, resolution=640)\n        input_image_np = resize_and_center_crop(input_image, target_width=width, target_height=height)\n\n        Image.fromarray(input_image_np).save(os.path.join(outputs_folder, f'{job_id}.png'))\n\n        input_image_pt = torch.from_numpy(input_image_np).float() / 127.5 - 1\n        input_image_pt = input_image_pt.permute(2, 0, 1)[None, :, None]\n\n        # VAE encoding\n\n        stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'VAE encoding ...'))))\n\n        if not high_vram:\n            load_model_as_complete(vae, target_device=gpu)\n\n        start_latent = vae_encode(input_image_pt, vae)\n\n        # CLIP Vision\n\n        stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'CLIP Vision encoding ...'))))\n\n        if not high_vram:\n            load_model_as_complete(image_encoder, target_device=gpu)\n\n        image_encoder_output = hf_clip_vision_encode(input_image_np, feature_extractor, image_encoder)\n        image_encoder_last_hidden_state = image_encoder_output.last_hidden_state\n\n        # Dtype\n\n        llama_vec = llama_vec.to(transformer.dtype)\n        llama_vec_n = llama_vec_n.to(transformer.dtype)\n        clip_l_pooler = clip_l_pooler.to(transformer.dtype)\n        clip_l_pooler_n = clip_l_pooler_n.to(transformer.dtype)\n        image_encoder_last_hidden_state = image_encoder_last_hidden_state.to(transformer.dtype)\n\n        # Sampling\n\n        stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'Start sampling ...'))))\n\n        rnd = torch.Generator(\"cpu\").manual_seed(seed)\n\n        history_latents = torch.zeros(size=(1, 16, 16 + 2 + 1, height // 8, width // 8), dtype=torch.float32).cpu()\n        history_pixels = None\n\n        history_latents = torch.cat([history_latents, start_latent.to(history_latents)], dim=2)\n        total_generated_latent_frames = 1\n\n        for section_index in range(total_latent_sections):\n            if stream.input_queue.top() == 'end':\n                stream.output_queue.push(('end', None))\n                return\n\n            print(f'section_index = {section_index}, total_latent_sections = {total_latent_sections}')\n\n            if not high_vram:\n                unload_complete_models()\n                move_model_to_device_with_memory_preservation(transformer, target_device=gpu, preserved_memory_gb=gpu_memory_preservation)\n\n            if use_teacache:\n                transformer.initialize_teacache(enable_teacache=True, num_steps=steps)\n            else:\n                transformer.initialize_teacache(enable_teacache=False)\n\n            def callback(d):\n                preview = d['denoised']\n                preview = vae_decode_fake(preview)\n\n                preview = (preview * 255.0).detach().cpu().numpy().clip(0, 255).astype(np.uint8)\n                preview = einops.rearrange(preview, 'b c t h w -> (b h) (t w) c')\n\n                if stream.input_queue.top() == 'end':\n                    stream.output_queue.push(('end', None))\n                    raise KeyboardInterrupt('User ends the task.')\n\n                current_step = d['i'] + 1\n                percentage = int(100.0 * current_step / steps)\n                hint = f'Sampling {current_step}/{steps}'\n                desc = f'Total generated frames: {int(max(0, total_generated_latent_frames * 4 - 3))}, Video length: {max(0, (total_generated_latent_frames * 4 - 3) / 30) :.2f} seconds (FPS-30). The video is being extended now ...'\n                stream.output_queue.push(('progress', (preview, desc, make_progress_bar_html(percentage, hint))))\n                return\n\n            indices = torch.arange(0, sum([1, 16, 2, 1, latent_window_size])).unsqueeze(0)\n            clean_latent_indices_start, clean_latent_4x_indices, clean_latent_2x_indices, clean_latent_1x_indices, latent_indices = indices.split([1, 16, 2, 1, latent_window_size], dim=1)\n            clean_latent_indices = torch.cat([clean_latent_indices_start, clean_latent_1x_indices], dim=1)\n\n            clean_latents_4x, clean_latents_2x, clean_latents_1x = history_latents[:, :, -sum([16, 2, 1]):, :, :].split([16, 2, 1], dim=2)\n            clean_latents = torch.cat([start_latent.to(history_latents), clean_latents_1x], dim=2)\n\n            generated_latents = sample_hunyuan(\n                transformer=transformer,\n                sampler='unipc',\n                width=width,\n                height=height,\n                frames=latent_window_size * 4 - 3,\n                real_guidance_scale=cfg,\n                distilled_guidance_scale=gs,\n                guidance_rescale=rs,\n                # shift=3.0,\n                num_inference_steps=steps,\n                generator=rnd,\n                prompt_embeds=llama_vec,\n                prompt_embeds_mask=llama_attention_mask,\n                prompt_poolers=clip_l_pooler,\n                negative_prompt_embeds=llama_vec_n,\n                negative_prompt_embeds_mask=llama_attention_mask_n,\n                negative_prompt_poolers=clip_l_pooler_n,\n                device=gpu,\n                dtype=torch.bfloat16,\n                image_embeddings=image_encoder_last_hidden_state,\n                latent_indices=latent_indices,\n                clean_latents=clean_latents,\n                clean_latent_indices=clean_latent_indices,\n                clean_latents_2x=clean_latents_2x,\n                clean_latent_2x_indices=clean_latent_2x_indices,\n                clean_latents_4x=clean_latents_4x,\n                clean_latent_4x_indices=clean_latent_4x_indices,\n                callback=callback,\n            )\n\n            total_generated_latent_frames += int(generated_latents.shape[2])\n            history_latents = torch.cat([history_latents, generated_latents.to(history_latents)], dim=2)\n\n            if not high_vram:\n                offload_model_from_device_for_memory_preservation(transformer, target_device=gpu, preserved_memory_gb=8)\n                load_model_as_complete(vae, target_device=gpu)\n\n            real_history_latents = history_latents[:, :, -total_generated_latent_frames:, :, :]\n\n            if history_pixels is None:\n                history_pixels = vae_decode(real_history_latents, vae).cpu()\n            else:\n                section_latent_frames = latent_window_size * 2\n                overlapped_frames = latent_window_size * 4 - 3\n\n                current_pixels = vae_decode(real_history_latents[:, :, -section_latent_frames:], vae).cpu()\n                history_pixels = soft_append_bcthw(history_pixels, current_pixels, overlapped_frames)\n\n            if not high_vram:\n                unload_complete_models()\n\n            output_filename = os.path.join(outputs_folder, f'{job_id}_{total_generated_latent_frames}.mp4')\n\n            save_bcthw_as_mp4(history_pixels, output_filename, fps=30, crf=mp4_crf)\n\n            print(f'Decoded. Current latent shape {real_history_latents.shape}; pixel shape {history_pixels.shape}')\n\n            stream.output_queue.push(('file', output_filename))\n    except:\n        traceback.print_exc()\n\n        if not high_vram:\n            unload_complete_models(\n                text_encoder, text_encoder_2, image_encoder, vae, transformer\n            )\n\n    stream.output_queue.push(('end', None))\n    return", "label": 0}
{"function": "    def producer(self):\n        partitioner = Crc32NamePartitioner(self._partitions) if self._hostname_partitioning \\\n            else FingerprintPartitioner(self._partitions)\n        return KeyedProducer(self._location, self._enable_ssl, self._cert_path, self._topic, partitioner, self._codec,\n                             batch_size=DEFAULT_BATCH_SIZE,\n                             buffer_memory=DEFAULT_BUFFER_MEMORY)", "label": 1}
{"function": "def reset():\n    # Reset the assistant's conversation history\n    assistant.reset()\n    return jsonify({'status': 'success'})", "label": 0}
{"function": "    def test_fields_under_root(self):\n        \"\"\"\n        wineventlog - Add tags and custom fields under root\n        \"\"\"\n        msg = \"Add tags and fields under root\"\n        self.write_event_log(msg)\n        evts = self.read_events(config={\n            \"tags\": [\"global\"],\n            \"fields\": {\"global\": \"field\", \"env\": \"prod\", \"log.level\": \"overwrite\"},\n            \"fields_under_root\": True,\n            \"event_logs\": [\n                {\n                    \"name\": self.providerName,\n                    \"api\": self.api,\n                    \"tags\": [\"local\"],\n                    \"fields_under_root\": True,\n                    \"fields\": {\"local\": \"field\", \"env\": \"dev\"}\n                }\n            ]\n        })\n        self.assertTrue(len(evts), 1)\n        self.assert_common_fields(evts[0], msg=msg, level=\"overwrite\", extra={\n            \"winlog.keywords\": [\"Classic\"],\n            \"winlog.opcode\": \"Info\",\n            \"global\": \"field\",\n            \"env\": \"dev\",\n            \"local\": \"field\",\n            \"tags\": [\"global\", \"local\"],\n        })", "label": 1}
{"function": "    def writeVars(self):\n        varDictNew = self.varDict\n        self.loadVars()\n        if self.varDict:  # \u5982\u679c\u6587\u4ef6\u4e2d\u53d8\u91cf\u4e0d\u4e3a\u7a7a\uff0c\u66f4\u65b0\u53d8\u91cf\u503c\n            self.srctext = re.sub(r'[$](\\w+)\\s*=[ \\t]*([#(),.\\w]*)[\\t ]*[;]?',\n                                  lambda m: '${} = {};'.format(m.group(1), varDictNew.get(m.group(1), \"\")),\n                                  self.srctext)\n            if self.varUndefined:  # \u5728\u7b2c\u4e00\u7684\u53d8\u91cf\u5904\u63d2\u5165\u591a\u51fa\u6765\u7684\u53d8\u91cf,\u5f15\u7528\u6bd4\u5b9a\u4e49\u7684\u53d8\u91cf\u591a\u7684\u65f6\u5019\u56de\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\n                s = ''\n                for var, val in varDictNew.items():\n                    if var in self.varUndefined:\n                        s += \"$\" + var + \" = \" + val + \";\\n\"\n                self.srctext = re.sub(r'[$](\\w+)\\s*=[ \\t]*([#(),.\\w]*)[\\t ]*[;]?', r'{}$\\1 = \\2;\\n'.format(s),\n                                      self.srctext, 1)\n        else:\n            s = ''\n            for var, val in varDictNew.items():\n                s += \"$\" + var + \" = \" + val + \";\\n\"\n            s += '\\n'\n            self.srctext = s + self.srctext\n        self.loadVars()", "label": 1}
{"function": "def _get_musa_home():\n    return os.environ.get('MUSA_HOME')", "label": 0}
{"function": "def save_json_file(file_path: str, data: dict) -> None:\n    with open(file_path, 'w', encoding='utf-8') as file:\n        json.dump(data, file, ensure_ascii=False, indent=2)", "label": 0}
{"function": "def copy_from_shm(file: str):\n    tmp_dir = \"/dev/shm/\"\n    fd, tmp_path = tempfile.mkstemp(dir=tmp_dir)\n    try:\n        yield tmp_path\n        shutil.copyfile(tmp_path, file)\n    finally:\n        os.remove(tmp_path)\n        os.close(fd)", "label": 0}
{"function": "def test__get_function_default_kwargs__arg_kwarg():\n    \"\"\" Test if `_get_function_default_kwargs` handles a kwarg, arg, args, and kwargs. \"\"\"\n\n    def func(arg, *args, kwarg=None, **kwargs):\n        pass\n\n    assert list(_get_function_default_kwargs(func).keys()) == ['kwarg']", "label": 1}
{"function": "    def clean_up(self):\n        del self.alive_nodes, self.min_sample_split, self.min_child_weight, self.rowsample,\\\n            self.colsample, self.max_depth, self.reg_lambda, self.gamma", "label": 1}
{"function": "def find_nfort(conf):\n\tfc=conf.find_program(['nfort'],var='FC')\n\tconf.get_nfort_version(fc)\n\tconf.env.FC_NAME='NFORT'\n\tconf.env.FC_MOD_CAPITALIZATION='lower'", "label": 1}
{"function": "    def __init__(self, messagebus):\n        super(StatsLogStream, self).__init__(messagebus)\n        self._topic = messagebus.topic_stats\n        self._group = messagebus.statslog_reader_group", "label": 1}
{"function": "    def __init__(self, need_search, title, description, step_type):\n        self.need_search = need_search\n        self.title = title\n        self.description = description\n        self.step_type = step_type", "label": 0}
{"function": "def enable_debugging():\n    set_log_level(logging.DEBUG)", "label": 1}
{"function": "    def next_state(self, c):\n        # for each byte we get its class\n        # if it is first byte, we also get byte length\n        # PY3K: aBuf is a byte stream, so c is an int, not a byte\n        byteCls = self._mModel['classTable'][wrap_ord(c)]\n        if self._mCurrentState == eStart:\n            self._mCurrentBytePos = 0\n            self._mCurrentCharLen = self._mModel['charLenTable'][byteCls]\n        # from byte's class and stateTable, we get its next state\n        curr_state = (self._mCurrentState * self._mModel['classFactor']\n                      + byteCls)\n        self._mCurrentState = self._mModel['stateTable'][curr_state]\n        self._mCurrentBytePos += 1\n        return self._mCurrentState", "label": 1}
{"function": "    def valRangeTime(self, obj):\n        \"\"\"Function to add RangeDateTime\n\n        :param obj: element to add RangeDateTime\n        \"\"\"\n        values = []\n        for i in self.parModis:\n            values.append(i.retRangeTime())\n        self._cicle_values(obj, self._checkvaldict(values))", "label": 1}
{"function": "    def close(self):\n        \"\"\"Immediately unwind the context stack\"\"\"\n        self.__exit__(None, None, None)", "label": 1}
{"function": "def sample_top_p(probs, p):\n    \"\"\"\n    Perform top-p (nucleus) sampling on a probability distribution.\n\n    Args:\n        probs (torch.Tensor): Probability distribution tensor.\n        p (float): Probability threshold for top-p sampling.\n\n    Returns:\n        torch.Tensor: Sampled token indices.\n\n    Note:\n        Top-p sampling selects the smallest set of tokens whose cumulative probability mass\n        exceeds the threshold p. The distribution is renormalized based on the selected tokens.\n    \"\"\"\n    probs_sort, probs_idx = torch.sort(probs, dim=-1, descending=True)\n    probs_sum = torch.cumsum(probs_sort, dim=-1)\n    mask = probs_sum - probs_sort > p\n    probs_sort[mask] = 0.0\n    probs_sort.div_(probs_sort.sum(dim=-1, keepdim=True))\n    next_token = torch.multinomial(probs_sort, num_samples=1)\n    next_token = torch.gather(probs_idx, -1, next_token)\n    return next_token", "label": 0}
{"function": "def right_mark_index(pinyin_no_number: Text) -> int: ...", "label": 1}
{"function": "    def test_get_navigation_signal_given_dtype(self):\n        s = self.signal\n        assert s._get_navigation_signal(dtype=\"bool\").data.dtype.name == \"bool\"", "label": 1}
{"function": "    async def play_audio_stream():\n        nonlocal first_chunk_time\n        p = pyaudio.PyAudio()\n        stream = p.open(format=pyaudio.paFloat32, channels=1, rate=24000, output=True, frames_per_buffer=2048)\n\n        try:\n            while True:\n                data = await asyncio.get_event_loop().run_in_executor(None, client_socket.recv, 8192)\n                if not data:\n                    break\n                if data == b\"END\":\n                    logger.info(\"End of audio received.\")\n                    break\n\n                audio_array = np.frombuffer(data, dtype=np.float32)\n                stream.write(audio_array.tobytes())\n\n                if first_chunk_time is None:\n                    first_chunk_time = time.time()\n\n        finally:\n            stream.stop_stream()\n            stream.close()\n            p.terminate()\n\n        logger.info(f\"Total time taken: {time.time() - start_time:.4f} seconds\")", "label": 0}
{"function": "def env():\n    return DjangoEnv()", "label": 1}
{"function": "    def barrier(self):\n        return self.value.barrier", "label": 1}
{"function": "def getbufsize():\n    \"\"\"\n    Return the size of the buffer used in ufuncs.\n\n    Returns\n    -------\n    getbufsize : int\n        Size of ufunc buffer in bytes.\n\n    \"\"\"\n    return umath.geterrobj()[0]", "label": 1}
{"function": "    def test_mean(self):\n        self.check('CAN15/GMPEtInterface_high_combo.csv',\n                   max_discrep_percentage=100.)", "label": 1}
{"function": "    def forward(self, x):\n        hx = x\n\n        hxin = self.rebnconvin(hx)\n\n        hx1 = self.rebnconv1(hxin)\n        hx = self.pool1(hx1)\n\n        hx2 = self.rebnconv2(hx)\n        hx = self.pool2(hx2)\n\n        hx3 = self.rebnconv3(hx)\n        hx = self.pool3(hx3)\n\n        hx4 = self.rebnconv4(hx)\n        hx = self.pool4(hx4)\n\n        hx5 = self.rebnconv5(hx)\n\n        hx6 = self.rebnconv6(hx5)\n\n        hx5d = self.rebnconv5d(torch.cat((hx6, hx5), 1))\n        hx5dup = _upsample_like(hx5d, hx4)\n\n        hx4d = self.rebnconv4d(torch.cat((hx5dup, hx4), 1))\n        hx4dup = _upsample_like(hx4d, hx3)\n\n        hx3d = self.rebnconv3d(torch.cat((hx4dup, hx3), 1))\n        hx3dup = _upsample_like(hx3d, hx2)\n\n        hx2d = self.rebnconv2d(torch.cat((hx3dup, hx2), 1))\n        hx2dup = _upsample_like(hx2d, hx1)\n\n        hx1d = self.rebnconv1d(torch.cat((hx2dup, hx1), 1))\n\n        return hx1d + hxin", "label": 0}
{"function": "def detection_predictor() -> DetectionPredictor:\n    detection_predictor = DetectionPredictor()\n    yield detection_predictor\n    del detection_predictor", "label": 0}
{"function": "def smooth(img):\n    def smooth_pix(img, tx, ty):\n        if tx == args.divide * width - 1 or ty == args.divide * width - 1 or tx == 0 or ty == 0: \n            return img\n        img[tx, ty] = (img[tx, ty] + img[tx + 1, ty] + img[tx, ty + 1] + img[tx - 1, ty] + img[tx, ty - 1] + img[tx + 1, ty - 1] + img[tx - 1, ty + 1] + img[tx - 1, ty - 1] + img[tx + 1, ty + 1]) / 9\n        return img\n\n    for p in range(args.divide):\n        for q in range(args.divide):\n            x = p * width\n            y = q * width\n            for k in range(width):\n                img = smooth_pix(img, x + k, y + width - 1)\n                if q != args.divide - 1:\n                    img = smooth_pix(img, x + k, y + width)\n            for k in range(width):\n                img = smooth_pix(img, x + width - 1, y + k)\n                if p != args.divide - 1:\n                    img = smooth_pix(img, x + width, y + k)\n    return img", "label": 1}
{"function": "    def setup_connections(self):\n        # \u6279\u5904\u7406\u7ebf\u7a0b\u4fe1\u53f7\u8fde\u63a5\n        self.batch_thread.task_progress.connect(self.update_task_progress)\n        self.batch_thread.task_error.connect(self.on_task_error)\n        self.batch_thread.task_completed.connect(self.on_task_completed)\n\n        # \u8868\u683c\u53f3\u952e\u83dc\u5355\n        self.task_table.setContextMenuPolicy(Qt.CustomContextMenu)\n        self.task_table.customContextMenuRequested.connect(self.show_context_menu)", "label": 0}
{"function": "def _find_all(a_str: str, sub: str):\n    start = 0\n    while True:\n        start = a_str.find(sub, start)\n        if start == -1:\n            return\n        yield start\n        start += len(sub)", "label": 0}
{"function": "    def __call__(self, doc):\n        \"\"\"Clean the document.\"\"\"\n        if hasattr(doc, 'getroot'):\n            doc = doc.getroot()\n\n        if self.fix_whitespace:\n            # Ensure newlines around block elements\n            for el in doc.iterdescendants():\n                if el.tag in BLOCK_ELEMENTS:\n                    el.tail = (el.tail or '') + '\\n'\n                    previous = el.getprevious()\n                    parent = el.getparent()\n                    if previous is None:\n                        parent.text = (parent.text or '') + '\\n'\n                    else:\n                        previous.tail = (previous.tail or '') + '\\n'\n\n        # Remove elements that match kill_xpath\n        if self.kill_xpath:\n            for el in doc.xpath(self.kill_xpath, namespaces=self.namespaces):\n                #log.debug('Killing: %s' % tostring(el))\n                parent = el.getparent()\n                # We can't kill the root element!\n                if parent is None:\n                    continue\n                if el.tail:\n                    previous = el.getprevious()\n                    if previous is None:\n                        parent.text = (parent.text or '') + el.tail\n                    else:\n                        previous.tail = (previous.tail or '') + el.tail\n                parent.remove(el)\n\n        # Collect all the allowed elements\n        to_keep = [el for el in doc.xpath(self.allow_xpath, namespaces=self.namespaces)] if self.allow_xpath else []\n\n        # Replace elements that match strip_xpath with their contents\n        if self.strip_xpath:\n            for el in doc.xpath(self.strip_xpath, namespaces=self.namespaces):\n                # Skip if allowed by allow_xpath\n                if el in to_keep:\n                    continue\n                parent = el.getparent()\n                previous = el.getprevious()\n                # We can't strip the root element!\n                if parent is None:\n                    continue\n                # Append the text to previous tail (or parent text if no previous), ensuring newline if block level\n                if el.text and isinstance(el.tag, six.string_types):\n                    if previous is None:\n                        parent.text = (parent.text or '') + el.text\n                    else:\n                        previous.tail = (previous.tail or '') + el.text\n                # Append the tail to last child tail, or previous tail, or parent text, ensuring newline if block level\n                if el.tail:\n                    if len(el):\n                        last = el[-1]\n                        last.tail = (last.tail or '') + el.tail\n                    elif previous is None:\n                        parent.text = (parent.text or '') + el.tail\n                    else:\n                        previous.tail = (previous.tail or '') + el.tail\n                index = parent.index(el)\n                parent[index:index+1] = el[:]\n\n        # Collapse whitespace down to a single space or a single newline\n        if self.fix_whitespace:\n            for el in doc.iter():\n                if el.text is not None:\n                    el.text = re.sub(r'\\s*\\n\\s*', '\\n', el.text)\n                    el.text = re.sub(r'[ \\t]+', ' ', el.text)\n                    # el.text = re.sub(r'\\s+', ' ', el.text)\n                if el.tail is not None:\n                    el.tail = re.sub(r'\\s*\\n\\s*', '\\n', el.tail)\n                    el.tail = re.sub(r'[ \\t]+', ' ', el.tail)", "label": 1}
{"function": "def ask_internet(query:str,  debug=False):\n  \n    content_list = search_web_ref(query,debug=debug)\n    if debug:\n        print(content_list)\n    prompt = gen_prompt(query,content_list,context_length_limit=6000,debug=debug)\n    total_token =  \"\"\n \n    for token in chat(prompt=prompt):\n    # for token in daxianggpt.chat(prompt=prompt):\n        if token:\n            total_token += token\n            yield token\n    yield \"\\n\\n\"\n    # \u662f\u5426\u8fd4\u56de\u53c2\u8003\u8d44\u6599\n    if True:\n        yield \"---\"\n        yield \"\\n\"\n        yield \"\u53c2\u8003\u8d44\u6599:\\n\"\n        count = 1\n        for url_content in content_list:\n            url = url_content.get('url')\n            yield \"*[{}. {}]({})*\".format(str(count),url,url )  \n            yield \"\\n\"\n            count += 1", "label": 0}
{"function": "async def test_echo():\n    \"\"\"Test the echo server\"\"\"\n    from examples.echo import mcp\n\n    async with Client(mcp) as client:\n        result = await client.call_tool_mcp(\"echo_tool\", {\"text\": \"hello\"})\n        assert len(result.content) == 1\n        assert result.content[0].text == \"hello\"  # type: ignore[attr-defined]\n\n    async with Client(mcp) as client:\n        result = await client.read_resource(AnyUrl(\"echo://static\"))\n        assert len(result) == 1\n        assert result[0].text == \"Echo!\"  # type: ignore[attr-defined]\n\n    async with Client(mcp) as client:\n        result = await client.read_resource(AnyUrl(\"echo://server42\"))\n        assert len(result) == 1\n        assert result[0].text == \"Echo: server42\"  # type: ignore[attr-defined]\n\n    async with Client(mcp) as client:\n        result = await client.get_prompt(\"echo\", {\"text\": \"hello\"})\n        assert len(result.messages) == 1\n        assert result.messages[0].content.text == \"hello\"  # type: ignore[attr-defined]", "label": 0}
{"function": "def main():\n    logger.info(\"\u5e94\u7528\u7a0b\u5e8f\u542f\u52a8\")\n    # \u4fa7\u8fb9\u680f\u8bbe\u8ba1\n    st.sidebar.markdown(\n        \"\"\"\n    # \ud83c\udfa5 \u5361\u5361\u5b57\u5e55\u52a9\u624b\n    ---\n    ### \ud83d\udee0\ufe0f \u529f\u80fd\u5217\u8868\n    \"\"\"\n    )\n\n    # \u521b\u5efa\u7f8e\u5316\u540e\u7684\u5bfc\u822a\u9009\u9879\n    page = st.sidebar.radio(\"\", options=[\"\ud83c\udfaf ASR \u5b57\u5e55\u8bc6\u522b\", \"\ud83c\udf0f \u5b57\u5e55\u7ffb\u8bd1\"], index=0)\n\n    logger.info(f\"\u7528\u6237\u9009\u62e9\u9875\u9762: {page}\")\n    # \u6839\u636e\u9009\u62e9\u663e\u793a\u4e0d\u540c\u7684\u9875\u9762\n    if \"ASR\" in page:\n        asr_page()\n    else:\n        translation_page()", "label": 0}
{"function": "    def text_completion(\n        self,\n        prompts: List[str],\n        temperature: float = 0.6,\n        top_p: float = 0.9,\n        max_gen_len: Optional[int] = None,\n        logprobs: bool = False,\n        echo: bool = False,\n    ) -> List[CompletionPrediction]:\n        \"\"\"\n        Perform text completion for a list of prompts using the language generation model.\n\n        Args:\n            prompts (List[str]): List of text prompts for completion.\n            temperature (float, optional): Temperature value for controlling randomness in sampling. Defaults to 0.6.\n            top_p (float, optional): Top-p probability threshold for nucleus sampling. Defaults to 0.9.\n            max_gen_len (Optional[int], optional): Maximum length of the generated completion sequence.\n                If not provided, it's set to the model's maximum sequence length minus 1.\n            logprobs (bool, optional): Flag indicating whether to compute token log probabilities. Defaults to False.\n            echo (bool, optional): Flag indicating whether to include prompt tokens in the generated output. Defaults to False.\n\n        Returns:\n            List[CompletionPrediction]: List of completion predictions, each containing the generated text completion.\n\n        Note:\n            This method generates text completions for the provided prompts, employing nucleus sampling to introduce controlled randomness.\n            If logprobs is True, token log probabilities are computed for each generated token.\n\n        \"\"\"\n        if max_gen_len is None:\n            max_gen_len = self.model.params.max_seq_len - 1\n        prompt_tokens = [self.tokenizer.encode(x, bos=True, eos=False) for x in prompts]\n        generation_tokens, generation_logprobs = self.generate(\n            prompt_tokens=prompt_tokens,\n            max_gen_len=max_gen_len,\n            temperature=temperature,\n            top_p=top_p,\n            logprobs=logprobs,\n            echo=echo,\n        )\n        if logprobs:\n            return [\n                {\n                    \"generation\": self.tokenizer.decode(t),\n                    \"tokens\": [self.tokenizer.decode([x]) for x in t],\n                    \"logprobs\": logprobs_i,\n                }\n                for t, logprobs_i in zip(generation_tokens, generation_logprobs)\n            ]\n        return [{\"generation\": self.tokenizer.decode(t)} for t in generation_tokens]", "label": 0}
{"function": "    def child_right(ind):\n        # Calculate second child position for given index\n        return ind*2 + 1", "label": 1}
{"function": "    def install_requirements():\n        console.print(Panel(t(\"Installing project in editable mode using `pip install -e .`\"), style=\"cyan\"))\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"-e\", \".\"], env={**os.environ, \"PIP_NO_CACHE_DIR\": \"0\", \"PYTHONIOENCODING\": \"utf-8\"})", "label": 0}
{"function": "def initialize() -> SessionVariables:\n    \"\"\"Initialize app logic.\"\"\"\n    if \"session_variables\" not in st.session_state:\n        st.set_page_config(\n            layout=\"wide\",\n            initial_sidebar_state=\"collapsed\",\n            page_title=\"GraphRAG\",\n        )\n        sv = SessionVariables()\n        datasets = load_dataset_listing()\n        sv.datasets.value = datasets\n        sv.dataset.value = (\n            st.query_params[\"dataset\"].lower()\n            if \"dataset\" in st.query_params\n            else datasets[0].key\n        )\n        load_dataset(sv.dataset.value, sv)\n        st.session_state[\"session_variables\"] = sv\n    return st.session_state[\"session_variables\"]", "label": 0}
{"function": "    def __init__(self, enter_result=None):\n        self.enter_result = enter_result", "label": 1}
{"function": "    def testExtractText(self):\n        local_pdf_path = os.path.join(os.path.dirname(__file__), \"gnarly_pdfs\", \"some_ocr1.pdf\")\n        reader = PdfReader(local_pdf_path)\n        page = reader.pages[0]\n\n        def visitor_body(text, cm, tm, font_dict, font_size):\n            print(repr(text), cm, tm, font_size)\n\n        def visitor_op(op, args, cm, tm):\n            # print(op, args, cm, tm)\n            pass\n\n        page.extract_text(visitor_text=visitor_body, visitor_operand_before=visitor_op)", "label": 0}
{"function": "def norm_spec(x):\r\n    return (x - spec_min) / (spec_max - spec_min) * 2 - 1\r", "label": 0}
{"function": "async def run_basic_search(\n    query: str,\n    sv: SessionVariables,\n) -> SearchResult:\n    \"\"\"Run basic search.\"\"\"\n    print(f\"Basic search query: {query}\")  # noqa T201\n\n    # build local search engine\n    response_placeholder = st.session_state[\n        f\"{SearchType.Basic.value.lower()}_response_placeholder\"\n    ]\n    response_container = st.session_state[f\"{SearchType.Basic.value.lower()}_container\"]\n\n    with response_placeholder, st.spinner(\"Generating answer using basic RAG...\"):\n        empty_context_data: dict[str, pd.DataFrame] = {}\n\n        response, context_data = await api.basic_search(\n            config=sv.graphrag_config.value,\n            text_units=sv.text_units.value,\n            query=query,\n        )\n\n        print(f\"Basic Response: {response}\")  # noqa T201\n        print(f\"Context data: {context_data}\")  # noqa T201\n\n    # display response and reference context to UI\n    search_result = SearchResult(\n        search_type=SearchType.Basic,\n        response=str(response),\n        context=context_data if isinstance(context_data, dict) else empty_context_data,\n    )\n\n    display_search_result(\n        container=response_container, result=search_result, stats=None\n    )\n\n    if \"response_lengths\" not in st.session_state:\n        st.session_state.response_lengths = []\n\n    st.session_state[\"response_lengths\"].append({\n        \"search\": SearchType.Basic.value.lower(),\n        \"result\": search_result,\n    })\n\n    return search_result", "label": 0}
{"function": "    def test_string_zfill(self):\n        self.check_func(lambda x: x.str.zfill(10))", "label": 1}
{"function": "    def close(self):\n        pass", "label": 1}
{"function": "def compute_down(expr, data, **kwargs):\n    leaf = expr._leaves()[0]\n    if all(isinstance(e, Cheap) for e in path(expr, leaf)):\n        return compute(expr, {leaf: into(Iterator, data)}, **kwargs)\n    else:\n        raise MDNotImplementedError()", "label": 1}
{"function": "def test_screenshot(tester: Crawl4AiTester):\n    print(\"\\n=== Testing Screenshot ===\")\n    request = {\n        \"urls\": [\"https://www.nbcnews.com/business\"],\n        \"priority\": 5,\n        \"screenshot\": True,\n        \"crawler_params\": {\"headless\": True},\n    }\n\n    result = tester.submit_and_wait(request)\n    print(\"Screenshot captured:\", bool(result[\"result\"][\"screenshot\"]))\n\n    if result[\"result\"][\"screenshot\"]:\n        # Save screenshot\n        screenshot_data = base64.b64decode(result[\"result\"][\"screenshot\"])\n        with open(\"test_screenshot.jpg\", \"wb\") as f:\n            f.write(screenshot_data)\n        print(\"Screenshot saved as test_screenshot.jpg\")\n\n    assert result[\"result\"][\"success\"]", "label": 0}
{"function": "    def tearDown(self):\n        asyncore.close_all(ignore_all=True)", "label": 1}
{"function": "    def hvac_mode(self):\n        \"\"\"Return hvac target hvac state.\"\"\"\n        return self._hvac_mode", "label": 1}
{"function": "async def get_response(query:str, instance_id:str) -> str | None:\n    \"\"\"\n    Received a response based on public secondme model.\n\n    Args:\n        query (str): Questions raised by users regarding the secondme model.\n        instance_id (str): ID used to identify the secondme model, or url used to identify the secondme model.\n\n    \"\"\"\n    id = instance_id.split('/')[-1]\n    path = f\"/api/chat/{id}\"\n    headers = {\"Content-Type\": \"application/json\"}\n    messages.append({\"role\": \"user\", \"content\": query})\n\n    data = {\n        \"messages\": messages,\n        \"metadata\": {\n        \"enable_l0_retrieval\": False,\n        \"role_id\": \"default_role\"\n    },\n    \"temperature\": 0.7,\n    \"max_tokens\": 2000,\n    \"stream\": True\n    }\n\n    conn = http.client.HTTPSConnection(url)\n\n    # Send the POST request\n    conn.request(\"POST\", path, body=json.dumps(data), headers=headers)\n\n    # Get the response\n    response = conn.getresponse()\n\n    full_content = \"\"\n\n    for line in response:\n        if line:\n            decoded_line = line.decode('utf-8').strip()\n            if decoded_line == 'data: [DONE]':\n                break\n            if decoded_line.startswith('data: '):\n                try:\n                    json_str = decoded_line[6:]\n                    chunk = json.loads(json_str)\n                    content = chunk['choices'][0]['delta'].get('content', '')\n                    if content:\n                        full_content += content\n                except json.JSONDecodeError:\n                    pass\n\n    conn.close()\n    if full_content:\n        messages.append({\"role\": \"system\", \"content\": full_content})\n        return full_content\n    else:\n        return None", "label": 0}
{"function": "async def test_create_dir(computer):\n    tmp_dir = \"test_create_dir\"\n    if await computer.interface.directory_exists(tmp_dir):\n        await computer.interface.delete_dir(tmp_dir)\n    await computer.interface.create_dir(tmp_dir)\n    exists = await computer.interface.directory_exists(tmp_dir)\n    assert exists is True, \"Directory should exist\"\n    await computer.interface.delete_dir(tmp_dir)", "label": 0}
{"function": "def test_model():\n    \"\"\"Test model with common chat questions.\"\"\"\n    from weclone.eval.test_model import main as test_main\n\n    test_main()", "label": 0}
{"function": "def create_module(tmp_path: Path, request: pytest.FixtureRequest) -> Callable[[str], Any]:\n    \"\"\"Taken from `pydantic/tests/conftest.py`, create module object, execute and return it.\"\"\"\n\n    def run(\n        source_code: str,\n        rewrite_assertions: bool = True,\n        module_name_prefix: str | None = None,\n    ) -> ModuleType:\n        \"\"\"Create module object, execute and return it.\n\n        Can be used as a decorator of the function from the source code of which the module will be constructed.\n\n        Args:\n            source_code: Python source code of the module\n            rewrite_assertions: whether to rewrite assertions in module or not\n            module_name_prefix: string prefix to use in the name of the module, does not affect the name of the file.\n\n        \"\"\"\n\n        # Max path length in Windows is 260. Leaving some buffer here\n        max_name_len = 240 - len(str(tmp_path))\n        # Windows does not allow these characters in paths. Linux bans slashes only.\n        sanitized_name = re.sub('[' + re.escape('<>:\"/\\\\|?*') + ']', '-', request.node.name)[:max_name_len]\n        module_name = f'{sanitized_name}_{secrets.token_hex(5)}'\n        path = tmp_path / f'{module_name}.py'\n        path.write_text(source_code)\n        filename = str(path)\n\n        if module_name_prefix:  # pragma: no cover\n            module_name = module_name_prefix + module_name\n\n        if rewrite_assertions:\n            loader = AssertionRewritingHook(config=request.config)\n            loader.mark_rewrite(module_name)\n        else:  # pragma: no cover\n            loader = None\n\n        spec = importlib.util.spec_from_file_location(module_name, filename, loader=loader)\n        sys.modules[module_name] = module = importlib.util.module_from_spec(spec)  # pyright: ignore[reportArgumentType]\n        spec.loader.exec_module(module)  # pyright: ignore[reportOptionalMemberAccess]\n        return module\n\n    return run", "label": 0}
{"function": "async def test_scrape_method_selenium(monkeypatch):\n    \"\"\"Test that the scrape method works correctly for selenium by returning the dummy selenium content.\"\"\"\n\n    async def dummy_selenium(url):\n        return f\"<html>dummy selenium content for {url}</html>\"\n\n    urls = [\"http://example.com\"]\n    loader = ChromiumLoader(urls, backend=\"selenium\")\n    loader.browser_name = \"chromium\"\n    monkeypatch.setattr(loader, \"ascrape_undetected_chromedriver\", dummy_selenium)\n    result = await loader.scrape(\"http://example.com\")\n    assert \"dummy selenium content\" in result", "label": 0}
{"function": "def create_cover_letter(parameters: dict, llm_api_key: str):\n    \"\"\"\n    Logic to create a CV.\n    \"\"\"\n    try:\n        logger.info(\"Generating a CV based on provided parameters.\")\n\n        # Carica il resume in testo semplice\n        with open(parameters[\"uploads\"][\"plainTextResume\"], \"r\", encoding=\"utf-8\") as file:\n            plain_text_resume = file.read()\n\n        style_manager = StyleManager()\n        available_styles = style_manager.get_styles()\n\n        if not available_styles:\n            logger.warning(\"No styles available. Proceeding without style selection.\")\n        else:\n            # Present style choices to the user\n            choices = style_manager.format_choices(available_styles)\n            questions = [\n                inquirer.List(\n                    \"style\",\n                    message=\"Select a style for the resume:\",\n                    choices=choices,\n                )\n            ]\n            style_answer = inquirer.prompt(questions)\n            if style_answer and \"style\" in style_answer:\n                selected_choice = style_answer[\"style\"]\n                for style_name, (file_name, author_link) in available_styles.items():\n                    if selected_choice.startswith(style_name):\n                        style_manager.set_selected_style(style_name)\n                        logger.info(f\"Selected style: {style_name}\")\n                        break\n            else:\n                logger.warning(\"No style selected. Proceeding with default style.\")\n        questions = [\n    inquirer.Text('job_url', message=\"Please enter the URL of the job description:\")\n        ]\n        answers = inquirer.prompt(questions)\n        job_url = answers.get('job_url')\n        resume_generator = ResumeGenerator()\n        resume_object = Resume(plain_text_resume)\n        driver = init_browser()\n        resume_generator.set_resume_object(resume_object)\n        resume_facade = ResumeFacade(            \n            api_key=llm_api_key,\n            style_manager=style_manager,\n            resume_generator=resume_generator,\n            resume_object=resume_object,\n            output_path=Path(\"data_folder/output\"),\n        )\n        resume_facade.set_driver(driver)\n        resume_facade.link_to_job(job_url)\n        result_base64, suggested_name = resume_facade.create_cover_letter()         \n\n        # Decodifica Base64 in dati binari\n        try:\n            pdf_data = base64.b64decode(result_base64)\n        except base64.binascii.Error as e:\n            logger.error(\"Error decoding Base64: %s\", e)\n            raise\n\n        # Definisci il percorso della cartella di output utilizzando `suggested_name`\n        output_dir = Path(parameters[\"outputFileDirectory\"]) / suggested_name\n\n        # Crea la cartella se non esiste\n        try:\n            output_dir.mkdir(parents=True, exist_ok=True)\n            logger.info(f\"Cartella di output creata o gi\u00e0 esistente: {output_dir}\")\n        except IOError as e:\n            logger.error(\"Error creating output directory: %s\", e)\n            raise\n        \n        output_path = output_dir / \"cover_letter_tailored.pdf\"\n        try:\n            with open(output_path, \"wb\") as file:\n                file.write(pdf_data)\n            logger.info(f\"CV salvato in: {output_path}\")\n        except IOError as e:\n            logger.error(\"Error writing file: %s\", e)\n            raise\n    except Exception as e:\n        logger.exception(f\"An error occurred while creating the CV: {e}\")\n        raise", "label": 0}
{"function": "    def values(self):\n        return self.args", "label": 1}
{"function": "    def test_init(self):\n        \"\"\"Test that a TimedCache can be initialized with an expiration.\"\"\"\n        expiration = datetime.timedelta(seconds=10)\n        cache = TimedCache(expiration)\n        assert cache.expiration == expiration\n        assert isinstance(cache.cache, dict)\n        assert len(cache.cache) == 0", "label": 0}
{"function": "    def halt(self):\n        self.serialport.setRTS(1)\n        self.serialport.setDTR(1)", "label": 1}
{"function": "    def repr_array(self, x, level):\n        if not x:\n            return \"array('%s')\" % x.typecode\n        header = \"array('%s', [\" % x.typecode\n        return self._repr_iterable(x, level, header, '])', self.maxarray)", "label": 1}
{"function": "async def run_generate_questions(query: str, sv: SessionVariables):\n    \"\"\"Run global search to generate questions for the dataset.\"\"\"\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n    tasks = []\n\n    tasks.append(\n        run_global_search_question_generation(\n            query=query,\n            sv=sv,\n        )\n    )\n\n    return await asyncio.gather(*tasks)", "label": 0}
{"function": "def replace_control_characters(s: str) -> str:\n    # we don't want to print control characters\n    # which distort the output (e.g. \\n or much worse)\n    # https://stackoverflow.com/questions/4324790/removing-control-characters-from-a-string-in-python/19016117#19016117\n    # http://www.unicode.org/reports/tr44/#GC_Values_Table\n    chars = []\n    for ch in s:\n        if unicodedata.category(ch)[0] != \"C\":\n            chars.append(ch) # this character is ok\n        else:\n            chars.append(f\"\\\\u{ord(ch):04x}\") # escape\n    return \"\".join(chars)", "label": 0}
{"function": "    def clean_markup(self, markup, parser=None):\n        \"\"\"Apply ``Cleaner`` to markup string or document and return a cleaned string or document.\"\"\"\n        result_type = type(markup)\n        if isinstance(markup, six.string_types):\n            doc = fromstring(markup, parser=parser)\n        else:\n            doc = copy.deepcopy(markup)\n        self(doc)\n        if issubclass(result_type, six.binary_type):\n            return tostring(doc, encoding='utf-8')\n        elif issubclass(result_type, six.text_type):\n            return tostring(doc, encoding='unicode')\n        else:\n            return doc", "label": 1}
{"function": "    def forward(self, z):\n        a = 1.0 / (1.0 + np.exp(-z))\n        return a", "label": 1}
{"function": "    def copy(self):\n        return MemGetFn(self._ass)", "label": 1}
{"function": "\tdef test_page_filter_matching(self):\n\t\t\"\"\"Test that page filters work correctly\"\"\"\n\t\tregistry = ActionRegistry()\n\n\t\t# Create a mock page\n\t\tmock_page = MagicMock(spec=Page)\n\t\tmock_page.url = 'https://example.com/page'\n\n\t\t# Create actions with different page filters\n\t\tmatching_action = RegisteredAction(\n\t\t\tname='matching_action',\n\t\t\tdescription='Action with matching page filter',\n\t\t\tfunction=lambda: None,\n\t\t\tparam_model=EmptyParamModel,\n\t\t\tdomains=None,\n\t\t\tpage_filter=lambda page: 'example.com' in page.url,\n\t\t)\n\n\t\tnon_matching_action = RegisteredAction(\n\t\t\tname='non_matching_action',\n\t\t\tdescription='Action with non-matching page filter',\n\t\t\tfunction=lambda: None,\n\t\t\tparam_model=EmptyParamModel,\n\t\t\tdomains=None,\n\t\t\tpage_filter=lambda page: 'other.com' in page.url,\n\t\t)\n\n\t\tregistry.actions = {'matching_action': matching_action, 'non_matching_action': non_matching_action}\n\n\t\t# Page-specific description should only include matching actions\n\t\tpage_description = registry.get_prompt_description(mock_page)\n\t\tassert 'matching_action' in page_description\n\t\tassert 'non_matching_action' not in page_description", "label": 0}
{"function": "    def _marshaled_dispatch(self, data, dispatch_method = None, path = None):\n        \"\"\"Dispatches an XML-RPC method from marshalled (XML) data.\n\n        XML-RPC methods are dispatched from the marshalled (XML) data\n        using the _dispatch method and the result is returned as\n        marshalled data. For backwards compatibility, a dispatch\n        function can be provided as an argument (see comment in\n        SimpleXMLRPCRequestHandler.do_POST) but overriding the\n        existing method through subclassing is the preferred means\n        of changing method dispatch behavior.\n        \"\"\"\n\n        try:\n            params, method = loads(data, use_builtin_types=self.use_builtin_types)\n\n            # generate response\n            if dispatch_method is not None:\n                response = dispatch_method(method, params)\n            else:\n                response = self._dispatch(method, params)\n            # wrap response in a singleton tuple\n            response = (response,)\n            response = dumps(response, methodresponse=1,\n                             allow_none=self.allow_none, encoding=self.encoding)\n        except Fault as fault:\n            response = dumps(fault, allow_none=self.allow_none,\n                             encoding=self.encoding)\n        except:\n            # report exception back to server\n            exc_type, exc_value, exc_tb = sys.exc_info()\n            response = dumps(\n                Fault(1, \"%s:%s\" % (exc_type, exc_value)),\n                encoding=self.encoding, allow_none=self.allow_none,\n                )\n\n        return response.encode(self.encoding, 'xmlcharrefreplace')", "label": 1}
{"function": "    def init(self, name, **_3to2kwargs):\n        defects = _3to2kwargs['defects']; del _3to2kwargs['defects']\n        parse_tree = _3to2kwargs['parse_tree']; del _3to2kwargs['parse_tree']\n        self._name = name\n        self._parse_tree = parse_tree\n        self._defects = defects", "label": 1}
{"function": "def get_agent_state():\n    data = request.json\n    project_name = data.get(\"project_name\")\n    agent_state = AgentState.get_latest_state(project_name)\n    return jsonify({\"state\": agent_state})", "label": 0}
{"function": "    async def main(self):\n        try:\n            main_start_time = time()\n            if config.open_update:\n                self.channel_items = get_channel_items()\n                channel_names = [\n                    name\n                    for channel_obj in self.channel_items.values()\n                    for name in channel_obj.keys()\n                ]\n                if not channel_names:\n                    print(f\"\u274c No channel names found! Please check the {config.source_file}!\")\n                    return\n                await self.visit_page(channel_names)\n                self.tasks = []\n                append_total_data(\n                    self.channel_items.items(),\n                    self.channel_data,\n                    self.hotel_fofa_result,\n                    self.multicast_result,\n                    self.hotel_foodie_result,\n                    self.subscribe_result,\n                    self.online_search_result,\n                )\n                cache_result = self.channel_data\n                test_result = {}\n                if config.open_speed_test:\n                    urls_total = get_urls_len(self.channel_data)\n                    test_data = copy.deepcopy(self.channel_data)\n                    process_nested_dict(\n                        test_data,\n                        seen=set(),\n                        filter_host=config.speed_test_filter_host,\n                        ipv6_support=self.ipv6_support\n                    )\n                    self.total = get_urls_len(test_data)\n                    print(f\"Total urls: {urls_total}, need to test speed: {self.total}\")\n                    self.update_progress(\n                        f\"\u6b63\u5728\u8fdb\u884c\u6d4b\u901f, \u5171{urls_total}\u4e2a\u63a5\u53e3, {self.total}\u4e2a\u63a5\u53e3\u9700\u8981\u8fdb\u884c\u6d4b\u901f\",\n                        0,\n                    )\n                    self.start_time = time()\n                    self.pbar = tqdm(total=self.total, desc=\"Speed test\")\n                    test_result = await test_speed(\n                        test_data,\n                        ipv6=self.ipv6_support,\n                        callback=lambda: self.pbar_update(name=\"\u6d4b\u901f\", item_name=\"\u63a5\u53e3\"),\n                    )\n                    cache_result = merge_objects(cache_result, test_result, match_key=\"url\")\n                    self.pbar.close()\n                self.channel_data = sort_channel_result(\n                    self.channel_data,\n                    result=test_result,\n                    filter_host=config.speed_test_filter_host,\n                    ipv6_support=self.ipv6_support\n                )\n                self.update_progress(f\"\u6b63\u5728\u751f\u6210\u7ed3\u679c\u6587\u4ef6\", 0)\n                write_channel_to_file(\n                    self.channel_data,\n                    epg=self.epg_result,\n                    ipv6=self.ipv6_support,\n                    first_channel_name=channel_names[0],\n                )\n                if config.open_history:\n                    if os.path.exists(constants.cache_path):\n                        with gzip.open(constants.cache_path, \"rb\") as file:\n                            try:\n                                cache = pickle.load(file)\n                            except EOFError:\n                                cache = {}\n                            cache_result = merge_objects(cache, cache_result, match_key=\"url\")\n                    with gzip.open(constants.cache_path, \"wb\") as file:\n                        pickle.dump(cache_result, file)\n                print(\n                    f\"\ud83e\udd73 Update completed! Total time spent: {format_interval(time() - main_start_time)}.\"\n                )\n            if self.run_ui:\n                open_service = config.open_service\n                service_tip = \", \u53ef\u4f7f\u7528\u4ee5\u4e0b\u5730\u5740\u8fdb\u884c\u89c2\u770b\" if open_service else \"\"\n                tip = (\n                    f\"\u2705 \u670d\u52a1\u542f\u52a8\u6210\u529f{service_tip}\"\n                    if open_service and config.open_update == False\n                    else f\"\ud83e\udd73\u66f4\u65b0\u5b8c\u6210, \u8017\u65f6: {format_interval(time() - main_start_time)}{service_tip}\"\n                )\n                self.update_progress(\n                    tip,\n                    100,\n                    finished=True,\n                    url=f\"{get_ip_address()}\" if open_service else None,\n                    now=self.now\n                )\n        except asyncio.exceptions.CancelledError:\n            print(\"Update cancelled!\")", "label": 0}
{"function": "    def post(self, shared, prep_res, exec_res):\n        shared[\"abstractions\"] = (\n            exec_res  # List of {\"name\": str, \"description\": str, \"files\": [int]}\n        )", "label": 0}
{"function": "    def decode(self, image, input_ids):\n        with torch.inference_mode():\n            output = self.model.generate_vllm(\n                input_ids=input_ids.unsqueeze(0).cuda(),\n                images=image.unsqueeze(0).half().cuda(),\n                temperature=0.6,\n                max_new_tokens=1024,\n                # num_beams=num_beams,\n                do_sample=True,\n                output_scores=True,\n                return_dict_in_generate=True,\n                repetition_penalty=1.1,\n                top_k=30,\n                top_p=0.9,\n            )\n\n            response = self.tokenizer.decode(\n                output.sequences[0], skip_special_tokens=True)\n            response = response.strip()\n            return response", "label": 0}
{"function": "    def get_img_info(self, index):\n        return {\"height\": self.annobase[index]['height'], \"width\": self.annobase[index]['width']}", "label": 1}
{"function": "def signal_handler(sig, frame):\n    print(\"Ctrl+C pressed, exiting...\")\n    sys.exit(0)", "label": 0}
{"function": "    async def run_single_prompt(self, prompt: str) -> None:\n        \"\"\"Run the agent with a single prompt.\"\"\"\n        await self.agent.run(prompt)", "label": 0}
{"function": "  def _entropy(self):\n    return (self.alpha -\n            math_ops.log(self.beta) +\n            math_ops.lgamma(self.alpha) +\n            (1. - self.alpha) * math_ops.digamma(self.alpha))", "label": 1}
{"function": "    def batch_outputs(self):\n        seq_shape = tf.shape(self.actor_out)\n        out_count = seq_shape[0] * seq_shape[1]\n        actor_shape = (out_count,) + self.action_dist.param_shape\n        critic_shape = (out_count,)\n        masks = tf.reshape(self.mask_ph, critic_shape)\n        return (tf.boolean_mask(tf.reshape(self.actor_out, actor_shape), masks),\n                tf.boolean_mask(tf.reshape(self.critic_out, critic_shape), masks))", "label": 1}
{"function": "    def test_query_level_single(self):\n        \"\"\"\n        wineventlog - Query by level (warning)\n        \"\"\"\n        self.write_event_log(\"success\", level=win32evtlog.EVENTLOG_SUCCESS)\n        self.write_event_log(\"error\", level=win32evtlog.EVENTLOG_ERROR_TYPE)\n        self.write_event_log(\n            \"warning\", level=win32evtlog.EVENTLOG_WARNING_TYPE)\n        self.write_event_log(\n            \"information\", level=win32evtlog.EVENTLOG_INFORMATION_TYPE)\n        evts = self.read_events(config={\n            \"event_logs\": [\n                {\n                    \"name\": self.providerName,\n                    \"api\": self.api,\n                    \"level\": \"warning\"\n                }\n            ]\n        })\n        self.assertTrue(len(evts), 1)\n        self.assertEqual(evts[0][\"log.level\"], \"warning\")", "label": 1}
{"function": "\tdef search(self, term, ctx='', done=None, before=None, after=None,\n\t\t       case=False):\n\t\toriginal = self.case_sensitive_like\n\t\tself.set_case_sensitive_like(case)\n\t\tc = self.connection.cursor()\n\t\tquery = \"\"\"\n\t\t\tSELECT t.*, c.path as ctx_path\n\t\t\tFROM Task t JOIN Context c\n\t\t\tON t.context = c.id\n\t\t\tWHERE t.title LIKE ?\n\t\t\t  AND c.path LIKE ?\n\t\t\"\"\"\n\t\tparams = ('%{}%'.format(term), '{}%'.format(ctx))\n\n\t\tif done is not None:\n\t\t\tcond = 'IS NOT NULL' if done else 'IS NULL'\n\t\t\tquery += \"\"\"\n\t\t\t\tAND t.done {}\n\t\t\t\"\"\".format(cond)\n\t\tif before is not None:\n\t\t\tquery += \"\"\"\n\t\t\t\tAND t.created < ?\n\t\t\t\"\"\"\n\t\t\tparams = params + (before,)\n\t\tif after is not None:\n\t\t\tquery += \"\"\"\n\t\t\t\tAND t.created > ?\n\t\t\t\"\"\"\n\t\t\tparams = params + (after,)\n\n\t\tc.execute(query, params)\n\t\tself.set_case_sensitive_like(original)\n\t\treturn c.fetchall()", "label": 1}
{"function": "    def load(self):\n        \"\"\"Loads alert catalogue yaml files\n\n        Returns\n        -------\n        dict\n            The alerts catalogue as a Python dictionary\n        \"\"\"\n        alertDict = {}\n\n        for filePath in self.alertFiles:\n            # '{}'.format(filePath) instead of simple open(filePath,'r')\n            # is needed for Py2 support only\n            with open('{}'.format(filePath), 'r') as ymlFile:\n                entry = yaml.load(ymlFile, Loader=yaml.SafeLoader)\n                if entry is None:\n                    continue  # this might be a stub for future entry\n                ID = entry['code']\n                alertDict[ID] = entry\n                if 'url' not in entry:  # give a default URL\n                    entry['url'] = ('https://psychopy.org/alerts/{}.html'\n                                    .format(ID))\n\n        return alertDict", "label": 1}
{"function": "    def HoRNDISLoaded():\n      return 'HoRNDIS' in subprocess.check_output(['kextstat'])", "label": 1}
{"function": "def run(\n        weights=ROOT / 'yolo.pt',  # model path or triton URL\n        source=ROOT / 'data/images',  # file/dir/URL/glob/screen/0(webcam)\n        data=ROOT / 'data/coco.yaml',  # dataset.yaml path\n        imgsz=(640, 640),  # inference size (height, width)\n        conf_thres=0.25,  # confidence threshold\n        iou_thres=0.45,  # NMS IOU threshold\n        max_det=1000,  # maximum detections per image\n        device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n        view_img=False,  # show results\n        save_txt=False,  # save results to *.txt\n        save_conf=False,  # save confidences in --save-txt labels\n        save_crop=False,  # save cropped prediction boxes\n        nosave=False,  # do not save images/videos\n        classes=None,  # filter by class: --class 0, or --class 0 2 3\n        agnostic_nms=False,  # class-agnostic NMS\n        augment=False,  # augmented inference\n        visualize=False,  # visualize features\n        update=False,  # update all models\n        project=ROOT / 'runs/detect',  # save results to project/name\n        name='exp',  # save results to project/name\n        exist_ok=False,  # existing project/name ok, do not increment\n        line_thickness=3,  # bounding box thickness (pixels)\n        hide_labels=False,  # hide labels\n        hide_conf=False,  # hide confidences\n        half=False,  # use FP16 half-precision inference\n        dnn=False,  # use OpenCV DNN for ONNX inference\n        vid_stride=1,  # video frame-rate stride\n):\n    source = str(source)\n    save_img = not nosave and not source.endswith('.txt')  # save inference images\n    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)\n    is_url = source.lower().startswith(('rtsp://', 'rtmp://', 'http://', 'https://'))\n    webcam = source.isnumeric() or source.endswith('.txt') or (is_url and not is_file)\n    screenshot = source.lower().startswith('screen')\n    if is_url and is_file:\n        source = check_file(source)  # download\n\n    # Directories\n    save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n    (save_dir / 'labels' if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n\n    # Load model\n    device = select_device(device)\n    model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n    stride, names, pt = model.stride, model.names, model.pt\n    imgsz = check_img_size(imgsz, s=stride)  # check image size\n\n    # Dataloader\n    bs = 1  # batch_size\n    if webcam:\n        view_img = check_imshow(warn=True)\n        dataset = LoadStreams(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n        bs = len(dataset)\n    elif screenshot:\n        dataset = LoadScreenshots(source, img_size=imgsz, stride=stride, auto=pt)\n    else:\n        dataset = LoadImages(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n    vid_path, vid_writer = [None] * bs, [None] * bs\n\n    # Run inference\n    model.warmup(imgsz=(1 if pt or model.triton else bs, 3, *imgsz))  # warmup\n    seen, windows, dt = 0, [], (Profile(), Profile(), Profile())\n    for path, im, im0s, vid_cap, s in dataset:\n        with dt[0]:\n            im = torch.from_numpy(im).to(model.device)\n            im = im.half() if model.fp16 else im.float()  # uint8 to fp16/32\n            im /= 255  # 0 - 255 to 0.0 - 1.0\n            if len(im.shape) == 3:\n                im = im[None]  # expand for batch dim\n\n        # Inference\n        with dt[1]:\n            visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False\n            pred = model(im, augment=augment, visualize=visualize)\n            pred = pred[0][1]\n\n        # NMS\n        with dt[2]:\n            pred = non_max_suppression(pred, conf_thres, iou_thres, classes, agnostic_nms, max_det=max_det)\n\n        # Second-stage classifier (optional)\n        # pred = utils.general.apply_classifier(pred, classifier_model, im, im0s)\n\n        # Process predictions\n        for i, det in enumerate(pred):  # per image\n            seen += 1\n            if webcam:  # batch_size >= 1\n                p, im0, frame = path[i], im0s[i].copy(), dataset.count\n                s += f'{i}: '\n            else:\n                p, im0, frame = path, im0s.copy(), getattr(dataset, 'frame', 0)\n\n            p = Path(p)  # to Path\n            save_path = str(save_dir / p.name)  # im.jpg\n            txt_path = str(save_dir / 'labels' / p.stem) + ('' if dataset.mode == 'image' else f'_{frame}')  # im.txt\n            s += '%gx%g ' % im.shape[2:]  # print string\n            gn = torch.tensor(im0.shape)[[1, 0, 1, 0]]  # normalization gain whwh\n            imc = im0.copy() if save_crop else im0  # for save_crop\n            annotator = Annotator(im0, line_width=line_thickness, example=str(names))\n            if len(det):\n                # Rescale boxes from img_size to im0 size\n                det[:, :4] = scale_boxes(im.shape[2:], det[:, :4], im0.shape).round()\n\n                # Print results\n                for c in det[:, 5].unique():\n                    n = (det[:, 5] == c).sum()  # detections per class\n                    s += f\"{n} {names[int(c)]}{'s' * (n > 1)}, \"  # add to string\n\n                # Write results\n                for *xyxy, conf, cls in reversed(det):\n                    if save_txt:  # Write to file\n                        xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n                        line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n                        with open(f'{txt_path}.txt', 'a') as f:\n                            f.write(('%g ' * len(line)).rstrip() % line + '\\n')\n\n                    if save_img or save_crop or view_img:  # Add bbox to image\n                        c = int(cls)  # integer class\n                        label = None if hide_labels else (names[c] if hide_conf else f'{names[c]} {conf:.2f}')\n                        annotator.box_label(xyxy, label, color=colors(c, True))\n                    if save_crop:\n                        save_one_box(xyxy, imc, file=save_dir / 'crops' / names[c] / f'{p.stem}.jpg', BGR=True)\n\n            # Stream results\n            im0 = annotator.result()\n            if view_img:\n                if platform.system() == 'Linux' and p not in windows:\n                    windows.append(p)\n                    cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)\n                    cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])\n                cv2.imshow(str(p), im0)\n                cv2.waitKey(1)  # 1 millisecond\n\n            # Save results (image with detections)\n            if save_img:\n                if dataset.mode == 'image':\n                    cv2.imwrite(save_path, im0)\n                else:  # 'video' or 'stream'\n                    if vid_path[i] != save_path:  # new video\n                        vid_path[i] = save_path\n                        if isinstance(vid_writer[i], cv2.VideoWriter):\n                            vid_writer[i].release()  # release previous video writer\n                        if vid_cap:  # video\n                            fps = vid_cap.get(cv2.CAP_PROP_FPS)\n                            w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n                            h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n                        else:  # stream\n                            fps, w, h = 30, im0.shape[1], im0.shape[0]\n                        save_path = str(Path(save_path).with_suffix('.mp4'))  # force *.mp4 suffix on results videos\n                        vid_writer[i] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*'mp4v'), fps, (w, h))\n                    vid_writer[i].write(im0)\n\n        # Print time (inference-only)\n        LOGGER.info(f\"{s}{'' if len(det) else '(no detections), '}{dt[1].dt * 1E3:.1f}ms\")\n\n    # Print results\n    t = tuple(x.t / seen * 1E3 for x in dt)  # speeds per image\n    LOGGER.info(f'Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {(1, 3, *imgsz)}' % t)\n    if save_txt or save_img:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else ''\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    if update:\n        strip_optimizer(weights[0])  # update model (to fix SourceChangeWarning)", "label": 0}
{"function": "    def __ge__(self, other: Any) -> bool: ...", "label": 1}
{"function": "    def update(self):\n        \"\"\"Move the alien right or left.\"\"\"\n        self.x += (self.settings.alien_speed *\n                        self.settings.fleet_direction)\n        self.rect.x = self.x", "label": 1}
{"function": "def test_get_top_percent_list(num_list: list, percent: float, target_num_list: list) -> None:\n    \"\"\"\n    num_list: \u6570\u5b57\u5217\u8868\uff0c\u5217\u8868\u5143\u7d20\u4e3a\u6570\u5b57\n    percent: \u5360\u6bd4\uff0cfloat, \u5411\u4e0b\u53d6\u8bc1\n    \"\"\"\n    assert target_num_list == get_top_percent_list(num_list, percent)", "label": 0}
{"function": "    def getConvexHull(self) -> Optional[Polygon]:\n        \"\"\"Get the unmodified 2D projected convex hull of the node (if any)\n\n        In case of one-at-a-time, this includes adhesion and head+fans clearance\n        \"\"\"\n        if self._node is None:\n            return None\n        if self._node.callDecoration(\"isNonPrintingMesh\"):\n            return None\n\n        # Parent can be None if node is just loaded.\n        if self._isSingularOneAtATimeNode():\n            hull = self.getConvexHullHeadFull()\n            if hull is None:\n                return None\n            hull = self._add2DAdhesionMargin(hull)\n            return hull\n\n        return self._compute2DConvexHull()", "label": 1}
{"function": "def is_rocm_pytorch() -> bool:\n    \"\"\"Check whether the PyTorch is compiled on ROCm.\"\"\"\n    is_rocm = False\n    if TORCH_VERSION != 'parrots':\n        try:\n            from torch.utils.cpp_extension import ROCM_HOME\n            is_rocm = True if ((torch.version.hip is not None) and\n                               (ROCM_HOME is not None)) else False\n        except ImportError:\n            pass\n    return is_rocm", "label": 0}
{"function": "    def get_registered_model_version(self, id):\n        \"\"\"\n        Retrieve an already created Model Version.\n\n        Parameters\n        ----------\n        id : str\n            ID of the Model Version.\n\n        Returns\n        -------\n        :class:`~verta._registry.modelversion.RegisteredModelVersion`\n        \"\"\"\n        return RegisteredModelVersion._get_by_id(self._conn, self._conf, id)", "label": 1}
{"function": "    def test_get_signal_signal_given_dtype(self):\n        s = self.signal\n        assert s._get_signal_signal(dtype=\"bool\").data.dtype.name == \"bool\"", "label": 1}
{"function": "    def containment(self, energy, rad_max):\n        \"\"\"Compute containment of the PSF.\n\n        Parameters\n        ----------\n        energy : `~astropy.units.Quantity`\n            Energy\n        rad_max : `~astropy.coordinates.Angle`\n            Maximum offset angle.\n\n        Returns\n        -------\n        fraction : array_like\n            Containment fraction (in range 0 .. 1)\n        \"\"\"\n        energy = np.atleast_1d(u.Quantity(energy))[:, np.newaxis]\n        rad_max = np.atleast_1d(u.Quantity(rad_max))\n        return self._interpolate_containment((energy, rad_max))", "label": 1}
{"function": "    def test_execute_tool_invalid_parameters(self):\n        \"\"\"Test that executing a tool with invalid parameters raises a ValueError.\"\"\"\n        self.tool_manager._add_tool(get_current_temperature, TemperatureParams)\n        tool_call = {\n            \"id\": \"call_1\",\n            \"function\": {\n                \"name\": \"get_current_temperature\",\n                \"arguments\": {\"location\": 123},  # Invalid type for location\n            },\n        }\n\n        with self.assertRaises(ValueError) as context:\n            self.tool_manager.execute_tool(tool_call)\n\n        # Verify the error message contains information about the validation error\n        self.assertIn(\n            \"Error in tool 'get_current_temperature' parameters\", str(context.exception)\n        )", "label": 0}
{"function": "    def alter_column(self, table_name, column_name,\n                        nullable=None,\n                        server_default=False,\n                        name=None,\n                        type_=None,\n                        autoincrement=None,\n                        existing_type=None,\n                        existing_server_default=False,\n                        existing_nullable=None,\n                        existing_autoincrement=None,\n                        schema=None\n    ):\n        \"\"\"Issue an \"alter column\" instruction using the\n        current migration context.\n\n        Generally, only that aspect of the column which\n        is being changed, i.e. name, type, nullability,\n        default, needs to be specified.  Multiple changes\n        can also be specified at once and the backend should\n        \"do the right thing\", emitting each change either\n        separately or together as the backend allows.\n\n        MySQL has special requirements here, since MySQL\n        cannot ALTER a column without a full specification.\n        When producing MySQL-compatible migration files,\n        it is recommended that the ``existing_type``,\n        ``existing_server_default``, and ``existing_nullable``\n        parameters be present, if not being altered.\n\n        Type changes which are against the SQLAlchemy\n        \"schema\" types :class:`~sqlalchemy.types.Boolean`\n        and  :class:`~sqlalchemy.types.Enum` may also\n        add or drop constraints which accompany those\n        types on backends that don't support them natively.\n        The ``existing_server_default`` argument is\n        used in this case as well to remove a previous\n        constraint.\n\n        :param table_name: string name of the target table.\n        :param column_name: string name of the target column,\n         as it exists before the operation begins.\n        :param nullable: Optional; specify ``True`` or ``False``\n         to alter the column's nullability.\n        :param server_default: Optional; specify a string\n         SQL expression, :func:`~sqlalchemy.sql.expression.text`,\n         or :class:`~sqlalchemy.schema.DefaultClause` to indicate\n         an alteration to the column's default value.\n         Set to ``None`` to have the default removed.\n        :param name: Optional; specify a string name here to\n         indicate the new name within a column rename operation.\n        :param type_: Optional; a :class:`~sqlalchemy.types.TypeEngine`\n         type object to specify a change to the column's type.\n         For SQLAlchemy types that also indicate a constraint (i.e.\n         :class:`~sqlalchemy.types.Boolean`, :class:`~sqlalchemy.types.Enum`),\n         the constraint is also generated.\n        :param autoincrement: set the ``AUTO_INCREMENT`` flag of the column;\n         currently understood by the MySQL dialect.\n        :param existing_type: Optional; a\n         :class:`~sqlalchemy.types.TypeEngine`\n         type object to specify the previous type.   This\n         is required for all MySQL column alter operations that\n         don't otherwise specify a new type, as well as for\n         when nullability is being changed on a SQL Server\n         column.  It is also used if the type is a so-called\n         SQLlchemy \"schema\" type which may define a constraint (i.e.\n         :class:`~sqlalchemy.types.Boolean`,\n         :class:`~sqlalchemy.types.Enum`),\n         so that the constraint can be dropped.\n        :param existing_server_default: Optional; The existing\n         default value of the column.   Required on MySQL if\n         an existing default is not being changed; else MySQL\n         removes the default.\n        :param existing_nullable: Optional; the existing nullability\n         of the column.  Required on MySQL if the existing nullability\n         is not being changed; else MySQL sets this to NULL.\n        :param existing_autoincrement: Optional; the existing autoincrement\n         of the column.  Used for MySQL's system of altering a column\n         that specifies ``AUTO_INCREMENT``.\n        :param schema: Optional schema name to operate within.\n\n         .. versionadded:: 0.4.0\n\n        \"\"\"\n\n        compiler = self.impl.dialect.statement_compiler(\n                            self.impl.dialect,\n                            None\n                        )\n        def _count_constraint(constraint):\n            return not isinstance(constraint, sa_schema.PrimaryKeyConstraint) and \\\n                (not constraint._create_rule or\n                    constraint._create_rule(compiler))\n\n        if existing_type and type_:\n            t = self._table(table_name,\n                        sa_schema.Column(column_name, existing_type),\n                        schema=schema\n                    )\n            for constraint in t.constraints:\n                if _count_constraint(constraint):\n                    self.impl.drop_constraint(constraint)\n\n        self.impl.alter_column(table_name, column_name,\n            nullable=nullable,\n            server_default=server_default,\n            name=name,\n            type_=type_,\n            schema=schema,\n            autoincrement=autoincrement,\n            existing_type=existing_type,\n            existing_server_default=existing_server_default,\n            existing_nullable=existing_nullable,\n            existing_autoincrement=existing_autoincrement\n        )\n\n        if type_:\n            t = self._table(table_name,\n                        sa_schema.Column(column_name, type_),\n                        schema=schema\n                    )\n            for constraint in t.constraints:\n                if _count_constraint(constraint):\n                    self.impl.add_constraint(constraint)", "label": 1}
{"function": "    def recomputeConvexHull(self) -> None:\n        if self._node is None or not self.__isDescendant(self._root, self._node):\n            if self._convex_hull_node:\n                # Convex hull node still exists, but the node is removed or no longer in the scene.\n                self._convex_hull_node.setParent(None)\n                self._convex_hull_node = None\n            return\n\n        if self._convex_hull_node:\n            self._convex_hull_node.setParent(None)\n        hull_node = ConvexHullNode.ConvexHullNode(self._node, self.getPrintingArea(), self._raft_thickness, self._root)\n        self._convex_hull_node = hull_node", "label": 1}
{"function": "def _ReshapeGrad(op, grad):\n  return [array_ops.reshape(grad, array_ops.shape(op.inputs[0])), None]", "label": 1}
{"function": "    def convertQss(self):\n        \"\"\"\u6839\u636evarDict\u4e2d\u53d8\u91cf\u7684\u503c\uff0c\u628a\u6a21\u677f\u6587\u4ef6\u4e2d\u5f15\u7528\u7684\u53d8\u91cf\u7528\u503c\u66ff\u6362\uff0c\u8f6c\u6362\u4e3aqss\u6587\u4ef6\u3002\n        \"\"\"\n\n        qssStr = self.srctext\n        varDict = self.varDict\n        self.loadVars()\n        # \u5220\u9664\u53d8\u91cf\u5b9a\u4e49\n        varsDefined = re.compile(r'[$](\\w+)\\s*=[ \\t]*([#(),.\\w]*)[ \\t;]*[\\r\\n]{0,2}')\n        qssStr = varsDefined.sub(\"\", qssStr)\n\n        for v in self.varDict:\n            if v in varDict.keys():\n                # qssStr = qssStr.replace(\"$\" + v, varDict[v])\n                qssStr = re.sub(r'[$](\\w+)([\\s;]*)', lambda m:'{}{}'.format(varDict[m.group(1)], m.group(2)), qssStr)\n            else:\n                self.varUndefined.append(v)\n                # qssStr = qssStr.replace(\"$\" + v, ' ')\n                qssStr = re.sub(r'[$](\\w+)([\\s;]*)', lambda m:'{}{}'.format(\" \", m.group(2)), qssStr)\n        # \u5220\u9664\u4ee3\u7801\u5757\n        qssStr = self.reCodeBlock.sub(\"\", qssStr)\n        self.qss = qssStr", "label": 1}
{"function": "def single_job(utt):\n    audio, sample_rate = torchaudio.load(utt2wav[utt], backend='soundfile')\n    if sample_rate != 16000:\n        audio = torchaudio.transforms.Resample(orig_freq=sample_rate, new_freq=16000)(audio)\n    # Convert audio to mono\n    if audio.shape[0] > 1:\n        audio = audio.mean(dim=0, keepdim=True)\n    if audio.shape[1] / 16000 > 30:\n        logging.warning('do not support extract speech token for audio longer than 30s')\n        speech_token = []\n    else:\n        feat = whisper.log_mel_spectrogram(audio, n_mels=128)\n        speech_token = ort_session.run(None, {ort_session.get_inputs()[0].name: feat.detach().cpu().numpy(),\n                                              ort_session.get_inputs()[1].name: np.array([feat.shape[2]], dtype=np.int32)})[0].flatten().tolist()\n    return utt, speech_token", "label": 0}
{"function": "def get_terminal_session():\n    project_name = request.args.get(\"project_name\")\n    agent_state = AgentState.get_latest_state(project_name)\n    if not agent_state:\n        return jsonify({\"terminal_state\": None})\n    else:\n        terminal_state = agent_state[\"terminal_session\"]\n        return jsonify({\"terminal_state\": terminal_state})", "label": 0}
{"function": "def measure_latency(ques, output_file, is_stream=False):\n    start_time = time.time()\n    if is_stream:\n        _ = list(stream_requests(ques, output_file))\n    else:\n        no_stream_requests(ques, output_file)\n    end_time = time.time()\n    return end_time - start_time", "label": 0}
{"function": "    def __init__(self, max_recur_limit=100):\n        \"\"\"Initialize with configuration parameters.\"\"\"\n        self.max_recur_limit = max_recur_limit", "label": 0}
{"function": "    def __init__(self, family, addr, handler=BaseTestHandler):\n        asyncore.dispatcher.__init__(self)\n        self.create_socket(family)\n        self.set_reuse_addr()\n        bind_af_aware(self.socket, addr)\n        self.listen(5)\n        self.handler = handler", "label": 1}
{"function": "async def login(request: Request):\n    root_url = gr.route_utils.get_root_url(request, \"/login\", None)\n    redirect_uri = f\"{root_url}/auth\"\n    return await oauth.google.authorize_redirect(request, redirect_uri)", "label": 0}
{"function": "def union_tensor_dict(tensor_dict1: TensorDict, tensor_dict2: TensorDict) -> TensorDict:\n    \"\"\"Union two tensordicts.\"\"\"\n    assert tensor_dict1.batch_size == tensor_dict2.batch_size, (\n        f\"Two tensor dict must have identical batch size. Got {tensor_dict1.batch_size} and {tensor_dict2.batch_size}\"\n    )\n    for key in tensor_dict2.keys():\n        if key not in tensor_dict1.keys():\n            tensor_dict1[key] = tensor_dict2[key]\n        else:\n            assert tensor_dict1[key].equal(tensor_dict2[key]), (\n                f\"{key} in tensor_dict1 and tensor_dict2 are not the same object\"\n            )\n\n    return tensor_dict1", "label": 0}
{"function": "    def _obtain_samples(self,\n                        trainer,\n                        itr,\n                        num_samples,\n                        update_posterior_rate,\n                        add_to_enc_buffer=True):\n        \"\"\"Obtain samples.\n\n        Args:\n            trainer (Trainer): Trainer.\n            itr (int): Index of iteration (epoch).\n            num_samples (int): Number of samples to obtain.\n            update_posterior_rate (int): How often (in episodes) to infer\n                posterior of policy.\n            add_to_enc_buffer (bool): Whether or not to add samples to encoder\n                buffer.\n\n        \"\"\"\n        self._policy.reset_belief()\n        total_samples = 0\n\n        if update_posterior_rate != np.inf:\n            num_samples_per_batch = (update_posterior_rate *\n                                     self.max_episode_length)\n        else:\n            num_samples_per_batch = num_samples\n\n        while total_samples < num_samples:\n            paths = trainer.obtain_samples(itr, num_samples_per_batch,\n                                           self._policy,\n                                           self._env[self._task_idx])\n            total_samples += sum([len(path['rewards']) for path in paths])\n\n            for path in paths:\n                p = {\n                    'observations':\n                    path['observations'],\n                    'actions':\n                    path['actions'],\n                    'rewards':\n                    path['rewards'].reshape(-1, 1),\n                    'next_observations':\n                    path['next_observations'],\n                    'dones':\n                    np.array([\n                        step_type == StepType.TERMINAL\n                        for step_type in path['step_types']\n                    ]).reshape(-1, 1)\n                }\n                self._replay_buffers[self._task_idx].add_path(p)\n\n                if add_to_enc_buffer:\n                    self._context_replay_buffers[self._task_idx].add_path(p)\n\n            if update_posterior_rate != np.inf:\n                context = self._sample_context(self._task_idx)\n                self._policy.infer_posterior(context)", "label": 1}
{"function": "    async def cleanup(self) -> None:\n        \"\"\"Clean up agent resources.\"\"\"\n        await self.agent.cleanup()\n        logger.info(\"Session ended\")", "label": 0}
{"function": "    def GetRootAsInParentNamespace(cls, buf, offset):\n        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)\n        x = InParentNamespace()\n        x.Init(buf, n + offset)\n        return x", "label": 1}
{"function": "  def inference_graph(self, data):\n    with ops.device(self.device_assigner):\n      # Compute activations for the neural network.\n      nn_activations = [layers.fully_connected(data, self.params.layer_size)]\n\n      for _ in range(1, self.params.num_layers):\n        # pylint: disable=W0106\n        nn_activations.append(\n            layers.fully_connected(\n                nn_activations[-1],\n                self.params.layer_size))\n\n      nn_activations_tensor = array_ops.concat(\n          nn_activations, 1, name=\"flattened_nn_activations\")\n\n      return nn_activations_tensor", "label": 1}
{"function": "    def prep(self, shared):\n        abstractions = shared[\n            \"abstractions\"\n        ]  # Now contains 'files' list of indices, name/description potentially translated\n        files_data = shared[\"files\"]\n        project_name = shared[\"project_name\"]  # Get project name\n        language = shared.get(\"language\", \"english\")  # Get language\n        use_cache = shared.get(\"use_cache\", True)  # Get use_cache flag, default to True\n\n        # Get the actual number of abstractions directly\n        num_abstractions = len(abstractions)\n\n        # Create context with abstraction names, indices, descriptions, and relevant file snippets\n        context = \"Identified Abstractions:\\\\n\"\n        all_relevant_indices = set()\n        abstraction_info_for_prompt = []\n        for i, abstr in enumerate(abstractions):\n            # Use 'files' which contains indices directly\n            file_indices_str = \", \".join(map(str, abstr[\"files\"]))\n            # Abstraction name and description might be translated already\n            info_line = f\"- Index {i}: {abstr['name']} (Relevant file indices: [{file_indices_str}])\\\\n  Description: {abstr['description']}\"\n            context += info_line + \"\\\\n\"\n            abstraction_info_for_prompt.append(\n                f\"{i} # {abstr['name']}\"\n            )  # Use potentially translated name here too\n            all_relevant_indices.update(abstr[\"files\"])\n\n        context += \"\\\\nRelevant File Snippets (Referenced by Index and Path):\\\\n\"\n        # Get content for relevant files using helper\n        relevant_files_content_map = get_content_for_indices(\n            files_data, sorted(list(all_relevant_indices))\n        )\n        # Format file content for context\n        file_context_str = \"\\\\n\\\\n\".join(\n            f\"--- File: {idx_path} ---\\\\n{content}\"\n            for idx_path, content in relevant_files_content_map.items()\n        )\n        context += file_context_str\n\n        return (\n            context,\n            \"\\n\".join(abstraction_info_for_prompt),\n            num_abstractions, # Pass the actual count\n            project_name,\n            language,\n            use_cache,\n        )  # Return use_cache", "label": 0}
{"function": "    def reset_parameters(self):\n        stdv = 1. / math.sqrt(self.weight.size(1))\n        self.weight.data.uniform_(-stdv, stdv)\n        if self.bias is not None:\n            self.bias.data.uniform_(-stdv, stdv)", "label": 1}
{"function": "  def _ConfigureNetwork(self, device_iface, host_iface):\n    \"\"\"Configures the |device_iface| to be on the same network as |host_iface|.\n    \"\"\"\n    def _Long2Ip(value):\n      return socket.inet_ntoa(struct.pack('!L', value))\n\n    def _IsNetworkUnique(network, addresses):\n      return all((addr & mask != network & mask) for addr, mask in addresses)\n\n    def _NextUnusedAddress(network, netmask, used_addresses):\n      # Excludes '0' and broadcast.\n      for suffix in range(1, 0xFFFFFFFF & ~netmask):\n        candidate = network | suffix\n        if candidate not in used_addresses:\n          return candidate\n\n    def HasHostAddress():\n      _, host_address = self._GetHostAddresses(host_iface)\n      return bool(host_address)\n\n    if not HasHostAddress():\n      if platform.GetHostPlatform().GetOSName() == 'mac':\n        if 'Telemetry' not in subprocess.check_output(\n            ['networksetup', '-listallnetworkservices']):\n          subprocess.check_call(\n              ['/usr/bin/sudo', 'networksetup',\n               '-createnetworkservice', 'Telemetry', host_iface])\n          subprocess.check_call(\n              ['/usr/bin/sudo', 'networksetup',\n               '-setmanual', 'Telemetry', '192.168.123.1', '255.255.255.0'])\n      elif platform.GetHostPlatform().GetOSName() == 'linux':\n        with open(self._NETWORK_INTERFACES) as f:\n          orig_interfaces = f.read()\n        if self._INTERFACES_INCLUDE not in orig_interfaces:\n          interfaces = '\\n'.join([\n              orig_interfaces,\n              '',\n              '# Added by Telemetry.',\n              self._INTERFACES_INCLUDE])\n          self._WriteProtectedFile(self._NETWORK_INTERFACES, interfaces)\n        interface_conf_file = self._TELEMETRY_INTERFACE_FILE.format(host_iface)\n        if not os.path.exists(interface_conf_file):\n          interface_conf_dir = os.path.dirname(interface_conf_file)\n          if not os.path.exists(interface_conf_dir):\n            subprocess.call(['/usr/bin/sudo', '/bin/mkdir', interface_conf_dir])\n            subprocess.call(\n                ['/usr/bin/sudo', '/bin/chmod', '755', interface_conf_dir])\n          interface_conf = '\\n'.join([\n              '# Added by Telemetry for RNDIS forwarding.',\n              'allow-hotplug %s' % host_iface,\n              'iface %s inet static' % host_iface,\n              '  address 192.168.123.1',\n              '  netmask 255.255.255.0',\n              ])\n          self._WriteProtectedFile(interface_conf_file, interface_conf)\n          subprocess.check_call(['/usr/bin/sudo', 'ifup', host_iface])\n      logging.info('Waiting for RNDIS connectivity...')\n      py_utils.WaitFor(HasHostAddress, 30)\n\n    addresses, host_address = self._GetHostAddresses(host_iface)\n    assert host_address, 'Interface %s could not be configured.' % host_iface\n\n    host_ip, netmask = host_address  # pylint: disable=unpacking-non-sequence\n    network = host_ip & netmask\n\n    if not _IsNetworkUnique(network, addresses):\n      logging.warning(\n        'The IP address configuration %s of %s is not unique!\\n'\n        'Check your /etc/network/interfaces. If this overlap is intended,\\n'\n        'you might need to use: ip rule add from <device_ip> lookup <table>\\n'\n        'or add the interface to a bridge in order to route to this network.',\n        host_address, host_iface\n      )\n\n    # Find unused IP address.\n    used_addresses = [addr for addr, _ in addresses]\n    used_addresses += [self._IpPrefix2AddressMask(addr)[0]\n                       for addr in self._GetDeviceAddresses(device_iface)]\n    used_addresses += [host_ip]\n\n    device_ip = _NextUnusedAddress(network, netmask, used_addresses)\n    assert device_ip, ('The network %s on %s is full.' %\n                       (host_address, host_iface))\n\n    host_ip = _Long2Ip(host_ip)\n    device_ip = _Long2Ip(device_ip)\n    netmask = _Long2Ip(netmask)\n\n    # TODO(szym) run via su -c if necessary.\n    self._device.RunShellCommand(\n        ['ifconfig', device_iface, device_ip, 'netmask', netmask, 'up'],\n        check_return=True)\n    # Enabling the interface sometimes breaks adb.\n    self._device.WaitUntilFullyBooted()\n    self._host_iface = host_iface\n    self._host_ip = host_ip\n    self.device_iface = device_iface\n    self._device_ip = device_ip", "label": 1}
{"function": "def test_connect(data):\n    print(\"Socket connected :: \", data)\n    emit_agent(\"socket_response\", {\"data\": \"Server Connected\"})", "label": 0}
{"function": "\tdef set_ResourceOwnerId(self,ResourceOwnerId):\n\t\tself.add_query_param('ResourceOwnerId',ResourceOwnerId)", "label": 1}
{"function": "    def graph(self):\n        \"\"\"Get graph data.\"\"\"\n        return self._graph", "label": 1}
{"function": "    def cmd_switch_groups(self, groupa, groupb):\n        \"\"\"Switch position of groupa to groupb\"\"\"\n        if groupa not in self.groups_map or groupb not in self.groups_map:\n            return\n\n        indexa = self.groups.index(self.groups_map[groupa])\n        indexb = self.groups.index(self.groups_map[groupb])\n\n        self.groups[indexa], self.groups[indexb] = \\\n            self.groups[indexb], self.groups[indexa]\n        hook.fire(\"setgroup\")\n\n        # update window _NET_WM_DESKTOP\n        for group in (self.groups[indexa], self.groups[indexb]):\n            for w in group.windows:\n                w.group = group", "label": 1}
{"function": "    def decode_image(self, image_data):\n        \"\"\"Decode the image data string.\n\n        Args:\n            image_data: string of image data.\n        Returns:\n            Decoded image data.\n        Raises:\n            ValueError: Value of image channels not supported.\n        \"\"\"\n        image = self._session.run(\n            self._decode, feed_dict={self._decode_data: image_data})\n        if len(image.shape) != 3 or image.shape[2] not in (1, 3):\n            raise ValueError('The image channels not supported.')\n\n        return image", "label": 1}
{"function": "    def Init(self, buf, pos):\n        self._tab = flatbuffers.table.Table(buf, pos)", "label": 1}
{"function": "  def RestoreRoutingPolicy(self):\n    policies = self._device.RunShellCommand(['ip', 'rule'], check_return=True)\n    if len(policies) > 1 and re.match(\"^1:.*lookup main\", policies[1]):\n      self._device.RunShellCommand(\n          ['ip', 'rule', 'del', 'prio', '1'], check_return=True)\n      self._device.RunShellCommand(\n          ['ip', 'route', 'flush', 'cache'], check_return=True)", "label": 1}
{"function": "\tdef test_domain_and_page_filter_together(self):\n\t\t\"\"\"Test that actions can be filtered by both domain and page filter\"\"\"\n\t\tregistry = ActionRegistry()\n\n\t\t# Create a mock page\n\t\tmock_page = MagicMock(spec=Page)\n\t\tmock_page.url = 'https://example.com/admin'\n\n\t\t# Actions with different combinations of filters\n\t\tactions = {\n\t\t\t'domain_only': RegisteredAction(\n\t\t\t\tname='domain_only',\n\t\t\t\tdescription='Domain filter only',\n\t\t\t\tfunction=lambda: None,\n\t\t\t\tparam_model=EmptyParamModel,\n\t\t\t\tdomains=['example.com'],\n\t\t\t\tpage_filter=None,\n\t\t\t),\n\t\t\t'page_only': RegisteredAction(\n\t\t\t\tname='page_only',\n\t\t\t\tdescription='Page filter only',\n\t\t\t\tfunction=lambda: None,\n\t\t\t\tparam_model=EmptyParamModel,\n\t\t\t\tdomains=None,\n\t\t\t\tpage_filter=lambda page: 'admin' in page.url,\n\t\t\t),\n\t\t\t'both_matching': RegisteredAction(\n\t\t\t\tname='both_matching',\n\t\t\t\tdescription='Both filters matching',\n\t\t\t\tfunction=lambda: None,\n\t\t\t\tparam_model=EmptyParamModel,\n\t\t\t\tdomains=['example.com'],\n\t\t\t\tpage_filter=lambda page: 'admin' in page.url,\n\t\t\t),\n\t\t\t'both_one_fail': RegisteredAction(\n\t\t\t\tname='both_one_fail',\n\t\t\t\tdescription='One filter fails',\n\t\t\t\tfunction=lambda: None,\n\t\t\t\tparam_model=EmptyParamModel,\n\t\t\t\tdomains=['other.com'],\n\t\t\t\tpage_filter=lambda page: 'admin' in page.url,\n\t\t\t),\n\t\t}\n\n\t\tregistry.actions = actions\n\n\t\t# Check that only actions with matching filters are included\n\t\tdescription = registry.get_prompt_description(mock_page)\n\t\tassert 'domain_only' in description  # Domain matches\n\t\tassert 'page_only' in description  # Page filter matches\n\t\tassert 'both_matching' in description  # Both filters match\n\t\tassert 'both_one_fail' not in description  # Domain filter fails\n\n\t\t# Test with different URL where page filter fails\n\t\tmock_page.url = 'https://example.com/dashboard'\n\t\tdescription = registry.get_prompt_description(mock_page)\n\t\tassert 'domain_only' in description  # Domain matches\n\t\tassert 'page_only' not in description  # Page filter fails\n\t\tassert 'both_matching' not in description  # Page filter fails\n\t\tassert 'both_one_fail' not in description  # Domain filter fails", "label": 0}
{"function": "\tdef get_VpcId(self):\n\t\treturn self.get_query_params().get('VpcId')", "label": 1}
{"function": "    def __getitem__(self, key: str):\n        \"\"\"Implement the [] operator for the class. Allows accessing attributes like dictionary items.\n\n        Args:\n            key (str): The attribute name to retrieve.\n\n        Returns:\n            Any: The value of the attribute.\n\n        Raises:\n            AttributeError: If the attribute does not exist.\n            TypeError: If the key type is not string\n        \"\"\"\n        return getattr(self, key)", "label": 0}
{"function": "def parse_config(env, config_file_path):\n  \"\"\"Parses configuration file.\n\n  Args:\n    env: The environment in which the preprocessing job will be run.\n    config_file_path: Path to the configuration file to be parsed.\n\n  Returns:\n    A dictionary containing the parsed runtime config.\n  \"\"\"\n  config = configparser.ConfigParser()\n  config.read(config_file_path)\n  return dict(config.items(env))", "label": 1}
{"function": "def run_command(command, shell=False):\n    \"\"\"Run a system command and ensure it succeeds.\"\"\"\n    try:\n        subprocess.run(command, shell=shell, check=True)\n    except subprocess.CalledProcessError as e:\n        print(f\"Error occurred while running command: {e}\")\n        sys.exit(1)", "label": 0}
{"function": "def process(input_image, prompt, n_prompt, seed, total_second_length, latent_window_size, steps, cfg, gs, rs, gpu_memory_preservation, use_teacache, mp4_crf):\n    global stream\n    assert input_image is not None, 'No input image!'\n\n    yield None, None, '', '', gr.update(interactive=False), gr.update(interactive=True)\n\n    stream = AsyncStream()\n\n    async_run(worker, input_image, prompt, n_prompt, seed, total_second_length, latent_window_size, steps, cfg, gs, rs, gpu_memory_preservation, use_teacache, mp4_crf)\n\n    output_filename = None\n\n    while True:\n        flag, data = stream.output_queue.next()\n\n        if flag == 'file':\n            output_filename = data\n            yield output_filename, gr.update(), gr.update(), gr.update(), gr.update(interactive=False), gr.update(interactive=True)\n\n        if flag == 'progress':\n            preview, desc, html = data\n            yield gr.update(), gr.update(visible=True, value=preview), desc, html, gr.update(interactive=False), gr.update(interactive=True)\n\n        if flag == 'end':\n            yield output_filename, gr.update(visible=False), gr.update(), '', gr.update(interactive=True), gr.update(interactive=False)\n            break", "label": 0}
{"function": "    def increment_counter():\n        st.session_state.seed += 1", "label": 0}
{"function": "def readable_server_selector(selection):\n    return selection.with_server_descriptions(\n        [s for s in selection.server_descriptions if s.is_readable])", "label": 1}
{"function": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"checkpoint\", type=str, help=\"the pytorch checkpoint to import\")\n    parser.add_argument(\"out\", type=str, help=\"the mlx safetensors file to generate\")\n    parser.add_argument(\n        \"-s\", \"--silent\", action=\"store_true\", help=\"only prints the checkpoint name\"\n    )\n    parser.add_argument(\"--wpss\", type=str, help=\"weights per step schedule config\")\n    parser.add_argument(\n        \"--max-out-n-q\",\n        type=int,\n        help=\"limit the number of depformer layers that are exported\",\n    )\n    args = parser.parse_args()\n\n    wpss = None\n    if args.wpss is not None:\n        if args.wpss == \"hibiki-2b\":\n            wpss = [0, 1, 2, 3, 4, 5, 6, 7] + [8] * 8 + [9] * 16\n        else:\n            raise ValueError(f\"unknown wpss {args.wpss}\")\n\n    ckpt_path = Path(args.checkpoint)\n    out_path = Path(args.out)\n    if not out_path.exists():\n        import_model(\n            ckpt_path,\n            out_path,\n            weights_per_step_schedule=wpss,\n            silent=args.silent,\n            max_out_n_q=args.max_out_n_q\n        )\n    print(out_path)", "label": 0}
{"function": "    def __init__(self):\n        self.browser = None", "label": 0}
{"function": "def test_detection_chunking(detection_predictor, test_image_tall):\n    detection_results = detection_predictor([test_image_tall])\n\n    assert len(detection_results) == 1\n    assert detection_results[0].image_bbox == [0, 0, 4096, 4096]\n\n    bboxes = detection_results[0].bboxes\n    assert len(bboxes) >= 3 # Sometimes merges into 3\n    assert abs(4000 - bboxes[1].polygon[0][0]) < 50", "label": 0}
{"function": "    def evaluate(path):\n        f = sum(matrix[y][x] for (x, y) in path)\n        h = min(distance(path[-1], target) for target in targets)\n        return f + h", "label": 1}
{"function": "def encode_png_handler(converter: TensorFlowConverter, tf_op: \"tf.Operation\"):\n    raise NotImplementedError(f\"[TensorFlowConverter] {tf_op.type} is not supported yet.\")", "label": 1}
{"function": "    def install_noto_font():\n        # Detect Linux distribution type\n        if os.path.exists('/etc/debian_version'):\n            # Debian/Ubuntu systems\n            cmd = ['sudo', 'apt-get', 'install', '-y', 'fonts-noto']\n            pkg_manager = \"apt-get\"\n        elif os.path.exists('/etc/redhat-release'):\n            # RHEL/CentOS/Fedora systems\n            cmd = ['sudo', 'yum', 'install', '-y', 'google-noto*']\n            pkg_manager = \"yum\"\n        else:\n            console.print(\"Warning: Unrecognized Linux distribution, please install Noto fonts manually\", style=\"yellow\")\n            return\n\n        subprocess.run(cmd, check=True)\n        console.print(f\"\u2705 Successfully installed Noto fonts using {pkg_manager}\", style=\"green\")", "label": 0}
{"function": "def main():\n    # ======================================================\n    # 1. configs & runtime variables\n    # ======================================================\n    # == parse configs ==\n    cfg = parse_configs()\n\n    # == get dtype & device ==\n    dtype = to_torch_dtype(cfg.get(\"dtype\", \"bf16\"))\n    device, coordinator = setup_device()\n    grad_ckpt_buffer_size = cfg.get(\"grad_ckpt_buffer_size\", 0)\n    if grad_ckpt_buffer_size > 0:\n        GLOBAL_ACTIVATION_MANAGER.setup_buffer(grad_ckpt_buffer_size, dtype)\n    checkpoint_io = CheckpointIO()\n    set_seed(cfg.get(\"seed\", 1024))\n    PinMemoryCache.force_dtype = dtype\n    pin_memory_cache_pre_alloc_numels = cfg.get(\"pin_memory_cache_pre_alloc_numels\", None)\n    PinMemoryCache.pre_alloc_numels = pin_memory_cache_pre_alloc_numels\n\n    # == init ColossalAI booster ==\n    plugin_type = cfg.get(\"plugin\", \"zero2\")\n    plugin_config = cfg.get(\"plugin_config\", {})\n    plugin_kwargs = {}\n    if plugin_type == \"hybrid\":\n        plugin_kwargs[\"custom_policy\"] = MMDiTPolicy\n    plugin = create_colossalai_plugin(\n        plugin=plugin_type,\n        dtype=cfg.get(\"dtype\", \"bf16\"),\n        grad_clip=cfg.get(\"grad_clip\", 0),\n        **plugin_config,\n        **plugin_kwargs,\n    )\n    booster = Booster(plugin=plugin)\n\n    seq_align = plugin_config.get(\"sp_size\", 1)\n\n    # == init exp_dir ==\n    exp_name, exp_dir = create_experiment_workspace(\n        cfg.get(\"outputs\", \"./outputs\"),\n        model_name=config_to_name(cfg),\n        config=cfg.to_dict(),\n        exp_name=cfg.get(\"exp_name\", None),  # useful for automatic restart to specify the exp_name\n    )\n\n    if is_log_process(plugin_type, plugin_config):\n        print(f\"changing {exp_dir} to share\")\n        os.system(f\"chgrp -R share {exp_dir}\")\n\n    # == init logger, tensorboard & wandb ==\n    logger = create_logger(exp_dir)\n    logger.info(\"Training configuration:\\n %s\", pformat(cfg.to_dict()))\n    tb_writer = None\n    if coordinator.is_master():\n        tb_writer = create_tensorboard_writer(exp_dir)\n        if cfg.get(\"wandb\", False):\n            wandb.init(\n                project=cfg.get(\"wandb_project\", \"Open-Sora\"),\n                name=exp_name,\n                config=cfg.to_dict(),\n                dir=exp_dir,\n            )\n    num_gpus = dist.get_world_size() if dist.is_initialized() else 1\n    tp_size = cfg[\"plugin_config\"].get(\"tp_size\", 1)\n    sp_size = cfg[\"plugin_config\"].get(\"sp_size\", 1)\n    pp_size = cfg[\"plugin_config\"].get(\"pp_size\", 1)\n    num_groups = num_gpus // (tp_size * sp_size * pp_size)\n    logger.info(\"Number of GPUs: %s\", num_gpus)\n    logger.info(\"Number of groups: %s\", num_groups)\n\n    # ======================================================\n    # 2. build dataset and dataloader\n    # ======================================================\n    logger.info(\"Building dataset...\")\n    # == build dataset ==\n    dataset = build_module(cfg.dataset, DATASETS)\n    logger.info(\"Dataset contains %s samples.\", len(dataset))\n\n    # == build dataloader ==\n    cache_pin_memory = pin_memory_cache_pre_alloc_numels is not None\n    dataloader_args = dict(\n        dataset=dataset,\n        batch_size=cfg.get(\"batch_size\", None),\n        num_workers=cfg.get(\"num_workers\", 4),\n        seed=cfg.get(\"seed\", 1024),\n        shuffle=True,\n        drop_last=True,\n        pin_memory=True,\n        process_group=get_data_parallel_group(),\n        prefetch_factor=cfg.get(\"prefetch_factor\", None),\n        cache_pin_memory=cache_pin_memory,\n        num_groups=num_groups,\n    )\n    print_mem(\"before prepare_dataloader\")\n    dataloader, sampler = prepare_dataloader(\n        bucket_config=cfg.get(\"bucket_config\", None),\n        num_bucket_build_workers=cfg.get(\"num_bucket_build_workers\", 1),\n        **dataloader_args,\n    )\n    print_mem(\"after prepare_dataloader\")\n    num_steps_per_epoch = len(dataloader)\n    dataset.to_efficient()\n\n    # ======================================================\n    # 3. build model\n    # ======================================================\n    logger.info(\"Building models...\")\n\n    # == build model model ==\n    model = build_module(cfg.model, MODELS, device_map=device, torch_dtype=dtype).train()\n    if cfg.get(\"grad_checkpoint\", True):\n        set_grad_checkpoint(model)\n    log_cuda_memory(\"diffusion\")\n    log_model_params(model)\n\n    # == build EMA model ==\n    use_lora = cfg.get(\"lora_config\", None) is not None\n    if cfg.get(\"ema_decay\", None) is not None and not use_lora:\n        ema = deepcopy(model).cpu().eval().requires_grad_(False)\n        ema_shape_dict = record_model_param_shape(ema)\n        logger.info(\"EMA model created.\")\n    else:\n        ema = ema_shape_dict = None\n        logger.info(\"No EMA model created.\")\n    log_cuda_memory(\"EMA\")\n\n    # == enable LoRA ==\n    if use_lora:\n        lora_config = LoraConfig(**cfg.get(\"lora_config\", None))\n        model = booster.enable_lora(\n            model=model,\n            lora_config=lora_config,\n            pretrained_dir=cfg.get(\"lora_checkpoint\", None),\n        )\n        log_cuda_memory(\"lora\")\n        log_model_params(model)\n\n    if not cfg.get(\"cached_video\", False):\n        # == buildn autoencoder ==\n        model_ae = build_module(cfg.ae, MODELS, device_map=device, torch_dtype=dtype).eval().requires_grad_(False)\n        del model_ae.decoder\n        log_cuda_memory(\"autoencoder\")\n        log_model_params(model_ae)\n        model_ae.encode = torch.compile(model_ae.encoder, dynamic=True)\n\n    if not cfg.get(\"cached_text\", False):\n        # == build text encoder (t5) ==\n        model_t5 = build_module(cfg.t5, MODELS, device_map=device, torch_dtype=dtype).eval().requires_grad_(False)\n        log_cuda_memory(\"t5\")\n        log_model_params(model_t5)\n\n        # == build text encoder (clip) ==\n        model_clip = build_module(cfg.clip, MODELS, device_map=device, torch_dtype=dtype).eval().requires_grad_(False)\n        log_cuda_memory(\"clip\")\n        log_model_params(model_clip)\n\n    # == setup optimizer ==\n    optimizer = create_optimizer(model, cfg.optim)\n\n    # == setup lr scheduler ==\n    lr_scheduler = create_lr_scheduler(\n        optimizer=optimizer,\n        num_steps_per_epoch=num_steps_per_epoch,\n        epochs=cfg.get(\"epochs\", 1000),\n        warmup_steps=cfg.get(\"warmup_steps\", None),\n        use_cosine_scheduler=cfg.get(\"use_cosine_scheduler\", False),\n    )\n    log_cuda_memory(\"optimizer\")\n\n    # == prepare null vectors for dropout ==\n    if cfg.get(\"cached_text\", False):\n        null_txt = torch.load(\"/mnt/ddn/sora/tmp_load/null_t5.pt\", map_location=device)\n        null_vec = torch.load(\"/mnt/ddn/sora/tmp_load/null_clip.pt\", map_location=device)\n    else:\n        null_txt = model_t5(\"\")\n        null_vec = model_clip(\"\")\n\n    # =======================================================\n    # 4. distributed training preparation with colossalai\n    # =======================================================\n    logger.info(\"Preparing for distributed training...\")\n    # == boosting ==\n    torch.set_default_dtype(dtype)\n    model, optimizer, _, dataloader, lr_scheduler = booster.boost(\n        model=model,\n        optimizer=optimizer,\n        lr_scheduler=lr_scheduler,\n        dataloader=dataloader,\n    )\n    torch.set_default_dtype(torch.float)\n    logger.info(\"Boosted model for distributed training\")\n    log_cuda_memory(\"boost\")\n\n    # == global variables ==\n    cfg_epochs = cfg.get(\"epochs\", 1000)\n    log_step = acc_step = 0\n    running_loss = 0.0\n    timers = Timers(record_time=cfg.get(\"record_time\", False), record_barrier=cfg.get(\"record_barrier\", False))\n    nsys = NsysProfiler(\n        warmup_steps=cfg.get(\"nsys_warmup_steps\", 2),\n        num_steps=cfg.get(\"nsys_num_steps\", 2),\n        enabled=cfg.get(\"nsys\", False),\n    )\n    logger.info(\"Training for %s epochs with %s steps per epoch\", cfg_epochs, num_steps_per_epoch)\n\n    # == resume ==\n    load_master_weights = cfg.get(\"load_master_weights\", False)\n    save_master_weights = cfg.get(\"save_master_weights\", False)\n    start_epoch = cfg.get(\"start_epoch\", None)\n    start_step = cfg.get(\"start_step\", None)\n    if cfg.get(\"load\", None) is not None:\n        logger.info(\"Loading checkpoint from %s\", cfg.load)\n\n        lr_scheduler_to_load = lr_scheduler\n        if cfg.get(\"update_warmup_steps\", False):\n            lr_scheduler_to_load = None\n        ret = checkpoint_io.load(\n            booster,\n            cfg.load,\n            model=model,\n            ema=ema,\n            optimizer=optimizer,\n            lr_scheduler=lr_scheduler_to_load,\n            sampler=(\n                None if start_step is not None else sampler\n            ),  # if specify start step, set last_micro_batch_access_index of a new sampler instead\n            include_master_weights=load_master_weights,\n        )\n        start_epoch = start_epoch if start_epoch is not None else ret[0]\n        start_step = start_step if start_step is not None else ret[1]\n        logger.info(\"Loaded checkpoint %s at epoch %s step %s\", cfg.load, ret[0], ret[1])\n\n        # load optimizer and scheduler will overwrite some of the hyperparameters, so we need to reset them\n        set_lr(optimizer, lr_scheduler, cfg.optim.lr, cfg.get(\"initial_lr\", None))\n        set_eps(optimizer, cfg.optim.eps)\n\n        if cfg.get(\"update_warmup_steps\", False):\n            assert (\n                cfg.get(\"warmup_steps\", None) is not None\n            ), \"you need to set warmup_steps in order to pass --update-warmup-steps True\"\n            # set_warmup_steps(lr_scheduler, cfg.warmup_steps)\n            lr_scheduler.step(start_epoch * num_steps_per_epoch + start_step)\n            logger.info(\"The learning rate starts from %s\", optimizer.param_groups[0][\"lr\"])\n    if start_step is not None:\n        # if start step exceeds data length, go to next epoch\n        if start_step > num_steps_per_epoch:\n            start_epoch = (\n                start_epoch + start_step // num_steps_per_epoch\n                if start_epoch is not None\n                else start_step // num_steps_per_epoch\n            )\n            start_step = start_step % num_steps_per_epoch\n    else:\n        start_step = 0\n    sampler.set_step(start_step)\n    start_epoch = start_epoch if start_epoch is not None else 0\n    logger.info(\"Starting from epoch %s step %s\", start_epoch, start_step)\n\n    # == sharding EMA model ==\n    if ema is not None:\n        model_sharding(ema)\n        ema = ema.to(device)\n        log_cuda_memory(\"sharding EMA\")\n\n    # == warmup autoencoder ==\n    if cfg.get(\"warmup_ae\", False):\n        shapes = bucket_to_shapes(cfg.get(\"bucket_config\", None), batch_size=cfg.ae.batch_size)\n        warmup_ae(model_ae, shapes, device, dtype)\n\n    # =======================================================\n    # 5. training iter\n    # =======================================================\n    sigma_min = cfg.get(\"sigma_min\", 1e-5)\n    accumulation_steps = cfg.get(\"accumulation_steps\", 1)\n    ckpt_every = cfg.get(\"ckpt_every\", 0)\n\n    if cfg.get(\"is_causal_vae\", False):\n        prepare_visual_condition = prepare_visual_condition_causal\n    else:\n        prepare_visual_condition = prepare_visual_condition_uncausal\n\n    @torch.no_grad()\n    def prepare_inputs(batch):\n        inp = dict()\n        x = batch.pop(\"video\")\n        y = batch.pop(\"text\")\n        bs = x.shape[0]\n\n        # == encode video ==\n        with nsys.range(\"encode_video\"), timers[\"encode_video\"]:\n            # == prepare condition ==\n            if cfg.get(\"condition_config\", None) is not None:\n                # condition for i2v & v2v\n                x_0, cond = prepare_visual_condition(x, cfg.condition_config, model_ae)\n                cond = pack(cond, patch_size=cfg.get(\"patch_size\", 2))\n                inp[\"cond\"] = cond\n            else:\n                if cfg.get(\"cached_video\", False):\n                    x_0 = batch.pop(\"video_latents\").to(device=device, dtype=dtype)\n                else:\n                    x_0 = model_ae.encode(x)\n\n        # == prepare timestep ==\n        # follow SD3 time shift, shift_alpha = 1 for 256px and shift_alpha = 3 for 1024px\n        shift_alpha = get_res_lin_function()((x_0.shape[-1] * x_0.shape[-2]) // 4)\n        # add temporal influence\n        shift_alpha *= math.sqrt(x_0.shape[-3])  # for image, T=1 so no effect\n        t = torch.sigmoid(torch.randn((bs), device=device))\n        t = time_shift(shift_alpha, t).to(dtype)\n\n        if cfg.get(\"cached_text\", False):\n            # == encode text ==\n            t5_embedding = batch.pop(\"text_t5\").to(device=device, dtype=dtype)\n            clip_embedding = batch.pop(\"text_clip\").to(device=device, dtype=dtype)\n            with nsys.range(\"encode_text\"), timers[\"encode_text\"]:\n                inp_ = prepare_ids(x_0, t5_embedding, clip_embedding)\n                inp.update(inp_)\n                x_0 = pack(x_0, patch_size=cfg.get(\"patch_size\", 2))\n        else:\n            # == encode text ==\n            with nsys.range(\"encode_text\"), timers[\"encode_text\"]:\n                inp_ = prepare(\n                    model_t5,\n                    model_clip,\n                    x_0,\n                    prompt=y,\n                    seq_align=seq_align,\n                    patch_size=cfg.get(\"patch_size\", 2),\n                )\n                inp.update(inp_)\n                x_0 = pack(x_0, patch_size=cfg.get(\"patch_size\", 2))\n\n        # == dropout ==\n        if cfg.get(\"dropout_ratio\", None) is not None:\n            cur_null_txt = null_txt\n            num_pad_null_txt = inp[\"txt\"].shape[1] - cur_null_txt.shape[1]\n            if num_pad_null_txt > 0:\n                cur_null_txt = torch.cat([cur_null_txt] + [cur_null_txt[:, -1:]] * num_pad_null_txt, dim=1)\n            inp[\"txt\"] = dropout_condition(\n                cfg.dropout_ratio.get(\"t5\", 0.0),\n                inp[\"txt\"],\n                cur_null_txt,\n            )\n            inp[\"y_vec\"] = dropout_condition(\n                cfg.dropout_ratio.get(\"clip\", 0.0),\n                inp[\"y_vec\"],\n                null_vec,\n            )\n\n        # == prepare noise vector ==\n        x_1 = torch.randn_like(x_0, dtype=torch.float32).to(device, dtype)\n        t_rev = 1 - t\n        x_t = t_rev[:, None, None] * x_0 + (1 - (1 - sigma_min) * t_rev[:, None, None]) * x_1\n        inp[\"img\"] = x_t\n        inp[\"timesteps\"] = t.to(dtype)\n        inp[\"guidance\"] = torch.full((x_t.shape[0],), cfg.get(\"guidance\", 4), device=x_t.device, dtype=x_t.dtype)\n\n        return inp, x_0, x_1\n\n    def run_iter(inp, x_0, x_1):\n        if is_pipeline_enabled(plugin_type, plugin_config):\n            inp[\"target\"] = (1 - sigma_min) * x_1 - x_0  # follow MovieGen, modify V_t accordingly\n            with nsys.range(\"forward-backward\"), timers[\"forward-backward\"]:\n                data_iter = iter([inp])\n                if cfg.get(\"no_i2v_ref_loss\", False):\n                    loss_fn = (\n                        lambda out, input_: get_batch_loss(out, input_[\"target\"], input_.pop(\"masks\", None))\n                        / accumulation_steps\n                    )\n                else:\n                    loss_fn = (\n                        lambda out, input_: F.mse_loss(out.float(), input_[\"target\"].float(), reduction=\"mean\")\n                        / accumulation_steps\n                    )\n                loss = booster.execute_pipeline(data_iter, model, loss_fn, optimizer)[\"loss\"]\n                loss = loss * accumulation_steps if loss is not None else loss\n                loss_item = all_reduce_mean(loss.data.clone().detach())\n        else:\n            with nsys.range(\"forward\"), timers[\"forward\"]:\n                model_pred = model(**inp)  # B, T, L\n                v_t = (1 - sigma_min) * x_1 - x_0\n                if cfg.get(\"no_i2v_ref_loss\", False):\n                    loss = get_batch_loss(model_pred, v_t, inp.pop(\"masks\", None))\n                else:\n                    loss = F.mse_loss(model_pred.float(), v_t.float(), reduction=\"mean\")\n\n            loss_item = all_reduce_mean(loss.data.clone().detach()).item()\n\n            # == backward & update ==\n            dist.barrier()\n            with nsys.range(\"backward\"), timers[\"backward\"]:\n                ctx = (\n                    booster.no_sync(model, optimizer)\n                    if cfg.get(\"plugin\", \"zero2\") in (\"zero1\", \"zero1-seq\") and (step + 1) % accumulation_steps != 0\n                    else nullcontext()\n                )\n                with ctx:\n                    booster.backward(loss=(loss / accumulation_steps), optimizer=optimizer)\n\n        with nsys.range(\"optim\"), timers[\"optim\"]:\n            if (step + 1) % accumulation_steps == 0:\n                booster.checkpoint_io.synchronize()\n                optimizer.step()\n                optimizer.zero_grad()\n            if lr_scheduler is not None:\n                lr_scheduler.step()\n\n        # == update EMA ==\n        if ema is not None:\n            with nsys.range(\"update_ema\"), timers[\"update_ema\"]:\n                update_ema(\n                    ema,\n                    model.unwrap(),\n                    optimizer=optimizer,\n                    decay=cfg.get(\"ema_decay\", 0.9999),\n                )\n\n        return loss_item\n\n    # =======================================================\n    # 6. training loop\n    # =======================================================\n    dist.barrier()\n    for epoch in range(start_epoch, cfg_epochs):\n        # == set dataloader to new epoch ==\n        sampler.set_epoch(epoch)\n        dataloader_iter = iter(dataloader)\n        logger.info(\"Beginning epoch %s...\", epoch)\n\n        # == training loop in an epoch ==\n        with tqdm(\n            enumerate(dataloader_iter, start=start_step),\n            desc=f\"Epoch {epoch}\",\n            disable=not is_log_process(plugin_type, plugin_config),\n            initial=start_step,\n            total=num_steps_per_epoch,\n        ) as pbar:\n            pbar_iter = iter(pbar)\n\n            # prefetch one for non-blocking data loading\n            def fetch_data():\n                step, batch = next(pbar_iter)\n                # print(f\"==debug== rank{dist.get_rank()} {dataloader_iter.get_cache_info()}\")\n                pinned_video = batch[\"video\"]\n                batch[\"video\"] = pinned_video.to(device, dtype, non_blocking=True)\n                return batch, step, pinned_video\n\n            batch_, step_, pinned_video_ = fetch_data()\n\n            for _ in range(start_step, num_steps_per_epoch):\n                nsys.step()\n                # == load data ===\n                with nsys.range(\"load_data\"), timers[\"load_data\"]:\n                    batch, step, pinned_video = batch_, step_, pinned_video_\n\n                    if step + 1 < num_steps_per_epoch:\n                        # only fetch new data if not last step\n                        batch_, step_, pinned_video_ = fetch_data()\n\n                # == run iter ==\n                with nsys.range(\"iter\"), timers[\"iter\"]:\n                    inp, x_0, x_1 = prepare_inputs(batch)\n                    if cache_pin_memory:\n                        dataloader_iter.remove_cache(pinned_video)\n                    loss = run_iter(inp, x_0, x_1)\n\n                # == update log info ==\n                if loss is not None:\n                    running_loss += loss\n\n                # == log config ==\n                global_step = epoch * num_steps_per_epoch + step\n                actual_update_step = (global_step + 1) // accumulation_steps\n                log_step += 1\n                acc_step += 1\n\n                # == logging ==\n                if (global_step + 1) % accumulation_steps == 0:\n                    if actual_update_step % cfg.get(\"log_every\", 1) == 0:\n                        if is_log_process(plugin_type, plugin_config):\n                            avg_loss = running_loss / log_step\n                            # progress bar\n                            pbar.set_postfix(\n                                {\n                                    \"loss\": avg_loss,\n                                    \"global_grad_norm\": optimizer.get_grad_norm(),\n                                    \"step\": step,\n                                    \"global_step\": global_step,\n                                    # \"actual_update_step\": actual_update_step,\n                                    \"lr\": optimizer.param_groups[0][\"lr\"],\n                                }\n                            )\n                            # tensorboard\n                            if tb_writer is not None:\n                                tb_writer.add_scalar(\"loss\", loss, actual_update_step)\n                            # wandb\n                            if cfg.get(\"wandb\", False):\n                                wandb_dict = {\n                                    \"iter\": global_step,\n                                    \"acc_step\": acc_step,\n                                    \"epoch\": epoch,\n                                    \"loss\": loss,\n                                    \"avg_loss\": avg_loss,\n                                    \"lr\": optimizer.param_groups[0][\"lr\"],\n                                    \"eps\": optimizer.param_groups[0][\"eps\"],\n                                    \"global_grad_norm\": optimizer.get_grad_norm(),  # test grad norm\n                                }\n                                if cfg.get(\"record_time\", False):\n                                    wandb_dict.update(timers.to_dict())\n                                wandb.log(wandb_dict, step=actual_update_step)\n\n                        running_loss = 0.0\n                        log_step = 0\n\n                # == checkpoint saving ==\n                # uncomment below 3 lines to forcely clean cache\n                with nsys.range(\"clean_cache\"), timers[\"clean_cache\"]:\n                    if ckpt_every > 0 and actual_update_step % ckpt_every == 0 and coordinator.is_master():\n                        subprocess.run(\"sudo drop_cache\", shell=True)\n\n                with nsys.range(\"checkpoint\"), timers[\"checkpoint\"]:\n                    if ckpt_every > 0 and actual_update_step % ckpt_every == 0:\n                        # mannual garbage collection\n                        gc.collect()\n\n                        save_dir = checkpoint_io.save(\n                            booster,\n                            exp_dir,\n                            model=model,\n                            ema=ema,\n                            optimizer=optimizer,\n                            lr_scheduler=lr_scheduler,\n                            sampler=sampler,\n                            epoch=epoch,\n                            step=step + 1,\n                            global_step=global_step + 1,\n                            batch_size=cfg.get(\"batch_size\", None),\n                            lora=use_lora,\n                            actual_update_step=actual_update_step,\n                            ema_shape_dict=ema_shape_dict,\n                            async_io=cfg.get(\"async_io\", False),\n                            include_master_weights=save_master_weights,\n                        )\n\n                        if is_log_process(plugin_type, plugin_config):\n                            os.system(f\"chgrp -R share {save_dir}\")\n\n                        logger.info(\n                            \"Saved checkpoint at epoch %s, step %s, global_step %s to %s\",\n                            epoch,\n                            step + 1,\n                            actual_update_step,\n                            save_dir,\n                        )\n\n                        # remove old checkpoints\n                        rm_checkpoints(exp_dir, keep_n_latest=cfg.get(\"keep_n_latest\", -1))\n                        logger.info(\"Removed old checkpoints and kept %s latest ones.\", cfg.get(\"keep_n_latest\", -1))\n                # uncomment below 3 lines to benchmark checkpoint\n                # if ckpt_every > 0 and actual_update_step % ckpt_every == 0:\n                #     booster.checkpoint_io._sync_io()\n                #     checkpoint_io._sync_io()\n                # == terminal timer ==\n                if cfg.get(\"record_time\", False):\n                    print(timers.to_str(epoch, step))\n\n        sampler.reset()\n        start_step = 0\n    log_cuda_max_memory(\"final\")", "label": 0}
{"function": "    def test_query_multi_param(self):\n        \"\"\"\n        wineventlog - Query by multiple params\n        \"\"\"\n        self.write_event_log(\"selected\", source=self.otherAppName,\n                             eventID=556, level=win32evtlog.EVENTLOG_ERROR_TYPE)\n        self.write_event_log(\"filtered\", source=self.otherAppName, eventID=556)\n        self.write_event_log(\n            \"filtered\", level=win32evtlog.EVENTLOG_WARNING_TYPE)\n        evts = self.read_events(config={\n            \"event_logs\": [\n                {\n                    \"name\": self.providerName,\n                    \"api\": self.api,\n                    \"event_id\": \"10-20, 30-40, -35, -18, 400-1000, -432\",\n                    \"level\": \"warn, error\",\n                    \"provider\": [self.otherAppName]\n                }\n            ]\n        })\n        self.assertTrue(len(evts), 1)\n        self.assertEqual(evts[0][\"message\"], \"selected\")", "label": 1}
{"function": "async def process_query(\n    query: str,\n    client: QdrantClient,\n    embedding_model: TextEmbedding,\n    collection_name: str,\n    openai_api_key: str,\n    voice: str\n) -> Dict:\n    \"\"\"Process user query and generate voice response.\"\"\"\n    try:\n        st.info(\"\ud83d\udd04 Step 1: Generating query embedding and searching documents...\")\n        # Get query embedding and search\n        query_embedding = list(embedding_model.embed([query]))[0]\n        st.write(f\"Generated embedding of size: {len(query_embedding)}\")\n        \n        search_response = client.query_points(\n            collection_name=collection_name,\n            query=query_embedding.tolist(),\n            limit=3,\n            with_payload=True\n        )\n        \n        search_results = search_response.points if hasattr(search_response, 'points') else []\n        st.write(f\"Found {len(search_results)} relevant documents\")\n        \n        if not search_results:\n            raise Exception(\"No relevant documents found in the vector database\")\n        \n        st.info(\"\ud83d\udd04 Step 2: Preparing context from search results...\")\n        # Prepare context from search results\n        context = \"Based on the following documentation:\\n\\n\"\n        for i, result in enumerate(search_results, 1):\n            payload = result.payload\n            if not payload:\n                continue\n            content = payload.get('content', '')\n            source = payload.get('file_name', 'Unknown Source')\n            context += f\"From {source}:\\n{content}\\n\\n\"\n            st.write(f\"Document {i} from: {source}\")\n        \n        context += f\"\\nUser Question: {query}\\n\\n\"\n        context += \"Please provide a clear, concise answer that can be easily spoken out loud.\"\n        \n        st.info(\"\ud83d\udd04 Step 3: Setting up agents...\")\n        # Setup agents if not already done\n        if not st.session_state.processor_agent or not st.session_state.tts_agent:\n            processor_agent, tts_agent = setup_agents(openai_api_key)\n            st.session_state.processor_agent = processor_agent\n            st.session_state.tts_agent = tts_agent\n            st.write(\"Initialized new processor and TTS agents\")\n        else:\n            st.write(\"Using existing agents\")\n        \n        st.info(\"\ud83d\udd04 Step 4: Generating text response...\")\n        # Generate text response using processor agent\n        processor_result = await Runner.run(st.session_state.processor_agent, context)\n        text_response = processor_result.final_output\n        st.write(f\"Generated text response of length: {len(text_response)}\")\n        \n        st.info(\"\ud83d\udd04 Step 5: Generating voice instructions...\")\n        # Generate voice instructions using TTS agent\n        tts_result = await Runner.run(st.session_state.tts_agent, text_response)\n        voice_instructions = tts_result.final_output\n        st.write(f\"Generated voice instructions of length: {len(voice_instructions)}\")\n        \n        st.info(\"\ud83d\udd04 Step 6: Generating and playing audio...\")\n        # Generate and play audio with streaming\n        async_openai = AsyncOpenAI(api_key=openai_api_key)\n        \n        # First create streaming response\n        async with async_openai.audio.speech.with_streaming_response.create(\n            model=\"gpt-4o-mini-tts\",\n            voice=voice,\n            input=text_response,\n            instructions=voice_instructions,\n            response_format=\"pcm\",\n        ) as stream_response:\n            st.write(\"Starting audio playback...\")\n            # Play audio directly using LocalAudioPlayer\n            await LocalAudioPlayer().play(stream_response)\n            st.write(\"Audio playback complete\")\n            \n            st.write(\"Generating downloadable MP3 version...\")\n            # Also save as MP3 for download\n            audio_response = await async_openai.audio.speech.create(\n                model=\"gpt-4o-mini-tts\",\n                voice=voice,\n                input=text_response,\n                instructions=voice_instructions,\n                response_format=\"mp3\"\n            )\n            \n            temp_dir = tempfile.gettempdir()\n            audio_path = os.path.join(temp_dir, f\"response_{uuid.uuid4()}.mp3\")\n            \n            with open(audio_path, \"wb\") as f:\n                f.write(audio_response.content)\n            st.write(f\"Saved MP3 file to: {audio_path}\")\n        \n        st.success(\"\u2705 Query processing complete!\")\n        return {\n            \"status\": \"success\",\n            \"text_response\": text_response,\n            \"voice_instructions\": voice_instructions,\n            \"audio_path\": audio_path,\n            \"sources\": [r.payload.get('file_name', 'Unknown Source') for r in search_results if r.payload]\n        }\n    \n    except Exception as e:\n        st.error(f\"\u274c Error during query processing: {str(e)}\")\n        return {\n            \"status\": \"error\",\n            \"error\": str(e),\n            \"query\": query\n        }", "label": 0}
{"function": "  def testContainsWildcardMultipleMatches(self, mock_CreateWildcardIterator,\n                                          mock_gsutil_api):\n    mock_CreateWildcardIterator.return_value = iter([\n        BucketListingObject(StorageUrlFromString('gs://test/helloworld')),\n        BucketListingObject(StorageUrlFromString('gs://test/helloworld2'))\n    ])\n    with self.assertRaises(CommandException):\n      ExpandUrlToSingleBlr('gs://test/hello*/', mock_gsutil_api, 'project_id',\n                           False, CreateOrGetGsutilLogger('copy_test'))", "label": 1}
{"function": "def shutdown_trace_provider():\n    yield\n    get_trace_provider().shutdown()", "label": 0}
{"function": "    def reg(self):\n        return self.value.reg", "label": 1}
{"function": "  def testCalcReductionLayers(self):\n    num_cells = 18\n    num_reduction_layers = 2\n    reduction_layers = nasnet_utils.calc_reduction_layers(\n        num_cells, num_reduction_layers)\n    self.assertEqual(len(reduction_layers), 2)\n    self.assertEqual(reduction_layers[0], 6)\n    self.assertEqual(reduction_layers[1], 12)", "label": 1}
{"function": "    def _wrap_object(self, space, obj):\n        return space.newlong_from_rarith_int(obj)", "label": 1}
{"function": "def _GatherGrad(op, grad):\n  \"\"\"Gradient for Gather op.\"\"\"\n  if op.inputs[0].get_shape().is_fully_defined():\n    dense_shape = constant_op.constant(op.inputs[0].get_shape().as_list())\n    values_shape = [-1] + op.inputs[0].get_shape()[1:].as_list()\n  else:\n    # op.inputs[0] can be large, so colocate the shape calculation with it.\n    with ops.colocate_with(op.inputs[0]):\n      dense_shape = array_ops.shape(op.inputs[0])\n      values_shape = array_ops.concat(0, [[-1], dense_shape[1:]])\n\n  values = array_ops.reshape(grad, values_shape)\n  indices = array_ops.reshape(op.inputs[1], [-1])\n  return [ops.IndexedSlices(values, indices, dense_shape), None]", "label": 1}
{"function": "    def test_ranges(self):\n        self.l1.flush()\n        self.c1.flush()\n        self.c2.flush()\n\n        # Subscribe to range 1000-1999...\n        dg = Datagram.create_add_range(1000, 1999)\n        self.c1.send(dg)\n        # Verify that l1 asks for the range as well...\n        self.expect(self.l1, dg)\n\n        # Send messages on a few channels on c2, see which ones c1 gets.\n        def check_channels(channels):\n            for channel, should_receive in channels:\n                dg = Datagram.create([channel], 123456789, 5858)\n                dg.add_uint16(channel) # For some semblance of uniqueness\n\n                self.c2.send(dg)\n\n                if should_receive:\n                    self.expect(self.c1, dg)\n                    self.expectNone(self.c1) # No repeats!\n                else:\n                    self.expectNone(self.c1)\n\n                # And, of course, l1 receives all of these:\n                self.expect(self.l1, dg)\n\n        check_channels([\n            (500, False),\n            (999, False),\n            (1000, True),\n            (1001, True),\n            (1299, True),\n            (1300, True),\n            (1500, True),\n            (1699, True),\n            (1700, True),\n            (1701, True),\n            (1900, True),\n            (1999, True),\n            (2000, False),\n            (2050, False),\n            (2500, False)])\n\n        # Ranged-subscriptions should still receive messages only once, even if\n        # multiple channels are in the range.\n        dg = Datagram.create([500, 1001, 1500], 0, 34)\n        dg.add_string('test')\n        self.c2.send(dg)\n        self.expect(self.c1, dg)\n        self.expectNone(self.c1) # No repeats!\n        self.expect(self.l1, dg)\n\n        # Now let's \"slice\" the range.\n        dg = Datagram.create_remove_range(1300, 1700)\n        self.c1.send(dg)\n        # l1 should request the slice upward\n        self.expect(self.l1, dg)\n\n        # And the slice should be gone:\n        check_channels([\n            (500, False),\n            (999, False),\n            (1000, True),\n            (1001, True),\n            (1299, True),\n            (1300, False),\n            (1500, False),\n            (1699, False),\n            (1700, False),\n            (1701, True),\n            (1900, True),\n            (1999, True),\n            (2000, False),\n            (2050, False),\n            (2500, False)])\n\n        # How about adding a second range that overlaps?\n        dg = Datagram.create_add_range(1900, 2100)\n        self.c1.send(dg)\n        # Verify that md asks for the entire range from l1...\n        self.expect(self.l1, dg)\n\n        # Now the subscriptions should be updated:\n        check_channels([\n            (500, False),\n            (999, False),\n            (1000, True),\n            (1001, True),\n            (1299, True),\n            (1300, False),\n            (1500, False),\n            (1699, False),\n            (1700, False),\n            (1701, True),\n            (1900, True),\n            (1999, True),\n            (2000, True),\n            (2050, True),\n            (2500, False)])\n\n        # Drop that first range...\n        dg = Datagram.create_remove_range(1000, 1999)\n        self.c1.send(dg)\n\n        # -- See comments after block --\n        ## And again, l1 should ask for difference only...\n        #expected = []\n        ## Difference #1: Drop 1000-1299\n        #expected.append(Datagram.create_remove_range(1000, 1299))\n        ## Difference #2: Drop 1701-1999\n        #expected.append(Datagram.create_remove_range(1701, 1999))\n        #self.expectMany(self.l1, expected)\n\n        # In this case because there are no remaining subscriptions in the\n        # entire removed range, it is more efficient for the network, CPU,\n        # and memory to just forward the entire range.\n        dg = Datagram.create_remove_range(1000, 1999)\n        self.expect(self.l1, dg)\n\n        # Now see if only the second range is active...\n        check_channels([\n            (500, False),\n            (999, False),\n            (1000, False),\n            (1001, False),\n            (1999, False),\n            (2000, True),\n            (2050, True),\n            (2500, False)])\n\n        # Grand finale: Cut c1 and see if the remaining range dies.\n        self.c1.close()\n        self.c1 = self.connectToServer()\n        self.expect(self.l1, Datagram.create_remove_range(2000, 2100))\n        self.expectNone(self.l1)\n\n        # ... but we lied! Now there are some more tests\n\n        # Lets add a new range to play with\n        dg = Datagram.create_add_range(3000, 5000)\n        self.c1.send(dg)\n        self.expect(self.l1, dg)\n        check_channels([\n            (2499, False),\n            (2501, False),\n            (2999, False),\n            (3000, True),\n            (4000, True),\n            (4372, True),\n            (5000, True),\n            (5001, False),\n            (5109, False)])\n\n        # Test removing a range that intersects with the front part\n        dg = Datagram.create_remove_range(2950, 3043)\n        self.c1.send(dg)\n        # --> and expect only the subscribed part to be removed\n        dg = Datagram.create_remove_range(3000, 3043)\n        self.expect(self.l1, dg)\n        check_channels([\n            (2913, False),\n            (2999, False),\n            (3000, False),\n            (3043, False),\n            (3044, True),\n            (4000, True),\n            (4372, True),\n            (5000, True),\n            (5001, False),\n            (5109, False)])\n\n        # Test removing a range that intersects with the end part\n        dg = Datagram.create_remove_range(4763, 6000)\n        self.c1.send(dg)\n        # --> and expect only the subscribed part to be removed\n        dg = Datagram.create_remove_range(4763, 5000)\n        self.expect(self.l1, dg)\n        check_channels([\n            (3000, False),\n            (3043, False),\n            (3044, True),\n            (4000, True),\n            (4372, True),\n            (4762, True),\n            (4763, False),\n            (5000, False),\n            (5001, False),\n            (5109, False)])\n\n        # Now remove some from the middle again so we can test weird intersections\n        dg = Datagram.create_remove_range(3951, 4049)\n        self.c1.send(dg)\n        # The entire range is subscribed, so it should all be unsubscribed\n        self.expect(self.l1, dg)\n        check_channels([\n            (3043, False),\n            (3044, True),\n            (3802, True),\n            (3950, True),\n            (3951, False),\n            (4049, False),\n            (4050, True),\n            (4133, True),\n            (4762, True),\n            (4763, False)])\n\n        # Ok... remove an intersection from the lower half of the upper range\n        dg = Datagram.create_remove_range(4030, 4070)\n        self.c1.send(dg)\n        # N.B. Its worth considering which of the following behaviors is preferred,\n        #      the first is a lot more work for the current MD, but may reduce the\n        #      work for other MDs. Consider performance testing both implementations.\n        ## --> and expect only the subscribed part to be removed\n        #self.expect(self.l1, Datagram.create_remove_range(4050, 4070))\n        self.expect(self.l1, dg)\n        check_channels([\n            (3043, False),\n            (3044, True),\n            (3802, True),\n            (3950, True),\n            (3951, False),\n            (4070, False),\n            (4071, True),\n            (4133, True),\n            (4762, True),\n            (4763, False)])\n\n        # Now remove an intersection from the upper half of the lower range\n        dg = Datagram.create_remove_range(3891, 4040)\n        self.c1.send(dg)\n        # N.B. Its worth considering which of the following behaviors is preferred,\n        #      the first is a lot more work for the current MD, but may reduce the\n        #      work for other MDs. Consider performance testing both implementations.\n        ## --> and expect only the subscribed part to be removed\n        #self.expect(self.l1, Datagram.create_remove_range(3891, 3950))\n        self.expect(self.l1, dg)\n        check_channels([\n            (3043, False),\n            (3044, True),\n            (3672, True),\n            (3890, True),\n            (3891, False),\n            (3893, False),\n            (4070, False),\n            (4071, True),\n            (4762, True),\n            (4763, False)])\n\n        # Now lets intersect part of both the upper and lower range\n        dg = Datagram.create_remove_range(3700, 4200)\n        self.c1.send(dg)\n        # N.B. Its worth considering which of the following behaviors is preferred,\n        #      the first is a lot more work for the current MD, but may reduce the\n        #      work for other MDs. Consider performance testing both implementations.\n        #      Additionally the first requires twice as much network traffice, but\n        #      it is still relatively small on a relatively infrequent operation.\n        ## --> and expect only the subscribed parts to be removed\n        #expected = []\n        #expected.append(Datagram.create_remove_range(3700, 3890))\n        #expected.append(Datagram.create_remove_range(4070, 4200))\n        #self.expectMany(self.l1, expected)\n        self.expect(self.l1, dg)\n        check_channels([\n            (3043, False),\n            (3044, True),\n            (3699, True),\n            (3700, False),\n            (4200, False),\n            (4201, True),\n            (4762, True),\n            (4763, False)])\n\n        # Now lets subscribe our 2nd client to an intersecting range\n        dg = Datagram.create_add_range(3500, 4500)\n        self.c2.send(dg)\n        self.expect(self.l1, dg)\n\n        # Now remove an upper part of the lower range that is contained within c2's range\n        dg = Datagram.create_remove_range(3650, 3800)\n        self.c1.send(dg)\n        # We shouldn't get a remove for this upstream, because the 2nd client is still interested\n        self.expectNone(self.l1)\n        check_channels([\n            # Lower range\n            (3043, False),\n            (3044, True), # lower bound\n            (3333, True),\n            (3480, True),\n            (3499, True),\n            (3500, True),\n            (3649, True), # upper bound\n            (3650, False),\n\n            (3787, False),\n            (4000, False),\n\n            # Upper range\n            (4200, False),\n            (4201, True)]) # lower bound\n\n        # Now remove part of the lower range that contains just the lower bound of c2's range,\n        # but not the upper bound of the lower range.\n        dg = Datagram.create_remove_range(3475, 3525)\n        self.c1.send(dg)\n        # We should expect to receive only the portion of the range which is outside c2's range\n        self.expect(self.l1, Datagram.create_remove_range(3475, 3499))\n        check_channels([\n            # Lower range\n            (3043, False),\n            (3044, True), # lower bound\n            (3474, True), # upper bound\n            (3475, False),\n\n            (3482, False),\n            (3499, False),\n\n            # Mid range\n            (3525, False),\n            (3526, True), # Lower bound\n            (3600, True),\n            (3649, True), # upper bound\n            (3650, False),\n\n            # Upper range\n            (4200, False),\n            (4201, True)]) # lower bound\n\n        # Now remove a range from c2 which contains the mid-range's upper bound\n        # and the upper-range's lower bound.\n        dg = Datagram.create_remove_range(3620, 4300)\n        self.c2.send(dg)\n        # We should expect to recieve only the portion of c2 which is between the two ranges\n        self.expect(self.l1, Datagram.create_remove_range(3650, 4200))\n        check_channels([\n            # Lower range\n            (3474, True), # upper bound\n            (3475, False),\n\n            # Mid range\n            (3525, False),\n            (3526, True), # Lower bound\n            (3649, True), # upper bound\n            (3650, False),\n\n            # Upper range\n            (4200, False),\n            (4201, True), # lower bound\n            (4762, True), # upper bound\n            (4763, False)])\n\n        # Cut c2 and watch the part die that is not in c1\n        self.c2.close()\n        self.c2 = self.connectToServer()\n        self.expect(self.l1, Datagram.create_remove_range(3500, 3525))\n        self.expectNone(self.l1)\n\n        # Now add c2 such that it contains all the c1 ranges\n        dg = Datagram.create_add_range(1000, 5000)\n        self.c2.send(dg)\n        self.expect(self.l1, dg)\n\n        # Then remove that range and see all the inbetween parts die\n        self.c2.send(Datagram.create_remove_range(1000, 5000))\n        expected = []\n        expected.append(Datagram.create_remove_range(1000, 3043))\n        expected.append(Datagram.create_remove_range(3475, 3525))\n        expected.append(Datagram.create_remove_range(3650, 4200))\n        expected.append(Datagram.create_remove_range(4763, 5000))\n        self.expectMany(self.l1, expected)\n        self.expectNone(self.l1)\n\n        # Cleanup\n        self.c1.close()\n        self.c2.close()\n        self.__class__.c1 = self.connectToServer()\n        self.__class__.c2 = self.connectToServer()\n        self.l1.flush()", "label": 1}
{"function": "    def start_state(self, batch_size):\n        if isinstance(self.init_state_vars, tuple):\n            res = []\n            # pylint: disable=E1133\n            for var in self.init_state_vars:\n                var_val = self.session.run(var)\n                res.append(np.array([var_val] * batch_size))\n            return tuple(res)\n        var_val = self.session.run(self.init_state_vars)\n        return np.array([var_val] * batch_size)", "label": 1}
{"function": "async def favicon():\n    return FileResponse(gradio_app._favicon)", "label": 0}
{"function": "def geterr():\n    \"\"\"\n    Get the current way of handling floating-point errors.\n\n    Returns\n    -------\n    res : dict\n        A dictionary with keys \"divide\", \"over\", \"under\", and \"invalid\",\n        whose values are from the strings \"ignore\", \"print\", \"log\", \"warn\",\n        \"raise\", and \"call\". The keys represent possible floating-point\n        exceptions, and the values define how these exceptions are handled.\n\n    See Also\n    --------\n    geterrcall, seterr, seterrcall\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterr()\n    {'over': 'warn', 'divide': 'warn', 'invalid': 'warn',\n    'under': 'ignore'}\n    >>> np.arange(3.) / np.arange(3.)\n    array([ NaN,   1.,   1.])\n\n    >>> oldsettings = np.seterr(all='warn', over='raise')\n    >>> np.geterr()\n    {'over': 'raise', 'divide': 'warn', 'invalid': 'warn', 'under': 'warn'}\n    >>> np.arange(3.) / np.arange(3.)\n    __main__:1: RuntimeWarning: invalid value encountered in divide\n    array([ NaN,   1.,   1.])\n\n    \"\"\"\n    maskvalue = umath.geterrobj()[1]\n    mask = 7\n    res = {}\n    val = (maskvalue >> SHIFT_DIVIDEBYZERO) & mask\n    res['divide'] = _errdict_rev[val]\n    val = (maskvalue >> SHIFT_OVERFLOW) & mask\n    res['over'] = _errdict_rev[val]\n    val = (maskvalue >> SHIFT_UNDERFLOW) & mask\n    res['under'] = _errdict_rev[val]\n    val = (maskvalue >> SHIFT_INVALID) & mask\n    res['invalid'] = _errdict_rev[val]\n    return res", "label": 1}
{"function": "def create_migration(description):\n    \"\"\"Create a new migration file\"\"\"\n    db_path = get_db_path()\n    migrations_dir = os.path.join(project_root, \"lpm_kernel\", \"database\", \"migrations\")\n    \n    manager = MigrationManager(db_path)\n    filepath = manager.create_migration(description, migrations_dir)\n    \n    # logger.info(f\"Created new migration at: {filepath}\")\n    return filepath", "label": 0}
{"function": "    def handle_error(self):\n        raise", "label": 1}
{"function": "def test():\n    filelist = [codedir + 'partial.v']\n    topmodule = 'TOP'\n    noreorder = False\n    nobind = False\n    include = None\n    define = None\n    \n    analyzer = VerilogDataflowAnalyzer(filelist, topmodule,\n                                       noreorder=noreorder,\n                                       nobind=nobind,\n                                       preprocess_include=include,\n                                       preprocess_define=define)\n    analyzer.generate()\n\n    directives = analyzer.get_directives()\n    instances = analyzer.getInstances()\n    terms = analyzer.getTerms()\n    binddict = analyzer.getBinddict()\n\n    output = []\n    \n    for bk, bv in sorted(binddict.items(), key=lambda x:str(x[0])):\n        for bvi in bv:\n            output.append(bvi.tostr())\n            output.append('\\n')\n            \n    rslt = ''.join(output)\n\n    print(rslt)\n    assert(expected == rslt)", "label": 1}
{"function": "    def __init__(self):\n        self.update_progress = None\n        self.run_ui = False\n        self.tasks = []\n        self.channel_items: CategoryChannelData = {}\n        self.hotel_fofa_result = {}\n        self.hotel_foodie_result = {}\n        self.multicast_result = {}\n        self.subscribe_result = {}\n        self.online_search_result = {}\n        self.epg_result = {}\n        self.channel_data: CategoryChannelData = {}\n        self.pbar = None\n        self.total = 0\n        self.start_time = None\n        self.stop_event = None\n        self.ipv6_support = False\n        self.now = None", "label": 0}
{"function": "    def __exit__(self, type, value, traceback):\n        torch.random.set_rng_state(self.state)", "label": 0}
{"function": "    def test_string_get_dummies(self):\n        with self.assertRaises(NotImplementedError):\n            self.check_func(lambda x: x.str.get_dummies())", "label": 1}
{"function": "def get_cache_path() -> str:\n    \"\"\"\n    Gets the path to the cache file.\n\n    Returns:\n        path (str): The path to the cache folder\n    \"\"\"\n    return os.path.join(ROOT_DIR, '.mp')", "label": 0}
{"function": "    def test_consistent_param_serialization(self):\n        \"\"\"Test that dictionary parameters are consistently serialized regardless of key order\"\"\"\n        # Test simple dictionary\n        params1 = {\"b\": 1, \"a\": 2}\n        params2 = {\"a\": 2, \"b\": 1}\n        cache1 = cache.TranslationCache(\"test_engine\", params1)\n        cache2 = cache.TranslationCache(\"test_engine\", params2)\n        self.assertEqual(cache1.translate_engine_params, cache2.translate_engine_params)\n\n        # Test nested dictionary\n        params1 = {\"outer2\": {\"inner2\": 2, \"inner1\": 1}, \"outer1\": 3}\n        params2 = {\"outer1\": 3, \"outer2\": {\"inner1\": 1, \"inner2\": 2}}\n        cache1 = cache.TranslationCache(\"test_engine\", params1)\n        cache2 = cache.TranslationCache(\"test_engine\", params2)\n        self.assertEqual(cache1.translate_engine_params, cache2.translate_engine_params)\n\n        # Test dictionary with list of dictionaries\n        params1 = {\"b\": [{\"y\": 1, \"x\": 2}], \"a\": 3}\n        params2 = {\"a\": 3, \"b\": [{\"x\": 2, \"y\": 1}]}\n        cache1 = cache.TranslationCache(\"test_engine\", params1)\n        cache2 = cache.TranslationCache(\"test_engine\", params2)\n        self.assertEqual(cache1.translate_engine_params, cache2.translate_engine_params)\n\n        # Test that different values still produce different results\n        params1 = {\"a\": 1, \"b\": 2}\n        params2 = {\"a\": 2, \"b\": 1}\n        cache1 = cache.TranslationCache(\"test_engine\", params1)\n        cache2 = cache.TranslationCache(\"test_engine\", params2)\n        self.assertNotEqual(\n            cache1.translate_engine_params, cache2.translate_engine_params\n        )", "label": 0}
{"function": "  def inference_graph(self, data):\n    with ops.device(self.device_assigner):\n      # Compute activations for the neural network.\n      nn_activations = layers.fully_connected(data, 1)\n\n      # There is always one activation per instance by definition, so squeeze\n      # away the extra dimension.\n      return array_ops.squeeze(nn_activations, squeeze_dims=[1])", "label": 1}
{"function": "    def test_full_integration(self, mock_get, mock_sleep, mock_cache):\n        \"\"\"Test that get_prices function properly handles rate limiting.\"\"\"\n        # Mock cache to return None (cache miss)\n        mock_cache.get_prices.return_value = None\n        \n        # Setup mock responses: first 429, then 200 with valid data\n        mock_429_response = Mock()\n        mock_429_response.status_code = 429\n        \n        mock_200_response = Mock()\n        mock_200_response.status_code = 200\n        mock_200_response.json.return_value = {\n            \"ticker\": \"AAPL\",\n            \"prices\": [\n                {\n                    \"time\": \"2024-01-01T00:00:00Z\",\n                    \"open\": 100.0,\n                    \"close\": 101.0,\n                    \"high\": 102.0,\n                    \"low\": 99.0,\n                    \"volume\": 1000\n                }\n            ]\n        }\n        \n        mock_get.side_effect = [mock_429_response, mock_200_response]\n        \n        # Set environment variable for API key\n        with patch.dict(os.environ, {\"FINANCIAL_DATASETS_API_KEY\": \"test-key\"}):\n            # Call get_prices\n            result = get_prices(\"AAPL\", \"2024-01-01\", \"2024-01-02\")\n        \n        # Verify the function succeeded and returned data\n        assert len(result) == 1\n        assert result[0].open == 100.0\n        assert result[0].close == 101.0\n        \n        # Verify rate limiting behavior\n        assert mock_get.call_count == 2\n        mock_sleep.assert_called_once_with(60)\n        \n        # Verify cache operations\n        mock_cache.get_prices.assert_called_once()\n        mock_cache.set_prices.assert_called_once()", "label": 0}
{"function": "    def get_recommended_projects(user_name: str, preferred_locale: str):\n        \"\"\" Gets all projects a user has mapped or validated on \"\"\"\n        from backend.services.project_search_service import ProjectSearchService\n\n        limit = 20\n        user = (\n            User.query.with_entities(User.id, User.mapping_level)\n            .filter(User.username == user_name)\n            .one_or_none()\n        )\n        if user is None:\n            raise NotFound()\n\n        # Get all projects that the user has contributed\n        sq = (\n            TaskHistory.query.with_entities(TaskHistory.project_id.label(\"project_id\"))\n            .distinct(TaskHistory.project_id)\n            .filter(TaskHistory.user_id == user.id)\n            .subquery()\n        )\n        # Get all campaigns for all contributed projects.\n        campaign_tags = (\n            Project.query.with_entities(Project.campaign.label(\"tag\"))\n            .filter(or_(Project.author_id == user.id, Project.id == sq.c.project_id))\n            .subquery()\n        )\n        # Get projects with given campaign tags but without user contributions.\n        query = ProjectSearchService.create_search_query()\n        projs = (\n            query.filter(Project.campaign.any(campaign_tags.c.tag)).limit(limit).all()\n        )\n\n        # Get only user mapping level projects.\n        len_projs = len(projs)\n        if len_projs < limit:\n            remaining_projs = (\n                query.filter(Project.mapper_level == user.mapping_level)\n                .limit(limit - len_projs)\n                .all()\n            )\n            projs.extend(remaining_projs)\n\n        dto = ProjectSearchResultsDTO()\n\n        # Get all total contributions for each paginated project.\n        contrib_counts = ProjectSearchService.get_total_contributions(projs)\n\n        zip_items = zip(projs, contrib_counts)\n\n        dto.results = [\n            ProjectSearchService.create_result_dto(p, \"en\", t) for p, t in zip_items\n        ]\n\n        return dto", "label": 1}
{"function": "\tdef _ip_range(maxips):\n\t\tclass _ip(list):\n\t\t\tdef __str__(self):\n\t\t\t\treturn '.'.join(map(str, self))\n\t\t\tdef __repr__(self):\n\t\t\t\treturn str(self)\n\t\t\tdef __key__(self):\n\t\t\t\treturn str(self)\n\t\t\tdef __hash__(self):\n\t\t\t\t#return (int)(struct.unpack('I', struct.pack(\"BBBB\",*self))[0])\n\t\t\t\treturn (int)(self[0] << 24 | self[1] << 16 | self[2] << 8 | self[3])\n\t\ti = 0\n\t\tc = [127,0,0,0]\n\t\twhile i < maxips:\n\t\t\tfor n in range(3,0,-1):\n\t\t\t\tif c[n] < 255:\n\t\t\t\t\tc[n] += 1\n\t\t\t\t\tbreak\n\t\t\t\tc[n] = 0\n\t\t\tyield (i, _ip(c))\n\t\t\ti += 1", "label": 1}
{"function": "def test_input_from_stdin_without_hints(shared_tmp_dir, test_vector) -> None:\n    \"\"\"Test that the CLI readds from stdin correctly.\"\"\"\n\n    test_input = b\"\"\n    with open(os.path.join(TEST_FILES_DIR, test_vector.filename), \"rb\") as stream:\n        test_input = stream.read()\n\n    result = subprocess.run(\n        [\n            \"python\",\n            \"-m\",\n            \"markitdown\",\n            os.path.join(TEST_FILES_DIR, test_vector.filename),\n        ],\n        input=test_input,\n        capture_output=True,\n        text=False,\n    )\n\n    stdout = result.stdout.decode(locale.getpreferredencoding())\n    assert (\n        result.returncode == 0\n    ), f\"CLI exited with error: {result.stderr.decode('utf-8')}\"\n    for test_string in test_vector.must_include:\n        assert test_string in stdout\n    for test_string in test_vector.must_not_include:\n        assert test_string not in stdout", "label": 0}
{"function": "    def test_handles_multiple_rate_limits(self, mock_get, mock_sleep):\n        \"\"\"Test that API retries multiple times after 429s.\"\"\"\n        # Setup mock responses: three 429s, then 200\n        mock_429_response = Mock()\n        mock_429_response.status_code = 429\n        \n        mock_200_response = Mock()\n        mock_200_response.status_code = 200\n        mock_200_response.text = \"Success\"\n        \n        mock_get.side_effect = [\n            mock_429_response, \n            mock_429_response, \n            mock_429_response, \n            mock_200_response\n        ]\n        \n        # Call the function\n        headers = {\"X-API-KEY\": \"test-key\"}\n        url = \"https://api.financialdatasets.ai/test\"\n        \n        result = _make_api_request(url, headers)\n        \n        # Verify behavior\n        assert result.status_code == 200\n        assert result.text == \"Success\"\n        \n        # Verify requests.get was called 4 times\n        assert mock_get.call_count == 4\n        \n        # Verify sleep was called 3 times with linear backoff: 60s, 90s, 120s\n        assert mock_sleep.call_count == 3\n        expected_calls = [call(60), call(90), call(120)]\n        mock_sleep.assert_has_calls(expected_calls)", "label": 0}
{"function": "    def test_state(self, tdata):\n        with open(tdata.path(\"mitmproxy/net/data/text_cert\"), \"rb\") as f:\n            d = f.read()\n        c = certs.Cert.from_pem(d)\n\n        c.get_state()\n        c2 = c.copy()\n        a = c.get_state()\n        b = c2.get_state()\n        assert a == b\n        assert c == c2\n        assert c is not c2\n\n        x = certs.Cert('')\n        x.set_state(a)\n        assert x == c", "label": 1}
{"function": "    def test_handles_post_rate_limiting(self, mock_post, mock_sleep):\n        \"\"\"Test that POST requests handle rate limiting.\"\"\"\n        # Setup mock responses: first 429, then 200\n        mock_429_response = Mock()\n        mock_429_response.status_code = 429\n        \n        mock_200_response = Mock()\n        mock_200_response.status_code = 200\n        mock_200_response.text = \"Success\"\n        \n        mock_post.side_effect = [mock_429_response, mock_200_response]\n        \n        # Call the function with POST method\n        headers = {\"X-API-KEY\": \"test-key\"}\n        url = \"https://api.financialdatasets.ai/test\"\n        json_data = {\"test\": \"data\"}\n        \n        result = _make_api_request(url, headers, method=\"POST\", json_data=json_data)\n        \n        # Verify behavior\n        assert result.status_code == 200\n        assert result.text == \"Success\"\n        \n        # Verify requests.post was called twice\n        assert mock_post.call_count == 2\n        mock_post.assert_has_calls([\n            call(url, headers=headers, json=json_data),\n            call(url, headers=headers, json=json_data)\n        ])\n        \n        # Verify sleep was called once with 60 seconds (first retry)\n        mock_sleep.assert_called_once_with(60)", "label": 0}
{"function": "    def __init__(self, real, timeperiod=30):\n        pass", "label": 1}
{"function": "    def process_result_value(self, value, dialect):\n        return utils.from_json_str(value)", "label": 1}
{"function": "def predict(query: str, history: None, model_id: str):\n    choice_data = ChatCompletionResponseStreamChoice(\n        index=0,\n        delta=DeltaMessage(role=\"assistant\"),\n        finish_reason=None\n    )\n    chunk = ChatCompletionResponse(model=model_id, choices=[\n                                choice_data], object=\"chat.completion.chunk\")\n    yield \"{}\".format(chunk.json(exclude_unset=True))\n    new_response = \"\"\n    current_length = 0\n    for token in free_ask_internet.ask_internet(query=query):\n    \n        new_response += token\n        if len(new_response) == current_length:\n            continue\n\n        new_text = new_response[current_length:]\n        current_length = len(new_response)\n\n        choice_data = ChatCompletionResponseStreamChoice(\n            index=0,\n            delta=DeltaMessage(content=new_text,role=\"assistant\"),\n            finish_reason=None\n        )\n        chunk = ChatCompletionResponse(model=model_id, choices=[\n                                       choice_data], object=\"chat.completion.chunk\")\n        yield \"{}\".format(chunk.json(exclude_unset=True))\n\n    choice_data = ChatCompletionResponseStreamChoice(\n        index=0,\n        delta=DeltaMessage(),\n        finish_reason=\"stop\"\n    )\n    chunk = ChatCompletionResponse(model=model_id, choices=[\n                                   choice_data], object=\"chat.completion.chunk\")\n    yield \"{}\".format(chunk.json(exclude_unset=True))\n    yield '[DONE]'", "label": 0}
{"function": "def set_log_level(level):\n    logger.setLevel(level)\n    handler.setLevel(level)", "label": 1}
{"function": "def worker(input_image, prompt, n_prompt, seed, total_second_length, latent_window_size, steps, cfg, gs, rs, gpu_memory_preservation, use_teacache, mp4_crf):\n    total_latent_sections = (total_second_length * 30) / (latent_window_size * 4)\n    total_latent_sections = int(max(round(total_latent_sections), 1))\n\n    job_id = generate_timestamp()\n\n    stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'Starting ...'))))\n\n    try:\n        # Clean GPU\n        if not high_vram:\n            unload_complete_models(\n                text_encoder, text_encoder_2, image_encoder, vae, transformer\n            )\n\n        # Text encoding\n\n        stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'Text encoding ...'))))\n\n        if not high_vram:\n            fake_diffusers_current_device(text_encoder, gpu)  # since we only encode one text - that is one model move and one encode, offload is same time consumption since it is also one load and one encode.\n            load_model_as_complete(text_encoder_2, target_device=gpu)\n\n        llama_vec, clip_l_pooler = encode_prompt_conds(prompt, text_encoder, text_encoder_2, tokenizer, tokenizer_2)\n\n        if cfg == 1:\n            llama_vec_n, clip_l_pooler_n = torch.zeros_like(llama_vec), torch.zeros_like(clip_l_pooler)\n        else:\n            llama_vec_n, clip_l_pooler_n = encode_prompt_conds(n_prompt, text_encoder, text_encoder_2, tokenizer, tokenizer_2)\n\n        llama_vec, llama_attention_mask = crop_or_pad_yield_mask(llama_vec, length=512)\n        llama_vec_n, llama_attention_mask_n = crop_or_pad_yield_mask(llama_vec_n, length=512)\n\n        # Processing input image\n\n        stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'Image processing ...'))))\n\n        H, W, C = input_image.shape\n        height, width = find_nearest_bucket(H, W, resolution=640)\n        input_image_np = resize_and_center_crop(input_image, target_width=width, target_height=height)\n\n        Image.fromarray(input_image_np).save(os.path.join(outputs_folder, f'{job_id}.png'))\n\n        input_image_pt = torch.from_numpy(input_image_np).float() / 127.5 - 1\n        input_image_pt = input_image_pt.permute(2, 0, 1)[None, :, None]\n\n        # VAE encoding\n\n        stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'VAE encoding ...'))))\n\n        if not high_vram:\n            load_model_as_complete(vae, target_device=gpu)\n\n        start_latent = vae_encode(input_image_pt, vae)\n\n        # CLIP Vision\n\n        stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'CLIP Vision encoding ...'))))\n\n        if not high_vram:\n            load_model_as_complete(image_encoder, target_device=gpu)\n\n        image_encoder_output = hf_clip_vision_encode(input_image_np, feature_extractor, image_encoder)\n        image_encoder_last_hidden_state = image_encoder_output.last_hidden_state\n\n        # Dtype\n\n        llama_vec = llama_vec.to(transformer.dtype)\n        llama_vec_n = llama_vec_n.to(transformer.dtype)\n        clip_l_pooler = clip_l_pooler.to(transformer.dtype)\n        clip_l_pooler_n = clip_l_pooler_n.to(transformer.dtype)\n        image_encoder_last_hidden_state = image_encoder_last_hidden_state.to(transformer.dtype)\n\n        # Sampling\n\n        stream.output_queue.push(('progress', (None, '', make_progress_bar_html(0, 'Start sampling ...'))))\n\n        rnd = torch.Generator(\"cpu\").manual_seed(seed)\n        num_frames = latent_window_size * 4 - 3\n\n        history_latents = torch.zeros(size=(1, 16, 1 + 2 + 16, height // 8, width // 8), dtype=torch.float32).cpu()\n        history_pixels = None\n        total_generated_latent_frames = 0\n\n        latent_paddings = reversed(range(total_latent_sections))\n\n        if total_latent_sections > 4:\n            # In theory the latent_paddings should follow the above sequence, but it seems that duplicating some\n            # items looks better than expanding it when total_latent_sections > 4\n            # One can try to remove below trick and just\n            # use `latent_paddings = list(reversed(range(total_latent_sections)))` to compare\n            latent_paddings = [3] + [2] * (total_latent_sections - 3) + [1, 0]\n\n        for latent_padding in latent_paddings:\n            is_last_section = latent_padding == 0\n            latent_padding_size = latent_padding * latent_window_size\n\n            if stream.input_queue.top() == 'end':\n                stream.output_queue.push(('end', None))\n                return\n\n            print(f'latent_padding_size = {latent_padding_size}, is_last_section = {is_last_section}')\n\n            indices = torch.arange(0, sum([1, latent_padding_size, latent_window_size, 1, 2, 16])).unsqueeze(0)\n            clean_latent_indices_pre, blank_indices, latent_indices, clean_latent_indices_post, clean_latent_2x_indices, clean_latent_4x_indices = indices.split([1, latent_padding_size, latent_window_size, 1, 2, 16], dim=1)\n            clean_latent_indices = torch.cat([clean_latent_indices_pre, clean_latent_indices_post], dim=1)\n\n            clean_latents_pre = start_latent.to(history_latents)\n            clean_latents_post, clean_latents_2x, clean_latents_4x = history_latents[:, :, :1 + 2 + 16, :, :].split([1, 2, 16], dim=2)\n            clean_latents = torch.cat([clean_latents_pre, clean_latents_post], dim=2)\n\n            if not high_vram:\n                unload_complete_models()\n                move_model_to_device_with_memory_preservation(transformer, target_device=gpu, preserved_memory_gb=gpu_memory_preservation)\n\n            if use_teacache:\n                transformer.initialize_teacache(enable_teacache=True, num_steps=steps)\n            else:\n                transformer.initialize_teacache(enable_teacache=False)\n\n            def callback(d):\n                preview = d['denoised']\n                preview = vae_decode_fake(preview)\n\n                preview = (preview * 255.0).detach().cpu().numpy().clip(0, 255).astype(np.uint8)\n                preview = einops.rearrange(preview, 'b c t h w -> (b h) (t w) c')\n\n                if stream.input_queue.top() == 'end':\n                    stream.output_queue.push(('end', None))\n                    raise KeyboardInterrupt('User ends the task.')\n\n                current_step = d['i'] + 1\n                percentage = int(100.0 * current_step / steps)\n                hint = f'Sampling {current_step}/{steps}'\n                desc = f'Total generated frames: {int(max(0, total_generated_latent_frames * 4 - 3))}, Video length: {max(0, (total_generated_latent_frames * 4 - 3) / 30) :.2f} seconds (FPS-30). The video is being extended now ...'\n                stream.output_queue.push(('progress', (preview, desc, make_progress_bar_html(percentage, hint))))\n                return\n\n            generated_latents = sample_hunyuan(\n                transformer=transformer,\n                sampler='unipc',\n                width=width,\n                height=height,\n                frames=num_frames,\n                real_guidance_scale=cfg,\n                distilled_guidance_scale=gs,\n                guidance_rescale=rs,\n                # shift=3.0,\n                num_inference_steps=steps,\n                generator=rnd,\n                prompt_embeds=llama_vec,\n                prompt_embeds_mask=llama_attention_mask,\n                prompt_poolers=clip_l_pooler,\n                negative_prompt_embeds=llama_vec_n,\n                negative_prompt_embeds_mask=llama_attention_mask_n,\n                negative_prompt_poolers=clip_l_pooler_n,\n                device=gpu,\n                dtype=torch.bfloat16,\n                image_embeddings=image_encoder_last_hidden_state,\n                latent_indices=latent_indices,\n                clean_latents=clean_latents,\n                clean_latent_indices=clean_latent_indices,\n                clean_latents_2x=clean_latents_2x,\n                clean_latent_2x_indices=clean_latent_2x_indices,\n                clean_latents_4x=clean_latents_4x,\n                clean_latent_4x_indices=clean_latent_4x_indices,\n                callback=callback,\n            )\n\n            if is_last_section:\n                generated_latents = torch.cat([start_latent.to(generated_latents), generated_latents], dim=2)\n\n            total_generated_latent_frames += int(generated_latents.shape[2])\n            history_latents = torch.cat([generated_latents.to(history_latents), history_latents], dim=2)\n\n            if not high_vram:\n                offload_model_from_device_for_memory_preservation(transformer, target_device=gpu, preserved_memory_gb=8)\n                load_model_as_complete(vae, target_device=gpu)\n\n            real_history_latents = history_latents[:, :, :total_generated_latent_frames, :, :]\n\n            if history_pixels is None:\n                history_pixels = vae_decode(real_history_latents, vae).cpu()\n            else:\n                section_latent_frames = (latent_window_size * 2 + 1) if is_last_section else (latent_window_size * 2)\n                overlapped_frames = latent_window_size * 4 - 3\n\n                current_pixels = vae_decode(real_history_latents[:, :, :section_latent_frames], vae).cpu()\n                history_pixels = soft_append_bcthw(current_pixels, history_pixels, overlapped_frames)\n\n            if not high_vram:\n                unload_complete_models()\n\n            output_filename = os.path.join(outputs_folder, f'{job_id}_{total_generated_latent_frames}.mp4')\n\n            save_bcthw_as_mp4(history_pixels, output_filename, fps=30, crf=mp4_crf)\n\n            print(f'Decoded. Current latent shape {real_history_latents.shape}; pixel shape {history_pixels.shape}')\n\n            stream.output_queue.push(('file', output_filename))\n\n            if is_last_section:\n                break\n    except:\n        traceback.print_exc()\n\n        if not high_vram:\n            unload_complete_models(\n                text_encoder, text_encoder_2, image_encoder, vae, transformer\n            )\n\n    stream.output_queue.push(('end', None))\n    return", "label": 0}
{"function": "def test_parse_hparam_args__nesting():\n    hparam_args = ['--moo.foo', 'HParams(boo=1)']\n    assert parse_hparam_args(hparam_args) == {'moo.foo': HParams(boo=1)}", "label": 1}
{"function": "def test_wikipedia_example(tokenizer_factory):\n    \"\"\"\n    Quick unit test, following along the Wikipedia example:\n    https://en.wikipedia.org/wiki/Byte_pair_encoding\n\n    According to Wikipedia, running bpe on the input string:\n    \"aaabdaaabac\"\n\n    for 3 merges will result in string:\n    \"XdXac\"\n\n    where:\n    X=ZY\n    Y=ab\n    Z=aa\n\n    Keep in mind that for us a=97, b=98, c=99, d=100 (ASCII values)\n    so Z will be 256, Y will be 257, X will be 258.\n\n    So we expect the output list of ids to be [258, 100, 258, 97, 99]\n    \"\"\"\n    tokenizer = tokenizer_factory()\n    text = \"aaabdaaabac\"\n    tokenizer.train(text, 256 + 3)\n    ids = tokenizer.encode(text)\n    assert ids == [258, 100, 258, 97, 99]\n    assert tokenizer.decode(tokenizer.encode(text)) == text", "label": 0}
{"function": "    def digest(self):\n        return sha3.sha3_384(self._data).digest()", "label": 1}
{"function": "    def __rsub__(self, other):\n        return -(self - other)", "label": 1}
{"function": "    def deserialize(self, group):\n        \"\"\"\n        Overrides main deserialize method to store data in attributes\n        \"\"\"\n        val = group.attrs[self.name]\n        jsonData = json.loads(val)\n        result = self._registry.deserialize(self._obj_class, jsonData)\n        self.inslot.setValue(result)\n        self.dirty = False", "label": 1}
{"function": "    def test_from_array_names_match(surv_arrays):\n        event, time = surv_arrays\n\n        with pytest.raises(ValueError,\n                           match=\"name_time must be different from name_event\"):\n            Surv.from_arrays(event, time,\n                             name_event='time_and_event', name_time='time_and_event')", "label": 1}
{"function": "def get_build_config():\n    \"\"\"Obtain the build information of PyTorch or Parrots.\"\"\"\n    if TORCH_VERSION == 'parrots':\n        from parrots.config import get_build_info\n        return get_build_info()\n    else:\n        return torch.__config__.show()", "label": 0}
{"function": "    def get_countries_contributed(user_id: int):\n        query = (\n            TaskHistory.query.with_entities(\n                func.unnest(Project.country).label(\"country\"),\n                TaskHistory.action_text,\n                func.count(TaskHistory.action_text).label(\"count\"),\n            )\n            .filter(TaskHistory.user_id == user_id)\n            .filter(\n                TaskHistory.action_text.in_(\n                    [\n                        TaskStatus.MAPPED.name,\n                        TaskStatus.BADIMAGERY.name,\n                        TaskStatus.VALIDATED.name,\n                    ]\n                )\n            )\n            .group_by(\"country\", TaskHistory.action_text)\n            .outerjoin(Project, Project.id == TaskHistory.project_id)\n            .all()\n        )\n        countries = list(set([q.country for q in query]))\n        result = []\n        for country in countries:\n            values = [q for q in query if q.country == country]\n\n            # Filter element to sum mapped values.\n            mapped = sum(\n                [\n                    v.count\n                    for v in values\n                    if v.action_text\n                    in [TaskStatus.MAPPED.name, TaskStatus.BADIMAGERY.name]\n                ]\n            )\n            validated = sum(\n                [v.count for v in values if v.action_text == TaskStatus.VALIDATED.name]\n            )\n            dto = UserCountryContributed(\n                dict(\n                    name=country,\n                    mapped=mapped,\n                    validated=validated,\n                    total=mapped + validated,\n                )\n            )\n            result.append(dto)\n\n        # Order by total\n        result = sorted(result, reverse=True, key=lambda i: i.total)\n        countries_dto = UserCountriesContributed()\n        countries_dto.countries_contributed = result\n        countries_dto.total = len(result)\n\n        return countries_dto", "label": 1}
{"function": "    def registered_model_versions(self):\n        return RegisteredModelVersions(self._conn, self._conf)", "label": 1}
{"function": "async def test_scrape_method_playwright(mock_playwright):\n    \"\"\"Test the scrape method with playwright backend.\"\"\"\n    mock_pw, mock_browser, mock_context, mock_page = mock_playwright\n\n    url = \"http://example.com\"\n    loader = ChromiumLoader([url], backend=\"playwright\")\n\n    mock_page.content.return_value = \"<html>Playwright content</html>\"\n    result = await loader.scrape(url)\n\n    assert \"Playwright content\" in result\n    assert mock_pw.chromium.launch.call_count == 1\n    assert mock_page.goto.call_count == 1\n    assert mock_page.wait_for_load_state.call_count == 1\n    assert mock_page.content.call_count == 1", "label": 0}
{"function": "def import_model(\n    in_path: str,\n    out_path: str,\n) -> None:\n    pkg = torch.load(in_path, map_location=torch.device(\"cpu\"))\n    if 'xp.cfg' in pkg:\n        cfg = pkg['xp.cfg']\n    else:\n        cfg = omegaconf.OmegaConf.load(Path(in_path).parent / '.hydra/config.yaml')\n\n    model = pkg[\"fsdp_best_state\"][\"model\"]\n\n    # Asumming same size of both streams n_q.\n    in_n_q = cfg.compression_model_n_q * 2\n    out_n_q = cfg.compression_model_n_q\n    print(f\"in_n_q: {in_n_q}, out_n_q: {out_n_q}\")\n    schedule = cfg.transformer_lm.get('depformer_weights_per_step_schedule', None)\n    if schedule is None:\n        schedule = list(range(in_n_q))\n\n    num_weights = max(schedule) + 1\n    schedule = schedule[:out_n_q]\n    kept_weights = max(schedule) + 1\n    print(f\"Number of dep weights: {num_weights}, keeping {kept_weights}\")\n\n    for idx in range(cfg.transformer_lm.depformer_num_layers):\n        in_proj_key = f\"depformer.layers.{idx}.self_attn.in_proj_weight\"\n        in_proj = model[in_proj_key]\n        in_proj = in_proj.view(num_weights, -1, *in_proj.shape[1:])\n        model[in_proj_key] = in_proj[:kept_weights].view(-1, *in_proj.shape[2:]).contiguous()\n        out_proj_key = f\"depformer.layers.{idx}.self_attn.out_proj.weight\"\n        out_proj = model[out_proj_key]\n        out_proj = out_proj.view(num_weights, -1, *out_proj.shape[1:])\n        model[out_proj_key] = out_proj[:kept_weights].view(-1, *out_proj.shape[2:]).contiguous()\n\n    # For mimi inference, we trim the depformer layer that are unused.\n    for dep_idx in range(out_n_q - 1, in_n_q - 1):\n        del model[f\"depformer_emb.{dep_idx}.weight\"]\n        if cfg.transformer_lm.get('depformer_low_rank_embeddings'):\n            del model[f\"depformer_emb.{dep_idx}.low_rank.weight\"]\n    for dep_idx in range(out_n_q, in_n_q):\n        del model[f\"linears.{dep_idx}.weight\"]\n    for real_idx in range(kept_weights, num_weights):\n        model.pop(f\"depformer_in.{real_idx}.weight\")\n        for idx in range(cfg.transformer_lm.depformer_num_layers):\n            model.pop(f\"depformer.layers.{idx}.gating.{real_idx}.linear_in.weight\")\n            model.pop(f\"depformer.layers.{idx}.gating.{real_idx}.linear_out.weight\")\n\n    schedule = schedule[:out_n_q]\n\n    save_file(model, out_path)", "label": 0}
{"function": "def SimpleEllipse(a=2.0, b=1.0):\n    newpoints = []\n\n    newpoints.append([a, 0.0, 0.0])\n    newpoints.append([0.0, b, 0.0])\n    newpoints.append([-a, 0.0, 0.0])\n    newpoints.append([0.0, -b, 0.0])\n\n    return newpoints", "label": 1}
{"function": "def test_output_to_stdout(shared_tmp_dir, test_vector) -> None:\n    \"\"\"Test that the CLI outputs to stdout correctly.\"\"\"\n\n    result = subprocess.run(\n        [\n            \"python\",\n            \"-m\",\n            \"markitdown\",\n            os.path.join(TEST_FILES_DIR, test_vector.filename),\n        ],\n        capture_output=True,\n        text=True,\n    )\n\n    assert result.returncode == 0, f\"CLI exited with error: {result.stderr}\"\n    for test_string in test_vector.must_include:\n        assert test_string in result.stdout\n    for test_string in test_vector.must_not_include:\n        assert test_string not in result.stdout", "label": 0}
{"function": "  def testContainingTypeBehaviorForExtensions(self):\n    self.assertEqual(unittest_pb2.optional_int32_extension.containing_type,\n                     unittest_pb2.TestAllExtensions.DESCRIPTOR)\n    self.assertEqual(unittest_pb2.TestRequired.single.containing_type,\n                     unittest_pb2.TestAllExtensions.DESCRIPTOR)", "label": 1}
{"function": "    def b2a_base64(data: _Bytes) -> bytes: ...", "label": 1}
{"function": "    def getPhysicalRoot(self):\n        return self", "label": 1}
{"function": "    def _wrap_object(self, space, obj):\n        return space.newlong(obj)", "label": 1}
{"function": "    def __str__(self):\n        return ' '.join(self.value)", "label": 1}
{"function": "def main():\n    \"\"\"\n    Main function to extract meta info for training.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-r\", \"--root_path\", type=str,\n                        required=True, help=\"Root path of the video directories\")\n    parser.add_argument(\"-n\", \"--dataset_name\", type=str,\n                        required=True, help=\"Name of the dataset\")\n    parser.add_argument(\"--meta_info_name\", type=str,\n                        help=\"Name of the meta information file\")\n\n    args = parser.parse_args()\n\n    if args.meta_info_name is None:\n        args.meta_info_name = args.dataset_name\n\n    image_dir = Path(args.root_path) / \"images\"\n    output_dir = Path(\"./data\")\n    output_dir.mkdir(exist_ok=True)\n\n    # Collect all video folder paths\n    frames_dir_paths = collect_video_folder_paths(image_dir)\n\n    meta_infos = []\n    for frames_dir_path in frames_dir_paths:\n        meta_info = construct_meta_info(frames_dir_path)\n        if meta_info:\n            meta_infos.append(meta_info)\n\n    output_file = output_dir / f\"{args.meta_info_name}_stage1.json\"\n    with output_file.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(meta_infos, f, indent=4)\n\n    print(f\"Final data count: {len(meta_infos)}\")", "label": 0}
{"function": "    def alertPath(self):\n        return Path(__file__).parent / \"alertsCatalogue\"", "label": 1}
{"function": "def get_release():\n    \"\"\"\n    Get the current release of the application\n    \"\"\"\n    try:\n        with open(os.path.join(BASE_DIR, \"pyproject.toml\"), \"rb\") as f:\n            pyproject_data = tomllib.load(f)\n        return pyproject_data[\"project\"][\"version\"]\n    except (FileNotFoundError, KeyError):\n        return \"NA\"  # Default: not available", "label": 0}
{"function": "def unpad_dataproto(data: 'DataProto', pad_size):\n    if pad_size != 0:\n        data = data[:-pad_size]\n    return data", "label": 0}
{"function": "    def __init__(self, open, high, low, close):\n        pass", "label": 1}
{"function": "    def valDataCenter(self, obj):\n        \"\"\"Function to add DataCenter\n\n        :param obj: element to add DataCenter\n        \"\"\"\n        values = []\n        for i in self.parModis:\n            values.append(i.retDataCenter())\n        for i in set(values):\n            dci = self.ElementTree.SubElement(obj, 'DataCenterId')\n            dci.text = i", "label": 1}
{"function": "    def calculate_centroid(self, box):\n        \"\"\"\n        Calculate the centroid of bounding box.\n\n        Args:\n            box (list): Bounding box data\n        \"\"\"\n        return int((box[0] + box[2]) // 2), int((box[1] + box[3]) // 2)", "label": 0}
{"function": "def get_bool_env_var(name: str, default: str = \"false\") -> bool:\n    value = os.getenv(name, default)\n    return value.lower() in (\"true\", \"1\")", "label": 0}
{"function": "    def create_foreign_key(self, name, source, referent, local_cols,\n                           remote_cols, onupdate=None, ondelete=None,\n                           source_schema=None, referent_schema=None):\n        \"\"\"Issue a \"create foreign key\" instruction using the\n        current migration context.\n\n        e.g.::\n\n            from alembic import op\n            op.create_foreign_key(\n                        \"fk_user_address\", \"address\",\n                        \"user\", [\"user_id\"], [\"id\"])\n\n        This internally generates a :class:`~sqlalchemy.schema.Table` object\n        containing the necessary columns, then generates a new\n        :class:`~sqlalchemy.schema.ForeignKeyConstraint`\n        object which it then associates with the :class:`~sqlalchemy.schema.Table`.\n        Any event listeners associated with this action will be fired\n        off normally.   The :class:`~sqlalchemy.schema.AddConstraint`\n        construct is ultimately used to generate the ALTER statement.\n\n        :param name: Name of the foreign key constraint.  The name is necessary\n         so that an ALTER statement can be emitted.  For setups that\n         use an automated naming scheme such as that described at\n         `NamingConventions <http://www.sqlalchemy.org/trac/wiki/UsageRecipes/NamingConventions>`_,\n         ``name`` here can be ``None``, as the event listener will\n         apply the name to the constraint object when it is associated\n         with the table.\n        :param source: String name of the source table.\n        :param referent: String name of the destination table.\n        :param local_cols: a list of string column names in the\n         source table.\n        :param remote_cols: a list of string column names in the\n         remote table.\n        :param onupdate: Optional string. If set, emit ON UPDATE <value> when\n         issuing DDL for this constraint. Typical values include CASCADE,\n         DELETE and RESTRICT.\n        :param ondelete: Optional string. If set, emit ON DELETE <value> when\n         issuing DDL for this constraint. Typical values include CASCADE,\n         DELETE and RESTRICT.\n        :param source_schema: Optional schema name of the source table.\n        :param referent_schema: Optional schema name of the destination table.\n\n        \"\"\"\n\n        self.impl.add_constraint(\n                    self._foreign_key_constraint(name, source, referent,\n                            local_cols, remote_cols,\n                            onupdate=onupdate, ondelete=ondelete,\n                            source_schema=source_schema,\n                            referent_schema=referent_schema)\n                )", "label": 1}
{"function": "def _create_train_cache(archive, output, names, args):\n    # Read label and wordnet_id\n    wid2ind = np.loadtxt(fname=LABEL_WORDNETID, dtype=object, delimiter=\",\")\n\n    def _get_label(wordnet_id):\n        for item in wid2ind:\n            if item[1] == wordnet_id:\n                return item[0]\n\n    images0 = []\n    print(\"Count image in TAR\")\n    pbar = tqdm.tqdm(total=len(names), unit='%')\n    for name in names:\n        category = os.path.splitext(name)[0]\n        marchive = tarfile.open(fileobj=archive.extractfile(name))\n        for mname in marchive.getnames():\n            if re.match(r'{}_[0-9]+\\.JPEG'.format(category), mname):\n                images0.append((_get_label(name[:9]), name, marchive, mname))\n            else:\n                print('Invalid file {} includes in tar file'.format(mname))\n                exit(-1)\n        pbar.update(1)\n    pbar.close()\n\n    # Thinning\n    images = []\n    for i, image in enumerate(images0):\n        if i % args.thinning == 0:\n            images.append(image)\n\n    def _load_func(index):\n        y, name, marchive, mname = images[index]\n        im = imread(marchive.extractfile(mname), num_channels=3)\n        x = _resize_image(im, args.width, args.height, args.mode == 'padding')\n        return x, np.array([y]).astype(np.int32)\n\n    from nnabla.utils.data_source import DataSourceWithFileCache\n    from nnabla.utils.data_source_implements import SimpleDataSource\n    from nnabla.logger import logger\n\n    logger.info('Num of data : {}'.format(len(images)))\n    shuffle = True\n    if args.shuffle == 'False':\n        shuffle = False\n    source = SimpleDataSource(_load_func, len(images), shuffle, rng=None)\n    DataSourceWithFileCache(\n        source, cache_dir=output, shuffle=args.shuffle)", "label": 1}
{"function": "    def bind_thread_to_cpu(self):\n        total_cores = self.get_total_cores()\n        # \u6bcf\u4e2a\u5361\u7684\u6838\u5fc3\u6570\u91cf\n        cores_per_rank = total_cores // 8\n        # \u8ba1\u7b97\u672c\u5730rank\n        local_rank = self.rank % 8\n        # \u8ba1\u7b97\u5f53\u524d rank \u7684 CPU \u6838\u8303\u56f4\n        start_core = local_rank * cores_per_rank\n        end_core = start_core + cores_per_rank - 1\n        # \u6784\u5efa CPU \u6838\u8303\u56f4\u5b57\u7b26\u4e32\n        cpu_cores_range = f\"{start_core}-{end_core}\"\n        pid = os.getpid()\n        command = f\"taskset -cp {cpu_cores_range} {pid}\"\n\n        subprocess.run(command, shell=True, check=True)\n        return f\"Binding Cores:{self.rank}:{pid}:{cpu_cores_range}\"", "label": 0}
{"function": "def env_variables(request: FixtureRequest):\n  # Set up the environment\n  env_name: str = request.param\n  envs = ENV_SETUPS[env_name]\n  original_env = {key: os.environ.get(key) for key in envs}\n  os.environ.update(envs)\n\n  yield  # Run the test\n\n  # Restore the environment\n  for key in envs:\n    if (original_val := original_env.get(key)) is None:\n      os.environ.pop(key, None)\n    else:\n      os.environ[key] = original_val", "label": 0}
{"function": "def compute_down(expr, data, map=None, **kwargs):\n    if map is None:\n        map = get_default_pmap()\n\n    leaf = expr._leaves()[0]\n\n    (chunk, chunk_expr), (agg, agg_expr) = split(leaf, expr)\n\n    parts = list(map(curry(compute_chunk, chunk, chunk_expr), data))\n\n    if isinstance(parts[0], np.ndarray):\n        intermediate = np.concatenate(parts)\n    elif isinstance(parts[0], pd.DataFrame):\n        intermediate = pd.concat(parts)\n    elif isinstance(parts[0], (Iterable, Iterator)):\n        intermediate = list(concat(parts))\n\n    return compute(agg_expr, {agg: intermediate})", "label": 1}
{"function": "    def save_account_info(self, email, password, token, total_usage):\n        \"\"\"Save account information to file\"\"\"\n        try:\n            with open(self.accounts_file, 'a', encoding='utf-8') as f:\n                f.write(f\"\\n{'='*50}\\n\")\n                f.write(f\"Email: {email}\\n\")\n                f.write(f\"Password: {password}\\n\")\n                f.write(f\"Token: {token}\\n\")\n                f.write(f\"Usage Limit: {total_usage}\\n\")\n                f.write(f\"{'='*50}\\n\")\n                \n            print(f\"{Fore.GREEN}{EMOJI['SUCCESS']} {self.translator.get('register.account_info_saved') if self.translator else 'Account information saved'}...{Style.RESET_ALL}\")\n            return True\n            \n        except Exception as e:\n            error_msg = self.translator.get('register.save_account_info_failed', error=str(e)) if self.translator else f'Failed to save account information: {str(e)}'\n            print(f\"{Fore.RED}{EMOJI['ERROR']} {error_msg}{Style.RESET_ALL}\")\n            return False", "label": 0}
{"function": "def simulate_progress(message, duration=1.0, steps=20):\n    print(f\"\\033[94m{message}\\033[0m\")\n    for i in range(steps + 1):\n        time.sleep(duration / steps)\n        progress_bar(i, steps, prefix=\"Progress:\", length=40)", "label": 0}
{"function": "    def __init__(self):\n        # pylint: disable=invalid-name\n        self.INSTALLED_APPS += [\"django_extensions\", \"drf_spectacular_sidecar\"]", "label": 0}
{"function": "def compress_video(input_file, output_file, out_size):\n    \"\"\"\u4f7f\u7528 ffmpeg \u538b\u7f29\u89c6\u9891\u6587\u4ef6\u3002\"\"\"\n    command = [\n        'ffmpeg',\n        '-i', input_file,\n        '-vf', f\"scale='min({out_size},iw)':'min({out_size},ih)':force_original_aspect_ratio=decrease\",\n        '-c:v', 'libx264',\n        '-crf', '18',\n        '-preset', 'slow',\n        '-c:a', 'copy',\n        output_file\n    ]\n    subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "label": 0}
{"function": "    def first():\n        if not AgentContext._contexts:\n            return None\n        return list(AgentContext._contexts.values())[0]", "label": 0}
{"function": "def run_command(command, shell=False):\n    \"\"\"Run a system command and ensure it succeeds.\"\"\"\n    try:\n        subprocess.run(command, shell=shell, check=True)\n    except subprocess.CalledProcessError as e:\n        print(f\"Error occurred while running command: {e}\")\n        sys.exit(1)", "label": 0}
{"function": "def get_lr(current_step, total_steps, lr):\n    return lr / 10 + 0.5 * lr * (1 + math.cos(math.pi * current_step / total_steps))", "label": 0}
{"function": "    def _extract_tools_from_module(self, module, tools: List[Dict[str, Any]]) -> None:\n        \"\"\"\n        Given a tool module, find and instantiate all tool classes (subclasses of BaseTool).\n        Append them to the 'tools' list.\n        \"\"\"\n        for name, obj in inspect.getmembers(module):\n            if (inspect.isclass(obj) and issubclass(obj, BaseTool) and obj != BaseTool):\n                try:\n                    tool_instance = obj()\n                    tools.append({\n                        \"name\": tool_instance.name,\n                        \"description\": tool_instance.description,\n                        \"input_schema\": tool_instance.input_schema\n                    })\n                    self.console.print(f\"[green]Loaded tool:[/green] {tool_instance.name}\")\n                except Exception as tool_init_err:\n                    self.console.print(f\"[red]Error initializing tool {name}:[/red] {str(tool_init_err)}\")", "label": 0}
{"function": "    def get_total_cores(self):\n        try:\n            total_cores = os.sysconf('SC_NPROCESSORS_ONLN')\n        except (AttributeError, ValueError):\n            total_cores = os.cpu_count()\n        return total_cores", "label": 0}
{"function": "def basic_request():\n    \"\"\"Fixture providing a basic request model for testing.\"\"\"\n    return RequestModel(\n        name=\"Test Request\", method=\"GET\", url=\"https://example.com/api\"\n    )", "label": 0}
{"function": "  async def on_event_callback(\n      self, *, invocation_context: InvocationContext, event: Event\n  ) -> Optional[Event]:\n    if not self.enable_event_callback:\n      return None\n    return Event(\n        invocation_id=\"\",\n        author=\"\",\n        content=types.Content(\n            parts=[\n                types.Part(\n                    text=self.ON_EVENT_CALLBACK_MSG,\n                )\n            ],\n            role=event.content.role,\n        ),\n    )", "label": 0}
{"function": "  def test_calculate_samples_count_per_handler_(self):\n    counters = ipr.calculate_samples_count_per_handler([\n      [\"foo\", \"BytecodeHandler:bar\"],\n      [\"foo\", \"BytecodeHandler:bar\"],\n      [\"beep\", \"BytecodeHandler:bar\"],\n    ])\n    self.assertItemsEqual(counters, [(\"bar\", 3)])", "label": 1}
{"function": "    def test_non_string_params(self):\n        \"\"\"Test that non-string parameters are automatically converted to JSON\"\"\"\n        params = {\"model\": \"gpt-3.5\", \"temperature\": 0.7}\n        cache_instance = cache.TranslationCache(\"test_engine\", params)\n\n        # Test that params are converted to JSON string internally\n        cache_instance.set(\"hello\", \"\u4f60\u597d\")\n        result = cache_instance.get(\"hello\")\n        self.assertEqual(result, \"\u4f60\u597d\")\n\n        # Test with different param types\n        array_params = [\"param1\", \"param2\"]\n        cache_instance2 = cache.TranslationCache(\"test_engine\", array_params)\n        cache_instance2.set(\"hello\", \"\u4f60\u597d2\")\n        self.assertEqual(cache_instance2.get(\"hello\"), \"\u4f60\u597d2\")\n\n        # Test with nested structures\n        nested_params = {\"options\": {\"temp\": 0.8, \"models\": [\"a\", \"b\"]}}\n        cache_instance3 = cache.TranslationCache(\"test_engine\", nested_params)\n        cache_instance3.set(\"hello\", \"\u4f60\u597d3\")\n        self.assertEqual(cache_instance3.get(\"hello\"), \"\u4f60\u597d3\")", "label": 0}
{"function": "def ft_ao_o0(mol, Gv):\n    nao = mol.nao_nr()\n    ngrids = Gv.shape[0]\n    aoG = numpy.zeros((nao,ngrids), dtype=numpy.complex)\n    gx = numpy.empty((12,ngrids), dtype=numpy.complex)\n    gy = numpy.empty((12,ngrids), dtype=numpy.complex)\n    gz = numpy.empty((12,ngrids), dtype=numpy.complex)\n    buf = numpy.empty((64,ngrids), dtype=numpy.complex)\n    kk = numpy.einsum('ki,ki->k', Gv, Gv)\n\n    i0 = 0\n    for ib in range(mol.nbas):\n        ci = mol._libcint_ctr_coeff(ib)\n        ei = mol.bas_exp(ib)\n        li = mol.bas_angular(ib)\n        ri = mol.bas_coord(ib)\n        ni = ci.shape[1]\n        di = (li*2+1) * ni\n        nfi = (li+1)*(li+2)//2\n        kr = numpy.dot(Gv,ri)\n        cs = numpy.exp(-1j*kr)\n\n        buf[:nfi*ni] = 0\n        for ip in range(ci.shape[0]):\n            ai = ei[ip]\n            fac = (numpy.pi/ai)**1.5 * numpy.exp(-.25/ai*kk)\n            gx[0] = 1\n            gy[0] = 1\n            gz[0] = cs * fac\n            if li > 0:\n                gx[1] = -1j*Gv[:,0]/(2*ai) * gx[0]\n                gy[1] = -1j*Gv[:,1]/(2*ai) * gy[0]\n                gz[1] = -1j*Gv[:,2]/(2*ai) * gz[0]\n                for m in range(1, li):\n                    gx[m+1] = m/(2*ai) * gx[m-1] - 1j*Gv[:,0]/(2*ai) * gx[m]\n                    gy[m+1] = m/(2*ai) * gy[m-1] - 1j*Gv[:,1]/(2*ai) * gy[m]\n                    gz[m+1] = m/(2*ai) * gz[m-1] - 1j*Gv[:,2]/(2*ai) * gz[m]\n\n            for m,(ix,iy,iz) in enumerate(loop_cart(li)):\n                val = gx[ix] * gy[iy] * gz[iz]\n                for i, cip in enumerate(ci[ip]):\n                    buf[i*nfi+m] += cip*val\n\n        ti = c2s_bra(li, numpy.eye(nfi)).T\n        tmp1 = numpy.empty((di,ngrids), dtype=numpy.complex)\n        for i in range(ni):\n            tmp1[i*(li*2+1):(i+1)*(li*2+1)] = \\\n                    numpy.einsum('pi,px->ix', ti, buf[i*nfi:(i+1)*nfi])\n        aoG[i0:i0+di] += tmp1\n        i0 += di\n    return aoG.T", "label": 1}
{"function": "    def __init__(self, editwin):\n        self.editwin = editwin\n        self.text = editwin.text\n        # Bind the check-restore event to the function restore_event,\n        # so that we can then use activate_restore (which calls event_add)\n        # and deactivate_restore (which calls event_delete).\n        editwin.text.bind(self.RESTORE_VIRTUAL_EVENT_NAME,\n                          self.restore_event)\n        self.counter = 0\n        self.is_restore_active = 0\n        self.set_style(self.STYLE)", "label": 1}
{"function": "def demo():\n    import time\n\n    ble = bluetooth.BLE()\n    uart = BLEUART(ble)\n\n    def on_rx():\n        print('rx: ', uart.read().decode().strip())\n\n    uart.irq(handler=on_rx)\n    nums = [4, 8, 15, 16, 23, 42]\n    i = 0\n\n    try:\n        while True:\n            uart.write(str(nums[i]) + '\\n')\n            i = (i + 1) % len(nums)\n            time.sleep_ms(1000)\n    except KeyboardInterrupt:\n        pass\n\n    uart.close()", "label": 1}
{"function": "def load_json_file(file_path: str) -> Optional[dict]:\n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            return json.load(file)\n    except FileNotFoundError:\n        _LOGGER.info('%s is not found.', file_path)\n        return None\n    except json.JSONDecodeError:\n        _LOGGER.info('%s is not a valid JSON file.', file_path)\n        return None", "label": 0}
{"function": "    def on_typing(self, e):\n        'Invoked when the user is typing in the textfield.'\n\n        if self.searching:\n            search.link_prefs(profile.prefs)\n            e.Skip()\n            self.buddylist.search(e.EventObject.Value)\n        else:\n            self.cancel_timer()", "label": 1}
{"function": "def run_VGGT(model, images, dtype, resolution=518):\n    # images: [B, 3, H, W]\n\n    assert len(images.shape) == 4\n    assert images.shape[1] == 3\n\n    # hard-coded to use 518 for VGGT\n    images = F.interpolate(images, size=(resolution, resolution), mode=\"bilinear\", align_corners=False)\n\n    with torch.no_grad():\n        with torch.cuda.amp.autocast(dtype=dtype):\n            images = images[None]  # add batch dimension\n            aggregated_tokens_list, ps_idx = model.aggregator(images)\n\n        # Predict Cameras\n        pose_enc = model.camera_head(aggregated_tokens_list)[-1]\n        # Extrinsic and intrinsic matrices, following OpenCV convention (camera from world)\n        extrinsic, intrinsic = pose_encoding_to_extri_intri(pose_enc, images.shape[-2:])\n        # Predict Depth Maps\n        depth_map, depth_conf = model.depth_head(aggregated_tokens_list, images, ps_idx)\n\n    extrinsic = extrinsic.squeeze(0).cpu().numpy()\n    intrinsic = intrinsic.squeeze(0).cpu().numpy()\n    depth_map = depth_map.squeeze(0).cpu().numpy()\n    depth_conf = depth_conf.squeeze(0).cpu().numpy()\n    return extrinsic, intrinsic, depth_map, depth_conf", "label": 0}
{"function": "def SimpleCircle(sides=4, radius=1.0):\n    newpoints = []\n\n    angle = radians(360) / sides\n    newpoints.append([radius, 0, 0])\n    if radius != 0 :\n        j = 1\n        while j < sides:\n            t = angle * j\n            x = cos(t) * radius\n            y = sin(t) * radius\n            newpoints.append([x, y, 0])\n            j += 1\n\n    return newpoints", "label": 1}
{"function": "def main():\n    torch.set_grad_enabled(False)\n    # ======================================================\n    # configs & runtime variables\n    # ======================================================\n    # == parse configs ==\n    cfg = parse_configs()\n\n    # == get dtype & device ==\n    dtype = to_torch_dtype(cfg.get(\"dtype\", \"fp32\"))\n    device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n    if is_distributed():\n        colossalai.launch_from_torch({})\n        device = get_current_device()\n    set_seed(cfg.get(\"seed\", 1024))\n\n    # == init logger ==\n    logger = create_logger()\n    logger.info(\"Inference configuration:\\n %s\", pformat(cfg.to_dict()))\n    verbose = cfg.get(\"verbose\", 1)\n\n    # ======================================================\n    # build model & loss\n    # ======================================================\n    if cfg.get(\"ckpt_path\", None) is not None:\n        cfg.model.from_pretrained = cfg.ckpt_path\n    logger.info(\"Building models...\")\n    model = build_module(cfg.model, MODELS, device_map=device, torch_dtype=dtype).eval()\n    log_model_params(model)\n\n    # ======================================================\n    # build dataset and dataloader\n    # ======================================================\n    logger.info(\"Building dataset...\")\n    # == build dataset ==\n    dataset = build_module(cfg.dataset, DATASETS)\n    logger.info(\"Dataset contains %s samples.\", len(dataset))\n    # == build dataloader ==\n    dataloader_args = dict(\n        dataset=dataset,\n        batch_size=cfg.get(\"batch_size\", None),\n        num_workers=cfg.get(\"num_workers\", 4),\n        seed=cfg.get(\"seed\", 1024),\n        shuffle=False,\n        drop_last=False,\n        pin_memory=True,\n        process_group=get_data_parallel_group(),\n        prefetch_factor=cfg.get(\"prefetch_factor\", None),\n    )\n\n    if cfg.get(\"eval_setting\", None) is not None:\n        # e.g. 32x256, 1x1024\n        num_frames = int(cfg.eval_setting.split(\"x\")[0])\n        resolution = str(cfg.eval_setting.split(\"x\")[-1])\n        bucket_config = {\n            resolution + \"px\" + \"_ar1:1\": {num_frames: (1.0, 1)},\n        }\n        print(\"eval setting:\\n\", bucket_config)\n    else:\n        bucket_config = cfg.get(\"bucket_config\", None)\n\n    dataloader, sampler = prepare_dataloader(\n        bucket_config=bucket_config,\n        num_bucket_build_workers=cfg.get(\"num_bucket_build_workers\", 1),\n        **dataloader_args,\n    )\n    dataiter = iter(dataloader)\n    num_steps_per_epoch = len(dataloader)\n\n    # ======================================================\n    # inference\n    # ======================================================\n    # prepare arguments\n    save_fps = cfg.get(\"fps\", 16) // cfg.get(\"frame_interval\", 1)\n    save_dir = cfg.get(\"save_dir\", None)\n    save_dir_orig = os.path.join(save_dir, \"orig\")\n    save_dir_recn = os.path.join(save_dir, \"recn\")\n    os.makedirs(save_dir_orig, exist_ok=True)\n    os.makedirs(save_dir_recn, exist_ok=True)\n\n    running_sum = running_var = 0.0\n    num_samples = 0\n\n    # Iter over the dataset\n    with tqdm(\n        enumerate(dataiter),\n        disable=not is_main_process() or verbose < 1,\n        total=num_steps_per_epoch,\n        initial=0,\n    ) as pbar:\n        for _, batch in pbar:\n            # == load data ==\n            x = batch[\"video\"].to(device, dtype)  # [B, C, T, H, W]\n            path = batch[\"path\"]\n\n            # == vae encoding & decoding ===\n            x_rec, posterior, z = model(x)\n\n            num_samples += 1\n            running_sum += z.mean()\n            running_var += (z - running_sum / num_samples).pow(2).mean()\n            if num_samples % 10 == 0:\n                logger.info(\n                    \"VAE feature per channel stats: mean %s, var %s\",\n                    (running_sum / num_samples).item(),\n                    (running_var / num_samples).sqrt().item(),\n                )\n\n            # == save samples ==\n            if is_main_process() and save_dir is not None:\n                for idx, x_orig in enumerate(x):\n                    fname = os.path.splitext(os.path.basename(path[idx]))[0]\n                    save_path_orig = os.path.join(save_dir_orig, f\"{fname}_orig\")\n                    save_sample(x_orig, save_path=save_path_orig, fps=save_fps)\n\n                    save_path_rec = os.path.join(save_dir_recn, f\"{fname}_recn\")\n                    save_sample(x_rec[idx], save_path=save_path_rec, fps=save_fps)\n\n    logger.info(\"Inference finished.\")\n    log_cuda_max_memory(\"inference\")", "label": 0}
{"function": "def load_yaml_file(yaml_file: str) -> dict:\n    with open(yaml_file, 'r', encoding='utf-8') as file:\n        return yaml.safe_load(file)", "label": 0}
{"function": "def load_yaml_file(file_path: str) -> Optional[dict]:\n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            return yaml.safe_load(file)\n    except FileNotFoundError:\n        _LOGGER.info('%s is not found.', file_path)\n        return None\n    except yaml.YAMLError:\n        _LOGGER.info('%s, is not a valid YAML file.', file_path)\n        return None", "label": 0}
{"function": "    def test_add_tool_missing_annotation_raises_exception(self):\n        \"\"\"Test that adding a tool with missing type annotations raises a TypeError.\"\"\"\n        with self.assertRaises(TypeError):\n            self.tool_manager._add_tool(missing_annotation_tool)", "label": 0}
{"function": "def stub_branches(mocker: MockerFixture) -> Callable[[list[str]], None]:\n    \"\"\"Return a function that stubs git branch discovery to *branches*.\"\"\"\n\n    def _factory(branches: list[str]) -> None:\n        mocker.patch(\n            \"gitingest.utils.git_utils.run_command\",\n            new_callable=AsyncMock,\n            return_value=(\"\\n\".join(f\"refs/heads/{b}\" for b in branches).encode() + b\"\\n\", b\"\"),\n        )\n        mocker.patch(\n            \"gitingest.utils.git_utils.fetch_remote_branches_or_tags\",\n            new_callable=AsyncMock,\n            return_value=branches,\n        )\n\n    return _factory", "label": 0}
{"function": "    def __call__(self, path, **params):\n        data = urlencode(dict(self.base_params, **params)).encode('ascii')\n        url = '%s/%s/%s' % (self.base_url + '/api', self.api_version, path)\n        r = json.loads(urlopen(url, data, self.timeout).read().decode('utf-8'))\n        if not r or not isinstance(r, dict):\n            raise EtherpadException('API returned: %s' % r)\n        if r.get('code') != 0:\n            raise EtherpadException(r.get('message', r))\n        return r.get('data')", "label": 1}
{"function": "def recognition_predictor() -> RecognitionPredictor:\n    recognition_predictor = RecognitionPredictor()\n    yield recognition_predictor\n    del recognition_predictor", "label": 0}
{"function": "    def test_mean(self):\n        self.check('CAN15/GMPEtInterface_med_combo.csv',\n                   max_discrep_percentage=200.)", "label": 1}
{"function": "    def www_authenticate(self):\n        \"\"\"The `WWW-Authenticate` header in a parsed form.\"\"\"\n        def on_update(www_auth):\n            if not www_auth and 'www-authenticate' in self.headers:\n                del self.headers['www-authenticate']\n            elif www_auth:\n                self.headers['WWW-Authenticate'] = www_auth.to_header()\n        header = self.headers.get('www-authenticate')\n        return parse_www_authenticate_header(header, on_update)", "label": 1}
{"function": "def cli(ctx, config_path):\n    \"\"\"WeClone: One-stop solution for creating digital avatars from chat history\"\"\"\n    # Only show community info when no subcommand is invoked\n    if ctx.invoked_subcommand is None:\n        show_community_info()\n        click.echo(ctx.get_help())\n        return\n\n    if config_path:\n        os.environ[\"WECLONE_CONFIG_PATH\"] = config_path\n        logger.info(f\"Config file path set to: {config_path}\")\n\n    _check_project_root()\n    _check_versions()\n    global cli_config\n    cli_config = cast(CliArgs, load_config(arg_type=\"cli_args\"))\n\n    configure_log_level_from_config()", "label": 0}
{"function": "    def should_continue_market(self, state: AgentState):\n        \"\"\"Determine if market analysis should continue.\"\"\"\n        messages = state[\"messages\"]\n        last_message = messages[-1]\n        if last_message.tool_calls:\n            return \"tools_market\"\n        return \"Msg Clear Market\"", "label": 0}
{"function": "    def get_cuda_bare_metal_version(self, cuda_dir):\n        raw_output = subprocess.check_output(\n            [cuda_dir + \"/bin/nvcc\", \"-V\"], universal_newlines=True)\n        output = raw_output.split()\n        release_idx = output.index(\"release\") + 1\n        bare_metal_version = parse(output[release_idx].split(\",\")[0])\n        cuda_version = f\"{bare_metal_version.major}{bare_metal_version.minor}\"\n        return cuda_version", "label": 0}
{"function": "def clear_default_runner():\n    set_default_agent_runner(None)", "label": 0}
{"function": "    def __lt__(self, other: Any) -> bool: ...", "label": 1}
{"function": "    def test_string_rsplit(self):\n        self.check_func_on_series(lambda x: x.str.rsplit().apply(str), self.pser[:-1])\n        self.check_func_on_series(lambda x: x.str.rsplit(r\"p*\").apply(str), self.pser[:-1])\n        pser = pd.Series([\"This is a sentence.\", \"This-is-a-long-word.\"])\n        self.check_func_on_series(lambda x: x.str.rsplit(n=2).apply(str), pser)\n        self.check_func_on_series(lambda x: x.str.rsplit(pat=\"-\", n=2).apply(str), pser)\n        self.check_func_on_series(lambda x: x.str.rsplit(n=2, expand=True), pser, almost=True)\n        with self.assertRaises(NotImplementedError):\n            self.check_func(lambda x: x.str.rsplit(expand=True))", "label": 1}
{"function": "def get_load_path_str(\n    init_path_str: str,\n    load_rename_rules: Optional[list[tuple[str, str]]] = None,\n    load_exclude_rules: Optional[list[str]] = None,\n) -> Optional[str]:\n    # Exclusion\n    if load_exclude_rules is not None:\n        for search_pattern in load_exclude_rules:\n            if re.search(search_pattern, init_path_str):\n                return None\n\n    # Renaming\n    load_path_str = init_path_str\n    if load_rename_rules is not None:\n        for search_pattern, replacement_pattern in load_rename_rules:\n            if re.search(search_pattern, load_path_str):\n                load_path_str = re.sub(search_pattern, replacement_pattern, load_path_str)\n                break\n\n    return load_path_str", "label": 0}
{"function": "    def test_constructor(self, prefix='0daf8h21'):\n        dcon = {'%s.xyx' % prefix: {'exchange': '%s.xyx' % prefix,\n                                    'routing_key': 'xyx'},\n                '%s.xyz' % prefix: {'exchange': '%s.xyz' % prefix,\n                                    'routing_key': 'xyz'}}\n        consumers = [compat.Consumer(self.connection, queue=prefix + str(i),\n                                     exchange=prefix + str(i))\n                     for i in range(3)]\n        c = compat.ConsumerSet(self.connection, consumers=consumers)\n        c2 = compat.ConsumerSet(self.connection, from_dict=dcon)\n\n        assert len(c.queues) == 3\n        assert len(c2.queues) == 2\n\n        c.add_consumer(compat.Consumer(self.connection,\n                                       queue=prefix + 'xaxxxa',\n                                       exchange=prefix + 'xaxxxa'))\n        assert len(c.queues) == 4\n        for cq in c.queues:\n            assert cq.channel is c.channel\n\n        c2.add_consumer_from_dict(\n            '%s.xxx' % prefix,\n            exchange='%s.xxx' % prefix,\n            routing_key='xxx',\n        )\n        assert len(c2.queues) == 3\n        for c2q in c2.queues:\n            assert c2q.channel is c2.channel\n\n        c.discard_all()\n        assert c.channel.called.count('queue_purge') == 4\n        c.consume()\n\n        c.close()\n        c2.close()\n        assert 'basic_cancel' in c.channel\n        assert 'close' in c.channel\n        assert 'close' in c2.channel", "label": 1}
{"function": "def test_docker_deployment(version=\"basic\"):\n    tester = Crawl4AiTester(\n        # base_url=\"http://localhost:11235\" ,\n        base_url=\"https://crawl4ai-sby74.ondigitalocean.app\",\n        api_token=\"test\",\n    )\n    print(f\"Testing Crawl4AI Docker {version} version\")\n\n    # Health check with timeout and retry\n    max_retries = 5\n    for i in range(max_retries):\n        try:\n            health = requests.get(f\"{tester.base_url}/health\", timeout=10)\n            print(\"Health check:\", health.json())\n            break\n        except requests.exceptions.RequestException:\n            if i == max_retries - 1:\n                print(f\"Failed to connect after {max_retries} attempts\")\n                sys.exit(1)\n            print(f\"Waiting for service to start (attempt {i+1}/{max_retries})...\")\n            time.sleep(5)\n\n    # Test cases based on version\n    test_basic_crawl(tester)\n    test_basic_crawl(tester)\n    test_basic_crawl_sync(tester)", "label": 0}
{"function": "    def repr_frozenset(self, x, level):\n        if not x:\n            return 'frozenset()'\n        x = _possibly_sorted(x)\n        return self._repr_iterable(x, level, 'frozenset({', '})',\n                                   self.maxfrozenset)", "label": 1}
{"function": "            def is_subcomponent_specification(values):\n                # checks whether the current value can be a specification of\n                # subcomponents, as for example the value for steps parameter\n                # (in Pipeline) or transformers parameter (in\n                # ColumnTransformer). These are always lists/tuples of lists/\n                # tuples, size bigger than 2 and an OpenMLFlow item involved.\n                if not isinstance(values, (tuple, list)):\n                    return False\n                for item in values:\n                    if not isinstance(item, (tuple, list)):\n                        return False\n                    if len(item) < 2:\n                        return False\n                    if not isinstance(item[1], (openml.flows.OpenMLFlow, str)):\n                        if (\n                            isinstance(item[1], str)\n                            and item[1] in SKLEARN_PIPELINE_STRING_COMPONENTS\n                        ):\n                            pass\n                        else:\n                            return False\n                return True", "label": 1}
{"function": "    def __repr__(self):\n        # make sure the __repr__ even works if the request was created\n        # from an invalid WSGI environment.  If we display the request\n        # in a debug session we don't want the repr to blow up.\n        args = []\n        try:\n            args.append(\"'%s'\" % self.url)\n            args.append('[%s]' % self.method)\n        except Exception:\n            args.append('(invalid WSGI environ)')\n\n        return '<%s %s>' % (\n            self.__class__.__name__,\n            ' '.join(args)\n        )", "label": 1}
{"function": "  def test_compiler_symbols_regex(self):\n    compiler_symbols = [\n      \"v8::internal::Parser\",\n      \"v8::internal::(anonymous namespace)::Compile\",\n      \"v8::internal::Compiler::foo\",\n    ]\n    for compiler_symbol in compiler_symbols:\n      self.assertTrue(ipr.COMPILER_SYMBOLS_RE.match(compiler_symbol))", "label": 1}
{"function": "    def __init__(self, model_path) -> None:\n        model, img_processor, image_token_len, tokenizer = init_omni_lmm(model_path)\n        self.model = model\n        self.image_token_len = image_token_len\n        self.image_transform = img_processor\n        self.tokenizer = tokenizer\n        self.model.eval()", "label": 0}
{"function": "    def forward(self, x):\n        b, c, h, w = x.shape\n\n        hx = x\n        hxin = self.rebnconvin(hx)\n\n        hx1 = self.rebnconv1(hxin)\n        hx = self.pool1(hx1)\n\n        hx2 = self.rebnconv2(hx)\n        hx = self.pool2(hx2)\n\n        hx3 = self.rebnconv3(hx)\n        hx = self.pool3(hx3)\n\n        hx4 = self.rebnconv4(hx)\n        hx = self.pool4(hx4)\n\n        hx5 = self.rebnconv5(hx)\n        hx = self.pool5(hx5)\n\n        hx6 = self.rebnconv6(hx)\n\n        hx7 = self.rebnconv7(hx6)\n\n        hx6d = self.rebnconv6d(torch.cat((hx7, hx6), 1))\n        hx6dup = _upsample_like(hx6d, hx5)\n\n        hx5d = self.rebnconv5d(torch.cat((hx6dup, hx5), 1))\n        hx5dup = _upsample_like(hx5d, hx4)\n\n        hx4d = self.rebnconv4d(torch.cat((hx5dup, hx4), 1))\n        hx4dup = _upsample_like(hx4d, hx3)\n\n        hx3d = self.rebnconv3d(torch.cat((hx4dup, hx3), 1))\n        hx3dup = _upsample_like(hx3d, hx2)\n\n        hx2d = self.rebnconv2d(torch.cat((hx3dup, hx2), 1))\n        hx2dup = _upsample_like(hx2d, hx1)\n\n        hx1d = self.rebnconv1d(torch.cat((hx2dup, hx1), 1))\n\n        return hx1d + hxin", "label": 0}
{"function": "def main(config_path):\n    config = load_config(config_path)\n    task_instances = initialize_tasks_and_models(config)\n\n    # get input and output path from config\n    input_data = config.get('inputs', None)\n    result_path = config.get('outputs', 'outputs'+'/'+TASK_NAME)\n\n    # formula_detection_task\n    model_formula_recognition = task_instances[TASK_NAME]\n\n    # for image detection\n    recognition_results = model_formula_recognition.predict(input_data, result_path)\n\n\n    print('Recognition results are as follows:')\n    for id, math in enumerate(recognition_results):\n        print(str(id+1)+': ', math)", "label": 0}
{"function": "    def should_continue_debate(self, state: AgentState) -> str:\n        \"\"\"Determine if debate should continue.\"\"\"\n\n        if (\n            state[\"investment_debate_state\"][\"count\"] >= 2 * self.max_debate_rounds\n        ):  # 3 rounds of back-and-forth between 2 agents\n            return \"Research Manager\"\n        if state[\"investment_debate_state\"][\"current_response\"].startswith(\"Bull\"):\n            return \"Bear Researcher\"\n        return \"Bull Researcher\"", "label": 0}
{"function": "    def test_live_migration(self):\n        self._test_compute_api('live_migration', 'cast',\n                instance=self.fake_instance_obj, dest='dest',\n                block_migration='blockity_block', host='tsoh',\n                migration='migration',\n                migrate_data={}, version='5.0')", "label": 1}
{"function": "  def transition_to_powers(self, powers):\n    \"\"\"Computes powers of the adder transition matrix efficiently.\n\n    Args:\n      powers: An integer Tensor, shape [...], with powers to raise the\n        transition matrix to.\n    Returns:\n      A floating point Tensor with shape [..., 2, 2] containing:\n        transition^power = [[1., power],\n                            [0., 1.]]\n    \"\"\"\n    paddings = array_ops.concat(\n        [\n            array_ops.zeros([array_ops.rank(powers), 2], dtype=dtypes.int32),\n            [(0, 1), (1, 0)]\n        ],\n        axis=0)\n    powers_padded = array_ops.pad(powers[..., None, None], paddings=paddings)\n    identity_matrices = linalg_ops.eye(\n        num_rows=2, batch_shape=array_ops.shape(powers), dtype=self.dtype)\n    return identity_matrices + math_ops.cast(powers_padded, self.dtype)", "label": 1}
{"function": "    def __mod__(self, query: _Query) -> URL: ...", "label": 1}
{"function": "    def test_der(self, tdata):\n        with open(tdata.path(\"mitmproxy/net/data/dercert\"), \"rb\") as f:\n            d = f.read()\n        s = certs.Cert.from_der(d)\n        assert s.cn", "label": 1}
{"function": "    def _train_once(self):\n        \"\"\"Perform one iteration of training.\"\"\"\n        for _ in range(self._num_steps_per_epoch):\n            indices = np.random.choice(range(self._num_train_tasks),\n                                       self._meta_batch_size)\n            self._optimize_policy(indices)", "label": 1}
{"function": "def get_video_paths(source_dir: Path, parallelism: int, rank: int) -> List[Path]:\n    \"\"\"\n    Get paths of videos to process, partitioned for parallel processing.\n\n    Args:\n        source_dir (Path): Source directory containing videos.\n        parallelism (int): Level of parallelism.\n        rank (int): Rank for distributed processing.\n\n    Returns:\n        List[Path]: List of video paths to process.\n    \"\"\"\n    video_paths = [item for item in sorted(\n        source_dir.iterdir()) if item.is_file() and item.suffix == '.mp4']\n    return [video_paths[i] for i in range(len(video_paths)) if i % parallelism == rank]", "label": 0}
{"function": "def get_models(name: str, device: torch.device, offload: bool, is_schnell: bool):\n    t5 = load_t5(device, max_length=256 if is_schnell else 512)\n    clip = load_clip(device)\n    model = load_flow_model(name, device=\"cpu\" if offload else device)\n    ae = load_ae(name, device=\"cpu\" if offload else device)\n    nsfw_classifier = pipeline(\"image-classification\", model=\"Falconsai/nsfw_image_detection\", device=device)\n    return model, ae, t5, clip, nsfw_classifier", "label": 0}
{"function": "def system_info():\n    return platform.system(), ARCH_ALIAS[platform.machine()]", "label": 0}
{"function": "  def testExecuteUpdateJobsErrorOnePendingDepCloudStorageCollisionNoForce(\n      self, uploader_cs_mock):\n    uploader_cs_mock.Exists.return_value = True\n    self.fs.CreateFile(self.file_path,\n                       contents='\\n'.join(self.expected_file_lines))\n    config = dependency_manager.BaseConfig(self.file_path, writable=True)\n    config._config_data = self.new_dependencies.copy()\n    config._is_dirty = True\n    config._pending_uploads = [self.new_pending_upload]\n    self.assertEqual(self.new_dependencies, config._config_data)\n    self.assertTrue(config._is_dirty)\n    self.assertEqual(1, len(config._pending_uploads))\n    self.assertEqual(self.new_pending_upload, config._pending_uploads[0])\n    expected_exists_calls = [mock.call(self.new_bucket, self.new_remote_path)]\n    expected_insert_calls = []\n    expected_copy_calls = []\n\n    self.assertRaises(dependency_manager.CloudStorageUploadConflictError,\n                      config.ExecuteUpdateJobs)\n    self.assertTrue(config._is_dirty)\n    self.assertTrue(config._pending_uploads)\n    self.assertEqual(self.new_dependencies, config._config_data)\n    self.assertEqual(1, len(config._pending_uploads))\n    self.assertEqual(self.new_pending_upload, config._pending_uploads[0])\n    file_module = fake_filesystem.FakeFileOpen(self.fs)\n    expected_file_lines = list(self.expected_file_lines)\n    for line in file_module(self.file_path):\n      self.assertEqual(expected_file_lines.pop(0), line.strip())\n    self.fs.CloseOpenFile(file_module(self.file_path))\n    self.assertEqual(expected_insert_calls,\n                     uploader_cs_mock.Insert.call_args_list)\n    self.assertEqual(expected_exists_calls,\n                     uploader_cs_mock.Exists.call_args_list)\n    self.assertEqual(expected_copy_calls,\n                     uploader_cs_mock.Copy.call_args_list)", "label": 1}
{"function": "        def _seed_current_object(current_value):\n            if isinstance(current_value, int):  # acceptable behaviour\n                return False\n            elif isinstance(current_value, np.random.RandomState):\n                raise ValueError(\n                    \"Models initialized with a RandomState object are not \"\n                    \"supported. Please seed with an integer. \"\n                )\n            elif current_value is not None:\n                raise ValueError(\n                    \"Models should be seeded with int or None (this should never \" \"happen). \"\n                )\n            else:\n                return True", "label": 1}
{"function": "    def create_unique_constraint(self, name, source, local_cols,\n                                 schema=None, **kw):\n        \"\"\"Issue a \"create unique constraint\" instruction using the\n        current migration context.\n\n        e.g.::\n\n            from alembic import op\n            op.create_unique_constraint(\"uq_user_name\", \"user\", [\"name\"])\n\n        This internally generates a :class:`~sqlalchemy.schema.Table` object\n        containing the necessary columns, then generates a new\n        :class:`~sqlalchemy.schema.UniqueConstraint`\n        object which it then associates with the :class:`~sqlalchemy.schema.Table`.\n        Any event listeners associated with this action will be fired\n        off normally.   The :class:`~sqlalchemy.schema.AddConstraint`\n        construct is ultimately used to generate the ALTER statement.\n\n        :param name: Name of the unique constraint.  The name is necessary\n         so that an ALTER statement can be emitted.  For setups that\n         use an automated naming scheme such as that described at\n         `NamingConventions <http://www.sqlalchemy.org/trac/wiki/UsageRecipes/NamingConventions>`_,\n         ``name`` here can be ``None``, as the event listener will\n         apply the name to the constraint object when it is associated\n         with the table.\n        :param source: String name of the source table. Dotted schema names are\n         supported.\n        :param local_cols: a list of string column names in the\n         source table.\n        :param deferrable: optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when\n         issuing DDL for this constraint.\n        :param initially: optional string. If set, emit INITIALLY <value> when issuing DDL\n         for this constraint.\n        :param schema: Optional schema name to operate within.\n\n         .. versionadded:: 0.4.0\n\n        \"\"\"\n\n        self.impl.add_constraint(\n                    self._unique_constraint(name, source, local_cols,\n                        schema=schema, **kw)\n                )", "label": 1}
{"function": "    def createTempUrl(self, content, suffix, path=None, relativeTo=None,\n            pythonUrl=False):\n        \"\"\"\n        Specialized function. Creates a file, fills it with content \n        (byte string), closes it and returns its URL.\n        relativeTo -- path relative to which the URL should be or None\n            for preferred relativeTo path or \"\" for absolute URL\n        \"\"\"\n        fullPath = self.createTempFile(content, suffix, path, \"\")\n        \n        return self.getRelativeUrl(relativeTo, fullPath, pythonUrl=pythonUrl)", "label": 1}
{"function": "    def set_user_is_expert(user_id: int, is_expert: bool) -> User:\n        \"\"\"\n        Enabled or disables expert mode for the user\n        :raises: UserServiceError\n        \"\"\"\n        user = UserService.get_user_by_id(user_id)\n        user.set_is_expert(is_expert)\n\n        return user", "label": 1}
{"function": "    def check_1d_slicing_with_arg(self, pyfunc, flags):\n        args = list(range(-9, 10))\n\n        arraytype = types.Array(types.int32, 1, 'C')\n        argtys = (arraytype, types.int32)\n        cr = compile_isolated(pyfunc, argtys, flags=flags)\n        cfunc = cr.entry_point\n\n        a = np.arange(10, dtype='i4')\n        for arg in args:\n            self.assertEqual(pyfunc(a, arg), cfunc(a, arg))\n\n        # Any\n        arraytype = types.Array(types.int32, 1, 'A')\n        argtys = (arraytype, types.int32)\n        cr = compile_isolated(pyfunc, argtys, flags=flags)\n        cfunc = cr.entry_point\n\n        a = np.arange(20, dtype='i4')[::2]\n        self.assertFalse(a.flags['C_CONTIGUOUS'])\n        self.assertFalse(a.flags['F_CONTIGUOUS'])\n        for arg in args:\n            self.assertEqual(pyfunc(a, arg), cfunc(a, arg))", "label": 1}
{"function": "def main(\n    debug=False,\n    max_plan_iterations=1,\n    max_step_num=3,\n    enable_background_investigation=True,\n):\n    \"\"\"Interactive mode with built-in questions.\n\n    Args:\n        enable_background_investigation: If True, performs web search before planning to enhance context\n        debug: If True, enables debug level logging\n        max_plan_iterations: Maximum number of plan iterations\n        max_step_num: Maximum number of steps in a plan\n    \"\"\"\n    # First select language\n    language = inquirer.select(\n        message=\"Select language / \u9009\u62e9\u8bed\u8a00:\",\n        choices=[\"English\", \"\u4e2d\u6587\"],\n    ).execute()\n\n    # Choose questions based on language\n    questions = (\n        BUILT_IN_QUESTIONS if language == \"English\" else BUILT_IN_QUESTIONS_ZH_CN\n    )\n    ask_own_option = (\n        \"[Ask my own question]\" if language == \"English\" else \"[\u81ea\u5b9a\u4e49\u95ee\u9898]\"\n    )\n\n    # Select a question\n    initial_question = inquirer.select(\n        message=(\n            \"What do you want to know?\" if language == \"English\" else \"\u60a8\u60f3\u4e86\u89e3\u4ec0\u4e48?\"\n        ),\n        choices=[ask_own_option] + questions,\n    ).execute()\n\n    if initial_question == ask_own_option:\n        initial_question = inquirer.text(\n            message=(\n                \"What do you want to know?\"\n                if language == \"English\"\n                else \"\u60a8\u60f3\u4e86\u89e3\u4ec0\u4e48?\"\n            ),\n        ).execute()\n\n    # Pass all parameters to ask function\n    ask(\n        question=initial_question,\n        debug=debug,\n        max_plan_iterations=max_plan_iterations,\n        max_step_num=max_step_num,\n        enable_background_investigation=enable_background_investigation,\n    )", "label": 0}
{"function": "    def start(self, message=\"Building\"):\n        self.is_running = True\n        self.animation_thread = threading.Thread(target=self._animate, args=(message,))\n        self.animation_thread.start()", "label": 0}
{"function": "def format_results(results: List[TaskResult]) -> str:\n    \"\"\"Format experiment results in Markdown for GitHub step summary.\"\"\"\n    output = [\"# Experiment Results\\n\"]\n\n    for result in results:\n        output.append(f\"## {result.name}\")\n        output.append(f\"**Status**: {'\u2705 Success' if result.success else '\u274c Failed'}\")\n        output.append(f\"**Runtime**: {result.runtime:.2f} seconds\")\n        output.append(f\"**Timestamp**: {result.timestamp}\")\n        output.append(\"\\n**Output**:\\n```\")\n        output.append(result.output)\n        output.append(\"```\\n\")\n\n    return \"\\n\".join(output)", "label": 0}
{"function": "    def __init__(self, model_name: str, device: str, offload: bool, track_usage: bool):\n        self.device = torch.device(device)\n        self.offload = offload\n        self.model_name = model_name\n        self.is_schnell = model_name == \"flux-schnell\"\n        self.model, self.ae, self.t5, self.clip, self.nsfw_classifier = get_models(\n            model_name,\n            device=self.device,\n            offload=self.offload,\n            is_schnell=self.is_schnell,\n        )\n        self.track_usage = track_usage", "label": 0}
{"function": "def run_pytest_and_generate_report():\n    start_time = datetime.now()\n\n    # Run pytest\n    output = subprocess.run(\n        \"python -m pytest\",\n        shell=True,\n        capture_output=True,\n        text=True\n    ).stdout\n\n    # duration\n    end_time = datetime.now()\n    duration = f\"{(end_time - start_time).total_seconds() / 60:.2f} minutes\"\n\n\n    # Parse test results from output\n    test_results = parse_pytest_output(output)\n    # Generate report\n    report = generate_test_report(test_results, duration)\n    # Print and save\n    print(report)\n    save_report(report)", "label": 0}
{"function": "def test_image_tall():\n    image = Image.new(\"RGB\", (4096, 4096), \"white\")\n    draw = ImageDraw.Draw(image)\n    draw.text((10, 10), \"Hello World\", fill=\"black\", font_size=72)\n    draw.text(\n        (4000, 4000),\n        \"This is a sentence of text.\\n\\nNow it is a paragraph.\\n\\nA three-line one.\",\n        fill=\"black\",\n        font_size=24,\n    )\n    return image", "label": 0}
{"function": "    def __init__(self):\n        self.alert = self.load()", "label": 1}
{"function": "def store_embeddings(\n    client: QdrantClient,\n    embedding_model: TextEmbedding,\n    documents: List,\n    collection_name: str\n) -> None:\n    \"\"\"Store document embeddings in Qdrant.\"\"\"\n    for doc in documents:\n        embedding = list(embedding_model.embed([doc.page_content]))[0]\n        client.upsert(\n            collection_name=collection_name,\n            points=[\n                models.PointStruct(\n                    id=str(uuid.uuid4()),\n                    vector=embedding.tolist(),\n                    payload={\n                        \"content\": doc.page_content,\n                        **doc.metadata\n                    }\n                )\n            ]\n        )", "label": 0}
{"function": "def _create_validation_cache(archive, output, names, ground_truth, args):\n    images0 = sorted(names)\n\n    # Thinning\n    images = []\n    for i, image in enumerate(images0):\n        if i % args.thinning == 0:\n            images.append(image)\n\n    def _load_func(index):\n        y, name = ground_truth[index], images[index]\n        im = imread(archive.extractfile(name), num_channels=3)\n        x = _resize_image(im, args.width, args.height, args.mode == 'padding')\n        return x, np.array([y]).astype(np.int32)\n\n    from nnabla.utils.data_source import DataSourceWithFileCache\n    from nnabla.utils.data_source_implements import SimpleDataSource\n    from nnabla.logger import logger\n\n    logger.info('Num of data : {}'.format(len(images)))\n    shuffle = False\n    if args.shuffle == 'True':\n        shuffle = True\n    source = SimpleDataSource(_load_func, len(images), shuffle, rng=None)\n    DataSourceWithFileCache(\n        source, cache_dir=output, shuffle=args.shuffle)", "label": 1}
{"function": "def sample(logits, temperature: float = 1.0):\n    \"\"\"\n    Samples a token from the logits using temperature scaling.\n\n    Args:\n        logits (torch.Tensor): The logits tensor for token predictions.\n        temperature (float, optional): Temperature for scaling logits. Defaults to 1.0.\n\n    Returns:\n        torch.Tensor: The sampled token.\n    \"\"\"\n    logits = logits / max(temperature, 1e-5)\n    probs = torch.softmax(logits, dim=-1)\n    return probs.div_(torch.empty_like(probs).exponential_(1)).argmax(dim=-1)", "label": 0}
{"function": "def perform_load_test(concurrency, total_requests, questions, output_file, is_stream=False):\n    latencies = []\n    questions = [\"\u4ec0\u4e48\u662f\u4e09\u5927\u4e13\u9879\", \"\u6c5f\u82cf\u9ad8\u4e09\u7269\u751f\u5730\uff0c\u519b\u6821\u80fd\u4e0d\u80fd\u62a5\uff0c\u54ea\u4e9b\u4e13\u4e1a\u4e0d\u80fd\u62a5\", \"\u5c71\u4e1c\u6587\u79d1\u5728\u6c5f\u82cf\u600e\u4e48\u9009\u5b66\u6821\", \"\u4e1c\u5357\u5927\u5b66\u5316\u5b66\u5de5\u7a0b\u4e0e\u5de5\u827a\uff0c\u751f\u7269\u79d1\u5b66\uff0c\u5236\u836f\u5de5\u7a0b\u5206\u6d41\u54ea\u4e2a\u597d\uff1f\", \"\u7537\u751f\u9ad8\u4e09\u7269\u5316\u5730\uff0c\u8fbd\u5b81\uff0c\u5b66\u65e5\u8bed\u597d\u9009\u5b66\u6821\u5417\"]\n    #questions = [\"\u4ec0\u4e48\u662f\u4e09\u5927\u4e13\u9879\"] * 5\n    with concurrent.futures.ThreadPoolExecutor(max_workers=concurrency) as executor:\n        future_to_request = {executor.submit(measure_latency, random.choice(questions), output_file, is_stream): i for i in range(total_requests)}\n        for future in concurrent.futures.as_completed(future_to_request):\n            try:\n                latency = future.result()\n                latencies.append(latency)\n            except Exception as e:\n                print(f\"\u8bf7\u6c42\u6267\u884c\u5f02\u5e38: {e}\")\n\n    # \u8ba1\u7b97\u7edf\u8ba1\u6570\u636e\n    p99 = np.percentile(latencies, 99)\n    p95 = np.percentile(latencies, 95)\n    total_time = sum(latencies)\n    qps = total_requests / total_time\n\n    return latencies, p99, p95, qps", "label": 0}
{"function": "def generate_video(\n    model,\n    prompt,\n    resolution,\n    video_length,\n    seed,\n    num_inference_steps,\n    guidance_scale,\n    flow_shift,\n    embedded_guidance_scale\n):\n    seed = None if seed == -1 else seed\n    width, height = resolution.split(\"x\")\n    width, height = int(width), int(height)\n    negative_prompt = \"\" # not applicable in the inference\n\n    outputs = model.predict(\n        prompt=prompt,\n        height=height,\n        width=width, \n        video_length=video_length,\n        seed=seed,\n        negative_prompt=negative_prompt,\n        infer_steps=num_inference_steps,\n        guidance_scale=guidance_scale,\n        num_videos_per_prompt=1,\n        flow_shift=flow_shift,\n        batch_size=1,\n        embedded_guidance_scale=embedded_guidance_scale\n    )\n    \n    samples = outputs['samples']\n    sample = samples[0].unsqueeze(0)\n    \n    save_path = os.path.join(os.getcwd(), \"gradio_outputs\")\n    os.makedirs(save_path, exist_ok=True)\n    \n    time_flag = datetime.fromtimestamp(time.time()).strftime(\"%Y-%m-%d-%H:%M:%S\")\n    video_path = f\"{save_path}/{time_flag}_seed{outputs['seeds'][0]}_{outputs['prompts'][0][:100].replace('/','')}.mp4\"\n    save_videos_grid(sample, video_path, fps=24)\n    logger.info(f'Sample saved to: {video_path}')\n    \n    return video_path", "label": 0}
{"function": "def test_encode_decode_identity(tokenizer_factory, text):\n    text = unpack(text)\n    tokenizer = tokenizer_factory()\n    ids = tokenizer.encode(text)\n    decoded = tokenizer.decode(ids)\n    assert text == decoded", "label": 0}
{"function": "  def get_noise_transform(self):\n    if self.use_level_noise:\n      return [[1., 0.],\n              [0., 1.]]\n    else:\n      return [[0.],\n              [1.]]", "label": 1}
{"function": "  def testExecuteUpdateJobsFailureOnSecondCopyNoCSCollisionNoForce(\n      self, uploader_cs_mock):\n    uploader_cs_mock.Exists.side_effect = [False, True, False]\n    uploader_cs_mock.Copy.side_effect = cloud_storage.CloudStorageError\n    self.fs.CreateFile(self.file_path,\n                       contents='\\n'.join(self.expected_file_lines))\n    config = dependency_manager.BaseConfig(self.file_path, writable=True)\n    config._config_data = self.new_dependencies.copy()\n    config._is_dirty = True\n    config._pending_uploads = [self.new_pending_upload,\n                               self.final_pending_upload]\n    self.assertEqual(self.new_dependencies, config._config_data)\n    self.assertTrue(config._is_dirty)\n    self.assertEqual(2, len(config._pending_uploads))\n    self.assertEqual(self.new_pending_upload, config._pending_uploads[0])\n    self.assertEqual(self.final_pending_upload, config._pending_uploads[1])\n    expected_exists_calls = [mock.call(self.new_bucket, self.new_remote_path),\n                             mock.call(self.final_bucket,\n                                       self.final_remote_path)]\n    expected_insert_calls = [mock.call(self.new_bucket, self.new_remote_path,\n                                       self.new_dep_path)]\n    expected_copy_calls = []\n    expected_delete_calls = [mock.call(self.new_bucket, self.new_remote_path)]\n\n    self.assertRaises(cloud_storage.CloudStorageError,\n                      config.ExecuteUpdateJobs)\n    self.assertTrue(config._is_dirty)\n    self.assertEqual(2, len(config._pending_uploads))\n    self.assertEqual(self.new_pending_upload, config._pending_uploads[0])\n    self.assertEqual(self.final_pending_upload, config._pending_uploads[1])\n    self.assertEqual(self.new_dependencies, config._config_data)\n    file_module = fake_filesystem.FakeFileOpen(self.fs)\n    expected_file_lines = list(self.expected_file_lines)\n    for line in file_module(self.file_path):\n      self.assertEqual(expected_file_lines.pop(0), line.strip())\n    self.fs.CloseOpenFile(file_module(self.file_path))\n    self.assertEqual(expected_insert_calls,\n                     uploader_cs_mock.Insert.call_args_list)\n    self.assertEqual(expected_exists_calls,\n                     uploader_cs_mock.Exists.call_args_list)\n    self.assertEqual(expected_copy_calls,\n                     uploader_cs_mock.Copy.call_args_list)\n    self.assertEqual(expected_delete_calls,\n                     uploader_cs_mock.Delete.call_args_list)", "label": 1}
{"function": "    def export_wav(self, wav, file_wave, remove_silence=False):\n        sf.write(file_wave, wav, self.target_sample_rate)\n\n        if remove_silence:\n            remove_silence_for_generated_wav(file_wave)", "label": 0}
{"function": "def test_request_with_digest_auth():\n    \"\"\"Test a request with digest authentication.\"\"\"\n    request = RequestModel(\n        name=\"Request with digest auth\",\n        method=\"GET\",\n        url=\"https://example.com/api/secure\",\n        auth=Auth.digest_auth(\"username\", \"password\"),\n    )\n\n    expected = \"curl \\\\\\n  --digest -u 'username:password' \\\\\\n  'https://example.com/api/secure'\"\n    assert request.to_curl() == expected", "label": 0}
{"function": "def test_cli_with_stdout_output() -> None:\n    \"\"\"Test CLI invocation with output directed to STDOUT.\"\"\"\n    output_file = Path(OUTPUT_FILE_NAME)\n    # Clean up any existing digest.txt file before test\n    if output_file.exists():\n        output_file.unlink()\n\n    try:\n        result = _invoke_isolated_cli_runner([\"./\", \"--output\", \"-\", \"--exclude-pattern\", \"tests/\"])\n\n        # \u2500\u2500\u2500 core expectations (stdout) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500-\n        assert result.exit_code == 0, f\"CLI exited with code {result.exit_code}, stderr: {result.stderr}\"\n        assert \"---\" in result.stdout, \"Expected file separator '---' not found in STDOUT\"\n        assert \"src/gitingest/__main__.py\" in result.stdout, (\n            \"Expected content (e.g., src/gitingest/__main__.py) not found in STDOUT\"\n        )\n        assert not output_file.exists(), f\"Output file {output_file} was unexpectedly created.\"\n\n        # \u2500\u2500\u2500 the summary must *not* pollute STDOUT, must appear on STDERR \u2500\u2500\u2500\n        summary = \"Analysis complete! Output sent to stdout.\"\n        stdout_lines = result.stdout.splitlines()\n        stderr_lines = result.stderr.splitlines()\n        assert summary not in stdout_lines, \"Unexpected summary message found in STDOUT\"\n        assert summary in stderr_lines, \"Expected summary message not found in STDERR\"\n        assert f\"Output written to: {output_file.name}\" not in stderr_lines\n    finally:\n        # Clean up any digest.txt file that might have been created during test\n        if output_file.exists():\n            output_file.unlink()", "label": 0}
{"function": "def set_run_dtype(x, dtype=None):\n    # \u4fdd\u5b58\u539f\u59cb\u73af\u5883\u53d8\u91cf\u7684\u503c\uff08\u5982\u679c\u5b58\u5728\uff09\n    npu_config.original_run_dtype = x.dtype\n    # \u8bbe\u7f6e\u73af\u5883\u53d8\u91cf\u4e3a\u6307\u5b9a\u7684\u503c\n    npu_config.current_run_dtype = dtype\n    try:\n        # Yield control back to the body of the `with` statement\n        yield\n    finally:\n        # \u6062\u590d\u539f\u59cb\u7684\u73af\u5883\u53d8\u91cf\u503c\n        npu_config.current_run_dtype = None\n        npu_config.original_run_dtype = None", "label": 0}
{"function": "def test_encode_url_basic():\n    \"\"\"Test basic URL encoding with simple path\"\"\"\n    url = \"https://example.com/path with spaces\"\n    expected = \"https://example.com/path%20with%20spaces\"\n    assert encode_url(url) == expected", "label": 0}
{"function": "def test__get_function_default_kwargs__kwarg():\n    \"\"\" Test if `_get_function_default_kwargs` handles a single kwarg. \"\"\"\n\n    def func(kwarg=HParam()):\n        pass\n\n    assert list(_get_function_default_kwargs(func).keys()) == ['kwarg']\n    assert all([isinstance(v, _HParam) for v in _get_function_default_kwargs(func).values()])", "label": 1}
{"function": "    def test_set_override_existing_item(self):\n        d = {}\n        b = KeypathDict(d)\n        b.set('a.b.c', 1)\n        r = {\n            'a': {\n                'b': {\n                    'c': 1\n                }\n            }\n        }\n        b.set('a.b.c', 2)\n        r = {\n            'a': {\n                'b': {\n                    'c': 2\n                }\n            }\n        }\n        self.assertEqual(b, r)\n        b.set('a.b.c.d', 3)\n        r = {\n            'a': {\n                'b': {\n                    'c': {\n                        'd': 3\n                    }\n                }\n            }\n        }\n        self.assertEqual(b, r)", "label": 1}
{"function": "def run_command_with_live_tail(ext: str, command: List[str], output_lines: int = 20,\n                               refresh_rate: float = 0.1, cwd: Optional[str] = None):\n    \"\"\"\n    Execute a script-like command with real-time output of the last `output_lines` lines.\n\n    - during execution: displays the last `output_lines` lines of output in real-time.\n    - On success: Clears the displayed output.\n    - On failure: Prints the full command output.\n\n    Args:\n        ext (str): the name of the native extension currently building.\n        command (List[str]): The command to execute, as a list of arguments.\n        output_lines (int, optional): Number of terminal lines to display during live output. Defaults to 20.\n        refresh_rate (float, optional): Time in seconds between output refreshes. Defaults to 0.1.\n        cwd (Optional[str], optional): Working directory to run the command in. Defaults to current directory.\n    \"\"\"\n    # Dump all subprocess output without any buffering if stdout is not a terminal\n    if not sys.stdout.isatty():\n        return subprocess.run(command, cwd=cwd, check=True)\n    # Start time for elapsed time calculation\n    start = time.time()\n    # Buffer for all output\n    all_output = []\n    write_buffer = deque(maxlen=output_lines)\n    # Current number of lines from sub process displayed\n    current_lines = 0\n\n    # ANSI escape codes for terminal control\n    CLEAR_LINE = '\\033[K'\n    MOVE_UP = '\\033[1A'\n    SAVE_CURSOR = '\\0337'\n    RESTORE_CURSOR = '\\0338'\n    CLEAR_REMAINING = '\\033[J'\n\n    def write_progress(status: Literal['RUNNING', 'SUCCEED', 'FAILED'] = 'RUNNING',\n                       new_line: Optional[str] = None):\n        \"\"\"Update terminal display with latest output\"\"\"\n        nonlocal current_lines, process\n        sys.stdout.write(SAVE_CURSOR)\n        sys.stdout.write(MOVE_UP * current_lines)\n        banner = f\"ext={ext} pid={process.pid} status={status.upper()} elapsed=({time.time()-start:.2f}S)\\n\"\n        if status != 'FAILED':\n            banner = colored(banner, 'green', bold=True)\n        else:\n            banner = colored(banner, 'red', bold=True)\n        sys.stdout.write(CLEAR_LINE + banner)\n        if new_line is not None:\n            all_output.append(new_line)\n            write_buffer.extend(split_line(ANSI_ESCAPE.sub('', new_line).rstrip()))\n        elif status == 'RUNNING':\n            sys.stdout.write(RESTORE_CURSOR)\n            sys.stdout.flush()\n            return\n\n        sys.stdout.write(CLEAR_REMAINING)\n        if status == 'RUNNING':\n            current_lines = 1 + len(write_buffer)\n            for text in write_buffer:\n                sys.stdout.write(text + '\\n')\n        elif status == 'FAILED':\n            for text in all_output:\n                sys.stdout.write(text)\n        sys.stdout.flush()\n\n    # Start subprocess\n    sys.stdout.write(colored(f'ext={ext} command={\" \".join(str(c) for c in command)}\\n', bold=True))\n    sys.stdout.flush()\n    process = subprocess.Popen(\n        command,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        cwd=cwd,\n        text=True,\n        bufsize=1\n    )\n\n    try:\n        write_progress()\n        poll_obj = select.poll()\n        poll_obj.register(process.stdout, select.POLLIN)\n        while process.poll() is None:\n            poll_result = poll_obj.poll(refresh_rate * 1000)\n            if poll_result:\n                write_progress(new_line=process.stdout.readline())\n            else:\n                write_progress()\n\n        # Get any remaining output\n        while True:\n            line = process.stdout.readline()\n            if not line:\n                break\n            write_progress(new_line=line)\n    except BaseException as e:\n        process.terminate()\n        raise e\n    finally:\n        exit_code = process.wait()\n        write_progress(status='SUCCEED' if exit_code == 0 else 'FAILED')", "label": 0}
{"function": "    def repr_deque(self, x, level):\n        return self._repr_iterable(x, level, 'deque([', '])', self.maxdeque)", "label": 1}
{"function": "async def run_global_search(query: str, sv: SessionVariables) -> SearchResult:\n    \"\"\"Run global search.\"\"\"\n    print(f\"Global search query: {query}\")  # noqa T201\n\n    # build global search engine\n    response_placeholder = st.session_state[\n        f\"{SearchType.Global.value.lower()}_response_placeholder\"\n    ]\n    response_container = st.session_state[\n        f\"{SearchType.Global.value.lower()}_container\"\n    ]\n\n    response_placeholder.empty()\n    with response_placeholder, st.spinner(\"Generating answer using global search...\"):\n        empty_context_data: dict[str, pd.DataFrame] = {}\n\n        response, context_data = await api.global_search(\n            config=sv.graphrag_config.value,\n            entities=sv.entities.value,\n            communities=sv.communities.value,\n            community_reports=sv.community_reports.value,\n            dynamic_community_selection=False,\n            response_type=\"Multiple Paragraphs\",\n            community_level=sv.dataset_config.value.community_level,\n            query=query,\n        )\n\n        print(f\"Context data: {context_data}\")  # noqa T201\n        print(f\"Global Response: {response}\")  # noqa T201\n\n    # display response and reference context to UI\n    search_result = SearchResult(\n        search_type=SearchType.Global,\n        response=str(response),\n        context=context_data if isinstance(context_data, dict) else empty_context_data,\n    )\n\n    display_search_result(\n        container=response_container, result=search_result, stats=None\n    )\n\n    if \"response_lengths\" not in st.session_state:\n        st.session_state.response_lengths = []\n\n    st.session_state[\"response_lengths\"].append({\n        \"result\": search_result,\n        \"search\": SearchType.Global.value.lower(),\n    })\n\n    return search_result", "label": 0}
{"function": "  def test_collapsed_callchains_generator_hide_other(self):\n    perf_stream = StringIO.StringIO(PERF_SCRIPT_OUTPUT)\n    callchains = list(ipr.collapsed_callchains_generator(perf_stream,\n                                                         hide_other=True,\n                                                         hide_compiler=True,\n                                                         hide_jit=True))\n    self.assertListEqual(callchains, [\n      [\"foo\", \"BytecodeHandler:bar\", \"[interpreter]\"],\n      [\"foo\", \"BytecodeHandler:bar\", \"[interpreter]\"],\n      [\"beep\", \"BytecodeHandler:bar\", \"[interpreter]\"],\n      [\"Lost\", \"[misattributed]\"],\n      [\"[entry trampoline]\"],\n    ])", "label": 1}
{"function": "    def test_setitem_with_dict_value_with_separator_in_keys(self):\n        d = {\n            'a': {\n                'b': {\n                    'c': 1,\n                    'd': 2,\n                },\n            },\n        }\n        b = KeypathDict(d)\n        v = {\n            'i.j.k': 3,\n            'x.y.z': 4,\n        }\n        # print(b['a.b.e.x.y.z'])\n        # print(b.keypaths())\n        with self.assertRaises(ValueError):\n            b['a.b.e'] = v", "label": 1}
{"function": "def test_latex_ocr(recognition_predictor):\n    img = Image.new(\"RGB\", (200, 100), color=\"white\")\n    draw = ImageDraw.Draw(img)\n    draw.text((10, 10), \"E = mc2\", fill=\"black\", font_size=48)\n\n    results: List[OCRResult] = recognition_predictor(\n        [img], [TaskNames.block_without_boxes], bboxes=[[[0, 0, 200, 100]]]\n    )\n    text = results[0].text_lines[0].text\n    assert len(results) == 1\n\n    assert text.startswith(\"<math\")\n    assert text.endswith(\"</math>\")", "label": 0}
{"function": "    def add_metapartition(\n        self, metapartition, metadata_merger=None, schema_validation=True\n    ):\n        \"\"\"\n        Adds a metapartition to the internal list structure to enable batch processing.\n\n        The top level `dataset_metadata` dictionary is combined with the existing dict and\n        all other attributes are stored in the `metapartitions` list\n\n        Parameters\n        ----------\n        metapartition: [MetaPartition]\n            The MetaPartition to be added.\n        metadata_merger: [callable]\n            A callable to perform the metadata merge. By default [kartothek.io_components.utils.combine_metadata] is used\n        schema_validation : [bool]\n            If True (default), ensure that the `table_meta` of both `MetaPartition` objects are the same\n        \"\"\"\n        if self.is_sentinel:\n            return metapartition\n\n        table_meta = metapartition.table_meta\n        existing_label = [mp_[\"label\"] for mp_ in self.metapartitions]\n\n        if any(\n            [mp_[\"label\"] in existing_label for mp_ in metapartition.metapartitions]\n        ):\n            raise RuntimeError(\n                \"Duplicate labels for nested metapartitions are not allowed!\"\n            )\n\n        if schema_validation:\n            table_meta = {}\n            for table, meta in self.table_meta.items():\n                other = metapartition.table_meta.get(table, None)\n                # This ensures that only schema-compatible metapartitions can be nested\n                # The returned schema by validate_compatible is the reference schema with the most\n                # information, i.e. the fewest null columns\n                table_meta[table] = validate_compatible([meta, other])\n\n        metadata_merger = metadata_merger or combine_metadata\n        new_dataset_metadata = metadata_merger(\n            [self.dataset_metadata, metapartition.dataset_metadata]\n        )\n\n        new_object = MetaPartition(\n            label=\"NestedMetaPartition\",\n            dataset_metadata=new_dataset_metadata,\n            metadata_version=metapartition.metadata_version,\n            table_meta=table_meta,\n            partition_keys=metapartition.partition_keys or None,\n            logical_conjunction=metapartition.logical_conjunction or None,\n        )\n\n        # Add metapartition information to the new object\n        new_metapartitions = self.metapartitions.copy()\n        new_metapartitions.extend(metapartition.metapartitions.copy())\n        new_object.metapartitions = new_metapartitions\n\n        return new_object", "label": 1}
{"function": "    def __init__(self, name, initializer):\n        \"\"\"\n        Note:  we store the tool name as __name__ so it can be used by\n        the class that attaches this to a construction environment.\n        \"\"\"\n        self.__name__ = name\n        self.initializer = initializer", "label": 1}
{"function": "    def __imatmul__(self, other):\n        return self.__matmul__(other)", "label": 1}
{"function": "def sample_query() -> IngestionQuery:\n    \"\"\"Provide a default ``IngestionQuery`` object for use in tests.\n\n    This fixture returns a ``IngestionQuery`` pre-populated with typical fields and some default ignore patterns.\n\n    Returns\n    -------\n    IngestionQuery\n        The sample ``IngestionQuery`` object.\n\n    \"\"\"\n    return IngestionQuery(\n        user_name=\"test_user\",\n        repo_name=\"test_repo\",\n        local_path=Path(\"/tmp/test_repo\").resolve(),\n        slug=\"test_user/test_repo\",\n        id=\"id\",\n        branch=\"main\",\n        max_file_size=1_000_000,\n        ignore_patterns={\"*.pyc\", \"__pycache__\", \".git\"},\n    )", "label": 0}
{"function": "def build():\n    # Clean screen\n    os.system(\"cls\" if platform.system().lower() == \"windows\" else \"clear\")\n    \n    # Display logo\n    print_logo()\n    \n    # Clean PyInstaller cache\n    print(\"\\033[93m\ud83e\uddf9 Cleaning build cache...\\033[0m\")\n    if os.path.exists('build'):\n        shutil.rmtree('build')\n    \n    # Reload environment variables to ensure getting the latest version\n    load_dotenv(override=True)\n    version = os.getenv('VERSION', '1.0.0')\n    print(f\"\\033[93m\ud83d\udce6 Building version: v{version}\\033[0m\")\n\n    try:\n        simulate_progress(\"Preparing build environment...\", 0.5)\n        \n        loading = LoadingAnimation()\n        loading.start(\"Building in progress\")\n        \n        # Set output name based on system type\n        system = platform.system().lower()\n        if system == \"windows\":\n            os_type = \"windows\"\n            ext = \".exe\"\n        elif system == \"linux\":\n            os_type = \"linux\"\n            ext = \"\"\n        else:  # Darwin\n            os_type = \"mac\"\n            ext = \"\"\n            \n        output_name = f\"CursorFreeVIP_{version}_{os_type}\"\n        \n        # Build command\n        build_command = f'pyinstaller --clean --noconfirm build.spec'\n        output_path = os.path.join('dist', f'{output_name}{ext}')\n        \n        os.system(build_command)\n        \n        loading.stop()\n\n        if os.path.exists(output_path):\n            print(f\"\\n\\033[92m\u2705 Build completed!\")\n            print(f\"\ud83d\udce6 Executable file located: {output_path}\\033[0m\")\n        else:\n            print(\"\\n\\033[91m\u274c Build failed: Output file not found\\033[0m\")\n            return False\n\n    except Exception as e:\n        if loading:\n            loading.stop()\n        print(f\"\\n\\033[91m\u274c Build process error: {str(e)}\\033[0m\")\n        return False\n\n    return True", "label": 0}
{"function": "    def create_table(self, name, *columns, **kw):\n        \"\"\"Issue a \"create table\" instruction using the current migration context.\n\n        This directive receives an argument list similar to that of the\n        traditional :class:`sqlalchemy.schema.Table` construct, but without the\n        metadata::\n\n            from sqlalchemy import INTEGER, VARCHAR, NVARCHAR, Column\n            from alembic import op\n\n            op.create_table(\n                'account',\n                Column('id', INTEGER, primary_key=True),\n                Column('name', VARCHAR(50), nullable=False),\n                Column('description', NVARCHAR(200))\n                Column('timestamp', TIMESTAMP, server_default=func.now())\n            )\n\n        Note that :meth:`.create_table` accepts :class:`~sqlalchemy.schema.Column`\n        constructs directly from the SQLAlchemy library.  In particular,\n        default values to be created on the database side are\n        specified using the ``server_default`` parameter, and not\n        ``default`` which only specifies Python-side defaults::\n\n            from alembic import op\n            from sqlalchemy import Column, TIMESTAMP, func\n\n            # specify \"DEFAULT NOW\" along with the \"timestamp\" column\n            op.create_table('account',\n                Column('id', INTEGER, primary_key=True),\n                Column('timestamp', TIMESTAMP, server_default=func.now())\n            )\n\n        :param name: Name of the table\n        :param \\*columns: collection of :class:`~sqlalchemy.schema.Column`\n         objects within\n         the table, as well as optional :class:`~sqlalchemy.schema.Constraint`\n         objects\n         and :class:`~.sqlalchemy.schema.Index` objects.\n        :param schema: Optional schema name to operate within.\n        :param \\**kw: Other keyword arguments are passed to the underlying\n         :class:`sqlalchemy.schema.Table` object created for the command.\n\n        \"\"\"\n        self.impl.create_table(\n            self._table(name, *columns, **kw)\n        )", "label": 1}
{"function": "def open_task_folder(task_id):\n    try:\n        sys = platform.system()\n        path = os.path.join(root_dir, \"storage\", \"tasks\", task_id)\n        if os.path.exists(path):\n            if sys == \"Windows\":\n                os.system(f\"start {path}\")\n            if sys == \"Darwin\":\n                os.system(f\"open {path}\")\n    except Exception as e:\n        logger.error(e)", "label": 0}
{"function": "    def parent(ind):\n        # Calculate parent position for given index\n        return ind//2", "label": 1}
{"function": "def download_model_if_doesnt_exist(model_name):\n    \"\"\"If pretrained kitti model doesn't exist, download and unzip it\n    \"\"\"\n    # values are tuples of (<google cloud URL>, <md5 checksum>)\n    download_paths = {\n        \"mono_640x192\":\n            (\"https://storage.googleapis.com/niantic-lon-static/research/monodepth2/mono_640x192.zip\",\n             \"a964b8356e08a02d009609d9e3928f7c\"),\n        \"stereo_640x192\":\n            (\"https://storage.googleapis.com/niantic-lon-static/research/monodepth2/stereo_640x192.zip\",\n             \"3dfb76bcff0786e4ec07ac00f658dd07\"),\n        \"mono+stereo_640x192\":\n            (\"https://storage.googleapis.com/niantic-lon-static/research/monodepth2/mono%2Bstereo_640x192.zip\",\n             \"c024d69012485ed05d7eaa9617a96b81\"),\n        \"mono_no_pt_640x192\":\n            (\"https://storage.googleapis.com/niantic-lon-static/research/monodepth2/mono_no_pt_640x192.zip\",\n             \"9c2f071e35027c895a4728358ffc913a\"),\n        \"stereo_no_pt_640x192\":\n            (\"https://storage.googleapis.com/niantic-lon-static/research/monodepth2/stereo_no_pt_640x192.zip\",\n             \"41ec2de112905f85541ac33a854742d1\"),\n        \"mono+stereo_no_pt_640x192\":\n            (\"https://storage.googleapis.com/niantic-lon-static/research/monodepth2/mono%2Bstereo_no_pt_640x192.zip\",\n             \"46c3b824f541d143a45c37df65fbab0a\"),\n        \"mono_1024x320\":\n            (\"https://storage.googleapis.com/niantic-lon-static/research/monodepth2/mono_1024x320.zip\",\n             \"0ab0766efdfeea89a0d9ea8ba90e1e63\"),\n        \"stereo_1024x320\":\n            (\"https://storage.googleapis.com/niantic-lon-static/research/monodepth2/stereo_1024x320.zip\",\n             \"afc2f2126d70cf3fdf26b550898b501a\"),\n        \"mono+stereo_1024x320\":\n            (\"https://storage.googleapis.com/niantic-lon-static/research/monodepth2/mono%2Bstereo_1024x320.zip\",\n             \"cdc5fc9b23513c07d5b19235d9ef08f7\"),\n        }\n\n    if not os.path.exists(\"models\"):\n        os.makedirs(\"models\")\n\n    model_path = os.path.join(\"models\", model_name)\n\n    def check_file_matches_md5(checksum, fpath):\n        if not os.path.exists(fpath):\n            return False\n        with open(fpath, 'rb') as f:\n            current_md5checksum = hashlib.md5(f.read()).hexdigest()\n        return current_md5checksum == checksum\n\n    # see if we have the model already downloaded...\n    if not os.path.exists(os.path.join(model_path, \"encoder.pth\")):\n\n        model_url, required_md5checksum = download_paths[model_name]\n\n        if not check_file_matches_md5(required_md5checksum, model_path + \".zip\"):\n            print(\"-> Downloading pretrained model to {}\".format(model_path + \".zip\"))\n            urllib.request.urlretrieve(model_url, model_path + \".zip\")\n\n        if not check_file_matches_md5(required_md5checksum, model_path + \".zip\"):\n            print(\"   Failed to download a file which matches the checksum - quitting\")\n            quit()\n\n        print(\"   Unzipping model...\")\n        with zipfile.ZipFile(model_path + \".zip\", 'r') as f:\n            f.extractall(model_path)\n\n        print(\"   Model unzipped to {}\".format(model_path))", "label": 1}
{"function": "def GPU(gpu_objects=None, manual_load=False, **kwargs):\n    gpu_objects = gpu_objects or []\n\n    if not isinstance(gpu_objects, (list, tuple)):\n        gpu_objects = [gpu_objects]\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            print(\"Entering Forge Space GPU ...\")\n            memory_management.unload_all_models()\n            if not manual_load:\n                for o in gpu_objects:\n                    o.gpu()\n            result = func(*args, **kwargs)\n            print(\"Cleaning Forge Space GPU ...\")\n            unload_module()\n            for o in gpu_objects:\n                o.to(device=torch.device('cpu'))\n            memory_management.soft_empty_cache()\n            return result\n        return wrapper\n    return decorator", "label": 0}
{"function": "def setup_qdrant() -> Tuple[QdrantClient, TextEmbedding]:\n    \"\"\"Initialize Qdrant client and embedding model.\"\"\"\n    if not all([st.session_state.qdrant_url, st.session_state.qdrant_api_key]):\n        raise ValueError(\"Qdrant credentials not provided\")\n    \n    client = QdrantClient(\n        url=st.session_state.qdrant_url,\n        api_key=st.session_state.qdrant_api_key\n    )\n    \n    embedding_model = TextEmbedding()\n    test_embedding = list(embedding_model.embed([\"test\"]))[0]\n    embedding_dim = len(test_embedding)\n    \n    try:\n        client.create_collection(\n            collection_name=COLLECTION_NAME,\n            vectors_config=VectorParams(\n                size=embedding_dim,\n                distance=Distance.COSINE\n            )\n        )\n    except Exception as e:\n        if \"already exists\" not in str(e):\n            raise e\n    \n    return client, embedding_model", "label": 0}
{"function": "    def pstate(self):\n        return self.value.pstate", "label": 1}
{"function": "    def test_atomic_min_double(self):\n        self.check_atomic_min(dtype=np.float64, lo=-65535, hi=65535)", "label": 1}
{"function": "def SimpleDistance(length=1.0, center=True):\n    newpoints = []\n\n    if center:\n        newpoints.append([-length / 2, 0.0, 0.0])\n        newpoints.append([length / 2, 0.0, 0.0])\n    else:\n        newpoints.append([0.0, 0.0, 0.0])\n        newpoints.append([length, 0.0, 0.0])\n\n    return newpoints", "label": 1}
{"function": "def test_tool_calling_agents_raises_tool_call_error_being_invoked_with_wrong_arguments(arguments):\n    @tool\n    def _sample_tool(prompt: str) -> str:\n        \"\"\"Tool that returns same string\n        Args:\n            prompt: The string to return\n        Returns:\n            The same string\n        \"\"\"\n\n        return prompt\n\n    agent = ToolCallingAgent(model=FakeToolCallModel(), tools=[_sample_tool])\n    with pytest.raises(AgentToolCallError):\n        agent.execute_tool_call(_sample_tool.name, arguments)", "label": 0}
{"function": "    def register_exit(self, callback):\n        return self.push(callback)", "label": 1}
{"function": "    def test_best_model2_alignment_does_not_change_pegged_alignment(self):\n        # arrange\n        sentence_pair = AlignedSent(\n            TestIBMModel.__TEST_TRG_SENTENCE, TestIBMModel.__TEST_SRC_SENTENCE\n        )\n        translation_table = {\n            'i': {\"j'\": 0.9, 'aime': 0.05, 'bien': 0.02, 'jambon': 0.03, None: 0},\n            'love': {\"j'\": 0.05, 'aime': 0.9, 'bien': 0.01, 'jambon': 0.01, None: 0.03},\n            'ham': {\"j'\": 0, 'aime': 0.01, 'bien': 0, 'jambon': 0.99, None: 0},\n        }\n        alignment_table = defaultdict(\n            lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: 0.2)))\n        )\n\n        ibm_model = IBMModel([])\n        ibm_model.translation_table = translation_table\n        ibm_model.alignment_table = alignment_table\n\n        # act: force 'love' to be pegged to 'jambon'\n        a_info = ibm_model.best_model2_alignment(sentence_pair, 2, 4)\n        # assert\n        self.assertEqual(a_info.alignment[1:], (1, 4, 4))\n        self.assertEqual(a_info.cepts, [[], [1], [], [], [2, 3]])", "label": 1}
{"function": "\t\tdef domain_filter_action():\n\t\t\tpass", "label": 0}
{"function": "    def validate_config(cls, config_yaml_path: Path) -> dict:\n        \"\"\"Validate the main configuration YAML file.\"\"\"\n        parameters = cls.load_yaml(config_yaml_path)\n        # Check for required keys and their types\n        for key, expected_type in cls.REQUIRED_CONFIG_KEYS.items():\n            if key not in parameters:\n                if key in [\"company_blacklist\", \"title_blacklist\", \"location_blacklist\"]:\n                    parameters[key] = []\n                else:\n                    raise ConfigError(f\"Missing required key '{key}' in {config_yaml_path}\")\n            elif not isinstance(parameters[key], expected_type):\n                if key in [\"company_blacklist\", \"title_blacklist\", \"location_blacklist\"] and parameters[key] is None:\n                    parameters[key] = []\n                else:\n                    raise ConfigError(\n                        f\"Invalid type for key '{key}' in {config_yaml_path}. Expected {expected_type.__name__}.\"\n                    )\n        cls._validate_experience_levels(parameters[\"experience_level\"], config_yaml_path)\n        cls._validate_job_types(parameters[\"job_types\"], config_yaml_path)\n        cls._validate_date_filters(parameters[\"date\"], config_yaml_path)\n        cls._validate_list_of_strings(parameters, [\"positions\", \"locations\"], config_yaml_path)\n        cls._validate_distance(parameters[\"distance\"], config_yaml_path)\n        cls._validate_blacklists(parameters, config_yaml_path)\n        return parameters", "label": 0}
{"function": "    def plot_exposure_vs_energy(self):\n        \"\"\"Plot exposure versus energy.\"\"\"\n        import matplotlib.pyplot as plt\n\n        plt.figure(figsize=(4, 3))\n        plt.plot(self.energy, self.exposure, color=\"black\", lw=3)\n        plt.semilogx()\n        plt.xlabel(\"Energy (MeV)\")\n        plt.ylabel(\"Exposure (cm^2 s)\")\n        plt.xlim(1e4 / 1.3, 1.3 * 1e6)\n        plt.ylim(0, 1.5e11)\n        plt.tight_layout()", "label": 1}
{"function": "def main(\n    ckpt_path: str,\n    config: str,\n    input_file: str = \"\",\n    interactive: bool = True,\n    max_new_tokens: int = 100,\n    temperature: float = 1.0,\n) -> None:\n    \"\"\"\n    Main function to load the model and perform interactive or batch text generation.\n\n    Args:\n        ckpt_path (str): Path to the model checkpoint directory.\n        config (str): Path to the model configuration file.\n        input_file (str, optional): Path to a file containing input prompts. Defaults to \"\".\n        interactive (bool, optional): Whether to run in interactive mode. Defaults to True.\n        max_new_tokens (int, optional): Maximum number of new tokens to generate. Defaults to 100.\n        temperature (float, optional): Temperature for sampling. Defaults to 1.0.\n    \"\"\"\n    world_size = int(os.getenv(\"WORLD_SIZE\", \"1\"))\n    rank = int(os.getenv(\"RANK\", \"0\"))\n    local_rank = int(os.getenv(\"LOCAL_RANK\", \"0\"))\n    if world_size > 1:\n        dist.init_process_group(\"nccl\")\n    global print\n    if rank != 0:\n        print = lambda *_, **__: None\n    torch.cuda.set_device(local_rank)\n    torch.set_default_dtype(torch.bfloat16)\n    torch.set_num_threads(8)\n    torch.manual_seed(965)\n    with open(config) as f:\n        args = ModelArgs(**json.load(f))\n    print(args)\n    with torch.device(\"cuda\"):\n        model = Transformer(args)\n    tokenizer = AutoTokenizer.from_pretrained(ckpt_path)\n    tokenizer.decode(generate(model, [tokenizer.encode(\"DeepSeek\")], 2, -1, 1.)[0])\n    load_model(model, os.path.join(ckpt_path, f\"model{rank}-mp{world_size}.safetensors\"))\n\n    if interactive:\n        messages = []\n        while True:\n            if world_size == 1:\n                prompt = input(\">>> \")\n            elif rank == 0:\n                prompt = input(\">>> \")\n                objects = [prompt]\n                dist.broadcast_object_list(objects, 0)\n            else:\n                objects = [None]\n                dist.broadcast_object_list(objects, 0)\n                prompt = objects[0]\n            if prompt == \"/exit\":\n                break\n            elif prompt == \"/clear\":\n                messages.clear()\n                continue\n            messages.append({\"role\": \"user\", \"content\": prompt})\n            prompt_tokens = tokenizer.apply_chat_template(messages, add_generation_prompt=True)\n            completion_tokens = generate(model, [prompt_tokens], max_new_tokens, tokenizer.eos_token_id, temperature)\n            completion = tokenizer.decode(completion_tokens[0], skip_special_tokens=True)\n            print(completion)\n            messages.append({\"role\": \"assistant\", \"content\": completion})\n    else:\n        with open(input_file) as f:\n            prompts = [line.strip() for line in f.readlines()]\n        assert len(prompts) <= args.max_batch_size, f\"Number of prompts exceeds maximum batch size ({args.max_batch_size})\"\n        prompt_tokens = [tokenizer.apply_chat_template([{\"role\": \"user\", \"content\": prompt}], add_generation_prompt=True) for prompt in prompts]\n        completion_tokens = generate(model, prompt_tokens, max_new_tokens, tokenizer.eos_token_id, temperature)\n        completions = tokenizer.batch_decode(completion_tokens, skip_special_tokens=True)\n        for prompt, completion in zip(prompts, completions):\n            print(\"Prompt:\", prompt)\n            print(\"Completion:\", completion)\n            print()\n\n    if world_size > 1:\n        dist.destroy_process_group()", "label": 0}
{"function": "\t\t\tdef __repr__(self):\n\t\t\t\treturn str(self)", "label": 1}
{"function": "    def __enter__(self):\n        return self", "label": 1}
{"function": "    async def run_default(self) -> None:\n        \"\"\"Run the agent in default mode.\"\"\"\n        prompt = input(\"Enter your prompt: \")\n        if not prompt.strip():\n            logger.warning(\"Empty prompt provided.\")\n            return\n\n        logger.warning(\"Processing your request...\")\n        await self.agent.run(prompt)\n        logger.info(\"Request processing completed.\")", "label": 0}
{"function": "def patch_multi_step_agent_with_suppressed_logging():\n    with patch.object(MultiStepAgent, \"__init__\", autospec=True) as mock_init:\n\n        def init_with_suppressed_logging(self, *args, verbosity_level=LogLevel.OFF, **kwargs):\n            original_multi_step_agent_init(self, *args, verbosity_level=verbosity_level, **kwargs)\n\n        mock_init.side_effect = init_with_suppressed_logging\n        yield", "label": 0}
{"function": "def generate(\n    mmgpt: MultiModalityCausalLM,\n    vl_chat_processor: VLChatProcessor,\n    prompt: str,\n    temperature: float = 1,\n    parallel_size: int = 16,\n    cfg_weight: float = 5,\n    image_token_num_per_image: int = 576,\n    img_size: int = 384,\n    patch_size: int = 16,\n):\n    input_ids = vl_chat_processor.tokenizer.encode(prompt)\n    input_ids = torch.LongTensor(input_ids)\n\n    tokens = torch.zeros((parallel_size*2, len(input_ids)), dtype=torch.int).cuda()\n    for i in range(parallel_size*2):\n        tokens[i, :] = input_ids\n        if i % 2 != 0:\n            tokens[i, 1:-1] = vl_chat_processor.pad_id\n\n    inputs_embeds = mmgpt.language_model.get_input_embeddings()(tokens)\n\n    generated_tokens = torch.zeros((parallel_size, image_token_num_per_image), dtype=torch.int).cuda()\n\n    for i in range(image_token_num_per_image):\n        outputs = mmgpt.language_model.model(inputs_embeds=inputs_embeds, use_cache=True, past_key_values=outputs.past_key_values if i != 0 else None)\n        hidden_states = outputs.last_hidden_state\n        \n        logits = mmgpt.gen_head(hidden_states[:, -1, :])\n        logit_cond = logits[0::2, :]\n        logit_uncond = logits[1::2, :]\n        \n        logits = logit_uncond + cfg_weight * (logit_cond-logit_uncond)\n        probs = torch.softmax(logits / temperature, dim=-1)\n\n        next_token = torch.multinomial(probs, num_samples=1)\n        generated_tokens[:, i] = next_token.squeeze(dim=-1)\n\n        next_token = torch.cat([next_token.unsqueeze(dim=1), next_token.unsqueeze(dim=1)], dim=1).view(-1)\n        img_embeds = mmgpt.prepare_gen_img_embeds(next_token)\n        inputs_embeds = img_embeds.unsqueeze(dim=1)\n\n\n    dec = mmgpt.gen_vision_model.decode_code(generated_tokens.to(dtype=torch.int), shape=[parallel_size, 8, img_size//patch_size, img_size//patch_size])\n    dec = dec.to(torch.float32).cpu().numpy().transpose(0, 2, 3, 1)\n\n    dec = np.clip((dec + 1) / 2 * 255, 0, 255)\n\n    visual_img = np.zeros((parallel_size, img_size, img_size, 3), dtype=np.uint8)\n    visual_img[:, :, :] = dec\n\n    os.makedirs('generated_samples', exist_ok=True)\n    for i in range(parallel_size):\n        save_path = os.path.join('generated_samples', \"img_{}.jpg\".format(i))\n        PIL.Image.fromarray(visual_img[i]).save(save_path)", "label": 0}
{"function": "def run_common_tests(error_text=\"Please, reload file and try again\"):\n    test_is_initial_text()\n    test_is_not_empty()\n    test_answer_placeholders_text_deleted()\n    test_file_importable()", "label": 1}
{"function": "    def train(self, trainer):\n        \"\"\"Obtain samples, train, and evaluate for each epoch.\n\n        Args:\n            trainer (Trainer): Gives the algorithm the access to\n                :method:`Trainer..step_epochs()`, which provides services\n                such as snapshotting and sampler control.\n\n        \"\"\"\n        for _ in trainer.step_epochs():\n            epoch = trainer.step_itr / self._num_steps_per_epoch\n\n            # obtain initial set of samples from all train tasks\n            if epoch == 0 or self._is_resuming:\n                for idx in range(self._num_train_tasks):\n                    self._task_idx = idx\n                    self._obtain_samples(trainer, epoch,\n                                         self._num_initial_steps, np.inf)\n                    self._is_resuming = False\n\n            # obtain samples from random tasks\n            for _ in range(self._num_tasks_sample):\n                idx = np.random.randint(self._num_train_tasks)\n                self._task_idx = idx\n                self._context_replay_buffers[idx].clear()\n                # obtain samples with z ~ prior\n                if self._num_steps_prior > 0:\n                    self._obtain_samples(trainer, epoch, self._num_steps_prior,\n                                         np.inf)\n                # obtain samples with z ~ posterior\n                if self._num_steps_posterior > 0:\n                    self._obtain_samples(trainer, epoch,\n                                         self._num_steps_posterior,\n                                         self._update_post_train)\n                # obtain extras samples for RL training but not encoder\n                if self._num_extra_rl_steps_posterior > 0:\n                    self._obtain_samples(trainer,\n                                         epoch,\n                                         self._num_extra_rl_steps_posterior,\n                                         self._update_post_train,\n                                         add_to_enc_buffer=False)\n\n            logger.log('Training...')\n            # sample train tasks and optimize networks\n            self._train_once()\n            trainer.step_itr += 1\n\n            logger.log('Evaluating...')\n            # evaluate\n            self._policy.reset_belief()\n            self._evaluator.evaluate(self)", "label": 1}
{"function": "    def add_child(self, child_node_name: str, duplicate_handling: str = \"skip\"):\n        \"\"\"\n        Adds a child node to the current node.\n        duplicate_handling (str): How to handle duplicate nodes. Options are \"skip\", \"none\", and \"raise error\".\n        \"\"\"\n        if self.has_child(child_node_name):\n            if duplicate_handling == \"skip\":\n                for child in self.children:\n                    if child.name == child_node_name:\n                        return child\n            elif duplicate_handling == \"raise error\":\n                raise Exception(\n                    f\"Insert node error. Node {child_node_name} already exists under its parent node {self.name}.\"\n                )\n        child_node = KnowledgeNode(name=child_node_name, parent=self)\n        self.children.append(child_node)\n        return child_node", "label": 0}
{"function": "    def __reduce__(self):\n        return (\n            _reconstruct_header,\n            (\n                self.__class__.__name__,\n                self.__class__.__bases__,\n                str(self),\n            ),\n            self.__dict__)", "label": 1}
{"function": "    def setUp(self):\n\n        model = gtsam.noiseModel.Isotropic.Sigma(6, 0.1)\n\n        # We consider a small graph:\n        #                            symbolic FG\n        #               x2               0  1\n        #             / | \\              1  2\n        #            /  |  \\             2  3\n        #          x3   |   x1           2  0\n        #           \\   |   /            0  3\n        #            \\  |  /\n        #               x0\n        #\n        p0 = Point3(0, 0, 0)\n        self.R0 = Rot3.Expmap(np.array([0.0, 0.0, 0.0]))\n        p1 = Point3(1, 2, 0)\n        self.R1 = Rot3.Expmap(np.array([0.0, 0.0, 1.570796]))\n        p2 = Point3(0, 2, 0)\n        self.R2 = Rot3.Expmap(np.array([0.0, 0.0, 3.141593]))\n        p3 = Point3(-1, 1, 0)\n        self.R3 = Rot3.Expmap(np.array([0.0, 0.0, 4.712389]))\n\n        pose0 = Pose3(self.R0, p0)\n        pose1 = Pose3(self.R1, p1)\n        pose2 = Pose3(self.R2, p2)\n        pose3 = Pose3(self.R3, p3)\n\n        g = NonlinearFactorGraph()\n        g.add(gtsam.BetweenFactorPose3(x0, x1, pose0.between(pose1), model))\n        g.add(gtsam.BetweenFactorPose3(x1, x2, pose1.between(pose2), model))\n        g.add(gtsam.BetweenFactorPose3(x2, x3, pose2.between(pose3), model))\n        g.add(gtsam.BetweenFactorPose3(x2, x0, pose2.between(pose0), model))\n        g.add(gtsam.BetweenFactorPose3(x0, x3, pose0.between(pose3), model))\n        g.add(gtsam.PriorFactorPose3(x0, pose0, model))\n        self.graph = g", "label": 1}
{"function": "def get_version():\n    command = [\"git\", \"describe\", \"--tags\"]\n    try:\n        version = subprocess.check_output(command).decode().strip()\n        version_parts = version.split(\"-\")\n        if len(version_parts) > 1 and version_parts[0].startswith(\"mineru\"):\n            return version_parts[1]\n        else:\n            raise ValueError(f\"Invalid version tag {version}. Expected format is mineru-<version>-released.\")\n    except Exception as e:\n        print(e)\n        return \"0.0.0\"", "label": 0}
{"function": "    def __init__(self, memcached_conn, *, cookie_name=\"AIOHTTP_SESSION\",\n                 domain=None, max_age=None, path='/',\n                 secure=None, httponly=True,\n                 key_factory=lambda: uuid.uuid4().hex,\n                 encoder=json.dumps, decoder=json.loads):\n        super().__init__(cookie_name=cookie_name, domain=domain,\n                         max_age=max_age, path=path, secure=secure,\n                         httponly=httponly,\n                         encoder=encoder, decoder=decoder)\n        self._key_factory = key_factory\n        self.conn = memcached_conn", "label": 1}
{"function": "def _init_logging(rank):\n    # logging\n    if rank == 0:\n        # set format\n        logging.basicConfig(\n            level=logging.INFO,\n            format=\"[%(asctime)s] %(levelname)s: %(message)s\",\n            handlers=[logging.StreamHandler(stream=sys.stdout)])\n    else:\n        logging.basicConfig(level=logging.ERROR)", "label": 0}
{"function": "async def test_browser_close_doesnt_affect_external_httpx_clients():\n\t\"\"\"\n\tTest that Browser.close() doesn't close HTTPX clients created outside the Browser instance.\n\tThis test demonstrates the issue where Browser.close() is closing all HTTPX clients.\n\t\"\"\"\n\t# Create an external HTTPX client that should remain open\n\texternal_client = httpx.AsyncClient()\n\n\t# Create a BrowserSession instance\n\tbrowser_session = BrowserSession(browser_profile=BrowserProfile(headless=True))\n\tawait browser_session.start()\n\n\t# Close the browser (which should trigger cleanup_httpx_clients)\n\tawait browser_session.stop()\n\n\t# Check if the external client is still usable\n\ttry:\n\t\t# If the client is closed, this will raise RuntimeError\n\t\t# Using a simple HEAD request to a reliable URL\n\t\tawait external_client.head('https://www.example.com', timeout=2.0)\n\t\tclient_is_closed = False\n\texcept RuntimeError as e:\n\t\t# If we get \"Cannot send a request, as the client has been closed\"\n\t\tclient_is_closed = 'client has been closed' in str(e)\n\texcept Exception:\n\t\t# Any other exception means the client is not closed but request failed\n\t\tclient_is_closed = False\n\tfinally:\n\t\t# Always clean up our test client properly\n\t\tawait external_client.aclose()\n\n\t# Our external client should not be closed by browser.close()\n\tassert not client_is_closed, 'External HTTPX client was incorrectly closed by Browser.close()'", "label": 0}
{"function": "    def testMethods(self):\n        self.assertArgIsBOOL(PDFSelection.drawForPage_withBox_active_, 2)", "label": 1}
{"function": "    def should_continue_news(self, state: AgentState):\n        \"\"\"Determine if news analysis should continue.\"\"\"\n        messages = state[\"messages\"]\n        last_message = messages[-1]\n        if last_message.tool_calls:\n            return \"tools_news\"\n        return \"Msg Clear News\"", "label": 0}
{"function": "def _match(qs, ks):\n    \"\"\"Return True if regexes in qs match any window of strings in tuple ks.\"\"\"\n    # compile regexes and force complete match\n    qts = tuple(map(lambda x: re.compile(x + \"$\"), qs))\n    for i in range(len(ks) - len(qs) + 1):\n        matches = [x.match(y) for x, y in zip(qts, ks[i:])]\n        if matches and all(matches):\n            return True\n    return False", "label": 0}
{"function": "        def make_token():\n            tk = buf[0]\n            tk.text = sep.join([t.text for t in buf])\n            if tk.chars:\n                tk.endchar = buf[-1].endchar\n            return tk", "label": 1}
{"function": "def pre_build():\n  update_pkgver_and_pkgrel(_G.newver.lstrip('v'))", "label": 1}
{"function": "\tdef validate(self):\n\t\tsanctioned_doc = frappe.db.exists('Sanctioned Loan Amount', {'applicant': self.applicant, 'company': self.company})\n\n\t\tif sanctioned_doc and sanctioned_doc != self.name:\n\t\t\tfrappe.throw(_(\"Sanctioned Loan Amount already exists for {0} against company {1}\").format(\n\t\t\t\tfrappe.bold(self.applicant), frappe.bold(self.company)\n\t\t\t))", "label": 1}
{"function": "\tdef tearDown(self):\n\t\tsuper(FailmanagerComplex, self).tearDown()\n\t\t# restore level\n\t\tfailmanager.logLevel = self.__saved_ll", "label": 1}
{"function": "    def __init__(self):\n        self.primary_to_aliases: dict[str, set[str]] = {}\n        self.alias_to_primary: dict[str, str] = {}\n\n        real_path = get_real_path(resource_path(constants.alias_path))\n        if os.path.exists(real_path):\n            with open(real_path, \"r\", encoding=\"utf-8\") as f:\n                for line in f:\n                    if line.strip() and not line.startswith(\"#\") and \",\" in line:\n                        parts = [p.strip() for p in line.split(\",\")]\n                        primary = parts[0]\n                        aliases = set(parts[1:])\n                        aliases.add(format_name(primary))\n                        self.primary_to_aliases[primary] = aliases\n                        for alias in aliases:\n                            self.alias_to_primary[alias] = primary\n                        self.alias_to_primary[primary] = primary", "label": 0}
{"function": "  def _define_vars(self, params):\n    pass", "label": 1}
{"function": "        def update_img2img(do_img2img):\n            return {\n                init_image: gr.update(visible=do_img2img),\n                image2image_strength: gr.update(visible=do_img2img),\n            }", "label": 0}
{"function": "    def test_string_rpartition(self):\n        with self.assertRaises(NotImplementedError):\n            self.check_func(lambda x: x.str.rpartition())", "label": 1}
{"function": "def test_basic_crawl_sync(tester: Crawl4AiTester):\n    print(\"\\n=== Testing Basic Crawl (Sync) ===\")\n    request = {\n        \"urls\": [\"https://www.nbcnews.com/business\"],\n        \"priority\": 10,\n        \"session_id\": \"test\",\n    }\n\n    result = tester.submit_sync(request)\n    print(f\"Basic crawl result length: {len(result['result']['markdown'])}\")\n    assert result[\"status\"] == \"completed\"\n    assert result[\"result\"][\"success\"]\n    assert len(result[\"result\"][\"markdown\"]) > 0", "label": 0}
{"function": "    def _optimize_policy(self, indices):\n        \"\"\"Perform algorithm optimizing.\n\n        Args:\n            indices (list): Tasks used for training.\n\n        \"\"\"\n        num_tasks = len(indices)\n        context = self._sample_context(indices)\n        # clear context and reset belief of policy\n        self._policy.reset_belief(num_tasks=num_tasks)\n\n        # data shape is (task, batch, feat)\n        obs, actions, rewards, next_obs, terms = self._sample_data(indices)\n        policy_outputs, task_z = self._policy(obs, context)\n        new_actions, policy_mean, policy_log_std, log_pi = policy_outputs[:4]\n\n        # flatten out the task dimension\n        t, b, _ = obs.size()\n        obs = obs.view(t * b, -1)\n        actions = actions.view(t * b, -1)\n        next_obs = next_obs.view(t * b, -1)\n\n        # optimize qf and encoder networks\n        q1_pred = self._qf1(torch.cat([obs, actions], dim=1), task_z)\n        q2_pred = self._qf2(torch.cat([obs, actions], dim=1), task_z)\n        v_pred = self._vf(obs, task_z.detach())\n\n        with torch.no_grad():\n            target_v_values = self.target_vf(next_obs, task_z)\n\n        # KL constraint on z if probabilistic\n        self.context_optimizer.zero_grad()\n        if self._use_information_bottleneck:\n            kl_div = self._policy.compute_kl_div()\n            kl_loss = self._kl_lambda * kl_div\n            kl_loss.backward(retain_graph=True)\n\n        self.qf1_optimizer.zero_grad()\n        self.qf2_optimizer.zero_grad()\n\n        rewards_flat = rewards.view(self._batch_size * num_tasks, -1)\n        rewards_flat = rewards_flat * self._reward_scale\n        terms_flat = terms.view(self._batch_size * num_tasks, -1)\n        q_target = rewards_flat + (\n            1. - terms_flat) * self._discount * target_v_values\n        qf_loss = torch.mean((q1_pred - q_target)**2) + torch.mean(\n            (q2_pred - q_target)**2)\n        qf_loss.backward()\n\n        self.qf1_optimizer.step()\n        self.qf2_optimizer.step()\n        self.context_optimizer.step()\n\n        # compute min Q on the new actions\n        q1 = self._qf1(torch.cat([obs, new_actions], dim=1), task_z.detach())\n        q2 = self._qf2(torch.cat([obs, new_actions], dim=1), task_z.detach())\n        min_q = torch.min(q1, q2)\n\n        # optimize vf\n        v_target = min_q - log_pi\n        vf_loss = self.vf_criterion(v_pred, v_target.detach())\n        self.vf_optimizer.zero_grad()\n        vf_loss.backward()\n        self.vf_optimizer.step()\n        self._update_target_network()\n\n        # optimize policy\n        log_policy_target = min_q\n        policy_loss = (log_pi - log_policy_target).mean()\n\n        mean_reg_loss = self._policy_mean_reg_coeff * (policy_mean**2).mean()\n        std_reg_loss = self._policy_std_reg_coeff * (policy_log_std**2).mean()\n        pre_tanh_value = policy_outputs[-1]\n        pre_activation_reg_loss = self._policy_pre_activation_coeff * (\n            (pre_tanh_value**2).sum(dim=1).mean())\n        policy_reg_loss = (mean_reg_loss + std_reg_loss +\n                           pre_activation_reg_loss)\n        policy_loss = policy_loss + policy_reg_loss\n\n        self._policy_optimizer.zero_grad()\n        policy_loss.backward()\n        self._policy_optimizer.step()", "label": 1}
{"function": "    def set_registered_model(self, *args, **kwargs):\n        \"\"\"\n        Alias for :meth:`Client.get_or_create_registered_model()`.\n\n        \"\"\"\n        return self.get_or_create_registered_model(*args, **kwargs)", "label": 1}
{"function": "def is_running_in_docker():\n    \"\"\"Detect if code is running inside a Docker container.\"\"\"\n    # Method 1: Check for .dockerenv file\n    if os.path.exists('/.dockerenv'):\n        return True\n    \n    # Method 2: Check cgroup\n    try:\n        with open('/proc/1/cgroup', 'r') as f:\n            return 'docker' in f.read()\n    except:\n        pass\n    \n    return False", "label": 0}
{"function": "def test_state_with_custom_values():\n    \"\"\"Test that State can be initialized with custom values.\"\"\"\n    test_step = Step(\n        need_search=True,\n        title=\"Test Step\",\n        description=\"Step description\",\n        step_type=StepType.RESEARCH,\n    )\n\n    test_plan = Plan(\n        locale=\"en-US\",\n        has_enough_context=False,\n        thought=\"Test thought\",\n        title=\"Test Plan\",\n        steps=[test_step],\n    )\n\n    # Initialize state with custom values and required messages field\n    state = State(\n        messages=[],\n        locale=\"fr-FR\",\n        observations=[\"Observation 1\"],\n        plan_iterations=2,\n        current_plan=test_plan,\n        final_report=\"Test report\",\n        auto_accepted_plan=True,\n        enable_background_investigation=False,\n        background_investigation_results=\"Test results\",\n    )\n\n    # Access state keys - these are explicitly initialized\n    assert state[\"locale\"] == \"fr-FR\"\n    assert state[\"observations\"] == [\"Observation 1\"]\n    assert state[\"plan_iterations\"] == 2\n    assert state[\"current_plan\"].title == \"Test Plan\"\n    assert state[\"current_plan\"].thought == \"Test thought\"\n    assert len(state[\"current_plan\"].steps) == 1\n    assert state[\"current_plan\"].steps[0].title == \"Test Step\"\n    assert state[\"final_report\"] == \"Test report\"\n    assert state[\"auto_accepted_plan\"] is True\n    assert state[\"enable_background_investigation\"] is False\n    assert state[\"background_investigation_results\"] == \"Test results\"", "label": 0}
{"function": "    def test_malformed_control(self):\n        dg = Datagram()\n        dg.add_uint16(0) # Datagram length\n        dg.add_uint8(1) # Number of recipients\n        dg.add_channel(CONTROL_CHANNEL) # Recipient\n        dg.add_channel(0) # Sender\n        dg.add_uint16(CONTROL_ADD_CHANNEL)\n        dg.add_channel(0x1CEDC0FF)\n        self.c1.s.send(dg.get_data())\n        # The MD should drop this packet completely.\n        self.expectNone(self.l1)\n        # The MD should drop the misbehaving participant.\n        self.assertRaises(EOFError, self.c1.recv_maybe())\n\n        # Cleanup\n        self.c1.close()\n        self.__class__.c1 = self.connectToServer()\n        self.l1.flush()", "label": 1}
{"function": "def build_delay_indices(B: int, T: int, C: int, delay_pattern: tp.List[int]) -> tp.Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Precompute (t_idx_BxTxC, indices_BTCx3) so that out[t, c] = in[t - delay[c], c].\n    Negative t_idx => BOS; t_idx >= T => PAD.\n    \"\"\"\n    delay_arr = torch.tensor(delay_pattern, dtype=torch.int32)\n\n    t_idx_BxT = torch.broadcast_to(\n        torch.arange(T, dtype=torch.int32)[None, :],\n        [B, T],\n    )\n    t_idx_BxTx1 = t_idx_BxT[..., None]\n    t_idx_BxTxC = t_idx_BxTx1 - delay_arr.view(1, 1, C)\n\n    b_idx_BxTxC = torch.broadcast_to(\n        torch.arange(B, dtype=torch.int32).view(B, 1, 1),\n        [B, T, C],\n    )\n    c_idx_BxTxC = torch.broadcast_to(\n        torch.arange(C, dtype=torch.int32).view(1, 1, C),\n        [B, T, C],\n    )\n\n    # We must clamp time indices to [0..T-1] so gather_nd equivalent won't fail\n    t_clamped_BxTxC = torch.clamp(t_idx_BxTxC, 0, T - 1)\n\n    indices_BTCx3 = torch.stack(\n        [\n            b_idx_BxTxC.reshape(-1),\n            t_clamped_BxTxC.reshape(-1),\n            c_idx_BxTxC.reshape(-1),\n        ],\n        dim=1,\n    ).long()  # Ensure indices are long type for indexing\n\n    return t_idx_BxTxC, indices_BTCx3", "label": 0}
{"function": "def normalizer_zh_tn() -> Callable[[str], str]:\n    from tn.chinese.normalizer import Normalizer\n\n    return Normalizer(remove_interjections=False).normalize", "label": 0}
{"function": "    def __init__(self, messagebus):\n        self._topic = messagebus.topic_scoring\n        self._group = messagebus.scoringlog_dbw_group\n        self._location = messagebus.kafka_location\n        self._codec = messagebus.codec\n        self._cert_path = messagebus.cert_path\n        self._enable_ssl = messagebus.enable_ssl", "label": 1}
{"function": "def clear_openai_settings():\n    _openai_shared._default_openai_key = None\n    _openai_shared._default_openai_client = None\n    _openai_shared._use_responses_by_default = True", "label": 0}
{"function": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--checkpoint\",\n        type=str,\n        default=\"kyutai/helium-1-preview-2b\",\n        help=\"the transformers checkpoint to import\",\n    )\n    parser.add_argument(\"--out\", type=str, help=\"the mlx safetensors file to generate\")\n    parser.add_argument(\n        \"-s\", \"--silent\", action=\"store_true\", help=\"Only prints the checkpoint name\"\n    )\n    args = parser.parse_args()\n\n    ckpt_path = Path(args.checkpoint)\n    if not ckpt_path.exists():\n        ckpt_path = hf_hub_download(\n            repo_id=args.checkpoint, filename=\"model.safetensors\"\n        )\n    out_path = Path(args.out)\n    if not out_path.exists():\n        import_model(ckpt_path, out_path, silent=args.silent)\n    print(out_path)", "label": 0}
{"function": "def run(\n        weights=ROOT / 'yolo.pt',  # weights path\n        imgsz=640,  # inference size (pixels)\n        batch_size=1,  # batch size\n        data=ROOT / 'data/coco.yaml',  # dataset.yaml path\n        device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n        half=False,  # use FP16 half-precision inference\n        test=False,  # test exports only\n        pt_only=False,  # test PyTorch only\n        hard_fail=False,  # throw error on benchmark failure\n):\n    y, t = [], time.time()\n    device = select_device(device)\n    model_type = type(attempt_load(weights, fuse=False))  # DetectionModel, SegmentationModel, etc.\n    for i, (name, f, suffix, cpu, gpu) in export.export_formats().iterrows():  # index, (name, file, suffix, CPU, GPU)\n        try:\n            assert i not in (9, 10), 'inference not supported'  # Edge TPU and TF.js are unsupported\n            assert i != 5 or platform.system() == 'Darwin', 'inference only supported on macOS>=10.13'  # CoreML\n            if 'cpu' in device.type:\n                assert cpu, 'inference not supported on CPU'\n            if 'cuda' in device.type:\n                assert gpu, 'inference not supported on GPU'\n\n            # Export\n            if f == '-':\n                w = weights  # PyTorch format\n            else:\n                w = export.run(weights=weights, imgsz=[imgsz], include=[f], device=device, half=half)[-1]  # all others\n            assert suffix in str(w), 'export failed'\n\n            # Validate\n            if model_type == SegmentationModel:\n                result = val_seg(data, w, batch_size, imgsz, plots=False, device=device, task='speed', half=half)\n                metric = result[0][7]  # (box(p, r, map50, map), mask(p, r, map50, map), *loss(box, obj, cls))\n            else:  # DetectionModel:\n                result = val_det(data, w, batch_size, imgsz, plots=False, device=device, task='speed', half=half)\n                metric = result[0][3]  # (p, r, map50, map, *loss(box, obj, cls))\n            speed = result[2][1]  # times (preprocess, inference, postprocess)\n            y.append([name, round(file_size(w), 1), round(metric, 4), round(speed, 2)])  # MB, mAP, t_inference\n        except Exception as e:\n            if hard_fail:\n                assert type(e) is AssertionError, f'Benchmark --hard-fail for {name}: {e}'\n            LOGGER.warning(f'WARNING \u26a0\ufe0f Benchmark failure for {name}: {e}')\n            y.append([name, None, None, None])  # mAP, t_inference\n        if pt_only and i == 0:\n            break  # break after PyTorch\n\n    # Print results\n    LOGGER.info('\\n')\n    parse_opt()\n    notebook_init()  # print system info\n    c = ['Format', 'Size (MB)', 'mAP50-95', 'Inference time (ms)'] if map else ['Format', 'Export', '', '']\n    py = pd.DataFrame(y, columns=c)\n    LOGGER.info(f'\\nBenchmarks complete ({time.time() - t:.2f}s)')\n    LOGGER.info(str(py if map else py.iloc[:, :2]))\n    if hard_fail and isinstance(hard_fail, str):\n        metrics = py['mAP50-95'].array  # values to compare to floor\n        floor = eval(hard_fail)  # minimum metric floor to pass\n        assert all(x > floor for x in metrics if pd.notna(x)), f'HARD FAIL: mAP50-95 < floor {floor}'\n    return py", "label": 0}
{"function": "async def test_graph_basic(storage):\n    \"\"\"\n    \u6d4b\u8bd5\u56fe\u6570\u636e\u5e93\u7684\u57fa\u672c\u64cd\u4f5c:\n    1. \u4f7f\u7528 upsert_node \u63d2\u5165\u4e24\u4e2a\u8282\u70b9\n    2. \u4f7f\u7528 upsert_edge \u63d2\u5165\u4e00\u6761\u8fde\u63a5\u4e24\u4e2a\u8282\u70b9\u7684\u8fb9\n    3. \u4f7f\u7528 get_node \u8bfb\u53d6\u4e00\u4e2a\u8282\u70b9\n    4. \u4f7f\u7528 get_edge \u8bfb\u53d6\u4e00\u6761\u8fb9\n    \"\"\"\n    try:\n        # 1. \u63d2\u5165\u7b2c\u4e00\u4e2a\u8282\u70b9\n        node1_id = \"\u4eba\u5de5\u667a\u80fd\"\n        node1_data = {\n            \"entity_id\": node1_id,\n            \"description\": \"\u4eba\u5de5\u667a\u80fd\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u4e00\u4e2a\u5206\u652f\uff0c\u5b83\u4f01\u56fe\u4e86\u89e3\u667a\u80fd\u7684\u5b9e\u8d28\uff0c\u5e76\u751f\u4ea7\u51fa\u4e00\u79cd\u65b0\u7684\u80fd\u4ee5\u4eba\u7c7b\u667a\u80fd\u76f8\u4f3c\u7684\u65b9\u5f0f\u505a\u51fa\u53cd\u5e94\u7684\u667a\u80fd\u673a\u5668\u3002\",\n            \"keywords\": \"AI,\u673a\u5668\u5b66\u4e60,\u6df1\u5ea6\u5b66\u4e60\",\n            \"entity_type\": \"\u6280\u672f\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8282\u70b91: {node1_id}\")\n        await storage.upsert_node(node1_id, node1_data)\n\n        # 2. \u63d2\u5165\u7b2c\u4e8c\u4e2a\u8282\u70b9\n        node2_id = \"\u673a\u5668\u5b66\u4e60\"\n        node2_data = {\n            \"entity_id\": node2_id,\n            \"description\": \"\u673a\u5668\u5b66\u4e60\u662f\u4eba\u5de5\u667a\u80fd\u7684\u4e00\u4e2a\u5206\u652f\uff0c\u5b83\u4f7f\u7528\u7edf\u8ba1\u5b66\u65b9\u6cd5\u8ba9\u8ba1\u7b97\u673a\u7cfb\u7edf\u5728\u4e0d\u88ab\u660e\u786e\u7f16\u7a0b\u7684\u60c5\u51b5\u4e0b\u4e5f\u80fd\u591f\u5b66\u4e60\u3002\",\n            \"keywords\": \"\u76d1\u7763\u5b66\u4e60,\u65e0\u76d1\u7763\u5b66\u4e60,\u5f3a\u5316\u5b66\u4e60\",\n            \"entity_type\": \"\u6280\u672f\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8282\u70b92: {node2_id}\")\n        await storage.upsert_node(node2_id, node2_data)\n\n        # 3. \u63d2\u5165\u8fde\u63a5\u8fb9\n        edge_data = {\n            \"relationship\": \"\u5305\u542b\",\n            \"weight\": 1.0,\n            \"description\": \"\u4eba\u5de5\u667a\u80fd\u9886\u57df\u5305\u542b\u673a\u5668\u5b66\u4e60\u8fd9\u4e2a\u5b50\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8fb9: {node1_id} -> {node2_id}\")\n        await storage.upsert_edge(node1_id, node2_id, edge_data)\n\n        # 4. \u8bfb\u53d6\u8282\u70b9\u5c5e\u6027\n        print(f\"\u8bfb\u53d6\u8282\u70b9\u5c5e\u6027: {node1_id}\")\n        node1_props = await storage.get_node(node1_id)\n        if node1_props:\n            print(f\"\u6210\u529f\u8bfb\u53d6\u8282\u70b9\u5c5e\u6027: {node1_id}\")\n            print(f\"\u8282\u70b9\u63cf\u8ff0: {node1_props.get('description', '\u65e0\u63cf\u8ff0')}\")\n            print(f\"\u8282\u70b9\u7c7b\u578b: {node1_props.get('entity_type', '\u65e0\u7c7b\u578b')}\")\n            print(f\"\u8282\u70b9\u5173\u952e\u8bcd: {node1_props.get('keywords', '\u65e0\u5173\u952e\u8bcd')}\")\n            # \u9a8c\u8bc1\u8fd4\u56de\u7684\u5c5e\u6027\u662f\u5426\u6b63\u786e\n            assert (\n                node1_props.get(\"entity_id\") == node1_id\n            ), f\"\u8282\u70b9ID\u4e0d\u5339\u914d: \u671f\u671b {node1_id}, \u5b9e\u9645 {node1_props.get('entity_id')}\"\n            assert (\n                node1_props.get(\"description\") == node1_data[\"description\"]\n            ), \"\u8282\u70b9\u63cf\u8ff0\u4e0d\u5339\u914d\"\n            assert (\n                node1_props.get(\"entity_type\") == node1_data[\"entity_type\"]\n            ), \"\u8282\u70b9\u7c7b\u578b\u4e0d\u5339\u914d\"\n        else:\n            print(f\"\u8bfb\u53d6\u8282\u70b9\u5c5e\u6027\u5931\u8d25: {node1_id}\")\n            assert False, f\"\u672a\u80fd\u8bfb\u53d6\u8282\u70b9\u5c5e\u6027: {node1_id}\"\n\n        # 5. \u8bfb\u53d6\u8fb9\u5c5e\u6027\n        print(f\"\u8bfb\u53d6\u8fb9\u5c5e\u6027: {node1_id} -> {node2_id}\")\n        edge_props = await storage.get_edge(node1_id, node2_id)\n        if edge_props:\n            print(f\"\u6210\u529f\u8bfb\u53d6\u8fb9\u5c5e\u6027: {node1_id} -> {node2_id}\")\n            print(f\"\u8fb9\u5173\u7cfb: {edge_props.get('relationship', '\u65e0\u5173\u7cfb')}\")\n            print(f\"\u8fb9\u63cf\u8ff0: {edge_props.get('description', '\u65e0\u63cf\u8ff0')}\")\n            print(f\"\u8fb9\u6743\u91cd: {edge_props.get('weight', '\u65e0\u6743\u91cd')}\")\n            # \u9a8c\u8bc1\u8fd4\u56de\u7684\u5c5e\u6027\u662f\u5426\u6b63\u786e\n            assert (\n                edge_props.get(\"relationship\") == edge_data[\"relationship\"]\n            ), \"\u8fb9\u5173\u7cfb\u4e0d\u5339\u914d\"\n            assert (\n                edge_props.get(\"description\") == edge_data[\"description\"]\n            ), \"\u8fb9\u63cf\u8ff0\u4e0d\u5339\u914d\"\n            assert edge_props.get(\"weight\") == edge_data[\"weight\"], \"\u8fb9\u6743\u91cd\u4e0d\u5339\u914d\"\n        else:\n            print(f\"\u8bfb\u53d6\u8fb9\u5c5e\u6027\u5931\u8d25: {node1_id} -> {node2_id}\")\n            assert False, f\"\u672a\u80fd\u8bfb\u53d6\u8fb9\u5c5e\u6027: {node1_id} -> {node2_id}\"\n\n        # 5.1 \u9a8c\u8bc1\u65e0\u5411\u56fe\u7279\u6027 - \u8bfb\u53d6\u53cd\u5411\u8fb9\u5c5e\u6027\n        print(f\"\u8bfb\u53d6\u53cd\u5411\u8fb9\u5c5e\u6027: {node2_id} -> {node1_id}\")\n        reverse_edge_props = await storage.get_edge(node2_id, node1_id)\n        if reverse_edge_props:\n            print(f\"\u6210\u529f\u8bfb\u53d6\u53cd\u5411\u8fb9\u5c5e\u6027: {node2_id} -> {node1_id}\")\n            print(f\"\u53cd\u5411\u8fb9\u5173\u7cfb: {reverse_edge_props.get('relationship', '\u65e0\u5173\u7cfb')}\")\n            print(f\"\u53cd\u5411\u8fb9\u63cf\u8ff0: {reverse_edge_props.get('description', '\u65e0\u63cf\u8ff0')}\")\n            print(f\"\u53cd\u5411\u8fb9\u6743\u91cd: {reverse_edge_props.get('weight', '\u65e0\u6743\u91cd')}\")\n            # \u9a8c\u8bc1\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u5c5e\u6027\u662f\u5426\u76f8\u540c\n            assert (\n                edge_props == reverse_edge_props\n            ), \"\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u5c5e\u6027\u4e0d\u4e00\u81f4\uff0c\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u5931\u8d25\"\n            print(\"\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u6210\u529f\uff1a\u6b63\u5411\u548c\u53cd\u5411\u8fb9\u5c5e\u6027\u4e00\u81f4\")\n        else:\n            print(f\"\u8bfb\u53d6\u53cd\u5411\u8fb9\u5c5e\u6027\u5931\u8d25: {node2_id} -> {node1_id}\")\n            assert (\n                False\n            ), f\"\u672a\u80fd\u8bfb\u53d6\u53cd\u5411\u8fb9\u5c5e\u6027: {node2_id} -> {node1_id}\uff0c\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u5931\u8d25\"\n\n        print(\"\u57fa\u672c\u6d4b\u8bd5\u5b8c\u6210\uff0c\u6570\u636e\u5df2\u4fdd\u7559\u5728\u6570\u636e\u5e93\u4e2d\")\n        return True\n\n    except Exception as e:\n        ASCIIColors.red(f\"\u6d4b\u8bd5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u9519\u8bef: {str(e)}\")\n        return False", "label": 0}
{"function": "def preprocess_image(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Preprocess the input image.\n\n    Args:\n        image (Image.Image): The input image.\n\n    Returns:\n        Image.Image: The preprocessed image.\n    \"\"\"\n    processed_image = pipeline.preprocess_image(image)\n    return processed_image", "label": 0}
{"function": "def alert(code=None, obj=object, strFields=None, trace=None):\n    \"\"\"The alert function is used for writing alerts to the standard error stream.\n    Only the ErrorHandler class can receive alerts via the \"receiveAlert\" method.\n\n    Parameters\n    ----------\n    code: int\n        The 4 digit code for retrieving alert from AlertCatalogue\n    obj: object\n        The object related to the alert e.g., TextComponent object\n    strFields: dict\n        Dict containing relevant values for formatting messages\n    trace: sys.exec_info() traceback object\n            The traceback\n    \"\"\"\n\n    msg = AlertEntry(code, obj, strFields, trace)\n\n    # format the warning into a string for console and logging targets\n    msgAsStr = (\"Alert {code}: {msg}\\n\"\n                \"For more info see https://docs.psychopy.org/alerts/{code}.html\"\n                .format(type=msg.type,\n                        name=msg.name,\n                        code=msg.code,\n                        cat=msg.cat,\n                        msg=msg.msg,\n                        trace=msg.trace))\n    # msgAsStr = (\"Component Type: {type} | \"\n    #             \"Component Name: {name} | \"\n    #             \"Code: {code} | \"\n    #             \"Category: {cat} | \"\n    #             \"Message: {msg} | \"\n    #             \"Traceback: {trace}\".format(type=msg.type,\n    #                                         name=msg.name,\n    #                                         code=msg.code,\n    #                                         cat=msg.cat,\n    #                                         msg=msg.msg,\n    #                                         trace=msg.trace))\n\n    # if a psychopy warning instead of a file-like stderr then pass a raw str\n    if hasattr(sys.stderr, 'receiveAlert'):\n        sys.stderr.receiveAlert(msg)\n    else:\n        # For tests detecting output - change when error handler set up\n        sys.stderr.write(msgAsStr)\n        for handler in _activeAlertHandlers:\n            handler.receiveAlert(msg)", "label": 1}
{"function": "    def test_string_slice(self):\n        self.check_func(lambda x: x.str.slice(start=1))\n        self.check_func(lambda x: x.str.slice(stop=3))\n        self.check_func(lambda x: x.str.slice(step=2))\n        self.check_func(lambda x: x.str.slice(start=0, stop=5, step=3))", "label": 1}
{"function": "def get_contents(filename):\n    with open(filename, 'rb') as f:\n        return f.read()", "label": 1}
{"function": "    def _reconstruct(cls, value):\n        return str.__new__(cls, value)", "label": 1}
{"function": "def check_ffmpeg():\n    from rich.console import Console\n    from rich.panel import Panel\n    from translations.translations import translate as t\n    console = Console()\n\n    try:\n        # Check if ffmpeg is installed\n        subprocess.run(['ffmpeg', '-version'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)\n        console.print(Panel(t(\"\u2705 FFmpeg is already installed\"), style=\"green\"))\n        return True\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        system = platform.system()\n        install_cmd = \"\"\n        \n        if system == \"Windows\":\n            install_cmd = \"choco install ffmpeg\"\n            extra_note = t(\"Install Chocolatey first (https://chocolatey.org/)\")\n        elif system == \"Darwin\":\n            install_cmd = \"brew install ffmpeg\"\n            extra_note = t(\"Install Homebrew first (https://brew.sh/)\")\n        elif system == \"Linux\":\n            install_cmd = \"sudo apt install ffmpeg  # Ubuntu/Debian\\nsudo yum install ffmpeg  # CentOS/RHEL\"\n            extra_note = t(\"Use your distribution's package manager\")\n        \n        console.print(Panel.fit(\n            t(\"\u274c FFmpeg not found\\n\\n\") +\n            f\"{t('\ud83d\udee0\ufe0f Install using:')}\\n[bold cyan]{install_cmd}[/bold cyan]\\n\\n\" +\n            f\"{t('\ud83d\udca1 Note:')}\\n{extra_note}\\n\\n\" +\n            f\"{t('\ud83d\udd04 After installing FFmpeg, please run this installer again:')}\\n[bold cyan]python install.py[/bold cyan]\",\n            style=\"red\"\n        ))\n        raise SystemExit(t(\"FFmpeg is required. Please install it and run the installer again.\"))", "label": 0}
{"function": "async def test_browser_use_parallel():\n    from browser_use.browser.browser import Browser, BrowserConfig\n    from browser_use.browser.context import (\n        BrowserContextConfig,\n    )\n    from browser_use.agent.service import Agent\n\n    from src.browser.custom_browser import CustomBrowser\n    from src.controller.custom_controller import CustomController\n    from src.utils import llm_provider\n    from src.agent.browser_use.browser_use_agent import BrowserUseAgent\n\n    # llm = utils.get_llm_model(\n    #     provider=\"openai\",\n    #     model_name=\"gpt-4o\",\n    #     temperature=0.8,\n    #     base_url=os.getenv(\"OPENAI_ENDPOINT\", \"\"),\n    #     api_key=os.getenv(\"OPENAI_API_KEY\", \"\"),\n    # )\n\n    # llm = utils.get_llm_model(\n    #     provider=\"google\",\n    #     model_name=\"gemini-2.0-flash\",\n    #     temperature=0.6,\n    #     api_key=os.getenv(\"GOOGLE_API_KEY\", \"\")\n    # )\n\n    # llm = utils.get_llm_model(\n    #     provider=\"deepseek\",\n    #     model_name=\"deepseek-reasoner\",\n    #     temperature=0.8\n    # )\n\n    # llm = utils.get_llm_model(\n    #     provider=\"deepseek\",\n    #     model_name=\"deepseek-chat\",\n    #     temperature=0.8\n    # )\n\n    # llm = utils.get_llm_model(\n    #     provider=\"ollama\", model_name=\"qwen2.5:7b\", temperature=0.5\n    # )\n\n    # llm = utils.get_llm_model(\n    #     provider=\"ollama\", model_name=\"deepseek-r1:14b\", temperature=0.5\n    # )\n\n    window_w, window_h = 1280, 1100\n\n    llm = llm_provider.get_llm_model(\n        provider=\"azure_openai\",\n        model_name=\"gpt-4o\",\n        temperature=0.5,\n        base_url=os.getenv(\"AZURE_OPENAI_ENDPOINT\", \"\"),\n        api_key=os.getenv(\"AZURE_OPENAI_API_KEY\", \"\"),\n    )\n\n    mcp_server_config = {\n        \"mcpServers\": {\n            # \"markitdown\": {\n            #     \"command\": \"docker\",\n            #     \"args\": [\n            #         \"run\",\n            #         \"--rm\",\n            #         \"-i\",\n            #         \"markitdown-mcp:latest\"\n            #     ]\n            # },\n            \"desktop-commander\": {\n                \"command\": \"npx\",\n                \"args\": [\n                    \"-y\",\n                    \"@wonderwhy-er/desktop-commander\"\n                ]\n            },\n            # \"filesystem\": {\n            #     \"command\": \"npx\",\n            #     \"args\": [\n            #         \"-y\",\n            #         \"@modelcontextprotocol/server-filesystem\",\n            #         \"/Users/xxx/ai_workspace\",\n            #     ]\n            # },\n        }\n    }\n    controller = CustomController()\n    await controller.setup_mcp_client(mcp_server_config)\n    use_own_browser = True\n    use_vision = True  # Set to False when using DeepSeek\n\n    max_actions_per_step = 10\n    browser = None\n    browser_context = None\n\n    try:\n        extra_browser_args = []\n        if use_own_browser:\n            browser_binary_path = os.getenv(\"BROWSER_PATH\", None)\n            if browser_binary_path == \"\":\n                browser_binary_path = None\n            browser_user_data = os.getenv(\"BROWSER_USER_DATA\", None)\n            if browser_user_data:\n                extra_browser_args += [f\"--user-data-dir={browser_user_data}\"]\n        else:\n            browser_binary_path = None\n        browser = CustomBrowser(\n            config=BrowserConfig(\n                headless=False,\n                browser_binary_path=browser_binary_path,\n                extra_browser_args=extra_browser_args,\n                new_context_config=BrowserContextConfig(\n                    window_width=window_w,\n                    window_height=window_h,\n                )\n            )\n        )\n        browser_context = await browser.new_context(\n            config=BrowserContextConfig(\n                trace_path=None,\n                save_recording_path=None,\n                save_downloads_path=\"./tmp/downloads\",\n                window_height=window_h,\n                window_width=window_w,\n                force_new_context=True\n            )\n        )\n        agents = [\n            BrowserUseAgent(task=task, llm=llm, browser=browser, controller=controller)\n            for task in [\n                'Search Google for weather in Tokyo',\n                # 'Check Reddit front page title',\n                # 'Find NASA image of the day',\n                # 'Check top story on CNN',\n                # 'Search latest SpaceX launch date',\n                # 'Look up population of Paris',\n                'Find current time in Sydney',\n                'Check who won last Super Bowl',\n                # 'Search trending topics on Twitter',\n            ]\n        ]\n\n        history = await asyncio.gather(*[agent.run() for agent in agents])\n        print(\"Final Result:\")\n        pprint(history.final_result(), indent=4)\n\n        print(\"\\nErrors:\")\n        pprint(history.errors(), indent=4)\n\n        pdb.set_trace()\n\n    except Exception:\n        import traceback\n\n        traceback.print_exc()\n    finally:\n        if browser_context:\n            await browser_context.close()\n        if browser:\n            await browser.close()\n        if controller:\n            await controller.close_mcp_client()", "label": 0}
{"function": "    def getConvexHullHead(self) -> Optional[Polygon]:\n        \"\"\"Get convex hull of the object + head size\n\n        In case of printing all at once this is None.\n        For one at the time this is area with intersection of mirrored head\n        \"\"\"\n        if self._node is None:\n            return None\n        if self._node.callDecoration(\"isNonPrintingMesh\"):\n            return None\n        if self._isSingularOneAtATimeNode():\n            head_with_fans = self._compute2DConvexHeadMin()\n            if head_with_fans is None:\n                return None\n            head_with_fans_with_adhesion_margin = self._add2DAdhesionMargin(head_with_fans)\n            return head_with_fans_with_adhesion_margin\n        return None", "label": 1}
{"function": "    def _pack_and_reshape(*values):\n      return array_ops.reshape(\n          array_ops.stack(axis=1, values=values),\n          array_ops.concat(values=[array_ops.shape(num_steps), [2, 2]], axis=0))", "label": 1}
{"function": "def single_job(utt):\n    audio, sample_rate = torchaudio.load(utt2wav[utt])\n    if sample_rate != 16000:\n        audio = torchaudio.transforms.Resample(orig_freq=sample_rate, new_freq=16000)(audio)\n    feat = kaldi.fbank(audio,\n                       num_mel_bins=80,\n                       dither=0,\n                       sample_frequency=16000)\n    feat = feat - feat.mean(dim=0, keepdim=True)\n    embedding = ort_session.run(None, {ort_session.get_inputs()[0].name: feat.unsqueeze(dim=0).cpu().numpy()})[0].flatten().tolist()\n    return utt, embedding", "label": 0}
{"function": "def test_add_metrics_duplicate_names(tracer):\n    \"\"\"Test handling of duplicate metric names\"\"\"\n    tracer.trace = {}\n    metrics = [\n        {\"name\": \"metric1\", \"score\": 0.95},\n        {\"name\": \"metric1\", \"score\": 0.85}\n    ]\n    tracer.add_metrics(metrics)\n    \n    assert len(tracer.trace_metrics) == 2\n    assert tracer.trace_metrics[0][\"name\"] == \"metric1\"\n    assert tracer.trace_metrics[1][\"name\"] == \"metric1_2\"", "label": 0}
{"function": "    def create_initial_state(\n        self, company_name: str, trade_date: str\n    ) -> Dict[str, Any]:\n        \"\"\"Create the initial state for the agent graph.\"\"\"\n        return {\n            \"messages\": [(\"human\", company_name)],\n            \"company_of_interest\": company_name,\n            \"trade_date\": str(trade_date),\n            \"investment_debate_state\": InvestDebateState(\n                {\"history\": \"\", \"current_response\": \"\", \"count\": 0}\n            ),\n            \"risk_debate_state\": RiskDebateState(\n                {\n                    \"history\": \"\",\n                    \"current_risky_response\": \"\",\n                    \"current_safe_response\": \"\",\n                    \"current_neutral_response\": \"\",\n                    \"count\": 0,\n                }\n            ),\n            \"market_report\": \"\",\n            \"fundamentals_report\": \"\",\n            \"sentiment_report\": \"\",\n            \"news_report\": \"\",\n        }", "label": 0}
{"function": "def get_api_response() -> requests.Response:\n    url = f'{ENDPOINTS[current_endpoint].split(\"/a\")[0]}'\n    response = requests.get(url)\n    return response", "label": 0}
{"function": "    def b2a_uu(data: _Bytes) -> bytes: ...", "label": 1}
{"function": "    def __str__(self):\n        return self.message + '\\n'", "label": 1}
{"function": "    def __init__(self, model_path) -> None:\n        self.model = AutoModel.from_pretrained(model_path, trust_remote_code=True).to(dtype=torch.bfloat16)\n        self.tokenizer = AutoTokenizer.from_pretrained(model_path, trust_remote_code=True)\n        self.model.eval().cuda()", "label": 0}
{"function": "def unregister():\n    # Stop the server if it's running\n    if hasattr(bpy.types, \"blendermcp_server\") and bpy.types.blendermcp_server:\n        bpy.types.blendermcp_server.stop()\n        del bpy.types.blendermcp_server\n    \n    bpy.utils.unregister_class(BLENDERMCP_PT_Panel)\n    bpy.utils.unregister_class(BLENDERMCP_OT_SetFreeTrialHyper3DAPIKey)\n    bpy.utils.unregister_class(BLENDERMCP_OT_StartServer)\n    bpy.utils.unregister_class(BLENDERMCP_OT_StopServer)\n    \n    del bpy.types.Scene.blendermcp_port\n    del bpy.types.Scene.blendermcp_server_running\n    del bpy.types.Scene.blendermcp_use_polyhaven\n    del bpy.types.Scene.blendermcp_use_hyper3d\n    del bpy.types.Scene.blendermcp_hyper3d_mode\n    del bpy.types.Scene.blendermcp_hyper3d_api_key\n    del bpy.types.Scene.blendermcp_use_sketchfab\n    del bpy.types.Scene.blendermcp_sketchfab_api_key\n\n    print(\"BlenderMCP addon unregistered\")", "label": 0}
{"function": "  def __init__(self,\n               alpha,\n               beta,\n               validate_args=False,\n               allow_nan_stats=True,\n               name=\"GammaWithSoftplusAlphaBeta\"):\n    with ops.name_scope(name, values=[alpha, beta]) as ns:\n      super(GammaWithSoftplusAlphaBeta, self).__init__(\n          alpha=nn.softplus(alpha),\n          beta=nn.softplus(beta),\n          validate_args=validate_args,\n          allow_nan_stats=allow_nan_stats,\n          name=ns)", "label": 1}
{"function": "def Logger(content):\n    if not ddp or dist.get_rank() == 0:\n        print(content)", "label": 0}
{"function": "async def get_screenshot():\n    logger.info(\"Screenshot endpoint called\")\n    screenshot_path = \".screenshots/updated_screen.png\"\n    if os.path.exists(screenshot_path):\n        return FileResponse(screenshot_path)\n    logger.error(\"No screenshot available\")\n    return JSONResponse(\n        status_code=404,\n        content={\"error\": \"No screenshot available\"}\n    )", "label": 0}
{"function": "async def test_desktop(monkeypatch):\n    \"\"\"Test the desktop server\"\"\"\n    from examples.desktop import mcp\n\n    async with Client(mcp) as client:\n        # Test the add function\n        result = await client.call_tool_mcp(\"add\", {\"a\": 1, \"b\": 2})\n        assert len(result.content) == 1\n        assert result.content[0].text == \"3\"  # type: ignore[attr-defined]\n\n    async with Client(mcp) as client:\n        result = await client.read_resource(AnyUrl(\"greeting://rooter12\"))\n        assert len(result) == 1\n        assert result[0].text == \"Hello, rooter12!\"  # type: ignore[attr-defined]", "label": 0}
{"function": "def main():\n    parser = argparse.ArgumentParser(description=\"Generate test report\")\n    parser.add_argument(\"--run-tests\", action=\"store_true\", help=\"Run tests before generating report\")\n    parser.add_argument(\n        \"--providers\",\n        type=str,\n        nargs=\"+\",\n        help=\"Specify providers to include/test (comma-separated or space-separated, default: uses DEFAULT_PROVIDERS)\",\n    )\n    parser.add_argument(\"--output\", type=str, help=\"Output file location (default: tests/verifications/REPORT.md)\")\n    parser.add_argument(\"--k\", type=str, help=\"Keyword expression to filter tests (passed to pytest -k)\")\n    args = parser.parse_args()\n\n    all_results = {}\n    final_providers_order = {}  # Dictionary to store results, preserving processing order\n    aggregated_tests = set()\n    provider_timestamps = {}\n\n    # 1. Determine the desired list and order of providers\n    if args.providers:\n        desired_providers = []\n        for provider_arg in args.providers:\n            desired_providers.extend([p.strip() for p in provider_arg.split(\",\")])\n    else:\n        desired_providers = DEFAULT_PROVIDERS  # Use default order/list\n\n    # 2. Run tests if requested (using the desired provider list)\n    if args.run_tests:\n        run_multiple_tests(desired_providers, args.k)\n\n    for provider in desired_providers:\n        # Construct the expected result file path directly\n        result_file = RESULTS_DIR / f\"{provider}.json\"\n\n        if result_file.exists():  # Check if the specific file exists\n            print(f\"Loading results for {provider} from {result_file}\")\n            try:\n                parsed_data = parse_results(result_file)\n                parsed_results, providers_in_file, tests_in_file, run_timestamp = parsed_data\n                all_results.update(parsed_results)\n                aggregated_tests.update(tests_in_file)\n\n                # Add models for this provider, ensuring it's added in the correct report order\n                if provider in providers_in_file:\n                    if provider not in final_providers_order:\n                        final_providers_order[provider] = set()\n                    final_providers_order[provider].update(providers_in_file[provider])\n                    if run_timestamp != \"Unknown\":\n                        provider_timestamps[provider] = run_timestamp\n                else:\n                    print(\n                        f\"Warning: Provider '{provider}' found in desired list but not within its result file data ({result_file}).\"\n                    )\n\n            except Exception as e:\n                print(f\"Error parsing results for provider {provider} from {result_file}: {e}\")\n        else:\n            # Only print warning if we expected results (i.e., provider was in the desired list)\n            print(f\"Result file for desired provider '{provider}' not found at {result_file}. Skipping.\")\n\n    # 5. Generate the report using the filtered & ordered results\n    print(f\"Final Provider Order for Report: {list(final_providers_order.keys())}\")\n    generate_report(all_results, final_providers_order, aggregated_tests, provider_timestamps, args.output)", "label": 0}
{"function": "    def mousePressEvent(self, event):\n        \"\"\" Check for left mouse button presses in order to enable drag and\n            drop.\n        \"\"\"\n        if event.button() == Qt.LeftButton:\n            self.dragStartPosition = event.pos()", "label": 1}
{"function": "    def _validate_experience_levels(cls, experience_levels: dict, config_path: Path):\n        \"\"\"Ensure experience levels are booleans.\"\"\"\n        for level in cls.EXPERIENCE_LEVELS:\n            if not isinstance(experience_levels.get(level), bool):\n                raise ConfigError(\n                    f\"Experience level '{level}' must be a boolean in {config_path}\"\n                )", "label": 0}
{"function": "def _TransposeGrad(op, grad):\n  \"\"\"Returns unshuffle(grad).\"\"\"\n  p = op.inputs[1]\n  return [array_ops.transpose(grad, array_ops.invert_permutation(p)), None]", "label": 1}
{"function": "def _process_batch(sess, original_images, semantic_predictions, image_names,\n                   image_heights, image_widths, image_id_offset, save_dir,\n                   raw_save_dir, train_id_to_eval_id=None):\n  \"\"\"Evaluates one single batch qualitatively.\n\n  Args:\n    sess: TensorFlow session.\n    original_images: One batch of original images.\n    semantic_predictions: One batch of semantic segmentation predictions.\n    image_names: Image names.\n    image_heights: Image heights.\n    image_widths: Image widths.\n    image_id_offset: Image id offset for indexing images.\n    save_dir: The directory where the predictions will be saved.\n    raw_save_dir: The directory where the raw predictions will be saved.\n    train_id_to_eval_id: A list mapping from train id to eval id.\n  \"\"\"\n  (original_images,\n   semantic_predictions,\n   image_names,\n   image_heights,\n   image_widths) = sess.run([original_images, semantic_predictions,\n                             image_names, image_heights, image_widths])\n\n  num_image = semantic_predictions.shape[0]\n  for i in range(num_image):\n    image_height = np.squeeze(image_heights[i])\n    image_width = np.squeeze(image_widths[i])\n    original_image = np.squeeze(original_images[i])\n    semantic_prediction = np.squeeze(semantic_predictions[i])\n    crop_semantic_prediction = semantic_prediction[:image_height, :image_width]\n\n    # Save image.\n    save_annotation.save_annotation(\n        original_image, save_dir, _IMAGE_FORMAT % (image_id_offset + i),\n        add_colormap=False)\n\n    # Save prediction.\n    save_annotation.save_annotation(\n        crop_semantic_prediction, save_dir,\n        _PREDICTION_FORMAT % (image_id_offset + i), add_colormap=True,\n        colormap_type=FLAGS.colormap_type)\n\n    if FLAGS.also_save_raw_predictions:\n      image_filename = os.path.basename(image_names[i])\n\n      if train_id_to_eval_id is not None:\n        crop_semantic_prediction = _convert_train_id_to_eval_id(\n            crop_semantic_prediction,\n            train_id_to_eval_id)\n      save_annotation.save_annotation(\n          crop_semantic_prediction, raw_save_dir, image_filename,\n          add_colormap=False)", "label": 1}
{"function": "def llama3_2_100M() -> torchtune.modules.transformer.TransformerDecoder:\n    return llama3_2.llama3_2(\n        vocab_size=128_256,\n        num_layers=4,\n        num_heads=8,\n        num_kv_heads=2,\n        embed_dim=1024,\n        max_seq_len=2048,\n        intermediate_dim=8192,\n        attn_dropout=0.0,\n        norm_eps=1e-5,\n        rope_base=500_000,\n        scale_factor=32,\n    )", "label": 0}
{"function": "    def cmd_qtile_info(self):\n        \"\"\"Returns a dictionary of info on the Qtile instance\"\"\"\n        return {}", "label": 1}
{"function": "def save_report(report, filename=None):\n    \"\"\"Save the report to a file.\"\"\"\n    if filename is None:\n        filename = f\"test_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\n    with open(filename, 'w') as file:\n        file.write(report)\n    print(f\"Report saved to {os.path.abspath(filename)}\")", "label": 0}
{"function": "    def __str__(self):\n        return \"{}/{}\".format(self.okta_domain, self.name)", "label": 1}
{"function": "def SimpleArc(sides=0, radius=1.0, startangle=0.0, endangle=45.0):\n    newpoints = []\n\n    startangle = radians(startangle)\n    endangle = radians(endangle)\n    sides += 1\n\n    angle = (endangle - startangle) / sides\n    x = cos(startangle) * radius\n    y = sin(startangle) * radius\n    newpoints.append([x, y, 0])\n    j = 1\n    while j < sides:\n        t = angle * j\n        x = cos(t + startangle) * radius\n        y = sin(t + startangle) * radius\n        newpoints.append([x, y, 0])\n        j += 1\n    x = cos(endangle) * radius\n    y = sin(endangle) * radius\n    newpoints.append([x, y, 0])\n\n    return newpoints", "label": 1}
{"function": "def test_retriever_initialization(setup_test_memory):\n    \"\"\"Test retriever initialization\"\"\"\n    video_file, index_file, chunks = setup_test_memory\n    \n    retriever = MemvidRetriever(video_file, index_file)\n    assert retriever.video_file == video_file\n    assert retriever.total_frames == len(chunks)", "label": 0}
{"function": "    def initialize(self):\n        BaseOptions.initialize(self)\n        self.parser.add_argument('--ntest', type=int, default=float(\"inf\"), help='# of test examples.')\n        self.parser.add_argument('--results_dir', type=str, default='./results/', help='saves results here.')\n        self.parser.add_argument('--aspect_ratio', type=float, default=1.0, help='aspect ratio of result images')\n        self.parser.add_argument('--phase', type=str, default='test', help='train, val, test, etc')\n        self.parser.add_argument('--which_epoch', type=str, default='latest', help='which epoch to load? set to latest to use latest cached model')\n        self.parser.add_argument('--how_many', type=int, default=50, help='how many test images to run')\n        self.parser.add_argument('--file_name', type=str, default='')\n        self.parser.add_argument('--suffix', type=str, default='')\n        self.isTrain = False", "label": 1}
{"function": "def get_search_terms(video_subject: str, amount: int, script: str, ai_model: str) -> List[str]:\n    \"\"\"\n    Generate a JSON-Array of search terms for stock videos,\n    depending on the subject of a video.\n\n    Args:\n        video_subject (str): The subject of the video.\n        amount (int): The amount of search terms to generate.\n        script (str): The script of the video.\n        ai_model (str): The AI model to use for generation.\n\n    Returns:\n        List[str]: The search terms for the video subject.\n    \"\"\"\n\n    # Build prompt\n    prompt = f\"\"\"\n    Generate {amount} search terms for stock videos,\n    depending on the subject of a video.\n    Subject: {video_subject}\n\n    The search terms are to be returned as\n    a JSON-Array of strings.\n\n    Each search term should consist of 1-3 words,\n    always add the main subject of the video.\n    \n    YOU MUST ONLY RETURN THE JSON-ARRAY OF STRINGS.\n    YOU MUST NOT RETURN ANYTHING ELSE. \n    YOU MUST NOT RETURN THE SCRIPT.\n    \n    The search terms must be related to the subject of the video.\n    Here is an example of a JSON-Array of strings:\n    [\"search term 1\", \"search term 2\", \"search term 3\"]\n\n    For context, here is the full text:\n    {script}\n    \"\"\"\n\n    # Generate search terms\n    response = generate_response(prompt, ai_model)\n    print(response)\n\n    # Parse response into a list of search terms\n    search_terms = []\n    \n    try:\n        search_terms = json.loads(response)\n        if not isinstance(search_terms, list) or not all(isinstance(term, str) for term in search_terms):\n            raise ValueError(\"Response is not a list of strings.\")\n\n    except (json.JSONDecodeError, ValueError):\n        # Get everything between the first and last square brackets\n        response = response[response.find(\"[\") + 1:response.rfind(\"]\")]\n\n        print(colored(\"[*] GPT returned an unformatted response. Attempting to clean...\", \"yellow\"))\n\n        # Attempt to extract list-like string and convert to list\n        match = re.search(r'\\[\"(?:[^\"\\\\]|\\\\.)*\"(?:,\\s*\"[^\"\\\\]*\")*\\]', response)\n        print(match.group())\n        if match:\n            try:\n                search_terms = json.loads(match.group())\n            except json.JSONDecodeError:\n                print(colored(\"[-] Could not parse response.\", \"red\"))\n                return []\n\n\n    # Let user know\n    print(colored(f\"\\nGenerated {len(search_terms)} search terms: {', '.join(search_terms)}\", \"cyan\"))\n\n    # Return search terms\n    return search_terms", "label": 0}
{"function": "def search_web_ref(query:str, debug=False):\n \n    content_list = []\n\n    try:\n\n        safe_string = urllib.parse.quote_plus(\":all !general \" + query)\n\n        response = requests.get('http://searxng:8080?q=' + safe_string + '&format=json')\n        response.raise_for_status()\n        search_results = response.json()\n \n        if debug:\n            print(\"JSON Response:\")\n            pprint(search_results)\n        pedding_urls = []\n\n        conv_links = []\n\n        if search_results.get('results'):\n            for item in search_results.get('results')[0:9]:\n                name = item.get('title')\n                snippet = item.get('content')\n                url = item.get('url')\n                pedding_urls.append(url)\n\n                if url:\n                    url_parsed = urlparse(url)\n                    domain = url_parsed.netloc\n                    icon_url =  url_parsed.scheme + '://' + url_parsed.netloc + '/favicon.ico'\n                    site_name = tldextract.extract(url).domain\n \n                conv_links.append({\n                    'site_name':site_name,\n                    'icon_url':icon_url,\n                    'title':name,\n                    'url':url,\n                    'snippet':snippet\n                })\n\n            results = []\n            futures = []\n\n            executor = ThreadPoolExecutor(max_workers=10) \n            for url in pedding_urls:\n                futures.append(executor.submit(extract_url_content,url))\n            try:\n                for future in futures:\n                    res = future.result(timeout=5)\n                    results.append(res)\n            except concurrent.futures.TimeoutError:\n                print(\"\u4efb\u52a1\u6267\u884c\u8d85\u65f6\")\n                executor.shutdown(wait=False,cancel_futures=True)\n\n            for content in results:\n                if content and content.get('content'):\n                    \n                    item_dict = {\n                        \"url\":content.get('url'),\n                        \"content\": content.get('content'),\n                        \"length\":len(content.get('content'))\n                    }\n                    content_list.append(item_dict)\n                if debug:\n                    print(\"URL: {}\".format(url))\n                    print(\"=================\")\n \n        return  conv_links,content_list\n    except Exception as ex:\n        raise ex", "label": 0}
{"function": "        def _build_pagination_info(self, content_obj):\n            pass", "label": 1}
{"function": "    def getPrintingArea(self) -> Optional[Polygon]:\n        \"\"\"Get the buildplate polygon where will be printed\n\n        In case of printing all at once this is the same as convex hull (no individual adhesion)\n        For one at the time this includes the adhesion area\n        \"\"\"\n        if self._isSingularOneAtATimeNode():\n            # In one-at-a-time mode, every printed object gets it's own adhesion\n            printing_area = self.getAdhesionArea()\n        else:\n            printing_area = self.getConvexHull()\n        return printing_area", "label": 1}
{"function": "    def infer(\n        self,\n        ref_file,\n        ref_text,\n        gen_text,\n        show_info=print,\n        progress=tqdm,\n        target_rms=0.1,\n        cross_fade_duration=0.15,\n        sway_sampling_coef=-1,\n        cfg_strength=2,\n        nfe_step=32,\n        speed=1.0,\n        fix_duration=None,\n        remove_silence=False,\n        file_wave=None,\n        file_spec=None,\n        seed=None,\n    ):\n        if seed is None:\n            seed = random.randint(0, sys.maxsize)\n        seed_everything(seed)\n        self.seed = seed\n\n        ref_file, ref_text = preprocess_ref_audio_text(ref_file, ref_text)\n\n        wav, sr, spec = infer_process(\n            ref_file,\n            ref_text,\n            gen_text,\n            self.ema_model,\n            self.vocoder,\n            self.mel_spec_type,\n            show_info=show_info,\n            progress=progress,\n            target_rms=target_rms,\n            cross_fade_duration=cross_fade_duration,\n            nfe_step=nfe_step,\n            cfg_strength=cfg_strength,\n            sway_sampling_coef=sway_sampling_coef,\n            speed=speed,\n            fix_duration=fix_duration,\n            device=self.device,\n        )\n\n        if file_wave is not None:\n            self.export_wav(wav, file_wave, remove_silence)\n\n        if file_spec is not None:\n            self.export_spectrogram(spec, file_spec)\n\n        return wav, sr, spec", "label": 0}
{"function": "def writable_server_selector(selection):\n    return selection.with_server_descriptions(\n        [s for s in selection.server_descriptions if s.is_writable])", "label": 1}
{"function": "def parse_args():\n    parser = argparse.ArgumentParser(description=\"VGGT Demo\")\n    parser.add_argument(\"--scene_dir\", type=str, required=True, help=\"Directory containing the scene images\")\n    parser.add_argument(\"--seed\", type=int, default=42, help=\"Random seed for reproducibility\")\n    parser.add_argument(\"--use_ba\", action=\"store_true\", default=False, help=\"Use BA for reconstruction\")\n    ######### BA parameters #########\n    parser.add_argument(\n        \"--max_reproj_error\", type=float, default=8.0, help=\"Maximum reprojection error for reconstruction\"\n    )\n    parser.add_argument(\"--shared_camera\", action=\"store_true\", default=False, help=\"Use shared camera for all images\")\n    parser.add_argument(\"--camera_type\", type=str, default=\"SIMPLE_PINHOLE\", help=\"Camera type for reconstruction\")\n    parser.add_argument(\"--vis_thresh\", type=float, default=0.2, help=\"Visibility threshold for tracks\")\n    parser.add_argument(\"--query_frame_num\", type=int, default=8, help=\"Number of frames to query\")\n    parser.add_argument(\"--max_query_pts\", type=int, default=4096, help=\"Maximum number of query points\")\n    parser.add_argument(\n        \"--fine_tracking\", action=\"store_true\", default=True, help=\"Use fine tracking (slower but more accurate)\"\n    )\n    parser.add_argument(\n        \"--conf_thres_value\", type=float, default=5.0, help=\"Confidence threshold value for depth filtering (wo BA)\"\n    )\n    return parser.parse_args()", "label": 0}
{"function": "    def __getattr__(self, attr):\n        if attr == 'dry_run':\n            myval = getattr(self, \"_\" + attr)\n            if myval is None:\n                return getattr(self.distribution, attr)\n            else:\n                return myval\n        else:\n            raise AttributeError(attr)", "label": 1}
{"function": "    def _load_image(self, logo_image):\n        pyboleto_dir = os.path.dirname(os.path.abspath(__file__))\n        image_path = os.path.join(pyboleto_dir, 'media', logo_image)\n        return image_path", "label": 1}
{"function": "def parse_arguments(argv):\n  \"\"\"Parse command line arguments.\"\"\"\n  parser = argparse.ArgumentParser(\n      description=\"Runs Preprocessing on Steam product data.\")\n  parser.add_argument(\n      \"--cloud\",\n      action=\"store_true\",\n      help=\"Run preprocessing on the cloud.\")\n  parser.add_argument(\n      \"--job_name\",\n      help=\"Dataflow job name.\")\n  parser.add_argument(\n      \"--job_dir\",\n      help=\"Bucket to stage code and write temp outputs for cloud runs.\")\n  parser.add_argument(\n      \"--output_dir\",\n      required=True,\n      help=\"Dir or bucket (if cloud run) to write train, val and test data.\")\n  parser.add_argument(\n      \"--tft_dir\",\n      required=True,\n      help=\"Dir or bucket (if cloud run) where tft outputs are written.\")\n  parser.add_argument(\n      \"--user_min_count\",\n      required=True,\n      type=int,\n      help=\"Min number of users owning an item to include it in the vocab.\")\n  parser.add_argument(\n      \"--item_min_count\",\n      required=True,\n      type=int,\n      help=\"Min number of items owned by a user to include it in the vocab.\")\n  parser.add_argument(\n      \"--plain_text\",\n      action=\"store_true\",\n      help=\"Write pipeline output to plain text instead of tf-record.\")\n  args = parser.parse_args(args=argv[1:])\n  return args", "label": 1}
{"function": "    def build(\n        ckpt_dir: str,\n        tokenizer_path: str,\n        max_seq_len: int,\n        max_batch_size: int,\n        model_parallel_size: Optional[int] = None,\n        seed: int = 1,\n    ) -> \"Llama\":\n        \"\"\"\n        Build a Llama instance by initializing and loading a model checkpoint.\n\n        Args:\n            ckpt_dir (str): Path to the directory containing checkpoint files.\n            tokenizer_path (str): Path to the tokenizer file.\n            max_seq_len (int): Maximum sequence length for input text.\n            max_batch_size (int): Maximum batch size for inference.\n            model_parallel_size (Optional[int], optional): Number of model parallel processes.\n                If not provided, it's determined from the environment. Defaults to None.\n\n        Returns:\n            Llama: An instance of the Llama class with the loaded model and tokenizer.\n\n        Raises:\n            AssertionError: If there are no checkpoint files in the specified directory,\n                or if the model parallel size does not match the number of checkpoint files.\n\n        Note:\n            This method initializes the distributed process group, sets the device to CUDA,\n            and loads the pre-trained model and tokenizer.\n        \"\"\"\n        assert 1 <= max_seq_len <= 8192, f\"max_seq_len must be between 1 and 8192, got {max_seq_len}.\"\n        assert os.path.isdir(ckpt_dir), f\"Checkpoint directory '{ckpt_dir}' does not exist.\"\n        assert os.path.isfile(tokenizer_path), f\"Tokenizer file '{tokenizer_path}' does not exist.\"\n        \n        if not torch.distributed.is_initialized():\n            torch.distributed.init_process_group(\"nccl\")\n        if not model_parallel_is_initialized():\n            if model_parallel_size is None:\n                model_parallel_size = int(os.environ.get(\"WORLD_SIZE\", 1))\n            initialize_model_parallel(model_parallel_size)\n\n        local_rank = int(os.environ.get(\"LOCAL_RANK\", 0))\n        torch.cuda.set_device(local_rank)\n\n        # seed must be the same in all processes\n        torch.manual_seed(seed)\n\n        if local_rank > 0:\n            sys.stdout = open(os.devnull, \"w\")\n\n        start_time = time.time()\n        checkpoints = sorted(Path(ckpt_dir).glob(\"*.pth\"))\n        assert len(checkpoints) > 0, f\"no checkpoint files found in {ckpt_dir}\"\n        assert model_parallel_size == len(\n            checkpoints\n        ), f\"Loading a checkpoint for MP={len(checkpoints)} but world size is {model_parallel_size}\"\n        ckpt_path = checkpoints[get_model_parallel_rank()]\n        checkpoint = torch.load(ckpt_path, map_location=\"cpu\")\n        with open(Path(ckpt_dir) / \"params.json\", \"r\") as f:\n            params = json.loads(f.read())\n\n        model_args: ModelArgs = ModelArgs(\n            max_seq_len=max_seq_len,\n            max_batch_size=max_batch_size,\n            **params,\n        )\n        tokenizer = Tokenizer(model_path=tokenizer_path)\n        assert model_args.vocab_size == tokenizer.n_words\n        if torch.cuda.is_bf16_supported():\n            torch.set_default_tensor_type(torch.cuda.BFloat16Tensor)\n        else:\n            torch.set_default_tensor_type(torch.cuda.HalfTensor)\n        model = Transformer(model_args)\n        model.load_state_dict(checkpoint, strict=False)\n        print(f\"Loaded in {time.time() - start_time:.2f} seconds\")\n\n        return Llama(model, tokenizer)", "label": 0}
{"function": "        def application(*args):\n            request = cls(args[-2])\n            with request:\n                return f(*args[:-2] + (request,))(*args[-2:])", "label": 1}
{"function": "async def test_complex_inputs():\n    \"\"\"Test the complex inputs server\"\"\"\n    from examples.fastmcp.complex_inputs import mcp\n\n    async with client_session(mcp._mcp_server) as client:\n        tank = {\"shrimp\": [{\"name\": \"bob\"}, {\"name\": \"alice\"}]}\n        result = await client.call_tool(\"name_shrimp\", {\"tank\": tank, \"extra_names\": [\"charlie\"]})\n        assert len(result.content) == 3\n        assert isinstance(result.content[0], TextContent)\n        assert isinstance(result.content[1], TextContent)\n        assert isinstance(result.content[2], TextContent)\n        assert result.content[0].text == \"bob\"\n        assert result.content[1].text == \"alice\"\n        assert result.content[2].text == \"charlie\"", "label": 0}
{"function": "    def __init__(self):\n        self.chat = MagicMock()\n        self.chat.completions = MagicMock()", "label": 0}
{"function": "def load_image_from_base64(image):\n    return Image.open(BytesIO(base64.b64decode(image)))", "label": 0}
{"function": "    def test_get_signal_signal_wrong_data_shape_dim0(self):\n        s = self.signal\n        s = s.transpose(signal_axes=0)\n        with pytest.raises(ValueError):\n            s._get_signal_signal(data=np.asarray(0))", "label": 1}
{"function": "    def __init__(self, host='localhost', port=9876):\n        self.host = host\n        self.port = port\n        self.running = False\n        self.socket = None\n        self.server_thread = None", "label": 0}
{"function": "def main(\n    device: str = \"cuda\" if torch.cuda.is_available() else \"cpu\",\n    offload: bool = False,\n    output_dir: str = \"output\",\n    track_usage: bool = False,\n):\n    torch_device = torch.device(device)\n    names = list(configs.keys())\n    name = st.selectbox(\"Which model to load?\", names)\n    if name is None or not st.checkbox(\"Load model\", False):\n        return\n\n    is_schnell = name == \"flux-schnell\"\n    model, ae, t5, clip, nsfw_classifier = get_models(\n        name,\n        device=torch_device,\n        offload=offload,\n        is_schnell=is_schnell,\n    )\n\n    do_img2img = (\n        st.checkbox(\n            \"Image to Image\",\n            False,\n            disabled=is_schnell,\n            help=\"Partially noise an image and denoise again to get variations.\\n\\nOnly works for flux-dev\",\n        )\n        and not is_schnell\n    )\n    if do_img2img:\n        init_image = get_image()\n        if init_image is None:\n            st.warning(\"Please add an image to do image to image\")\n        image2image_strength = st.number_input(\"Noising strength\", min_value=0.0, max_value=1.0, value=0.8)\n        if init_image is not None:\n            h, w = init_image.shape[-2:]\n            st.write(f\"Got image of size {w}x{h} ({h * w / 1e6:.2f}MP)\")\n        resize_img = st.checkbox(\"Resize image\", False) or init_image is None\n    else:\n        init_image = None\n        resize_img = True\n        image2image_strength = 0.0\n\n    # allow for packing and conversion to latent space\n    width = int(\n        16 * (st.number_input(\"Width\", min_value=128, value=1360, step=16, disabled=not resize_img) // 16)\n    )\n    height = int(\n        16 * (st.number_input(\"Height\", min_value=128, value=768, step=16, disabled=not resize_img) // 16)\n    )\n    num_steps = int(st.number_input(\"Number of steps\", min_value=1, value=(4 if is_schnell else 50)))\n    guidance = float(st.number_input(\"Guidance\", min_value=1.0, value=3.5, disabled=is_schnell))\n    seed_str = st.text_input(\"Seed\", disabled=is_schnell)\n    if seed_str.isdecimal():\n        seed = int(seed_str)\n    else:\n        st.info(\"No seed set, set to positive integer to enable\")\n        seed = None\n    save_samples = st.checkbox(\"Save samples?\", not is_schnell)\n    add_sampling_metadata = st.checkbox(\"Add sampling parameters to metadata?\", True)\n\n    default_prompt = (\n        \"a photo of a forest with mist swirling around the tree trunks. The word \"\n        '\"FLUX\" is painted over it in big, red brush strokes with visible texture'\n    )\n    prompt = st_keyup(\"Enter a prompt\", value=default_prompt, debounce=300, key=\"interactive_text\")\n\n    output_name = os.path.join(output_dir, \"img_{idx}.jpg\")\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n        idx = 0\n    else:\n        fns = [fn for fn in iglob(output_name.format(idx=\"*\")) if re.search(r\"img_[0-9]+\\.jpg$\", fn)]\n        if len(fns) > 0:\n            idx = max(int(fn.split(\"_\")[-1].split(\".\")[0]) for fn in fns) + 1\n        else:\n            idx = 0\n\n    rng = torch.Generator(device=\"cpu\")\n\n    if \"seed\" not in st.session_state:\n        st.session_state.seed = rng.seed()\n\n    def increment_counter():\n        st.session_state.seed += 1\n\n    def decrement_counter():\n        if st.session_state.seed > 0:\n            st.session_state.seed -= 1\n\n    opts = SamplingOptions(\n        prompt=prompt,\n        width=width,\n        height=height,\n        num_steps=num_steps,\n        guidance=guidance,\n        seed=seed,\n    )\n\n    if name == \"flux-schnell\":\n        cols = st.columns([5, 1, 1, 5])\n        with cols[1]:\n            st.button(\"\u21a9\", on_click=increment_counter)\n        with cols[2]:\n            st.button(\"\u21aa\", on_click=decrement_counter)\n    if is_schnell or st.button(\"Sample\"):\n        if is_schnell:\n            opts.seed = st.session_state.seed\n        elif opts.seed is None:\n            opts.seed = rng.seed()\n        print(f\"Generating '{opts.prompt}' with seed {opts.seed}\")\n        t0 = time.perf_counter()\n\n        if init_image is not None:\n            if resize_img:\n                init_image = torch.nn.functional.interpolate(init_image, (opts.height, opts.width))\n            else:\n                h, w = init_image.shape[-2:]\n                init_image = init_image[..., : 16 * (h // 16), : 16 * (w // 16)]\n                opts.height = init_image.shape[-2]\n                opts.width = init_image.shape[-1]\n            if offload:\n                ae.encoder.to(torch_device)\n            init_image = ae.encode(init_image.to(torch_device))\n            if offload:\n                ae = ae.cpu()\n                torch.cuda.empty_cache()\n\n        # prepare input\n        x = get_noise(\n            1,\n            opts.height,\n            opts.width,\n            device=torch_device,\n            dtype=torch.bfloat16,\n            seed=opts.seed,\n        )\n        # divide pixel space by 16**2 to account for latent space conversion\n        timesteps = get_schedule(\n            opts.num_steps,\n            (x.shape[-1] * x.shape[-2]) // 4,\n            shift=(not is_schnell),\n        )\n        if init_image is not None:\n            t_idx = int((1 - image2image_strength) * num_steps)\n            t = timesteps[t_idx]\n            timesteps = timesteps[t_idx:]\n            x = t * x + (1.0 - t) * init_image.to(x.dtype)\n\n        if offload:\n            t5, clip = t5.to(torch_device), clip.to(torch_device)\n        inp = prepare(t5=t5, clip=clip, img=x, prompt=opts.prompt)\n\n        # offload TEs to CPU, load model to gpu\n        if offload:\n            t5, clip = t5.cpu(), clip.cpu()\n            torch.cuda.empty_cache()\n            model = model.to(torch_device)\n\n        # denoise initial noise\n        x = denoise(model, **inp, timesteps=timesteps, guidance=opts.guidance)\n\n        # offload model, load autoencoder to gpu\n        if offload:\n            model.cpu()\n            torch.cuda.empty_cache()\n            ae.decoder.to(x.device)\n\n        # decode latents to pixel space\n        x = unpack(x.float(), opts.height, opts.width)\n        with torch.autocast(device_type=torch_device.type, dtype=torch.bfloat16):\n            x = ae.decode(x)\n\n        if offload:\n            ae.decoder.cpu()\n            torch.cuda.empty_cache()\n\n        t1 = time.perf_counter()\n\n        fn = output_name.format(idx=idx)\n        print(f\"Done in {t1 - t0:.1f}s.\")\n        # bring into PIL format and save\n        x = x.clamp(-1, 1)\n        x = embed_watermark(x.float())\n        x = rearrange(x[0], \"c h w -> h w c\")\n\n        img = Image.fromarray((127.5 * (x + 1.0)).cpu().byte().numpy())\n        nsfw_score = [x[\"score\"] for x in nsfw_classifier(img) if x[\"label\"] == \"nsfw\"][0]\n\n        if nsfw_score < NSFW_THRESHOLD:\n            buffer = BytesIO()\n            exif_data = Image.Exif()\n            if init_image is None:\n                exif_data[ExifTags.Base.Software] = \"AI generated;txt2img;flux\"\n            else:\n                exif_data[ExifTags.Base.Software] = \"AI generated;img2img;flux\"\n            exif_data[ExifTags.Base.Make] = \"Black Forest Labs\"\n            exif_data[ExifTags.Base.Model] = name\n            if add_sampling_metadata:\n                exif_data[ExifTags.Base.ImageDescription] = prompt\n            img.save(buffer, format=\"jpeg\", exif=exif_data, quality=95, subsampling=0)\n\n            img_bytes = buffer.getvalue()\n            if save_samples:\n                print(f\"Saving {fn}\")\n                with open(fn, \"wb\") as file:\n                    file.write(img_bytes)\n                idx += 1\n            if track_usage:\n                track_usage_via_api(name, 1)\n\n            st.session_state[\"samples\"] = {\n                \"prompt\": opts.prompt,\n                \"img\": img,\n                \"seed\": opts.seed,\n                \"bytes\": img_bytes,\n            }\n            opts.seed = None\n        else:\n            st.warning(\"Your generated image may contain NSFW content.\")\n            st.session_state[\"samples\"] = None\n\n    samples = st.session_state.get(\"samples\", None)\n    if samples is not None:\n        st.image(samples[\"img\"], caption=samples[\"prompt\"])\n        st.download_button(\n            \"Download full-resolution\",\n            samples[\"bytes\"],\n            file_name=\"generated.jpg\",\n            mime=\"image/jpg\",\n        )\n        st.write(f\"Seed: {samples['seed']}\")", "label": 0}
{"function": "    def end_before(self, key=None, **kwargs):\n        \"\"\"End document before this point\"\"\"\n        if key:\n            self._end_before = self._firestore_doc(key)\n        else:\n            self._end_before = self._fields_by_column_name(**kwargs)\n        return self", "label": 1}
{"function": "def get_twitter_cache_path() -> str:\n    \"\"\"\n    Gets the path to the Twitter cache file.\n\n    Returns:\n        path (str): The path to the Twitter cache folder\n    \"\"\"\n    return os.path.join(get_cache_path(), 'twitter.json')", "label": 0}
{"function": "    def test_fetch(self, n='test_fetch'):\n        c = compat.Consumer(self.connection, queue=n, exchange=n,\n                            routing_key='rkey')\n        assert c.fetch() is None\n        assert c.fetch(no_ack=True) is None\n        assert 'basic_get' in c.backend\n\n        callback_called = [False]\n\n        def receive(payload, message):\n            callback_called[0] = True\n\n        c.backend.to_deliver.append('42')\n        payload = c.fetch().payload\n        assert payload == '42'\n        c.backend.to_deliver.append('46')\n        c.register_callback(receive)\n        assert c.fetch(enable_callbacks=True).payload == '46'\n        assert callback_called[0]", "label": 1}
{"function": "def get_current_temperature_v2(\n    location: str, unit: TemperatureUnit = TemperatureUnit.CELSIUS\n) -> Dict[str, str]:\n    \"\"\"Gets the current temperature for a specific location and unit (with enum support).\"\"\"\n    return {\"location\": location, \"unit\": unit, \"temperature\": \"72\"}", "label": 0}
{"function": "def sec_to_hm_str(t):\n    \"\"\"Convert time in seconds to a nice string\n    e.g. 10239 -> '02h50m39s'\n    \"\"\"\n    h, m, s = sec_to_hm(t)\n    return \"{:02d}h{:02d}m{:02d}s\".format(h, m, s)", "label": 1}
{"function": "def tearDownModule():\n    global mol, Gvbase, Gv, gxyz\n    del mol, Gvbase, Gv, gxyz", "label": 1}
{"function": "    def generate_image(\n        self,\n        width,\n        height,\n        num_steps,\n        guidance,\n        seed,\n        prompt,\n        init_image=None,\n        image2image_strength=0.0,\n        add_sampling_metadata=True,\n    ):\n        seed = int(seed)\n        if seed == -1:\n            seed = None\n\n        opts = SamplingOptions(\n            prompt=prompt,\n            width=width,\n            height=height,\n            num_steps=num_steps,\n            guidance=guidance,\n            seed=seed,\n        )\n\n        if opts.seed is None:\n            opts.seed = torch.Generator(device=\"cpu\").seed()\n        print(f\"Generating '{opts.prompt}' with seed {opts.seed}\")\n        t0 = time.perf_counter()\n\n        if init_image is not None:\n            if isinstance(init_image, np.ndarray):\n                init_image = torch.from_numpy(init_image).permute(2, 0, 1).float() / 255.0\n                init_image = init_image.unsqueeze(0)\n            init_image = init_image.to(self.device)\n            init_image = torch.nn.functional.interpolate(init_image, (opts.height, opts.width))\n            if self.offload:\n                self.ae.encoder.to(self.device)\n            init_image = self.ae.encode(init_image.to())\n            if self.offload:\n                self.ae = self.ae.cpu()\n                torch.cuda.empty_cache()\n\n        # prepare input\n        x = get_noise(\n            1,\n            opts.height,\n            opts.width,\n            device=self.device,\n            dtype=torch.bfloat16,\n            seed=opts.seed,\n        )\n        timesteps = get_schedule(\n            opts.num_steps,\n            x.shape[-1] * x.shape[-2] // 4,\n            shift=(not self.is_schnell),\n        )\n        if init_image is not None:\n            t_idx = int((1 - image2image_strength) * num_steps)\n            t = timesteps[t_idx]\n            timesteps = timesteps[t_idx:]\n            x = t * x + (1.0 - t) * init_image.to(x.dtype)\n\n        if self.offload:\n            self.t5, self.clip = self.t5.to(self.device), self.clip.to(self.device)\n        inp = prepare(t5=self.t5, clip=self.clip, img=x, prompt=opts.prompt)\n\n        # offload TEs to CPU, load model to gpu\n        if self.offload:\n            self.t5, self.clip = self.t5.cpu(), self.clip.cpu()\n            torch.cuda.empty_cache()\n            self.model = self.model.to(self.device)\n\n        # denoise initial noise\n        x = denoise(self.model, **inp, timesteps=timesteps, guidance=opts.guidance)\n\n        # offload model, load autoencoder to gpu\n        if self.offload:\n            self.model.cpu()\n            torch.cuda.empty_cache()\n            self.ae.decoder.to(x.device)\n\n        # decode latents to pixel space\n        x = unpack(x.float(), opts.height, opts.width)\n        with torch.autocast(device_type=self.device.type, dtype=torch.bfloat16):\n            x = self.ae.decode(x)\n\n        if self.offload:\n            self.ae.decoder.cpu()\n            torch.cuda.empty_cache()\n\n        t1 = time.perf_counter()\n\n        print(f\"Done in {t1 - t0:.1f}s.\")\n        # bring into PIL format\n        x = x.clamp(-1, 1)\n        x = embed_watermark(x.float())\n        x = rearrange(x[0], \"c h w -> h w c\")\n\n        img = Image.fromarray((127.5 * (x + 1.0)).cpu().byte().numpy())\n        nsfw_score = [x[\"score\"] for x in self.nsfw_classifier(img) if x[\"label\"] == \"nsfw\"][0]\n\n        if nsfw_score < NSFW_THRESHOLD:\n            filename = f\"output/gradio/{uuid.uuid4()}.jpg\"\n            os.makedirs(os.path.dirname(filename), exist_ok=True)\n            exif_data = Image.Exif()\n            if init_image is None:\n                exif_data[ExifTags.Base.Software] = \"AI generated;txt2img;flux\"\n            else:\n                exif_data[ExifTags.Base.Software] = \"AI generated;img2img;flux\"\n            exif_data[ExifTags.Base.Make] = \"Black Forest Labs\"\n            exif_data[ExifTags.Base.Model] = self.model_name\n            if add_sampling_metadata:\n                exif_data[ExifTags.Base.ImageDescription] = prompt\n            img.save(filename, format=\"jpeg\", exif=exif_data, quality=95, subsampling=0)\n\n            if self.track_usage:\n                track_usage_via_api(self.model_name, 1)\n\n            return img, str(opts.seed), filename, None\n        else:\n            return None, str(opts.seed), None, \"Your generated image may contain NSFW content.\"", "label": 0}
{"function": "def main(uri):\n    # type: (Text) -> None\n    api = StrictIota(uri)\n\n    try:\n        node_info = api.get_node_info()\n    except NetworkError as e:\n        print(\n            \"Hm.  {uri} isn't responding; is the node running?\".format(uri=uri)\n        )\n        print(e)\n    except BadApiResponse as e:\n        print(\"Looks like {uri} isn't very talkative today ):\".format(uri=uri))\n        print(e)\n    else:\n        print('Hello {uri}!'.format(uri=uri))\n        pprint(node_info)", "label": 1}
{"function": "def format_flake8_output(\n    input_string: str,\n    show_line_numbers: bool = False,\n    *,\n    previous_errors_string: str = \"\",\n    replacement_window: Optional[Tuple[int, int]] = None,\n    replacement_n_lines: Optional[int] = None,\n) -> str:\n    \"\"\"Filter flake8 output for previous errors and print it for a given file.\n\n    Args:\n        input_string: The flake8 output as a string\n        show_line_numbers: Whether to show line numbers in the output\n        previous_errors_string: The previous errors as a string\n        replacement_window: The window of the edit (lines that will be replaced)\n        replacement_n_lines: The number of lines used to replace the text\n\n    Returns:\n        The filtered flake8 output as a string\n    \"\"\"\n    errors = [Flake8Error.from_line(line.strip()) for line in input_string.split(\"\\n\") if line.strip()]\n    # print(f\"New errors before filtering: {errors=}\")\n    lines = []\n    if previous_errors_string:\n        assert replacement_window is not None\n        assert replacement_n_lines is not None\n        previous_errors = [\n            Flake8Error.from_line(line.strip()) for line in previous_errors_string.split(\"\\n\") if line.strip()\n        ]\n        # print(f\"Previous errors before updating: {previous_errors=}\")\n        previous_errors = _update_previous_errors(previous_errors, replacement_window, replacement_n_lines)\n        # print(f\"Previous errors after updating: {previous_errors=}\")\n        errors = [error for error in errors if error not in previous_errors]\n        # Sometimes new errors appear above the replacement window that were 'shadowed' by the previous errors\n        # they still clearly aren't caused by the edit.\n        errors = [error for error in errors if error.line_number >= replacement_window[0]]\n        # print(f\"New errors after filtering: {errors=}\")\n    for error in errors:\n        if not show_line_numbers:\n            lines.append(f\"- {error.problem}\")\n        else:\n            lines.append(f\"- line {error.line_number} col {error.col_number}: {error.problem}\")\n    return \"\\n\".join(lines)", "label": 0}
{"function": "    def _create_or_update_initial(\n            self, resource_group_name, ip_groups_name, parameters, custom_headers=None, raw=False, **operation_config):\n        # Construct URL\n        url = self.create_or_update.metadata['url']\n        path_format_arguments = {\n            'resourceGroupName': self._serialize.url(\"resource_group_name\", resource_group_name, 'str'),\n            'ipGroupsName': self._serialize.url(\"ip_groups_name\", ip_groups_name, 'str'),\n            'subscriptionId': self._serialize.url(\"self.config.subscription_id\", self.config.subscription_id, 'str')\n        }\n        url = self._client.format_url(url, **path_format_arguments)\n\n        # Construct parameters\n        query_parameters = {}\n        query_parameters['api-version'] = self._serialize.query(\"self.api_version\", self.api_version, 'str')\n\n        # Construct headers\n        header_parameters = {}\n        header_parameters['Accept'] = 'application/json'\n        header_parameters['Content-Type'] = 'application/json; charset=utf-8'\n        if self.config.generate_client_request_id:\n            header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())\n        if custom_headers:\n            header_parameters.update(custom_headers)\n        if self.config.accept_language is not None:\n            header_parameters['accept-language'] = self._serialize.header(\"self.config.accept_language\", self.config.accept_language, 'str')\n\n        # Construct body\n        body_content = self._serialize.body(parameters, 'IpGroup')\n\n        # Construct and send request\n        request = self._client.put(url, query_parameters, header_parameters, body_content)\n        response = self._client.send(request, stream=False, **operation_config)\n\n        if response.status_code not in [200, 201]:\n            raise models.ErrorException(self._deserialize, response)\n\n        deserialized = None\n\n        if response.status_code == 200:\n            deserialized = self._deserialize('IpGroup', response)\n        if response.status_code == 201:\n            deserialized = self._deserialize('IpGroup', response)\n\n        if raw:\n            client_raw_response = ClientRawResponse(deserialized, response)\n            return client_raw_response\n\n        return deserialized", "label": 1}
{"function": "def test_lazy_load(loader_with_dummy):\n    \"\"\"Test that lazy_load yields Document objects with the correct dummy content and metadata.\"\"\"\n    docs = list(loader_with_dummy.lazy_load())\n    assert len(docs) == 2\n    for doc, url in zip(docs, loader_with_dummy.urls):\n        assert isinstance(doc, Document)\n        assert f\"dummy content for {url}\" in doc.page_content\n        assert doc.metadata[\"source\"] == url", "label": 0}
{"function": "async def test_graph_advanced(storage):\n    \"\"\"\n    \u6d4b\u8bd5\u56fe\u6570\u636e\u5e93\u7684\u9ad8\u7ea7\u64cd\u4f5c:\n    1. \u4f7f\u7528 node_degree \u83b7\u53d6\u8282\u70b9\u7684\u5ea6\u6570\n    2. \u4f7f\u7528 edge_degree \u83b7\u53d6\u8fb9\u7684\u5ea6\u6570\n    3. \u4f7f\u7528 get_node_edges \u83b7\u53d6\u8282\u70b9\u7684\u6240\u6709\u8fb9\n    4. \u4f7f\u7528 get_all_labels \u83b7\u53d6\u6240\u6709\u6807\u7b7e\n    5. \u4f7f\u7528 get_knowledge_graph \u83b7\u53d6\u77e5\u8bc6\u56fe\u8c31\n    6. \u4f7f\u7528 delete_node \u5220\u9664\u8282\u70b9\n    7. \u4f7f\u7528 remove_nodes \u6279\u91cf\u5220\u9664\u8282\u70b9\n    8. \u4f7f\u7528 remove_edges \u5220\u9664\u8fb9\n    9. \u4f7f\u7528 drop \u6e05\u7406\u6570\u636e\n    \"\"\"\n    try:\n        # 1. \u63d2\u5165\u6d4b\u8bd5\u6570\u636e\n        # \u63d2\u5165\u8282\u70b91: \u4eba\u5de5\u667a\u80fd\n        node1_id = \"\u4eba\u5de5\u667a\u80fd\"\n        node1_data = {\n            \"entity_id\": node1_id,\n            \"description\": \"\u4eba\u5de5\u667a\u80fd\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u4e00\u4e2a\u5206\u652f\uff0c\u5b83\u4f01\u56fe\u4e86\u89e3\u667a\u80fd\u7684\u5b9e\u8d28\uff0c\u5e76\u751f\u4ea7\u51fa\u4e00\u79cd\u65b0\u7684\u80fd\u4ee5\u4eba\u7c7b\u667a\u80fd\u76f8\u4f3c\u7684\u65b9\u5f0f\u505a\u51fa\u53cd\u5e94\u7684\u667a\u80fd\u673a\u5668\u3002\",\n            \"keywords\": \"AI,\u673a\u5668\u5b66\u4e60,\u6df1\u5ea6\u5b66\u4e60\",\n            \"entity_type\": \"\u6280\u672f\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8282\u70b91: {node1_id}\")\n        await storage.upsert_node(node1_id, node1_data)\n\n        # \u63d2\u5165\u8282\u70b92: \u673a\u5668\u5b66\u4e60\n        node2_id = \"\u673a\u5668\u5b66\u4e60\"\n        node2_data = {\n            \"entity_id\": node2_id,\n            \"description\": \"\u673a\u5668\u5b66\u4e60\u662f\u4eba\u5de5\u667a\u80fd\u7684\u4e00\u4e2a\u5206\u652f\uff0c\u5b83\u4f7f\u7528\u7edf\u8ba1\u5b66\u65b9\u6cd5\u8ba9\u8ba1\u7b97\u673a\u7cfb\u7edf\u5728\u4e0d\u88ab\u660e\u786e\u7f16\u7a0b\u7684\u60c5\u51b5\u4e0b\u4e5f\u80fd\u591f\u5b66\u4e60\u3002\",\n            \"keywords\": \"\u76d1\u7763\u5b66\u4e60,\u65e0\u76d1\u7763\u5b66\u4e60,\u5f3a\u5316\u5b66\u4e60\",\n            \"entity_type\": \"\u6280\u672f\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8282\u70b92: {node2_id}\")\n        await storage.upsert_node(node2_id, node2_data)\n\n        # \u63d2\u5165\u8282\u70b93: \u6df1\u5ea6\u5b66\u4e60\n        node3_id = \"\u6df1\u5ea6\u5b66\u4e60\"\n        node3_data = {\n            \"entity_id\": node3_id,\n            \"description\": \"\u6df1\u5ea6\u5b66\u4e60\u662f\u673a\u5668\u5b66\u4e60\u7684\u4e00\u4e2a\u5206\u652f\uff0c\u5b83\u4f7f\u7528\u591a\u5c42\u795e\u7ecf\u7f51\u7edc\u6765\u6a21\u62df\u4eba\u8111\u7684\u5b66\u4e60\u8fc7\u7a0b\u3002\",\n            \"keywords\": \"\u795e\u7ecf\u7f51\u7edc,CNN,RNN\",\n            \"entity_type\": \"\u6280\u672f\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8282\u70b93: {node3_id}\")\n        await storage.upsert_node(node3_id, node3_data)\n\n        # \u63d2\u5165\u8fb91: \u4eba\u5de5\u667a\u80fd -> \u673a\u5668\u5b66\u4e60\n        edge1_data = {\n            \"relationship\": \"\u5305\u542b\",\n            \"weight\": 1.0,\n            \"description\": \"\u4eba\u5de5\u667a\u80fd\u9886\u57df\u5305\u542b\u673a\u5668\u5b66\u4e60\u8fd9\u4e2a\u5b50\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8fb91: {node1_id} -> {node2_id}\")\n        await storage.upsert_edge(node1_id, node2_id, edge1_data)\n\n        # \u63d2\u5165\u8fb92: \u673a\u5668\u5b66\u4e60 -> \u6df1\u5ea6\u5b66\u4e60\n        edge2_data = {\n            \"relationship\": \"\u5305\u542b\",\n            \"weight\": 1.0,\n            \"description\": \"\u673a\u5668\u5b66\u4e60\u9886\u57df\u5305\u542b\u6df1\u5ea6\u5b66\u4e60\u8fd9\u4e2a\u5b50\u9886\u57df\",\n        }\n        print(f\"\u63d2\u5165\u8fb92: {node2_id} -> {node3_id}\")\n        await storage.upsert_edge(node2_id, node3_id, edge2_data)\n\n        # 2. \u6d4b\u8bd5 node_degree - \u83b7\u53d6\u8282\u70b9\u7684\u5ea6\u6570\n        print(f\"== \u6d4b\u8bd5 node_degree: {node1_id}\")\n        node1_degree = await storage.node_degree(node1_id)\n        print(f\"\u8282\u70b9 {node1_id} \u7684\u5ea6\u6570: {node1_degree}\")\n        assert node1_degree == 1, f\"\u8282\u70b9 {node1_id} \u7684\u5ea6\u6570\u5e94\u4e3a1\uff0c\u5b9e\u9645\u4e3a {node1_degree}\"\n\n        # 2.1 \u6d4b\u8bd5\u6240\u6709\u8282\u70b9\u7684\u5ea6\u6570\n        print(\"== \u6d4b\u8bd5\u6240\u6709\u8282\u70b9\u7684\u5ea6\u6570\")\n        node2_degree = await storage.node_degree(node2_id)\n        node3_degree = await storage.node_degree(node3_id)\n        print(f\"\u8282\u70b9 {node2_id} \u7684\u5ea6\u6570: {node2_degree}\")\n        print(f\"\u8282\u70b9 {node3_id} \u7684\u5ea6\u6570: {node3_degree}\")\n        assert node2_degree == 2, f\"\u8282\u70b9 {node2_id} \u7684\u5ea6\u6570\u5e94\u4e3a2\uff0c\u5b9e\u9645\u4e3a {node2_degree}\"\n        assert node3_degree == 1, f\"\u8282\u70b9 {node3_id} \u7684\u5ea6\u6570\u5e94\u4e3a1\uff0c\u5b9e\u9645\u4e3a {node3_degree}\"\n\n        # 3. \u6d4b\u8bd5 edge_degree - \u83b7\u53d6\u8fb9\u7684\u5ea6\u6570\n        print(f\"== \u6d4b\u8bd5 edge_degree: {node1_id} -> {node2_id}\")\n        edge_degree = await storage.edge_degree(node1_id, node2_id)\n        print(f\"\u8fb9 {node1_id} -> {node2_id} \u7684\u5ea6\u6570: {edge_degree}\")\n        assert (\n            edge_degree == 3\n        ), f\"\u8fb9 {node1_id} -> {node2_id} \u7684\u5ea6\u6570\u5e94\u4e3a3\uff0c\u5b9e\u9645\u4e3a {edge_degree}\"\n\n        # 3.1 \u6d4b\u8bd5\u53cd\u5411\u8fb9\u7684\u5ea6\u6570 - \u9a8c\u8bc1\u65e0\u5411\u56fe\u7279\u6027\n        print(f\"== \u6d4b\u8bd5\u53cd\u5411\u8fb9\u7684\u5ea6\u6570: {node2_id} -> {node1_id}\")\n        reverse_edge_degree = await storage.edge_degree(node2_id, node1_id)\n        print(f\"\u53cd\u5411\u8fb9 {node2_id} -> {node1_id} \u7684\u5ea6\u6570: {reverse_edge_degree}\")\n        assert (\n            edge_degree == reverse_edge_degree\n        ), \"\u6b63\u5411\u8fb9\u548c\u53cd\u5411\u8fb9\u7684\u5ea6\u6570\u4e0d\u4e00\u81f4\uff0c\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u5931\u8d25\"\n        print(\"\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u6210\u529f\uff1a\u6b63\u5411\u8fb9\u548c\u53cd\u5411\u8fb9\u7684\u5ea6\u6570\u4e00\u81f4\")\n\n        # 4. \u6d4b\u8bd5 get_node_edges - \u83b7\u53d6\u8282\u70b9\u7684\u6240\u6709\u8fb9\n        print(f\"== \u6d4b\u8bd5 get_node_edges: {node2_id}\")\n        node2_edges = await storage.get_node_edges(node2_id)\n        print(f\"\u8282\u70b9 {node2_id} \u7684\u6240\u6709\u8fb9: {node2_edges}\")\n        assert (\n            len(node2_edges) == 2\n        ), f\"\u8282\u70b9 {node2_id} \u5e94\u67092\u6761\u8fb9\uff0c\u5b9e\u9645\u6709 {len(node2_edges)}\"\n\n        # 4.1 \u9a8c\u8bc1\u8282\u70b9\u8fb9\u7684\u65e0\u5411\u56fe\u7279\u6027\n        print(\"== \u9a8c\u8bc1\u8282\u70b9\u8fb9\u7684\u65e0\u5411\u56fe\u7279\u6027\")\n        # \u68c0\u67e5\u662f\u5426\u5305\u542b\u4e0enode1\u548cnode3\u7684\u8fde\u63a5\u5173\u7cfb\uff08\u65e0\u8bba\u65b9\u5411\uff09\n        has_connection_with_node1 = False\n        has_connection_with_node3 = False\n        for edge in node2_edges:\n            # \u68c0\u67e5\u662f\u5426\u6709\u4e0enode1\u7684\u8fde\u63a5\uff08\u65e0\u8bba\u65b9\u5411\uff09\n            if (edge[0] == node1_id and edge[1] == node2_id) or (\n                edge[0] == node2_id and edge[1] == node1_id\n            ):\n                has_connection_with_node1 = True\n            # \u68c0\u67e5\u662f\u5426\u6709\u4e0enode3\u7684\u8fde\u63a5\uff08\u65e0\u8bba\u65b9\u5411\uff09\n            if (edge[0] == node2_id and edge[1] == node3_id) or (\n                edge[0] == node3_id and edge[1] == node2_id\n            ):\n                has_connection_with_node3 = True\n\n        assert (\n            has_connection_with_node1\n        ), f\"\u8282\u70b9 {node2_id} \u7684\u8fb9\u5217\u8868\u4e2d\u5e94\u5305\u542b\u4e0e {node1_id} \u7684\u8fde\u63a5\"\n        assert (\n            has_connection_with_node3\n        ), f\"\u8282\u70b9 {node2_id} \u7684\u8fb9\u5217\u8868\u4e2d\u5e94\u5305\u542b\u4e0e {node3_id} \u7684\u8fde\u63a5\"\n        print(f\"\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u6210\u529f\uff1a\u8282\u70b9 {node2_id} \u7684\u8fb9\u5217\u8868\u5305\u542b\u6240\u6709\u76f8\u5173\u7684\u8fb9\")\n\n        # 5. \u6d4b\u8bd5 get_all_labels - \u83b7\u53d6\u6240\u6709\u6807\u7b7e\n        print(\"== \u6d4b\u8bd5 get_all_labels\")\n        all_labels = await storage.get_all_labels()\n        print(f\"\u6240\u6709\u6807\u7b7e: {all_labels}\")\n        assert len(all_labels) == 3, f\"\u5e94\u67093\u4e2a\u6807\u7b7e\uff0c\u5b9e\u9645\u6709 {len(all_labels)}\"\n        assert node1_id in all_labels, f\"{node1_id} \u5e94\u5728\u6807\u7b7e\u5217\u8868\u4e2d\"\n        assert node2_id in all_labels, f\"{node2_id} \u5e94\u5728\u6807\u7b7e\u5217\u8868\u4e2d\"\n        assert node3_id in all_labels, f\"{node3_id} \u5e94\u5728\u6807\u7b7e\u5217\u8868\u4e2d\"\n\n        # 6. \u6d4b\u8bd5 get_knowledge_graph - \u83b7\u53d6\u77e5\u8bc6\u56fe\u8c31\n        print(\"== \u6d4b\u8bd5 get_knowledge_graph\")\n        kg = await storage.get_knowledge_graph(\"*\", max_depth=2, max_nodes=10)\n        print(f\"\u77e5\u8bc6\u56fe\u8c31\u8282\u70b9\u6570: {len(kg.nodes)}\")\n        print(f\"\u77e5\u8bc6\u56fe\u8c31\u8fb9\u6570: {len(kg.edges)}\")\n        assert isinstance(kg, KnowledgeGraph), \"\u8fd4\u56de\u7ed3\u679c\u5e94\u4e3a KnowledgeGraph \u7c7b\u578b\"\n        assert len(kg.nodes) == 3, f\"\u77e5\u8bc6\u56fe\u8c31\u5e94\u67093\u4e2a\u8282\u70b9\uff0c\u5b9e\u9645\u6709 {len(kg.nodes)}\"\n        assert len(kg.edges) == 2, f\"\u77e5\u8bc6\u56fe\u8c31\u5e94\u67092\u6761\u8fb9\uff0c\u5b9e\u9645\u6709 {len(kg.edges)}\"\n\n        # 7. \u6d4b\u8bd5 delete_node - \u5220\u9664\u8282\u70b9\n        print(f\"== \u6d4b\u8bd5 delete_node: {node3_id}\")\n        await storage.delete_node(node3_id)\n        node3_props = await storage.get_node(node3_id)\n        print(f\"\u5220\u9664\u540e\u67e5\u8be2\u8282\u70b9\u5c5e\u6027 {node3_id}: {node3_props}\")\n        assert node3_props is None, f\"\u8282\u70b9 {node3_id} \u5e94\u5df2\u88ab\u5220\u9664\"\n\n        # \u91cd\u65b0\u63d2\u5165\u8282\u70b93\u7528\u4e8e\u540e\u7eed\u6d4b\u8bd5\n        await storage.upsert_node(node3_id, node3_data)\n        await storage.upsert_edge(node2_id, node3_id, edge2_data)\n\n        # 8. \u6d4b\u8bd5 remove_edges - \u5220\u9664\u8fb9\n        print(f\"== \u6d4b\u8bd5 remove_edges: {node2_id} -> {node3_id}\")\n        await storage.remove_edges([(node2_id, node3_id)])\n        edge_props = await storage.get_edge(node2_id, node3_id)\n        print(f\"\u5220\u9664\u540e\u67e5\u8be2\u8fb9\u5c5e\u6027 {node2_id} -> {node3_id}: {edge_props}\")\n        assert edge_props is None, f\"\u8fb9 {node2_id} -> {node3_id} \u5e94\u5df2\u88ab\u5220\u9664\"\n\n        # 8.1 \u9a8c\u8bc1\u5220\u9664\u8fb9\u7684\u65e0\u5411\u56fe\u7279\u6027\n        print(f\"== \u9a8c\u8bc1\u5220\u9664\u8fb9\u7684\u65e0\u5411\u56fe\u7279\u6027: {node3_id} -> {node2_id}\")\n        reverse_edge_props = await storage.get_edge(node3_id, node2_id)\n        print(f\"\u5220\u9664\u540e\u67e5\u8be2\u53cd\u5411\u8fb9\u5c5e\u6027 {node3_id} -> {node2_id}: {reverse_edge_props}\")\n        assert (\n            reverse_edge_props is None\n        ), f\"\u53cd\u5411\u8fb9 {node3_id} -> {node2_id} \u4e5f\u5e94\u88ab\u5220\u9664\uff0c\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u5931\u8d25\"\n        print(\"\u65e0\u5411\u56fe\u7279\u6027\u9a8c\u8bc1\u6210\u529f\uff1a\u5220\u9664\u4e00\u4e2a\u65b9\u5411\u7684\u8fb9\u540e\uff0c\u53cd\u5411\u8fb9\u4e5f\u88ab\u5220\u9664\")\n\n        # 9. \u6d4b\u8bd5 remove_nodes - \u6279\u91cf\u5220\u9664\u8282\u70b9\n        print(f\"== \u6d4b\u8bd5 remove_nodes: [{node2_id}, {node3_id}]\")\n        await storage.remove_nodes([node2_id, node3_id])\n        node2_props = await storage.get_node(node2_id)\n        node3_props = await storage.get_node(node3_id)\n        print(f\"\u5220\u9664\u540e\u67e5\u8be2\u8282\u70b9\u5c5e\u6027 {node2_id}: {node2_props}\")\n        print(f\"\u5220\u9664\u540e\u67e5\u8be2\u8282\u70b9\u5c5e\u6027 {node3_id}: {node3_props}\")\n        assert node2_props is None, f\"\u8282\u70b9 {node2_id} \u5e94\u5df2\u88ab\u5220\u9664\"\n        assert node3_props is None, f\"\u8282\u70b9 {node3_id} \u5e94\u5df2\u88ab\u5220\u9664\"\n\n        print(\"\\n\u9ad8\u7ea7\u6d4b\u8bd5\u5b8c\u6210\")\n        return True\n\n    except Exception as e:\n        ASCIIColors.red(f\"\u6d4b\u8bd5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u9519\u8bef: {str(e)}\")\n        return False", "label": 0}
{"function": "def print_banner() -> None:\n    \"\"\"\n    Prints the introductory ASCII Art Banner.\n\n    Returns:\n        None\n    \"\"\"\n    with open(f\"{ROOT_DIR}/assets/banner.txt\", \"r\") as file:\n        print(colored(file.read(), \"green\"))", "label": 0}
{"function": "def run(\n        weights=ROOT / 'yolo.pt',  # model path or triton URL\n        source=ROOT / 'data/images',  # file/dir/URL/glob/screen/0(webcam)\n        data=ROOT / 'data/coco.yaml',  # dataset.yaml path\n        imgsz=(640, 640),  # inference size (height, width)\n        conf_thres=0.25,  # confidence threshold\n        iou_thres=0.45,  # NMS IOU threshold\n        max_det=1000,  # maximum detections per image\n        device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n        view_img=False,  # show results\n        save_txt=False,  # save results to *.txt\n        save_conf=False,  # save confidences in --save-txt labels\n        save_crop=False,  # save cropped prediction boxes\n        nosave=False,  # do not save images/videos\n        classes=None,  # filter by class: --class 0, or --class 0 2 3\n        agnostic_nms=False,  # class-agnostic NMS\n        augment=False,  # augmented inference\n        visualize=False,  # visualize features\n        update=False,  # update all models\n        project=ROOT / 'runs/detect',  # save results to project/name\n        name='exp',  # save results to project/name\n        exist_ok=False,  # existing project/name ok, do not increment\n        line_thickness=3,  # bounding box thickness (pixels)\n        hide_labels=False,  # hide labels\n        hide_conf=False,  # hide confidences\n        half=False,  # use FP16 half-precision inference\n        dnn=False,  # use OpenCV DNN for ONNX inference\n        vid_stride=1,  # video frame-rate stride\n):\n    source = str(source)\n    save_img = not nosave and not source.endswith('.txt')  # save inference images\n    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)\n    is_url = source.lower().startswith(('rtsp://', 'rtmp://', 'http://', 'https://'))\n    webcam = source.isnumeric() or source.endswith('.txt') or (is_url and not is_file)\n    screenshot = source.lower().startswith('screen')\n    if is_url and is_file:\n        source = check_file(source)  # download\n\n    # Directories\n    save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n    (save_dir / 'labels' if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n\n    # Load model\n    device = select_device(device)\n    model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n    stride, names, pt = model.stride, model.names, model.pt\n    imgsz = check_img_size(imgsz, s=stride)  # check image size\n\n    # Dataloader\n    bs = 1  # batch_size\n    if webcam:\n        view_img = check_imshow(warn=True)\n        dataset = LoadStreams(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n        bs = len(dataset)\n    elif screenshot:\n        dataset = LoadScreenshots(source, img_size=imgsz, stride=stride, auto=pt)\n    else:\n        dataset = LoadImages(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n    vid_path, vid_writer = [None] * bs, [None] * bs\n\n    # Run inference\n    model.warmup(imgsz=(1 if pt or model.triton else bs, 3, *imgsz))  # warmup\n    seen, windows, dt = 0, [], (Profile(), Profile(), Profile())\n    for path, im, im0s, vid_cap, s in dataset:\n        with dt[0]:\n            im = torch.from_numpy(im).to(model.device)\n            im = im.half() if model.fp16 else im.float()  # uint8 to fp16/32\n            im /= 255  # 0 - 255 to 0.0 - 1.0\n            if len(im.shape) == 3:\n                im = im[None]  # expand for batch dim\n\n        # Inference\n        with dt[1]:\n            visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False\n            pred = model(im, augment=augment, visualize=visualize)\n\n        # NMS\n        with dt[2]:\n            pred = non_max_suppression(pred, conf_thres, iou_thres, classes, agnostic_nms, max_det=max_det)\n\n        # Second-stage classifier (optional)\n        # pred = utils.general.apply_classifier(pred, classifier_model, im, im0s)\n\n        # Process predictions\n        for i, det in enumerate(pred):  # per image\n            seen += 1\n            if webcam:  # batch_size >= 1\n                p, im0, frame = path[i], im0s[i].copy(), dataset.count\n                s += f'{i}: '\n            else:\n                p, im0, frame = path, im0s.copy(), getattr(dataset, 'frame', 0)\n\n            p = Path(p)  # to Path\n            save_path = str(save_dir / p.name)  # im.jpg\n            txt_path = str(save_dir / 'labels' / p.stem) + ('' if dataset.mode == 'image' else f'_{frame}')  # im.txt\n            s += '%gx%g ' % im.shape[2:]  # print string\n            gn = torch.tensor(im0.shape)[[1, 0, 1, 0]]  # normalization gain whwh\n            imc = im0.copy() if save_crop else im0  # for save_crop\n            annotator = Annotator(im0, line_width=line_thickness, example=str(names))\n            if len(det):\n                # Rescale boxes from img_size to im0 size\n                det[:, :4] = scale_boxes(im.shape[2:], det[:, :4], im0.shape).round()\n\n                # Print results\n                for c in det[:, 5].unique():\n                    n = (det[:, 5] == c).sum()  # detections per class\n                    s += f\"{n} {names[int(c)]}{'s' * (n > 1)}, \"  # add to string\n\n                # Write results\n                for *xyxy, conf, cls in reversed(det):\n                    if save_txt:  # Write to file\n                        xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n                        line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n                        with open(f'{txt_path}.txt', 'a') as f:\n                            f.write(('%g ' * len(line)).rstrip() % line + '\\n')\n\n                    if save_img or save_crop or view_img:  # Add bbox to image\n                        c = int(cls)  # integer class\n                        label = None if hide_labels else (names[c] if hide_conf else f'{names[c]} {conf:.2f}')\n                        annotator.box_label(xyxy, label, color=colors(c, True))\n                    if save_crop:\n                        save_one_box(xyxy, imc, file=save_dir / 'crops' / names[c] / f'{p.stem}.jpg', BGR=True)\n\n            # Stream results\n            im0 = annotator.result()\n            if view_img:\n                if platform.system() == 'Linux' and p not in windows:\n                    windows.append(p)\n                    cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)\n                    cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])\n                cv2.imshow(str(p), im0)\n                cv2.waitKey(1)  # 1 millisecond\n\n            # Save results (image with detections)\n            if save_img:\n                if dataset.mode == 'image':\n                    cv2.imwrite(save_path, im0)\n                else:  # 'video' or 'stream'\n                    if vid_path[i] != save_path:  # new video\n                        vid_path[i] = save_path\n                        if isinstance(vid_writer[i], cv2.VideoWriter):\n                            vid_writer[i].release()  # release previous video writer\n                        if vid_cap:  # video\n                            fps = vid_cap.get(cv2.CAP_PROP_FPS)\n                            w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n                            h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n                        else:  # stream\n                            fps, w, h = 30, im0.shape[1], im0.shape[0]\n                        save_path = str(Path(save_path).with_suffix('.mp4'))  # force *.mp4 suffix on results videos\n                        vid_writer[i] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*'mp4v'), fps, (w, h))\n                    vid_writer[i].write(im0)\n\n        # Print time (inference-only)\n        LOGGER.info(f\"{s}{'' if len(det) else '(no detections), '}{dt[1].dt * 1E3:.1f}ms\")\n\n    # Print results\n    t = tuple(x.t / seen * 1E3 for x in dt)  # speeds per image\n    LOGGER.info(f'Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {(1, 3, *imgsz)}' % t)\n    if save_txt or save_img:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else ''\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    if update:\n        strip_optimizer(weights[0])  # update model (to fix SourceChangeWarning)", "label": 0}
{"function": "def extract_glb(\n    state: dict,\n    mesh_simplify: float,\n    texture_size: int,\n    req: gr.Request,\n) -> Tuple[str, str]:\n    \"\"\"\n    Extract a GLB file from the 3D model.\n\n    Args:\n        state (dict): The state of the generated 3D model.\n        mesh_simplify (float): The mesh simplification factor.\n        texture_size (int): The texture resolution.\n\n    Returns:\n        str: The path to the extracted GLB file.\n    \"\"\"\n    user_dir = os.path.join(TMP_DIR, str(req.session_hash))\n    gs, mesh = unpack_state(state)\n    glb = postprocessing_utils.to_glb(gs, mesh, simplify=mesh_simplify, texture_size=texture_size, verbose=False)\n    glb_path = os.path.join(user_dir, 'sample.glb')\n    glb.export(glb_path)\n    torch.cuda.empty_cache()\n    return glb_path, glb_path", "label": 0}
{"function": "def symbol_by_name(patching):\n    return patching('thorn.environment.django.symbol_by_name')", "label": 1}
{"function": "async def get_online_instances():\n    \"\"\"\n    Check which secondme models are available for chatting online.\n    \"\"\"\n    url = \"https://app.secondme.io/api/upload/list?page_size=100\"\n    response = requests.get(url)\n\n    if response.status_code == 200:\n        data = response.json()\n        items = data.get(\"data\", {}).get(\"items\", [])\n\n        online_items = [\n            {\n                \"upload_name\": item[\"upload_name\"],\n                \"instance_id\": item[\"instance_id\"],\n                \"description\": item[\"description\"]\n            }\n            for item in items if item.get(\"status\") == \"online\"\n        ]\n\n        return json.dumps(online_items, ensure_ascii=False, indent=2)\n    else:\n        raise Exception(f\"Request failed with status code: {response.status_code}\")", "label": 0}
{"function": "async def test_exclude_default_entity_type():\n    \"\"\"Test excluding the default 'Entity' type while keeping custom types.\"\"\"\n    graphiti = Graphiti(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD)\n\n    try:\n        await graphiti.build_indices_and_constraints()\n\n        # Define entity types but exclude the default 'Entity' type\n        entity_types = {\n            'Person': Person,\n            'Organization': Organization,\n        }\n\n        # Add an episode that would normally create both Entity and custom type entities\n        episode_content = (\n            'John Smith works at Acme Corporation in New York. The weather is nice today.'\n        )\n\n        result = await graphiti.add_episode(\n            name='Business Meeting',\n            episode_body=episode_content,\n            source_description='Meeting notes',\n            reference_time=datetime.now(timezone.utc),\n            entity_types=entity_types,\n            excluded_entity_types=['Entity'],  # Exclude default type\n            group_id='test_exclude_default',\n        )\n\n        # Verify that nodes were created (custom types should still work)\n        assert result is not None\n\n        # Search for nodes to verify only custom types were created\n        search_results = await graphiti.search_(\n            query='John Smith Acme Corporation', group_ids=['test_exclude_default']\n        )\n\n        # Check that entities were created but with specific types, not default 'Entity'\n        found_nodes = search_results.nodes\n        for node in found_nodes:\n            assert 'Entity' in node.labels  # All nodes should have Entity label\n            # But they should also have specific type labels\n            assert any(label in ['Person', 'Organization'] for label in node.labels), (\n                f'Node {node.name} should have a specific type label, got: {node.labels}'\n            )\n\n        # Clean up\n        await _cleanup_test_nodes(graphiti, 'test_exclude_default')\n\n    finally:\n        await graphiti.close()", "label": 0}
{"function": "    def prep(self, shared):\n        repo_url = shared.get(\"repo_url\")\n        local_dir = shared.get(\"local_dir\")\n        project_name = shared.get(\"project_name\")\n\n        if not project_name:\n            # Basic name derivation from URL or directory\n            if repo_url:\n                project_name = repo_url.split(\"/\")[-1].replace(\".git\", \"\")\n            else:\n                project_name = os.path.basename(os.path.abspath(local_dir))\n            shared[\"project_name\"] = project_name\n\n        # Get file patterns directly from shared\n        include_patterns = shared[\"include_patterns\"]\n        exclude_patterns = shared[\"exclude_patterns\"]\n        max_file_size = shared[\"max_file_size\"]\n\n        return {\n            \"repo_url\": repo_url,\n            \"local_dir\": local_dir,\n            \"token\": shared.get(\"github_token\"),\n            \"include_patterns\": include_patterns,\n            \"exclude_patterns\": exclude_patterns,\n            \"max_file_size\": max_file_size,\n            \"use_relative_paths\": True,\n        }", "label": 0}
{"function": "def _warn_if_string(iterable):\n    \"\"\"Helper for the response objects to check if the iterable returned\n    to the WSGI server is not a string.\n    \"\"\"\n    if isinstance(iterable, string_types):\n        from warnings import warn\n        warn(Warning('response iterable was set to a string.  This appears '\n                     'to work but means that the server will send the '\n                     'data to the client char, by char.  This is almost '\n                     'never intended behavior, use response.data to assign '\n                     'strings to the response object.'), stacklevel=2)", "label": 1}
{"function": "    def generate(\n        self,\n        text: str,\n        speaker: int,\n        context: List[Segment],\n        max_audio_length_ms: float = 90_000,\n        temperature: float = 0.9,\n        topk: int = 50,\n    ) -> torch.Tensor:\n        self._model.reset_caches()\n\n        max_generation_len = int(max_audio_length_ms / 80)\n        tokens, tokens_mask = [], []\n        for segment in context:\n            segment_tokens, segment_tokens_mask = self._tokenize_segment(segment)\n            tokens.append(segment_tokens)\n            tokens_mask.append(segment_tokens_mask)\n\n        gen_segment_tokens, gen_segment_tokens_mask = self._tokenize_text_segment(text, speaker)\n        tokens.append(gen_segment_tokens)\n        tokens_mask.append(gen_segment_tokens_mask)\n\n        prompt_tokens = torch.cat(tokens, dim=0).long().to(self.device)\n        prompt_tokens_mask = torch.cat(tokens_mask, dim=0).bool().to(self.device)\n\n        samples = []\n        curr_tokens = prompt_tokens.unsqueeze(0)\n        curr_tokens_mask = prompt_tokens_mask.unsqueeze(0)\n        curr_pos = torch.arange(0, prompt_tokens.size(0)).unsqueeze(0).long().to(self.device)\n\n        max_seq_len = 2048\n        max_context_len = max_seq_len - max_generation_len\n        if curr_tokens.size(1) >= max_context_len:\n            raise ValueError(\n                f\"Inputs too long, must be below max_seq_len - max_generation_len: {max_context_len}\"\n            )\n\n        for _ in range(max_generation_len):\n            sample = self._model.generate_frame(curr_tokens, curr_tokens_mask, curr_pos, temperature, topk)\n            if torch.all(sample == 0):\n                break  # eos\n\n            samples.append(sample)\n\n            curr_tokens = torch.cat([sample, torch.zeros(1, 1).long().to(self.device)], dim=1).unsqueeze(1)\n            curr_tokens_mask = torch.cat(\n                [torch.ones_like(sample).bool(), torch.zeros(1, 1).bool().to(self.device)], dim=1\n            ).unsqueeze(1)\n            curr_pos = curr_pos[:, -1:] + 1\n\n        audio = self._audio_tokenizer.decode(torch.stack(samples).permute(1, 2, 0)).squeeze(0).squeeze(0)\n\n        # This applies an imperceptible watermark to identify audio as AI-generated.\n        # Watermarking ensures transparency, dissuades misuse, and enables traceability.\n        # Please be a responsible AI citizen and keep the watermarking in place.\n        # If using CSM 1B in another application, use your own private key and keep it secret.\n        audio, wm_sample_rate = watermark(self._watermarker, audio, self.sample_rate, CSM_1B_GH_WATERMARK)\n        audio = torchaudio.functional.resample(audio, orig_freq=wm_sample_rate, new_freq=self.sample_rate)\n\n        return audio", "label": 0}
{"function": "def _GatherNdGrad(unused_op, unused_grad):\n  raise NotImplementedError(\"Gradient for gather_nd is not implemented.\")", "label": 1}
{"function": "    async def run_interactive(self) -> None:\n        \"\"\"Run the agent in interactive mode.\"\"\"\n        print(\"\\nMCP Agent Interactive Mode (type 'exit' to quit)\\n\")\n        while True:\n            user_input = input(\"\\nEnter your request: \")\n            if user_input.lower() in [\"exit\", \"quit\", \"q\"]:\n                break\n            response = await self.agent.run(user_input)\n            print(f\"\\nAgent: {response}\")", "label": 0}
{"function": "def InParentNamespaceEnd(builder): return builder.EndObject()", "label": 1}
{"function": "def weight_dequant_kernel(x_ptr, s_ptr, y_ptr, M, N, BLOCK_SIZE: tl.constexpr):\n    \"\"\"\n    Dequantizes weights using the provided scaling factors and stores the result.\n\n    Args:\n        x_ptr (tl.pointer): Pointer to the quantized weights.\n        s_ptr (tl.pointer): Pointer to the scaling factors.\n        y_ptr (tl.pointer): Pointer to the output buffer for dequantized weights.\n        M (int): Number of rows in the weight matrix.\n        N (int): Number of columns in the weight matrix.\n        BLOCK_SIZE (tl.constexpr): Size of the block for tiling.\n\n    Returns:\n        None\n    \"\"\"\n    pid_m = tl.program_id(axis=0)\n    pid_n = tl.program_id(axis=1)\n    n = tl.cdiv(N, BLOCK_SIZE)\n    offs_m = pid_m * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    offs_n = pid_n * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    offs = offs_m[:, None] * N + offs_n[None, :]\n    mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    x = tl.load(x_ptr + offs, mask=mask).to(tl.float32)\n    s = tl.load(s_ptr + pid_m * n + pid_n)\n    y = x * s\n    tl.store(y_ptr + offs, y, mask=mask)", "label": 0}
{"function": "    def accept_license_terms(user_id: int, license_id: int):\n        \"\"\" Saves the fact user has accepted license terms \"\"\"\n        user = UserService.get_user_by_id(user_id)\n        user.accept_license_terms(license_id)", "label": 1}
{"function": "def _add_outer_none(shape):\n    \"\"\"\n    Add None as an outer dimension for the shape.\n    \"\"\"\n    if isinstance(shape, tf.TensorShape):\n        return [None] + shape.dims\n    return [None, shape]", "label": 1}
{"function": "    def get_scene_info(self):\n        \"\"\"Get information about the current Blender scene\"\"\"\n        try:\n            print(\"Getting scene info...\")\n            # Simplify the scene info to reduce data size\n            scene_info = {\n                \"name\": bpy.context.scene.name,\n                \"object_count\": len(bpy.context.scene.objects),\n                \"objects\": [],\n                \"materials_count\": len(bpy.data.materials),\n            }\n            \n            # Collect minimal object information (limit to first 10 objects)\n            for i, obj in enumerate(bpy.context.scene.objects):\n                if i >= 10:  # Reduced from 20 to 10\n                    break\n                    \n                obj_info = {\n                    \"name\": obj.name,\n                    \"type\": obj.type,\n                    # Only include basic location data\n                    \"location\": [round(float(obj.location.x), 2), \n                                round(float(obj.location.y), 2), \n                                round(float(obj.location.z), 2)],\n                }\n                scene_info[\"objects\"].append(obj_info)\n            \n            print(f\"Scene info collected: {len(scene_info['objects'])} objects\")\n            return scene_info\n        except Exception as e:\n            print(f\"Error in get_scene_info: {str(e)}\")\n            traceback.print_exc()\n            return {\"error\": str(e)}", "label": 0}
{"function": "    def __init__(\n        self,\n        model: Model,\n    ):\n        self._model = model\n        self._model.setup_caches(1)\n\n        self._text_tokenizer = load_llama3_tokenizer()\n\n        device = next(model.parameters()).device\n        mimi_weight = hf_hub_download(loaders.DEFAULT_REPO, loaders.MIMI_NAME)\n        mimi = loaders.get_mimi(mimi_weight, device=device)\n        mimi.set_num_codebooks(32)\n        self._audio_tokenizer = mimi\n\n        self._watermarker = load_watermarker(device=device)\n\n        self.sample_rate = mimi.sample_rate\n        self.device = device", "label": 0}
{"function": "def process_single_video(video_path: Path,\n                         output_dir: Path,\n                         image_processor: ImageProcessorForDataProcessing,\n                         audio_processor: AudioProcessor,\n                         step: int) -> None:\n    \"\"\"\n    Process a single video file.\n\n    Args:\n        video_path (Path): Path to the video file.\n        output_dir (Path): Directory to save the output.\n        image_processor (ImageProcessorForDataProcessing): Image processor object.\n        audio_processor (AudioProcessor): Audio processor object.\n        gpu_status (bool): Whether to use GPU for processing.\n    \"\"\"\n    assert video_path.exists(), f\"Video path {video_path} does not exist\"\n    dirs = setup_directories(video_path)\n    logging.info(f\"Processing video: {video_path}\")\n\n    try:\n        if step == 1:\n            images_output_dir = output_dir / 'images' / video_path.stem\n            images_output_dir.mkdir(parents=True, exist_ok=True)\n            images_output_dir = convert_video_to_images(\n                video_path, images_output_dir)\n            logging.info(f\"Images saved to: {images_output_dir}\")\n\n            audio_output_dir = output_dir / 'audios'\n            audio_output_dir.mkdir(parents=True, exist_ok=True)\n            audio_output_path = audio_output_dir / f'{video_path.stem}.wav'\n            audio_output_path = extract_audio_from_videos(\n                video_path, audio_output_path)\n            logging.info(f\"Audio extracted to: {audio_output_path}\")\n\n            face_mask, _, sep_pose_mask, sep_face_mask, sep_lip_mask = image_processor.preprocess(\n                images_output_dir)\n            cv2.imwrite(\n                str(dirs[\"face_mask\"] / f\"{video_path.stem}.png\"), face_mask)\n            cv2.imwrite(str(dirs[\"sep_pose_mask\"] /\n                        f\"{video_path.stem}.png\"), sep_pose_mask)\n            cv2.imwrite(str(dirs[\"sep_face_mask\"] /\n                        f\"{video_path.stem}.png\"), sep_face_mask)\n            cv2.imwrite(str(dirs[\"sep_lip_mask\"] /\n                        f\"{video_path.stem}.png\"), sep_lip_mask)\n        else:\n            images_dir = output_dir / \"images\" / video_path.stem\n            audio_path = output_dir / \"audios\" / f\"{video_path.stem}.wav\"\n            _, face_emb, _, _, _ = image_processor.preprocess(images_dir)\n            torch.save(face_emb, str(\n                dirs[\"face_emb\"] / f\"{video_path.stem}.pt\"))\n            audio_emb, _ = audio_processor.preprocess(audio_path)\n            torch.save(audio_emb, str(\n                dirs[\"audio_emb\"] / f\"{video_path.stem}.pt\"))\n    except Exception as e:\n        logging.error(f\"Failed to process video {video_path}: {e}\")", "label": 0}
{"function": "    def test_from_array_shape_mismatch(surv_arrays):\n        event, time = surv_arrays\n\n        msg = \"Found input variables with inconsistent numbers of samples\"\n        with pytest.raises(ValueError, match=msg):\n            Surv.from_arrays(event[1:], time)\n\n        with pytest.raises(ValueError, match=msg):\n            Surv.from_arrays(event, time[1:])", "label": 1}
{"function": "def post_build():\n  git_add_files('PKGBUILD')\n  git_commit()", "label": 1}
{"function": "    def training_step(engine, _):\n        data = torch.rand(4, 100, device=device)\n        model.train()\n        data = data.to(device)\n        optimizer.zero_grad()\n        output = model(data)\n        loss = output.sum()\n        loss.backward()\n        xm.optimizer_step(optimizer, barrier=True)\n        return loss.item()", "label": 1}
{"function": "def expand_question_into_multimodal(question_text, image_token_len, im_st_token, im_ed_token, im_patch_token):\n    if '<image>' in question_text[0]['content']:\n        question_text[0]['content'] = question_text[0]['content'].replace(\n            '<image>', im_st_token + im_patch_token * image_token_len + im_ed_token)\n    else:\n        question_text[0]['content'] = im_st_token + im_patch_token * \\\n            image_token_len + im_ed_token + '\\n' + question_text[0]['content']\n    return question_text", "label": 0}
{"function": "def layout_predictor() -> LayoutPredictor:\n    layout_predictor = LayoutPredictor()\n    yield layout_predictor\n    del layout_predictor", "label": 0}
{"function": "async def test_simple_echo():\n    \"\"\"Test the simple echo server\"\"\"\n    from examples.fastmcp.simple_echo import mcp\n\n    async with client_session(mcp._mcp_server) as client:\n        result = await client.call_tool(\"echo\", {\"text\": \"hello\"})\n        assert len(result.content) == 1\n        content = result.content[0]\n        assert isinstance(content, TextContent)\n        assert content.text == \"hello\"", "label": 0}
{"function": "async def test_delete_file(computer):\n    tmp_path = \"test_delete_file.txt\"\n    await computer.interface.write_text(tmp_path, \"bye\")\n    exists = await computer.interface.file_exists(tmp_path)\n    assert exists is True, \"File should exist\"\n    await computer.interface.delete_file(tmp_path)\n    exists = await computer.interface.file_exists(tmp_path)\n    assert exists is False, \"File should not exist\"", "label": 0}
{"function": "    def handle(self, *args, **options):\n        Site.objects.update_or_create(\n            id=settings.SITE_ID,\n            defaults={\n                'domain': settings.HOST_NAME,\n                'name': settings.SITE_NAME\n            }\n        )", "label": 1}
{"function": "def create_resume_pdf_job_tailored(parameters: dict, llm_api_key: str):\n    \"\"\"\n    Logic to create a CV.\n    \"\"\"\n    try:\n        logger.info(\"Generating a CV based on provided parameters.\")\n\n        # Carica il resume in testo semplice\n        with open(parameters[\"uploads\"][\"plainTextResume\"], \"r\", encoding=\"utf-8\") as file:\n            plain_text_resume = file.read()\n\n        style_manager = StyleManager()\n        available_styles = style_manager.get_styles()\n\n        if not available_styles:\n            logger.warning(\"No styles available. Proceeding without style selection.\")\n        else:\n            # Present style choices to the user\n            choices = style_manager.format_choices(available_styles)\n            questions = [\n                inquirer.List(\n                    \"style\",\n                    message=\"Select a style for the resume:\",\n                    choices=choices,\n                )\n            ]\n            style_answer = inquirer.prompt(questions)\n            if style_answer and \"style\" in style_answer:\n                selected_choice = style_answer[\"style\"]\n                for style_name, (file_name, author_link) in available_styles.items():\n                    if selected_choice.startswith(style_name):\n                        style_manager.set_selected_style(style_name)\n                        logger.info(f\"Selected style: {style_name}\")\n                        break\n            else:\n                logger.warning(\"No style selected. Proceeding with default style.\")\n        questions = [inquirer.Text('job_url', message=\"Please enter the URL of the job description:\")]\n        answers = inquirer.prompt(questions)\n        job_url = answers.get('job_url')\n        resume_generator = ResumeGenerator()\n        resume_object = Resume(plain_text_resume)\n        driver = init_browser()\n        resume_generator.set_resume_object(resume_object)\n        resume_facade = ResumeFacade(            \n            api_key=llm_api_key,\n            style_manager=style_manager,\n            resume_generator=resume_generator,\n            resume_object=resume_object,\n            output_path=Path(\"data_folder/output\"),\n        )\n        resume_facade.set_driver(driver)\n        resume_facade.link_to_job(job_url)\n        result_base64, suggested_name = resume_facade.create_resume_pdf_job_tailored()         \n\n        # Decodifica Base64 in dati binari\n        try:\n            pdf_data = base64.b64decode(result_base64)\n        except base64.binascii.Error as e:\n            logger.error(\"Error decoding Base64: %s\", e)\n            raise\n\n        # Definisci il percorso della cartella di output utilizzando `suggested_name`\n        output_dir = Path(parameters[\"outputFileDirectory\"]) / suggested_name\n\n        # Crea la cartella se non esiste\n        try:\n            output_dir.mkdir(parents=True, exist_ok=True)\n            logger.info(f\"Cartella di output creata o gi\u00e0 esistente: {output_dir}\")\n        except IOError as e:\n            logger.error(\"Error creating output directory: %s\", e)\n            raise\n        \n        output_path = output_dir / \"resume_tailored.pdf\"\n        try:\n            with open(output_path, \"wb\") as file:\n                file.write(pdf_data)\n            logger.info(f\"CV salvato in: {output_path}\")\n        except IOError as e:\n            logger.error(\"Error writing file: %s\", e)\n            raise\n    except Exception as e:\n        logger.exception(f\"An error occurred while creating the CV: {e}\")\n        raise", "label": 0}
{"function": "def deps_list(*pkgs):\n    return [deps[pkg] for pkg in pkgs]", "label": 0}
{"function": "def setup_logging():\n    \"\"\"Fixture to set up logging for all tests.\n\n    We want to propagate to the root logger so that\n    pytest caplog can capture logs, and we can test\n    logging for the default oumi logger.\n    \"\"\"\n    logger = get_logger(\"oumi\")\n    logger.propagate = True\n    return logger", "label": 0}
{"function": "def download_single_file(\n    url: str,\n    *,\n    model_dir: str,\n    progress: bool = True,\n    file_name: str | None = None,\n    hash_prefix: str | None = None,\n) -> str:\n    os.makedirs(model_dir, exist_ok=True)\n    if not file_name:\n        from urllib.parse import urlparse\n        parts = urlparse(url)\n        file_name = os.path.basename(parts.path)\n    cached_file = os.path.abspath(os.path.join(model_dir, file_name))\n    if not os.path.exists(cached_file):\n        tmp_filename = cached_file + '.tmp'\n        print(f'Downloading: \"{url}\" to {cached_file} using temp file {tmp_filename}\\n')\n        from torch.hub import download_url_to_file\n        download_url_to_file(url, tmp_filename, progress=progress, hash_prefix=hash_prefix)\n        os.replace(tmp_filename, cached_file)\n    return cached_file", "label": 0}
{"function": "    def __init__(self, output_file, sampling_rate):\n        super().__init__()\n        self.output_file = output_file\n        self.sampling_rate = sampling_rate\n        self.queue = queue.Queue()\n        self.stop_event = threading.Event()\n        self.audio_data = []", "label": 0}
{"function": "def get_csv_paths():\n    # Define the directory you want to search\n    directory = Path(\"./tests/data/csv/\")\n\n    # List all CSV files in the directory and its subdirectories\n    return sorted(directory.rglob(\"*.csv\"))", "label": 0}
{"function": "    def norm2bytes(value):\n        return value.encode() if isinstance(value, str) and six.PY3 else value", "label": 1}
{"function": "    def get_mapped_projects(user_name: str, preferred_locale: str):\n        \"\"\" Gets all projects a user has mapped or validated on \"\"\"\n        user = UserService.get_user_by_username(user_name)\n        return User.get_mapped_projects(user.id, preferred_locale)", "label": 1}
{"function": "async def run_mcp() -> None:\n    \"\"\"Main entry point for the MCP runner.\"\"\"\n    args = parse_args()\n    runner = MCPRunner()\n\n    try:\n        await runner.initialize(args.connection, args.server_url)\n\n        if args.prompt:\n            await runner.run_single_prompt(args.prompt)\n        elif args.interactive:\n            await runner.run_interactive()\n        else:\n            await runner.run_default()\n\n    except KeyboardInterrupt:\n        logger.info(\"Program interrupted by user\")\n    except Exception as e:\n        logger.error(f\"Error running MCPAgent: {str(e)}\", exc_info=True)\n        sys.exit(1)\n    finally:\n        await runner.cleanup()", "label": 0}
{"function": "    def digest(self):\n        return mysql323.encrypt(self._data[:64]).decode('hex')", "label": 1}
{"function": "    def exec(self, prep_res):\n        (\n            context,\n            file_listing_for_prompt,\n            file_count,\n            project_name,\n            language,\n            use_cache,\n            max_abstraction_num,\n        ) = prep_res  # Unpack all parameters\n        print(f\"Identifying abstractions using LLM...\")\n\n        # Add language instruction and hints only if not English\n        language_instruction = \"\"\n        name_lang_hint = \"\"\n        desc_lang_hint = \"\"\n        if language.lower() != \"english\":\n            language_instruction = f\"IMPORTANT: Generate the `name` and `description` for each abstraction in **{language.capitalize()}** language. Do NOT use English for these fields.\\n\\n\"\n            # Keep specific hints here as name/description are primary targets\n            name_lang_hint = f\" (value in {language.capitalize()})\"\n            desc_lang_hint = f\" (value in {language.capitalize()})\"\n\n        prompt = f\"\"\"\nFor the project `{project_name}`:\n\nCodebase Context:\n{context}\n\n{language_instruction}Analyze the codebase context.\nIdentify the top 5-{max_abstraction_num} core most important abstractions to help those new to the codebase.\n\nFor each abstraction, provide:\n1. A concise `name`{name_lang_hint}.\n2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words{desc_lang_hint}.\n3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.\n\nList of file indices and paths present in the context:\n{file_listing_for_prompt}\n\nFormat the output as a YAML list of dictionaries:\n\n```yaml\n- name: |\n    Query Processing{name_lang_hint}\n  description: |\n    Explains what the abstraction does.\n    It's like a central dispatcher routing requests.{desc_lang_hint}\n  file_indices:\n    - 0 # path/to/file1.py\n    - 3 # path/to/related.py\n- name: |\n    Query Optimization{name_lang_hint}\n  description: |\n    Another core concept, similar to a blueprint for objects.{desc_lang_hint}\n  file_indices:\n    - 5 # path/to/another.js\n# ... up to {max_abstraction_num} abstractions\n```\"\"\"\n        response = call_llm(prompt, use_cache=(use_cache and self.cur_retry == 0))  # Use cache only if enabled and not retrying\n\n        # --- Validation ---\n        yaml_str = response.strip().split(\"```yaml\")[1].split(\"```\")[0].strip()\n        abstractions = yaml.safe_load(yaml_str)\n\n        if not isinstance(abstractions, list):\n            raise ValueError(\"LLM Output is not a list\")\n\n        validated_abstractions = []\n        for item in abstractions:\n            if not isinstance(item, dict) or not all(\n                k in item for k in [\"name\", \"description\", \"file_indices\"]\n            ):\n                raise ValueError(f\"Missing keys in abstraction item: {item}\")\n            if not isinstance(item[\"name\"], str):\n                raise ValueError(f\"Name is not a string in item: {item}\")\n            if not isinstance(item[\"description\"], str):\n                raise ValueError(f\"Description is not a string in item: {item}\")\n            if not isinstance(item[\"file_indices\"], list):\n                raise ValueError(f\"file_indices is not a list in item: {item}\")\n\n            # Validate indices\n            validated_indices = []\n            for idx_entry in item[\"file_indices\"]:\n                try:\n                    if isinstance(idx_entry, int):\n                        idx = idx_entry\n                    elif isinstance(idx_entry, str) and \"#\" in idx_entry:\n                        idx = int(idx_entry.split(\"#\")[0].strip())\n                    else:\n                        idx = int(str(idx_entry).strip())\n\n                    if not (0 <= idx < file_count):\n                        raise ValueError(\n                            f\"Invalid file index {idx} found in item {item['name']}. Max index is {file_count - 1}.\"\n                        )\n                    validated_indices.append(idx)\n                except (ValueError, TypeError):\n                    raise ValueError(\n                        f\"Could not parse index from entry: {idx_entry} in item {item['name']}\"\n                    )\n\n            item[\"files\"] = sorted(list(set(validated_indices)))\n            # Store only the required fields\n            validated_abstractions.append(\n                {\n                    \"name\": item[\"name\"],  # Potentially translated name\n                    \"description\": item[\n                        \"description\"\n                    ],  # Potentially translated description\n                    \"files\": item[\"files\"],\n                }\n            )\n\n        print(f\"Identified {len(validated_abstractions)} abstractions.\")\n        return validated_abstractions", "label": 0}
{"function": "    def __init__(self):\n        # pylint: disable=invalid-name\n        self.INSTALLED_APPS += [\"drf_spectacular_sidecar\"]", "label": 0}
{"function": "async def test_jsonrpc_request():\n    json_data = {\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"initialize\",\n        \"params\": {\n            \"protocolVersion\": LATEST_PROTOCOL_VERSION,\n            \"capabilities\": {\"batch\": None, \"sampling\": None},\n            \"clientInfo\": {\"name\": \"mcp\", \"version\": \"0.1.0\"},\n        },\n    }\n\n    request = JSONRPCMessage.model_validate(json_data)\n    assert isinstance(request.root, JSONRPCRequest)\n    ClientRequest.model_validate(request.model_dump(by_alias=True, exclude_none=True))\n\n    assert request.root.jsonrpc == \"2.0\"\n    assert request.root.id == 1\n    assert request.root.method == \"initialize\"\n    assert request.root.params is not None\n    assert request.root.params[\"protocolVersion\"] == LATEST_PROTOCOL_VERSION", "label": 0}
{"function": "    def kv_store(self):\n        \"\"\"Get data store.\"\"\"\n        return self._kv_store", "label": 1}
{"function": "def clean_hifigan_model():\r\n    global hifigan_model\r\n    if hifigan_model:\r\n        hifigan_model = hifigan_model.cpu()\r\n        hifigan_model = None\r\n        try:\r\n            torch.cuda.empty_cache()\r\n        except:\r\n            pass\r", "label": 0}
{"function": "def exception_hook(exctype, value, tb):\n    logger.error(\"\".join(traceback.format_exception(exctype, value, tb)))\n    sys.__excepthook__(exctype, value, tb)  # \u8c03\u7528\u9ed8\u8ba4\u7684\u5f02\u5e38\u5904\u7406", "label": 0}
{"function": "async def main():\n    \"\"\"\u4e3b\u51fd\u6570\"\"\"\n    # \u663e\u793a\u7a0b\u5e8f\u6807\u9898\n    ASCIIColors.cyan(\"\"\"\n    \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551                  \u901a\u7528\u56fe\u5b58\u50a8\u6d4b\u8bd5\u7a0b\u5e8f                          \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \"\"\")\n\n    # \u68c0\u67e5.env\u6587\u4ef6\n    if not check_env_file():\n        return\n\n    # \u52a0\u8f7d\u73af\u5883\u53d8\u91cf\n    load_dotenv(dotenv_path=\".env\", override=False)\n\n    # \u83b7\u53d6\u56fe\u5b58\u50a8\u7c7b\u578b\n    graph_storage_type = os.getenv(\"LIGHTRAG_GRAPH_STORAGE\", \"NetworkXStorage\")\n    ASCIIColors.magenta(f\"\\n\u5f53\u524d\u914d\u7f6e\u7684\u56fe\u5b58\u50a8\u7c7b\u578b: {graph_storage_type}\")\n    ASCIIColors.white(\n        f\"\u652f\u6301\u7684\u56fe\u5b58\u50a8\u7c7b\u578b: {', '.join(STORAGE_IMPLEMENTATIONS['GRAPH_STORAGE']['implementations'])}\"\n    )\n\n    # \u521d\u59cb\u5316\u5b58\u50a8\u5b9e\u4f8b\n    storage = await initialize_graph_storage()\n    if not storage:\n        ASCIIColors.red(\"\u521d\u59cb\u5316\u5b58\u50a8\u5b9e\u4f8b\u5931\u8d25\uff0c\u6d4b\u8bd5\u7a0b\u5e8f\u9000\u51fa\")\n        return\n\n    try:\n        # \u663e\u793a\u6d4b\u8bd5\u9009\u9879\n        ASCIIColors.yellow(\"\\n\u8bf7\u9009\u62e9\u6d4b\u8bd5\u7c7b\u578b:\")\n        ASCIIColors.white(\"1. \u57fa\u672c\u6d4b\u8bd5 (\u8282\u70b9\u548c\u8fb9\u7684\u63d2\u5165\u3001\u8bfb\u53d6)\")\n        ASCIIColors.white(\"2. \u9ad8\u7ea7\u6d4b\u8bd5 (\u5ea6\u6570\u3001\u6807\u7b7e\u3001\u77e5\u8bc6\u56fe\u8c31\u3001\u5220\u9664\u64cd\u4f5c\u7b49)\")\n        ASCIIColors.white(\"3. \u6279\u91cf\u64cd\u4f5c\u6d4b\u8bd5 (\u6279\u91cf\u83b7\u53d6\u8282\u70b9\u3001\u8fb9\u5c5e\u6027\u548c\u5ea6\u6570\u7b49)\")\n        ASCIIColors.white(\"4. \u65e0\u5411\u56fe\u7279\u6027\u6d4b\u8bd5 (\u9a8c\u8bc1\u5b58\u50a8\u7684\u65e0\u5411\u56fe\u7279\u6027)\")\n        ASCIIColors.white(\"5. \u7279\u6b8a\u5b57\u7b26\u6d4b\u8bd5 (\u9a8c\u8bc1\u5355\u5f15\u53f7\u3001\u53cc\u5f15\u53f7\u548c\u53cd\u659c\u6760\u7b49\u7279\u6b8a\u5b57\u7b26)\")\n        ASCIIColors.white(\"6. \u5168\u90e8\u6d4b\u8bd5\")\n\n        choice = input(\"\\n\u8bf7\u8f93\u5165\u9009\u9879 (1/2/3/4/5/6): \")\n\n        # \u5728\u6267\u884c\u6d4b\u8bd5\u524d\u6e05\u7406\u6570\u636e\n        if choice in [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"]:\n            ASCIIColors.yellow(\"\\n\u6267\u884c\u6d4b\u8bd5\u524d\u6e05\u7406\u6570\u636e...\")\n            await storage.drop()\n            ASCIIColors.green(\"\u6570\u636e\u6e05\u7406\u5b8c\u6210\\n\")\n\n        if choice == \"1\":\n            await test_graph_basic(storage)\n        elif choice == \"2\":\n            await test_graph_advanced(storage)\n        elif choice == \"3\":\n            await test_graph_batch_operations(storage)\n        elif choice == \"4\":\n            await test_graph_undirected_property(storage)\n        elif choice == \"5\":\n            await test_graph_special_characters(storage)\n        elif choice == \"6\":\n            ASCIIColors.cyan(\"\\n=== \u5f00\u59cb\u57fa\u672c\u6d4b\u8bd5 ===\")\n            basic_result = await test_graph_basic(storage)\n\n            if basic_result:\n                ASCIIColors.cyan(\"\\n=== \u5f00\u59cb\u9ad8\u7ea7\u6d4b\u8bd5 ===\")\n                advanced_result = await test_graph_advanced(storage)\n\n                if advanced_result:\n                    ASCIIColors.cyan(\"\\n=== \u5f00\u59cb\u6279\u91cf\u64cd\u4f5c\u6d4b\u8bd5 ===\")\n                    batch_result = await test_graph_batch_operations(storage)\n\n                    if batch_result:\n                        ASCIIColors.cyan(\"\\n=== \u5f00\u59cb\u65e0\u5411\u56fe\u7279\u6027\u6d4b\u8bd5 ===\")\n                        undirected_result = await test_graph_undirected_property(\n                            storage\n                        )\n\n                        if undirected_result:\n                            ASCIIColors.cyan(\"\\n=== \u5f00\u59cb\u7279\u6b8a\u5b57\u7b26\u6d4b\u8bd5 ===\")\n                            await test_graph_special_characters(storage)\n        else:\n            ASCIIColors.red(\"\u65e0\u6548\u7684\u9009\u9879\")\n\n    finally:\n        # \u5173\u95ed\u8fde\u63a5\n        if storage:\n            await storage.finalize()\n            ASCIIColors.green(\"\\n\u5b58\u50a8\u8fde\u63a5\u5df2\u5173\u95ed\")", "label": 0}
{"function": "    def __init__(self, kv_store, local_g, partition_book):\n        self._kv_store = kv_store\n        self._graph = local_g\n        self.partition_book = partition_book\n        self._roles = {}", "label": 1}
{"function": "    def imm(self):\n        return self.value.imm", "label": 1}
{"function": "def update_gallery_on_upload(input_video, input_images):\n    \"\"\"\n    Whenever user uploads or changes files, immediately handle them\n    and show in the gallery. Return (target_dir, image_paths).\n    If nothing is uploaded, returns \"None\" and empty list.\n    \"\"\"\n    if not input_video and not input_images:\n        return None, None, None, None\n    target_dir, image_paths = handle_uploads(input_video, input_images)\n    return None, target_dir, image_paths, \"Upload complete. Click 'Reconstruct' to begin 3D processing.\"", "label": 0}
{"function": "def test_convert_url(shared_tmp_dir, test_vector):\n    \"\"\"Test the conversion of a stream with no stream info.\"\"\"\n    # Note: tmp_dir is not used here, but is needed to match the signature\n\n    time.sleep(1)  # Ensure we don't hit rate limits\n    result = subprocess.run(\n        [\"python\", \"-m\", \"markitdown\", TEST_FILES_URL + \"/\" + test_vector.filename],\n        capture_output=True,\n        text=False,\n    )\n\n    stdout = result.stdout.decode(locale.getpreferredencoding())\n    assert result.returncode == 0, f\"CLI exited with error: {result.stderr}\"\n    for test_string in test_vector.must_include:\n        assert test_string in stdout\n    for test_string in test_vector.must_not_include:\n        assert test_string not in stdout", "label": 0}
{"function": "    def test_deduplicate(self):\n        sobol = RandomModelBridge(\n            search_space=get_discrete_search_space(),\n            model=SobolGenerator(deduplicate=True),\n            transforms=Cont_X_trans,\n        )\n        for _ in range(24):  # Search space is {[0, 3], [5, 7], {\"red\", \"panda\"}}\n            self.assertEqual(len(sobol.gen(1).arms), 1)\n        with self.assertRaises(SearchSpaceExhausted):\n            sobol.gen(1)", "label": 1}
{"function": "def generate_report(\n    results_dict: dict[str, Any],\n    providers: dict[str, set[str]],\n    all_tests: set[str],\n    provider_timestamps: dict[str, str],\n    output_file=None,\n):\n    \"\"\"Generate the markdown report.\n\n    Args:\n        results_dict: Aggregated results [provider][model][test_name] -> status.\n        providers: Dict of all providers and their models {provider: {models}}.\n                   The order of keys in this dict determines the report order.\n        all_tests: Set of all test names found.\n        provider_timestamps: Dict of provider to timestamp when tests were run\n        output_file: Optional path to save the report.\n    \"\"\"\n    if output_file is None:\n        # Default to creating the report in the same directory as this script\n        output_file = Path(__file__).parent / \"REPORT.md\"\n    else:\n        output_file = Path(output_file)\n\n    # Convert provider model sets to sorted lists (use passed-in providers dict)\n    providers_sorted = {prov: sorted(models) for prov, models in providers.items()}\n\n    # Sort tests alphabetically (use passed-in all_tests set)\n    sorted_tests = sorted(all_tests)\n\n    # Calculate counts for each base test name\n    base_test_case_counts: defaultdict[str, int] = defaultdict(int)\n    base_test_name_map: dict[str, str] = {}\n    for test_name in sorted_tests:\n        match = re.match(r\"^(.*?)( \\([^)]+\\))?$\", test_name)\n        if match:\n            base_name = match.group(1).strip()\n            base_test_case_counts[base_name] += 1\n            base_test_name_map[test_name] = base_name\n        else:\n            # Should not happen with current naming, but handle defensively\n            base_test_case_counts[test_name] += 1\n            base_test_name_map[test_name] = test_name\n\n    if not sorted_tests:\n        print(\"Warning: No test results found to generate a report.\")\n        # Optionally create an empty report or return early\n        with open(output_file, \"w\") as f:\n            f.write(\"# Test Results Report\\n\\nNo test results found.\\n\")\n        print(f\"Generated empty report: {output_file}\")\n        return\n\n    report = [\"# Test Results Report\\n\"]\n    report.append(f\"*Generated on: {time.strftime('%Y-%m-%d %H:%M:%S')}*\\n\")\n    report.append(\"*This report was generated by running `python tests/verifications/generate_report.py`*\\n\")\n\n    # Icons for pass/fail\n    pass_icon = \"\u2705\"\n    fail_icon = \"\u274c\"\n    na_icon = \"\u26aa\"\n\n    # Add emoji legend\n    report.append(\"## Legend\\n\")\n    report.append(f\"- {pass_icon} - Test passed\")\n    report.append(f\"- {fail_icon} - Test failed\")\n    report.append(f\"- {na_icon} - Test not applicable or not run for this model\")\n    report.append(\"\\n\")\n\n    # Add a summary section\n    report.append(\"## Summary\\n\")\n\n    # Count total tests and passes (use passed-in providers and all_tests)\n    total_tests = 0\n    passed_tests = 0\n    provider_totals = {}\n    for provider, models in providers_sorted.items():\n        provider_passed = 0\n        provider_total = 0\n        if provider in results_dict:\n            for model in models:\n                if model in results_dict[provider]:\n                    model_results = results_dict[provider][model]\n                    for test in sorted_tests:\n                        if test in model_results:\n                            provider_total += 1\n                            total_tests += 1\n                            if model_results[test]:\n                                provider_passed += 1\n                                passed_tests += 1\n        provider_totals[provider] = (provider_passed, provider_total)\n\n    # Add summary table (use the order from the providers dict keys)\n    report.append(\"| Provider | Pass Rate | Tests Passed | Total Tests |\")\n    report.append(\"| --- | --- | --- | --- |\")\n    # Iterate through providers in the order they appear in the input dict\n    for provider in providers_sorted.keys():\n        passed, total = provider_totals.get(provider, (0, 0))\n        pass_rate = f\"{(passed / total * 100):.1f}%\" if total > 0 else \"N/A\"\n        report.append(f\"| {provider.capitalize()} | {pass_rate} | {passed} | {total} |\")\n    report.append(\"\\n\")\n\n    for provider in providers_sorted.keys():\n        provider_models = providers_sorted[provider]  # Use sorted models\n        if not provider_models:\n            continue\n\n        report.append(f\"\\n## {provider.capitalize()}\\n\")\n\n        # Add timestamp when test was run\n        if provider in provider_timestamps:\n            report.append(f\"*Tests run on: {provider_timestamps[provider]}*\\n\")\n\n        # Add test command for reproducing results\n        test_cmd_all = f\"pytest tests/verifications/openai_api/test_chat_completion.py --provider={provider} -v\"\n        report.append(f\"```bash\\n# Run all tests for this provider:\\n{test_cmd_all}\\n\")\n\n        # Find an example test with a case ID\n        example_base_test_name = None\n        example_case_id = None\n        # Get first test as fallback base, handle empty list\n        first_test_name = sorted_tests[0] if sorted_tests else \"unknown_test\"\n\n        match = re.match(r\"^(.*?) \\((.*?)\\)$\", first_test_name)\n        if match:\n            example_base_test_name = match.group(1).strip()\n            example_case_id = match.group(2).strip()\n        else:\n            example_base_test_name = first_test_name\n\n        base_name = base_test_name_map.get(first_test_name, first_test_name)  # Get base name\n        case_count = base_test_case_counts.get(base_name, 1)  # Get count\n        filter_str = f\"{example_base_test_name} and {example_case_id}\" if case_count > 1 else example_base_test_name\n\n        test_cmd_specific_case = (\n            f'pytest tests/verifications/openai_api/test_chat_completion.py --provider={provider} -k \"{filter_str}\"'\n        )\n        report.append(\n            f\"# Example: Run only the '{example_case_id}' case of {example_base_test_name}:\\n{test_cmd_specific_case}\\n```\\n\"\n        )\n\n        # Get display names (use passed-in providers dict)\n        provider_config = VERIFICATION_CONFIG.get(\"providers\", {}).get(provider, {})\n        display_name_map = provider_config.get(\"model_display_names\", {})\n\n        # Add Model Key Table (use provider_models)\n        report.append(f\"\\n**Model Key ({provider.capitalize()})**\\n\")\n        provider_key_lines = [\"| Display Name | Full Model ID |\", \"| --- | --- |\"]\n        for model_id in provider_models:\n            display_name = display_name_map.get(model_id, model_id)\n            provider_key_lines.append(f\"| {display_name} | `{model_id}` |\")\n        report.extend(provider_key_lines)\n        report.append(\"\\n\")\n\n        # Create results table header (use provider_models)\n        display_names = [display_name_map.get(m, m) for m in provider_models]\n        header = \"| Test | \" + \" | \".join(display_names) + \" |\"\n        separator = \"| --- | \" + \" | \".join([\"---\"] * len(provider_models)) + \" |\"\n        report.append(header)\n        report.append(separator)\n\n        # Get results for this provider from results_dict\n        provider_results_data = results_dict.get(provider, {})\n\n        # Add rows for each test (use sorted_tests)\n        for test in sorted_tests:\n            # Determine display name based on case count\n            base_name = base_test_name_map.get(test, test)  # Get base name\n            case_count = base_test_case_counts.get(base_name, 1)  # Get count\n            display_test_name = base_name if case_count == 1 else test  # Choose display name\n            row = f\"| {display_test_name} |\"  # Use display name\n\n            for model_id in provider_models:\n                if model_id in provider_results_data and test in provider_results_data[model_id]:\n                    result = pass_icon if provider_results_data[model_id][test] else fail_icon\n                else:\n                    result = na_icon\n                row += f\" {result} |\"\n            report.append(row)\n\n    # Write to file\n    with open(output_file, \"w\") as f:\n        f.write(\"\\n\".join(report))\n        f.write(\"\\n\")\n\n    print(f\"Report generated: {output_file}\")", "label": 0}
{"function": "def stream_output(\n    process: subprocess.Popen, prefix: str, logger: logging.Logger\n) -> queue.Queue:\n    output_queue = queue.Queue()\n\n    def stream_pipe(pipe, prefix):\n        for line in iter(pipe.readline, \"\"):\n            if prefix == \"CLIENT\":\n                output_queue.put(line.rstrip())\n            logger.debug(f\"{prefix} | {line.rstrip()}\")\n\n    stdout_thread = threading.Thread(\n        target=stream_pipe, args=(process.stdout, prefix), daemon=True\n    )\n    stderr_thread = threading.Thread(\n        target=stream_pipe, args=(process.stderr, prefix), daemon=True\n    )\n\n    stdout_thread.start()\n    stderr_thread.start()\n    return output_queue, (stdout_thread, stderr_thread)", "label": 0}
{"function": "def run():\n    site_packages = site.getsitepackages()[0]\n    base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    baseimages_dir = os.path.join(base_dir, \"exo\", \"apputil\", \"baseimages\")\n    \n    command = [\n        f\"{sys.executable}\", \"-m\", \"nuitka\", \"exo/main.py\",\n        \"--company-name=exolabs\",\n        \"--product-name=exo\",\n        \"--output-dir=dist\",\n        \"--follow-imports\",\n        \"--standalone\",\n        \"--output-filename=exo\",\n        \"--python-flag=no_site\",\n        \"--onefile\",\n        f\"--include-data-dir={baseimages_dir}=exo/apputil/baseimages\"\n    ]\n\n    if sys.platform == \"darwin\": \n        command.extend([\n            \"--macos-app-name=exo\",\n            \"--macos-app-mode=gui\",\n            \"--macos-app-version=0.0.1\",\n            \"--macos-signed-app-name=net.exolabs.exo\",\n            \"--include-distribution-meta=mlx\",\n            \"--include-module=mlx._reprlib_fix\",\n            \"--include-module=mlx._os_warning\",\n            \"--include-distribution-meta=huggingface_hub\",\n            \"--include-module=huggingface_hub.repocard\",\n            f\"--include-data-files={site_packages}/mlx/lib/mlx.metallib=mlx/lib/mlx.metallib\",\n            f\"--include-data-files={site_packages}/mlx/lib/mlx.metallib=./mlx.metallib\",\n            \"--include-distribution-meta=pygments\",\n            \"--nofollow-import-to=tinygrad\"\n        ])\n        inference_modules = [\n            name for _, name, _ in pkgutil.iter_modules(['exo/inference/mlx/models'])\n        ]\n        for module in inference_modules:\n            command.append(f\"--include-module=exo.inference.mlx.models.{module}\")\n    elif sys.platform == \"win32\":  \n        command.extend([\n            \"--windows-icon-from-ico=docs/exo-logo-win.ico\",\n            \"--file-version=0.0.1\",\n            \"--product-version=0.0.1\"\n        ])\n    elif sys.platform.startswith(\"linux\"):  \n        command.extend([\n            \"--include-distribution-metadata=pygments\",\n            \"--linux-icon=docs/exo-rounded.png\"\n        ])\n    try:\n        subprocess.run(command, check=True)\n        print(\"Build completed!\")\n    except subprocess.CalledProcessError as e:\n        print(f\"An error occurred: {e}\")", "label": 0}
{"function": "def tracer():\n    user_details = {\n        \"project_name\": \"test_project\",\n        \"dataset_name\": \"test_dataset\",\n        \"project_id\": \"test_id\",\n        \"trace_name\": \"test_trace\",\n        \"interval_time\": 1\n    }\n    tracer = BaseTracer(user_details)\n    tracer.trace_metrics = []\n    tracer.visited_metrics = []\n    return tracer", "label": 0}
{"function": "\tdef testbanNOK(self):\n\t\tself._addDefItems()\n\t\tself.__failManager.setMaxRetry(10)\n\t\tself.assertRaises(FailManagerEmpty, self.__failManager.toBan)", "label": 1}
{"function": "    def test_live_migration_force_complete(self):\n        migration = migration_obj.Migration()\n        migration.id = 1\n        migration.source_compute = 'fake'\n        ctxt = context.RequestContext('fake_user', 'fake_project')\n        version = '5.0'\n        rpcapi = compute_rpcapi.ComputeAPI()\n        rpcapi.router.client = mock.Mock()\n        mock_client = mock.MagicMock()\n        rpcapi.router.client.return_value = mock_client\n        mock_client.can_send_version.return_value = True\n        mock_cctx = mock.MagicMock()\n        mock_client.prepare.return_value = mock_cctx\n        rpcapi.live_migration_force_complete(ctxt, self.fake_instance_obj,\n                                             migration)\n        mock_client.prepare.assert_called_with(server=migration.source_compute,\n                                               version=version)\n        mock_cctx.cast.assert_called_with(ctxt,\n                                          'live_migration_force_complete',\n                                          instance=self.fake_instance_obj)", "label": 1}
{"function": "    def tables(self):\n        return list(set(self.data.keys()).union(set(self.files.keys())))", "label": 1}
{"function": "    def test_post_remove(self):\n        self.l1.flush()\n        self.c1.flush()\n        self.c2.flush()\n\n        # Create a datagram to be sent post-remove...\n        dg_pr = Datagram.create([555444333], 0, 4321)\n        dg_pr.add_string('Testing...')\n\n        # Hang it on c1...\n        dg_add_pr = Datagram.create_add_post_remove(171717, dg_pr)\n        self.c1.send(dg_add_pr)\n\n        # Expect post remove to be pre-routed upstream\n        self.expect(self.l1, dg_add_pr)\n\n        # Verify nothing else is happening yet...\n        self.expectNone(self.l1)\n        self.expectNone(self.c1)\n        self.expectNone(self.c2)\n\n        # Reconnect c1 and see if dg gets sent.\n        self.c1.close()\n        self.__class__.c1 = self.connectToServer()\n\n        # The upstream should receive the post remove and also receive a clear_post_removes\n        dg_clear_prs = Datagram.create_clear_post_removes(171717)\n        self.expectMany(self.l1, [dg_pr, dg_clear_prs])\n\n        # Reconnect c1, the message shouldn't be sent again\n        self.c1.close()\n        self.__class__.c1 = self.connectToServer()\n        self.expectNone(self.l1)\n\n        # Hang dg as a post-remove for c2...\n        dg_add_pr = Datagram.create_add_post_remove(181818, dg_pr)\n        self.c2.send(dg_add_pr)\n        self.expect(self.l1, dg_add_pr)\n\n        # Wait, nevermind...\n        dg_clear_prs = Datagram.create_clear_post_removes(181818)\n        self.c2.send(dg_clear_prs)\n        self.expect(self.l1, dg_clear_prs)\n\n        # Did the cancellation work?\n        self.c2.close()\n        self.__class__.c2 = self.connectToServer()\n        self.expectNone(self.l1)\n\n        # Try hanging multiple post-removes on c1\n        dg_add_pr = Datagram.create_add_post_remove(191919, dg_pr)\n        dg_pr2 = Datagram.create([987987987], 0, 6959)\n        dg_add_pr2 = Datagram.create_add_post_remove(191919, dg_pr2)\n        dg_pr3 = Datagram.create([986666687], 0, 1252)\n        dg_add_pr3 = Datagram.create_add_post_remove(202020, dg_pr3)\n        self.c1.send(dg_add_pr)\n        self.c1.send(dg_add_pr2)\n        self.c1.send(dg_add_pr3)\n\n        # Expect post removes to be pre-routed upstream\n        self.expectMany(self.l1, [dg_add_pr, dg_add_pr2, dg_add_pr3])\n\n        # After adding three, we don't want to see anything \"pushed\" or the like\n        self.expectNone(self.l1)\n        self.expectNone(self.c1)\n        self.expectNone(self.c2)\n\n        # Reconnect c1 and see if both datagrams gets sent ...\n        self.c1.close()\n        self.__class__.c1 = self.connectToServer()\n\n        # ... expecting the post removes ...\n        expected = [dg_pr, dg_pr2, dg_pr3]\n        # ... and a clear for each channel ...\n        dg_clear_prs = Datagram.create_clear_post_removes(191919)\n        dg_clear_prs2 = Datagram.create_clear_post_removes(202020)\n        expected += [dg_clear_prs, dg_clear_prs2]\n        # ... exactly 2 Post Removes, and 3 Clears ...\n        self.expectMany(self.l1, expected)\n        # ... and no more messages (duplicates or otherwise)\n        self.expectNone(self.l1)", "label": 1}
{"function": "    def just_opened(self, entity, attribute, old, new, kwargs):\n        if (new == \"Open\"):\n            self.log(\"Just opened front door\")\n            self.just_opened_door = True\n            self.run_in(self.reset_just_opened, 90)", "label": 1}
{"function": "\tdef set_ClientToken(self,ClientToken):\n\t\tself.add_query_param('ClientToken',ClientToken)", "label": 1}
{"function": "    def __init__(self):\n        \"\"\"Initializes the distance calculation class with default values for Visual, Image, track and distance\n        parameters.\n        \"\"\"\n\n        # Visual & im0 information\n        self.im0 = None\n        self.annotator = None\n        self.view_img = False\n        self.line_color = (255, 255, 0)\n        self.centroid_color = (255, 0, 255)\n\n        # Predict/track information\n        self.clss = None\n        self.names = None\n        self.boxes = None\n        self.line_thickness = 2\n        self.trk_ids = None\n\n        # Distance calculation information\n        self.centroids = []\n        self.pixel_per_meter = 10\n\n        # Mouse event\n        self.left_mouse_count = 0\n        self.selected_boxes = {}\n\n        # Check if environment support imshow\n        self.env_check = check_imshow(warn=True)", "label": 0}
{"function": "def patch_builtins_input(monkeypatch):\n    def print_text(text=None):\n        if text is not None:\n            print(text)\n\n    monkeypatch.setattr(\"builtins.input\", print_text)", "label": 0}
{"function": "def prompt_templates():\n    return {\n        \"system_prompt\": \"This is a test system prompt.\",\n        \"managed_agent\": {\"task\": \"Task for {{name}}: {{task}}\", \"report\": \"Report for {{name}}: {{final_answer}}\"},\n        \"planning\": {\n            \"initial_plan\": \"The plan.\",\n            \"update_plan_pre_messages\": \"custom\",\n            \"update_plan_post_messages\": \"custom\",\n        },\n        \"final_answer\": {\"pre_messages\": \"custom\", \"post_messages\": \"custom\"},\n    }", "label": 0}
{"function": "def pretty_print_semaphore(semaphore):\n    if semaphore is None:\n        return \"None\"\n    return f\"Semaphore(value={semaphore._value}, locked={semaphore.locked()})\"", "label": 0}
{"function": "    def write(self, b):\n        '''Write raw bytes.'''\n        self.logger.verbose('Facedancer Tx: %s' % hexlify(b))\n        self.serialport.write(b)", "label": 1}
{"function": "async def test_openrouter_dynamic_model(monkeypatch):\n    settings = Settings(\n        ENABLE_OPENROUTER=True,\n        OPENROUTER_API_KEY=\"key\",\n        OPENROUTER_MODEL=\"base-model\",\n        LLM_KEY=\"OPENROUTER\",\n    )\n    SettingsManager.set_settings(settings)\n    importlib.reload(config_registry)\n\n    monkeypatch.setattr(app, \"ARTIFACT_MANAGER\", DummyArtifactManager())\n    async_mock = AsyncMock(return_value=DummyResponse('{\"status\": \"ok\"}'))\n    monkeypatch.setattr(api_handler_factory.litellm, \"acompletion\", async_mock)\n\n    base_handler = api_handler_factory.LLMAPIHandlerFactory.get_llm_api_handler(\"OPENROUTER\")\n    override_handler = api_handler_factory.LLMAPIHandlerFactory.get_override_llm_api_handler(\n        \"openrouter/other-model\", default=base_handler\n    )\n    result = await override_handler(\"hi\", \"test\")\n    assert result == {\"status\": \"ok\"}\n    called_model = async_mock.call_args.kwargs.get(\"model\")\n    assert called_model == \"openrouter/other-model\"", "label": 0}
{"function": "    def test_max_retries_exceeded(self, mock_get, mock_sleep):\n        \"\"\"Test that function stops retrying after max_retries and returns final 429.\"\"\"\n        # Setup mock responses: all 429s (exceeds max retries)\n        mock_429_response = Mock()\n        mock_429_response.status_code = 429\n        mock_429_response.text = \"Too Many Requests\"\n        \n        mock_get.return_value = mock_429_response\n        \n        # Call the function with max_retries=2\n        headers = {\"X-API-KEY\": \"test-key\"}\n        url = \"https://api.financialdatasets.ai/test\"\n        \n        result = _make_api_request(url, headers, max_retries=2)\n        \n        # Verify final 429 is returned\n        assert result.status_code == 429\n        assert result.text == \"Too Many Requests\"\n        \n        # Verify requests.get was called 3 times (1 initial + 2 retries)\n        assert mock_get.call_count == 3\n        \n        # Verify sleep was called 2 times with linear backoff: 60s, 90s\n        assert mock_sleep.call_count == 2\n        expected_calls = [call(60), call(90)]\n        mock_sleep.assert_has_calls(expected_calls)", "label": 0}
{"function": "def set_seed(seed: int):\n    \"\"\"Sets the random seed for reproducibility.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed(seed)\n        torch.cuda.manual_seed_all(seed)\n    # Ensure deterministic behavior for cuDNN (if used)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False", "label": 0}
{"function": "    def __enter__(self):\n        self.state = torch.random.get_rng_state()\n        torch.manual_seed(self.seed)", "label": 0}
{"function": "    def test_append_params(self):\n        \"\"\"Test the append_params method\"\"\"\n        cache_instance = cache.TranslationCache(\"test_engine\", {\"initial\": \"value\"})\n\n        # Test appending new parameter\n        cache_instance.add_params(\"new_param\", \"new_value\")\n        self.assertEqual(\n            cache_instance.params, {\"initial\": \"value\", \"new_param\": \"new_value\"}\n        )\n\n        # Test that cache with appended params works correctly\n        cache_instance.set(\"hello\", \"\u4f60\u597d\")\n        self.assertEqual(cache_instance.get(\"hello\"), \"\u4f60\u597d\")\n\n        # Test overwriting existing parameter\n        cache_instance.add_params(\"initial\", \"new_value\")\n        self.assertEqual(\n            cache_instance.params, {\"initial\": \"new_value\", \"new_param\": \"new_value\"}\n        )\n\n        # Cache should work with updated params\n        cache_instance.set(\"hello2\", \"\u4f60\u597d2\")\n        self.assertEqual(cache_instance.get(\"hello2\"), \"\u4f60\u597d2\")", "label": 0}
{"function": "def main():\n    \"\"\"\n    Entry point for the assistant CLI loop.\n    Provides a prompt for user input and handles 'quit' and 'reset' commands.\n    \"\"\"\n    console = Console()\n    style = Style.from_dict({'prompt': 'orange'})\n\n    try:\n        assistant = Assistant()\n    except ValueError as e:\n        console.print(f\"[bold red]Error:[/bold red] {str(e)}\")\n        console.print(\"Please ensure ANTHROPIC_API_KEY is set correctly.\")\n        return\n\n    welcome_text = \"\"\"\n# Claude Engineer v3. A self-improving assistant framework with tool creation\n\nType 'refresh' to reload available tools\nType 'reset' to clear conversation history\nType 'quit' to exit\n\nAvailable tools:\n\"\"\"\n    console.print(Markdown(welcome_text))\n    assistant.display_available_tools()\n\n    while True:\n        try:\n            user_input = prompt(\"You: \", style=style).strip()\n\n            if user_input.lower() == 'quit':\n                console.print(\"\\n[bold blue]\ud83d\udc4b Goodbye![/bold blue]\")\n                break\n            elif user_input.lower() == 'reset':\n                assistant.reset()\n                continue\n\n            response = assistant.chat(user_input)\n            console.print(\"\\n[bold purple]Claude Engineer:[/bold purple]\")\n            if isinstance(response, str):\n                safe_response = response.replace('[', '\\\\[').replace(']', '\\\\]')\n                console.print(safe_response)\n            else:\n                console.print(str(response))\n\n        except KeyboardInterrupt:\n            continue\n        except EOFError:\n            break", "label": 0}
{"function": "    def setUp(self):\n        super().setUp()\n        self.server = TaskResourcesMixin()\n        self.server.sessions = {}\n        self.server.resource_handshakes = {}\n        self.server.client = self.client\n        self.server.node = LocalNode(**dt_p2p_factory.Node().to_dict())\n        self.server.resource_manager.storage.get_dir.return_value = self.tempdir\n        self.ecc = cryptography.ECCx(None)\n        self.task_id = msg_helpers.fake_golem_uuid(self.public_key)", "label": 1}
{"function": "def load_csm_1b(device: str = \"cuda\") -> Generator:\n    model = Model.from_pretrained(\"sesame/csm-1b\")\n    model.to(device=device, dtype=torch.bfloat16)\n\n    generator = Generator(model)\n    return generator", "label": 0}
{"function": "def get_messages():\n    data = request.json\n    project_name = data.get(\"project_name\")\n    messages = manager.get_messages(project_name)\n    return jsonify({\"messages\": messages})", "label": 0}
{"function": "def test_join_path(path_input: list, target_path: str) -> None:\n    \"\"\"\n    path_input: \u8f93\u5165path\u7684\u5217\u8868\uff0c\u5217\u8868\u5143\u7d20\u5747\u4e3a\u5b57\u7b26\u4e32\n    \"\"\"\n    assert target_path == join_path(*path_input)", "label": 0}
{"function": "    def get_graph_args(self) -> Dict[str, Any]:\n        \"\"\"Get arguments for the graph invocation.\"\"\"\n        return {\n            \"stream_mode\": \"values\",\n            \"config\": {\"recursion_limit\": self.max_recur_limit},\n        }", "label": 0}
{"function": "def set_logging(log_level):\n  \"\"\"Set the logging.\"\"\"\n  logging.getLogger().setLevel(getattr(logging, log_level.upper()))", "label": 1}
{"function": "    def __init__(\n        self,\n        config,\n        checkpoint_dir,\n        device_id=0,\n        rank=0,\n        t5_fsdp=False,\n        dit_fsdp=False,\n        use_usp=False,\n        t5_cpu=False,\n        init_on_cpu=True,\n    ):\n        r\"\"\"\n        Initializes the image-to-video generation model components.\n\n        Args:\n            config (EasyDict):\n                Object containing model parameters initialized from config.py\n            checkpoint_dir (`str`):\n                Path to directory containing model checkpoints\n            device_id (`int`,  *optional*, defaults to 0):\n                Id of target GPU device\n            rank (`int`,  *optional*, defaults to 0):\n                Process rank for distributed training\n            t5_fsdp (`bool`, *optional*, defaults to False):\n                Enable FSDP sharding for T5 model\n            dit_fsdp (`bool`, *optional*, defaults to False):\n                Enable FSDP sharding for DiT model\n            use_usp (`bool`, *optional*, defaults to False):\n                Enable distribution strategy of USP.\n            t5_cpu (`bool`, *optional*, defaults to False):\n                Whether to place T5 model on CPU. Only works without t5_fsdp.\n            init_on_cpu (`bool`, *optional*, defaults to True):\n                Enable initializing Transformer Model on CPU. Only works without FSDP or USP.\n        \"\"\"\n        self.device = torch.device(f\"cuda:{device_id}\")\n        self.config = config\n        self.rank = rank\n        self.use_usp = use_usp\n        self.t5_cpu = t5_cpu\n\n        self.num_train_timesteps = config.num_train_timesteps\n        self.param_dtype = config.param_dtype\n\n        shard_fn = partial(shard_model, device_id=device_id)\n        self.text_encoder = T5EncoderModel(\n            text_len=config.text_len,\n            dtype=config.t5_dtype,\n            device=torch.device('cpu'),\n            checkpoint_path=os.path.join(checkpoint_dir, config.t5_checkpoint),\n            tokenizer_path=os.path.join(checkpoint_dir, config.t5_tokenizer),\n            shard_fn=shard_fn if t5_fsdp else None,\n        )\n\n        self.vae_stride = config.vae_stride\n        self.patch_size = config.patch_size\n        self.vae = WanVAE(\n            vae_pth=os.path.join(checkpoint_dir, config.vae_checkpoint),\n            device=self.device)\n\n        self.clip = CLIPModel(\n            dtype=config.clip_dtype,\n            device=self.device,\n            checkpoint_path=os.path.join(checkpoint_dir,\n                                         config.clip_checkpoint),\n            tokenizer_path=os.path.join(checkpoint_dir, config.clip_tokenizer))\n\n        logging.info(f\"Creating WanModel from {checkpoint_dir}\")\n        self.model = WanModel.from_pretrained(checkpoint_dir)\n        self.model.eval().requires_grad_(False)\n\n        if t5_fsdp or dit_fsdp or use_usp:\n            init_on_cpu = False\n\n        if use_usp:\n            from xfuser.core.distributed import get_sequence_parallel_world_size\n\n            from .distributed.xdit_context_parallel import (\n                usp_attn_forward,\n                usp_dit_forward,\n            )\n            for block in self.model.blocks:\n                block.self_attn.forward = types.MethodType(\n                    usp_attn_forward, block.self_attn)\n            self.model.forward = types.MethodType(usp_dit_forward, self.model)\n            self.sp_size = get_sequence_parallel_world_size()\n        else:\n            self.sp_size = 1\n\n        if dist.is_initialized():\n            dist.barrier()\n        if dit_fsdp:\n            self.model = shard_fn(self.model)\n        else:\n            if not init_on_cpu:\n                self.model.to(self.device)\n\n        self.sample_neg_prompt = config.sample_neg_prompt", "label": 0}
{"function": "    def test_fields_not_under_root(self):\n        \"\"\"\n        wineventlog - Add custom fields (not under root)\n        \"\"\"\n        msg = \"Add fields (not under root)\"\n        self.write_event_log(msg)\n        evts = self.read_events(config={\n            \"fields\": {\"global\": \"field\", \"env\": \"prod\", \"level\": \"overwrite\"},\n            \"event_logs\": [\n                {\n                    \"name\": self.providerName,\n                    \"api\": self.api,\n                    \"fields\": {\"local\": \"field\", \"env\": \"dev\", \"num\": 1}\n                }\n            ]\n        })\n        self.assertTrue(len(evts), 1)\n        self.assert_common_fields(evts[0], msg=msg, extra={\n            \"log.level\": \"information\",\n            \"winlog.keywords\": [\"Classic\"],\n            \"winlog.opcode\": \"Info\",\n            \"fields.global\": \"field\",\n            \"fields.env\": \"dev\",\n            \"fields.level\": \"overwrite\",\n            \"fields.local\": \"field\",\n            \"fields.num\": 1,\n        })\n        self.assertTrue(\"tags\" not in evts[0])", "label": 1}
{"function": "    def reset(self):\n        self._mCurrentState = eStart", "label": 1}
{"function": "def anyio_backend():\n    return \"asyncio\"", "label": 0}
{"function": "def add_session_middleware(app):\n    config_data = {\n        \"GOOGLE_CLIENT_ID\": GOOGLE_CLIENT_ID,\n        \"GOOGLE_CLIENT_SECRET\": GOOGLE_CLIENT_SECRET,\n    }\n    starlette_config = Config(environ=config_data)\n    oauth = OAuth(starlette_config)\n    oauth.register(\n        name=\"google\",\n        server_metadata_url=(\n            \"https://accounts.google.com/\" \".well-known/openid-configuration\"\n        ),\n        client_kwargs={\"scope\": \"openid email profile\"},\n    )\n\n    app.add_middleware(SessionMiddleware, secret_key=SECRET_KEY)\n    return oauth", "label": 0}
{"function": "    def valBound(self):\n        \"\"\"Function return the Bounding Box of mosaic\"\"\"\n        boundary = self.parModis[0].retBoundary()\n        for i in range(1, len(self.parModis)):\n            bound = self.parModis[i].retBoundary()\n            if bound['min_lat'] < boundary['min_lat']:\n                boundary['min_lat'] = bound['min_lat']\n            if bound['min_lon'] < boundary['min_lon']:\n                boundary['min_lon'] = bound['min_lon']\n            if bound['max_lat'] > boundary['max_lat']:\n                boundary['max_lat'] = bound['max_lat']\n            if bound['max_lon'] > boundary['max_lon']:\n                boundary['max_lon'] = bound['max_lon']\n        self.boundary = boundary", "label": 1}
{"function": "def search_for_stock_videos(query: str, api_key: str, it: int, min_dur: int) -> List[str]:\n    \"\"\"\n    Searches for stock videos based on a query.\n\n    Args:\n        query (str): The query to search for.\n        api_key (str): The API key to use.\n\n    Returns:\n        List[str]: A list of stock videos.\n    \"\"\"\n    \n    # Build headers\n    headers = {\n        \"Authorization\": api_key\n    }\n\n    # Build URL\n    qurl = f\"https://api.pexels.com/videos/search?query={query}&per_page={it}\"\n\n    # Send the request\n    r = requests.get(qurl, headers=headers)\n\n    # Parse the response\n    response = r.json()\n\n    # Parse each video\n    raw_urls = []\n    video_url = []\n    video_res = 0\n    try:\n        # loop through each video in the result\n        for i in range(it):\n            #check if video has desired minimum duration\n            if response[\"videos\"][i][\"duration\"] < min_dur:\n                continue\n            raw_urls = response[\"videos\"][i][\"video_files\"]\n            temp_video_url = \"\"\n            \n            # loop through each url to determine the best quality\n            for video in raw_urls:\n                # Check if video has a valid download link\n                if \".com/video-files\" in video[\"link\"]:\n                    # Only save the URL with the largest resolution\n                    if (video[\"width\"]*video[\"height\"]) > video_res:\n                        temp_video_url = video[\"link\"]\n                        video_res = video[\"width\"]*video[\"height\"]\n                        \n            # add the url to the return list if it's not empty\n            if temp_video_url != \"\":\n                video_url.append(temp_video_url)\n                \n    except Exception as e:\n        print(colored(\"[-] No Videos found.\", \"red\"))\n        print(colored(e, \"red\"))\n\n    # Let user know\n    print(colored(f\"\\t=> \\\"{query}\\\" found {len(video_url)} Videos\", \"cyan\"))\n\n    # Return the video url\n    return video_url", "label": 0}
